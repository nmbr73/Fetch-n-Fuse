{
 "ver": "0.1",
 "info": {
  "id": "7sGcWw",
  "date": "0",
  "viewed": 0,
  "name": "Rotating Volume Rings JiPi",
  "description": "Slow. Drag Mouse to rotate.",
  "likes": 0,
  "published": "Private",
  "usePreview": 0,
  "tags": [
   "volume",
   "tori"
  ],
  "hasliked": 0,
  "parentid": "7syyDh",
  "parentname": "Rotating Volume Rings"
 },
 "renderpass": [
  {
   "inputs": [],
   "outputs": [
    {
     "id": "4dfGRr",
     "channel": 0
    }
   ],
   "code": "//cloud marching function from shader \"Cloudy Shapes\" by kaneta: https://www.shadertoy.com/view/WdXGRj\n//soft shadows function by iq in shader \"Soft Shadow Variation.\": https://www.shadertoy.com/view/lsKcDD\n//cosine color palette function courtesy of iq\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\nvec3 rot_x(in vec3 v, in float theta) {\n    mat3 rotx = mat3(1.0, 0.0, 0.0, 0.0, cos(theta), sin(theta), 0.0, -sin(theta), cos(theta));\n    return rotx * v;\n}\nvec3 rot_y(in vec3 v, in float theta) {\n    mat3 roty = mat3(cos(theta), 0.0, -sin(theta), 0.0, 1.0, 0.0, sin(theta), 0.0, cos(theta));\n    return roty * v;\n}\nvec3 rot_z(in vec3 v, in float theta) {\n    mat3 roty = mat3(cos(theta), sin(theta), 0.0, -sin(theta), cos(theta), 0.0, 0.0, 0.0, 1.0);\n    return roty * v;\n}\nvec3 computeColor( float density, float radius )\n{\n\t// color based on density alone, gives impression of occlusion within\n\t// the media\n\tvec3 result = mix( vec3(1.0,0.9,0.8), vec3(0.4,0.15,0.1), density );\n\t\n\t// color added to the media\n\tvec3 colCenter = 7.*vec3(0.8,1.0,1.0);\n\tvec3 colEdge = 1.5*vec3(0.48,0.53,0.5);\n\tresult *= mix( colCenter, colEdge, min( (radius+.05)/.9, 1.15 ) );\n\t\n\treturn result;\n}\nfloat noise(\n\tin vec3 x\n){\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f*f*(3.0 - 2.0*f);\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\nconst mat3 m3  = mat3( 0.00,  0.80,  0.60,\n                      -0.80,  0.36, -0.48,\n                      -0.60, -0.48,  0.64 );\nfloat fbm (in vec3 p, in int o)\n{\n    float f = 0.0;\n    float freq = 1.0;\n    for (int i = 0; i < o; i++)\n    {\n        float n = noise(p * freq) / freq;\n        f += n;\n        freq *= 2.0;\n        p = m3 * p;\n    }\n    return f;\n}\nfloat rmf(vec3 p)\n{\n    float signal = 0.0;\n    float value  = 0.0;\n    float weight = 1.0;\n    float h = 1.0;\n    float f = 1.0;\n\n    for (int i=0; i < 4; i++) \n    {\n        signal = noise(p)*2.0-0.4;\n        signal = pow(1.0 - abs(signal), 2.0) * weight;\n        weight = clamp(0.0, 1.0, signal * 16.0);\n        value += (signal * pow(f, -1.0));\n        f *= 2.0;\n        p *= 2.0;\n    }\n    \n    return (value * 1.25) - 1.0;\n}\n\n  \nfloat sdSphere(in vec3 p, in vec3 c, in float r) {\n    p = rot_x(p, iTime * 2.0);\n    return length(p - c) - (r + fbm(p * 1.35, 4));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nvec2 map(in vec3 p){\n    float t = iTime * 0.125;\n    vec3 p_rz = rot_z(p, iTime * .25);\n    vec3 p_rx = rot_x(p, iTime * 0.125);\n    vec2 t1 = vec2(1.- sdTorus(p_rz, vec2(6.0, 0.5)) + fbm(t+p_rz+fbm(p, 2)*3.5, 4)*.75, 1.0);\n    vec2 t2 = vec2(1.- sdTorus(p_rx, vec2(12.0, 1.0)) +rmf(t+p_rx*1.25*(fbm(t+p_rx, 4)*0.625))*.5, 2.0);\n    vec2 s1 = vec2(1.-sdSphere(p, vec3(0), 0.5), 3.0);\n    \n    if (t1.x > t2.x && t1.x > s1.x) {\n        return t1;\n    } else if (t2.x > s1.x) {\n        return t2;\n    } else {\n        return s1;\n    }\n}\n\nfloat map_2(in vec3 p){\n    float t = iTime * 0.125;\n    vec3 p_rz = rot_z(p, iTime * .25);\n    vec3 p_rx = rot_x(p, iTime * 0.125);\n    float t1 = sdTorus(p_rz, vec2(6.0, 0.5)) + fbm(t+p_rz+fbm(p, 1)*3.5, 2)*.75;\n    float t2 = sdTorus(p_rx, vec2(12.0, 1.0)) +rmf(t+p_rx*1.25*(fbm(t+p_rx, 2)*0.625))*0.5;\n    float s1 = sdSphere(p, vec3(0), 0.5);\n    \n    return min(t1, min(t2, s1));\n}\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, int technique )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    \n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map_2( ro + rd*t );\n\n        // traditional technique\n        if( technique==0 )\n        {\n        \tres = min( res, 10.0*h/t );\n        }\n        // improved technique\n        else\n        {\n            // use this if you are getting artifact on the first iteration, or unroll the\n            // first iteration out of the loop\n            //float y = (i==0) ? 0.0 : h*h/(2.0*ph); \n\n            float y = h*h/(2.0*ph);\n            float d = sqrt(h*h-y*y);\n            res = min( res, 10.0*d/max(0.0,t-y) );\n            ph = h;\n        }\n        \n        t += h;\n        \n        if( res<0.0001 || t>tmax ) break;\n        \n    }\n    res = clamp( res, 0.0, 1.0 );\n    return res*res*(3.0-2.0*res);\n}\n    \n//fixed value for now\nfloat jitter;\n\n#define MAX_STEPS 35\n#define SHADOW_STEPS 6\n#define VOLUME_LENGTH 50.\n#define SHADOW_LENGTH 2.\nvec4 cloudMarch(vec3 p, vec3 ray)\n{\n    float density = 0.;\n\n    float stepLength = VOLUME_LENGTH / float(MAX_STEPS);\n    float shadowStepLength = SHADOW_LENGTH / float(SHADOW_STEPS);\n    vec3 light = normalize(vec3(-1.0, 2.0, 1.0));\n\n    vec4 sum = vec4(0., 0., 0., 1.);\n    \n    vec3 pos = p + ray * jitter * stepLength;\n    \n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        if (abs(sum.a) < 0.1) {\n        \tbreak;\n        }\n        vec2 res_i = map(pos);\n        float d = res_i.x;\n        if(d> 0.001)\n        {\n            float mat_i = res_i.y;\n            vec3 lpos = pos + light * jitter * shadowStepLength;\n            float shadow = 0.;\n    \n            for (int s = 0; s < SHADOW_STEPS; s++)\n            {\n                lpos += light * shadowStepLength;\n                vec2 res_s = map(lpos);\n                float lsample = res_s.x;\n                shadow += lsample;\n            }\n    \n            density = clamp((d / float(MAX_STEPS)) * 20.0, 0.0, 1.0);\n            float s = exp((-shadow / float(SHADOW_STEPS)) * 3.0);\n            sum.rgb += vec3(s * density) * vec3(1.1, 0.9, .5) * sum.a;\n            sum.a *= 1.-density;\n            vec3 pa_col = vec3(0.0);\n            float ss = 1.0;\n            if (mat_i == 1.0){\n                pa_col = pal( density * 0.5, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(2.0,1.0,0.0),vec3(0.5,0.20,0.25) );\n                ss = clamp(calcSoftshadow(pos, light, 0.01, 50.0, 0)+0.5, 0.0, 1.0);\n            } else if (mat_i == 2.0) {\n                pa_col = pal( density*2.0, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20) );\n            } else {\n                pa_col = pal( density *8.0 , vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,0.7,0.4),vec3(0.0,0.15,0.20) ) * 3.0;\n            }\n            vec2 res_m = map(pos + vec3(0,0.25,0.0));\n            sum.rgb += exp(-res_m.x * .2) *pa_col * sum.a;\n            sum *= ss;\n        }\n        pos += ray * stepLength;\n    }\n\n    return sum;\n}\n\nvec3 camera(in vec2 uv, in vec3 ro, vec3 ta, float fd){\n    vec3 up = vec3(0,1,0); \n    vec3 ww = normalize(ta-ro); \n    vec3 uu = normalize(cross(ww, up)); \n    vec3 vv = normalize(cross(uu, ww)); \n    \n    vec3 rd = normalize(uv.x*uu + uv.y*vv + fd*ww);\n    return rd;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= vec2(0.5);\n    uv.x *= iResolution.x/iResolution.y;\n   // jitter = hash(uv.x + uv.y * 57.0 + iTime) * 0.0125;\n    vec3 li = normalize(vec3(0.5, .8, 3.0));\n    float a = 10.0 * iMouse.x/iResolution.x;\n    vec3 ro = 1.35*vec3( 14.0 * sin(a), 13.0, 14.0* cos(a));\n    vec3 ta = vec3(0,0,0);   \n    vec3 rd = camera(uv, ro, ta, 1.0);\n    fragColor = pow(cloudMarch(ro, rd), vec4(2.15)) * 0.15;\n}",
   "name": "Image",
   "description": "",
   "type": "image"
  }
 ]
}