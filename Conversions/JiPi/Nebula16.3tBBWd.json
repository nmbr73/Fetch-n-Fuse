{"Shader":{"ver":"0.1","info":{"id":"3tBBWd","date":"1600099230","viewed":414,"name":"Nebula 16","username":"Leria","description":"Big purple nebula seen from a near position (spherical bounding box)\nA+mouse: tune density\nC toggle : control albedo or sigma_s","likes":6,"published":3,"flags":48,"usePreview":0,"tags":["fractal","noise","nebula","multiplicative"],"hasliked":0},"renderpass":[{"inputs":[{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":37,"channel":0}],"code":"\/\/ Fork of \"Nebula 11 preintegrated\" by Leria. https:\/\/shadertoy.com\/view\/wlBBDw\n\/\/ 2020-09-08 16:02:06\n\n\/\/Free for any use, just let my name appears or a link to this shader\n\n\/\/animation 0 or 1\n#define ANIM\t\t\t\t1\n\n#define RADIUS\t\t\t\t4.\n#define GRAV_CONST\t\t\t6.674\n#define THICK\t\t\t\t2.\n#define DISTORSION\t\t\t6.67\n#define\tMASS\t\t\t\t.1\n    \n#define ALPHA \t\t\t\t20.\n#define COLOR\t\t\t\t1   \n\n#define DISPERSION_VELOCITY\t.15\n\n\/\/Set High definition to 1 for more details (sort of LOD) else 0 :\n#define HIGH_DEF\t\t\t1\n\/\/----> in HIGH_DEF mode, you can\n\/\/choose the nathure of noise ADDITIVE 1 = additive noise || 0 = multiplicative\n\t#define ADDITIVE \t\t0\n\n\n\/\/Stretch or not the colored volume\n#define STRETCH\t\t \t\t1\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n#define GaussRand( rand1, rand2 ) \\\n    ( sqrt( - 2.*log(max(1e-5,rand1)) ) * vec2 ( cos( 6.28*(rand2) ),sin( 6.28*(rand2) ) ) )\n\n#define GaussNoise(p)  GaussRand( .5+.5*snoise(p), .5+.5*snoise(p+17.12) ).x\n\n#define f(x) (.5+.5*cos(x))\n#define Pnoise(p) (2.* (clamp( noise(p)\/.122 +.5 ,0.,1.)) )\n\/\/#define Psnoise(p) ( 2.*( exp( snoise(p)) ) )\n\/\/#define Psnoise(p)   2.*(  snoise(p) + 1. )\n\/\/#define Psnoise(p)   max(0., 1. + 1.*GaussNoise(p) )\n\/\/#define Psnoise(p)   max(0., .8 + 1.8*snoise(p) )\n  #define Psnoise(p)   max(0., 1. + .4*GaussNoise(p) )\n\n#define  rnd(v)  fract(sin( v * vec2(12.9898, 78.233) ) * 43758.5453)\n#define srnd(v) ( 2.* rnd(v) - 1. )\n\nstruct Camera\n{\n \tvec3 pos; \/\/position\n    vec3 target; \/\/focal point = target point\n    vec3 forward;\n    vec3 right;\n    vec3 up;\n    \n    mat4 view;\n};\n\nstruct Matter\n{\n    vec3 pos; \/\/position\n    float radius; \/\/accretion disk\n    float mass;\n};\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nMatter m;\nCamera cam;\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvec3 I = vec3(1., 0., 0.); \t\/\/x axis\nvec3 J = vec3(0., 1., 0.);\t\/\/y axis\nvec3 K = vec3(0., 0., 1.);\t\/\/ z axis\nvec3 lightpos = vec3(0.);\n\n#define Bnoise(x) abs(noise(x))\n\nvec3 stretching  = vec3(  1., 1., 1. ); \n\nfloat fbm_add( vec3 p ) { \/\/ in [-1,1]\n    \n    float f;\n    vec3 s = vec3(2.);\n    #if STRETCH\n   \tp *= stretching*  vec3(   1.\/8. );\n    s = 2.\/pow(stretching,vec3(1.\/4.));\n    #endif\n    \n    f = noise(p); p = p*s;\n\n    #if HIGH_DEF\n    f += 0.5000*noise( p ); p = p*s;\n    f += 0.2500*noise( p ); p = p*s;\n    f += 0.1250*noise( p ); p = p*s;\n    f += 0.0625*noise( p );   \n    #endif\n    return f;\n}\n\nfloat fbm_mul( vec3 p ) { \/\/ in [-1,1]\n    \n    float f;\n    vec3 s = vec3(2.);\n    #if STRETCH\n   \tp *= stretching* 1.\/8.;\n   \ts = 2.\/pow(stretching,vec3(1.\/4.));\n    #endif\n\n   \n    f = Psnoise(p); p = p*s;\n\n    #if HIGH_DEF\n    f *=  Psnoise( p ); p = p*s;\n    f *=  Psnoise( p ); p = p*s;\n    f *=  Psnoise( p ); p = p*s;\n    f *=  Psnoise( p ); \n    #endif\n    return f;\n}\n\nfloat fbm(vec3 p)\n{\n \n    #if ADDITIVE\n    return fbm_add(p);\n    #else\n   \treturn fbm_mul(p);\n    #endif\n    \n}\n\n\/* Transparency *\/\nfloat current_transparency(float dist, float material_coef, float density)\n{\n   return exp(-dist*material_coef*density); \n}\n\nfloat current_opacity(float t)\n{\n \treturn 1.-t;   \n}\n\nvec3 current_opacity(vec3 rgb_o)\n{\n \treturn 1.-rgb_o; \n}\n\n#define transp current_transparency\n\n#define ROT rotation_matrix\n\n\/\/end of rotation\n\nvec3 ray_interpolation(Ray r, float t) \n{\n \treturn (r.origin + r.dir*t);   \n}\n\nvoid set_matter(vec3 pos, \n                float mass,\n                float radius)\n{\n \tm = Matter(pos, radius, mass);\n}\n\nfloat sdf_sphere(vec3 pXp0, float radius)\n{\n    return (length(pXp0) - (radius));\n}\n\nvoid init_matter(void)\n{\n \tset_matter(vec3(0., 0., 0.), MASS, RADIUS);\n}\n\nvoid set_camera(vec3 pos, vec3 target)\n{\n    cam.pos = pos;\n    cam.target = target;\n    cam.forward = normalize(pos-target);\n    cam.right = cross(normalize(vec3(0., 1., 0.)), cam.forward);\n    cam.up = cross(cam.forward, cam.right);\n        \n    cam.view = mat4(vec4(cam.right, 0.), vec4(cam.up, 0.), vec4(cam.forward, 0.), vec4(1.) );\n    \n}\n\nvoid init_camera(void)\n{\n    init_matter();\n    set_camera(vec3(0., 0., 4.5), m.pos); \n}\n\nfloat energy_t_r(float velocity, float typical_scale)\n{\n \treturn .5*(pow(velocity,2.))\/typical_scale;   \n}\n\nfloat local_velocity( vec3 p, float disp_turb)\n{\n\tfloat disp_rate =  32.*disp_turb*Psnoise(p*1.25); \/\/generation of a local dispersion = turbulence * rate\n    disp_rate +=  64.*disp_turb*fbm(p*5.); \/\/generation of a local dispersion = turbulence * rate\n\n\treturn 1.60*DISPERSION_VELOCITY *disp_rate; \n}\n\nvoid ray_march_scene(Ray r, float k, inout vec3 c, inout vec3 transp_tot)\n{\n    float uniform_step = k;\n    float jit = 1.;\n    \/\/jit = 50.*fract(1e4*sin(1e4*dot(r.dir, vec3(1., 7.1, 13.3))));\n   \n    float t_gen = 1.;\n\n    float param_t = intersect_sphere(r, m.pos, RADIUS);\n    if(param_t <= -1.)\n        return;\n    vec3 p = ray_interpolation(r, k*jit);        \n     \n    float vt = -1.;\n    \/\/rgb transparency               \n    \n    vec3 t_acc = vec3(1.);\t\/\/ accumulated parameters for transparency\n    \n    for(int s=0; s < 120; s++)\n    {               \n        vec3 dU = vec3(0.);\n\n        float dist_dist = dot(p-cam.pos, p-cam.pos);\n        float dist_center = length(m.pos-cam.pos);\n        vec3 center = p-m.pos;\n\n        \n        \/\/if too far, then big step        \n        float d = length(center)-RADIUS-.5-jit*k;\n\n        if(length(center)-RADIUS < 0.)\n        {\n            \n            float anim = 1.;\n            #if ANIM      \n            \/\/anim = iTime;\n            \n            #endif\n                                                 \/\/ --- textured bubble model\n            \n            float rad_bubl = 2.35; \/\/radius of bubble, also control the opening of the bubble\n            vec3 pB = vec3(0); \/\/ vec3(-1.,1.,-1.);\/\/RADIUS\/2.);\n            float r_p = length(p-pB)\/2.*RADIUS;\n            float d = 1. +.1*( length(p-pB) \/ (rad_bubl) -1.);\n            \n            \/\/if ( length(p-pB) < rad_bubl ) c.r += .03; \/\/ hack to display the bubble\n\n            \n\t\t\tvec3 dp = vec3(0.);\n            dp += d*(p-pB);      \n            \n            float size = length((p-pB+dp)-m.pos)\/RADIUS;\n\n#define SQR(x) ( (x)*(x) ) \n            \/\/push bubble\n            float l = max(0., 1.-d*d);\n\t\t\t\/\/float l = exp(-.5*SQR(d\/2.));\n#if 0\n          \/\/float n = Psnoise( (p-pB+dp)*l)*(max(0., d)*l) ;\n          \/\/float n = .5+.5*snoise( (p-pB+dp)*l)*(max(0., d)*l) ;\n\n            float mask = smoothstep(n,\n                                    .5*RADIUS,\n                                  \tRADIUS-length(center)\n                                    );\n            \/\/mask = n;\n#else\n            rad_bubl+=1.;\n             float dr = noise( p - 124.17),\n                  de = noise( p - 98.12 ),\n                 \n              mask = smoothstep ( .2+.1*de, .0, abs( ( length(p)-(rad_bubl))\/rad_bubl  -.8*dr )   ) ;\n#endif\n            \/\/mask = 1.;\n            \n                                                 \/\/ --- local transparency \n            float dispersion_turbulence =  clamp( mask, 0.,1. );            \n                                    \n            \/\/DISPERSION_VELOCITY is the average dispersion velocity\n            float velocity = local_velocity(p, dispersion_turbulence); \/\/local velocity (sometimes called sigma_v)\n            #define VT velocity\n            \n            \/\/energy \n            float scale = 10.;\n            float energy_transfer_rate = energy_t_r(VT, scale); \/\/energy transfer rate by unit of mass as a dust grain density (transfer function)\n\n            \/\/primitive of the transfer function\n#define INT_E(v)\t(.5*(v*v*v)\/(4.*scale))       \n            \n            \/\/preintegration formula\n#define PREINT_E(d0, d1)\t((INT_E(d1)-INT_E(d0))\/(d1-d0))          \n            \n            vec3 absorb_coef = vec3(.5, .01, 2.)\/4.;   \/\/ <<< $PHYS $PARAM sigma_t (well, part of)\n            absorb_coef *= exp( 10.*(KeyParam(64+1)-.5) ); \/\/ $TUNE\n            vec3 prof = vec3(0);\n            if(vt <= 0.)\n            {\n                prof = absorb_coef*k*energy_transfer_rate;\n                vt = velocity;                \n            }\n            \n            #define PREINTEGRATION\t1\n            \n            #if PREINTEGRATION\n            else\n                \n            {\n                prof = absorb_coef*k*PREINT_E(vt, VT);\n                vt = velocity;\n            }\n            \n            #else\n           vt = 0.;\n            prof = absorb_coef*k*energy_transfer_rate;\n\n            #endif\n            \n            vec3 rgb_t = exp(-prof);    \/\/ <<< local transparency\n            \n            vec3 col_loc = vec3(.8, .5, .1);  \/\/ <<< $PHYS $PARAM albedo, = sigma_s\/sigma_t\n            if KeyToggle(64+3) col_loc \/= absorb_coef; \/\/  $TUNE  control sigma_s rather than albedo\n            \n            \n            \/\/ attention: sigma_t = sigma_a + sigma_s , albedo = sigma_s\/sigma_t\n            \/\/        -> sigma_a = sigma_t ( 1 - albedo ) must be physical. Or always ok ?\n            \n            \/\/ e.g. here: sigma_a = vec3(.1, .6, 10) * Etr(VT,10) * ( 1 - vec3(.8, .5, .1) )\n            \/\/            E_tr = .5 VT\u00b3\/10,  VT = 1.6 * .15 *256.*mask*fbm(p*4.)\n            \/\/                 = 12000 *(mask*fbm)\u00b3\n            \/\/ note that Dl = k has no unit: part of big coef should go there\n            \n\n            float epsilon = k\/10.;           \/\/ --- local lighting\n            vec3 L = normalize(p-lightpos);\n            #define val(x,y,z) energy_t_r( local_velocity(p+epsilon*vec3(x,y,z), dispersion_turbulence) , scale)\n#if 1\n            vec3 N =   vec3( val(1,0,0), val(0,1,0), val(0,0,1) )\n                      - energy_transfer_rate;\n            N = normalize(N+1e-5);\n            float dif = abs(dot(N, L));\n#else                  \n         \t\n            float dif = abs(clamp(( val(0,0,0) \/\/ energy_transfer_rate \n                                   - val(L.x,L.y,L.z) \/\/ energy_t_r( local_velocity(p+epsilon*L, dispersion_turbulence) , scale)\n                                  )\/epsilon\n                              , -1.0\n                              , 1.0  ));\n#endif\n                                           \/\/ above : diff = abs(Lambert)\n            \/\/dif = .75* ( 1. + dif*dif ); \/\/ Rayleigh phase function\n\n#define Gauss(x,s) 1.\/(std_dev*2.51)*exp(-(X*X)\/(2.*(std_dev*std_dev)))\n            float meansunlight = .7;\n            float std_dev = .7;\n            float X = (size-meansunlight);\n            float L0 = 7.;\n            L = p-lightpos;\n            float source = 1.\/ dot(L\/L0,L\/L0)* exp(- 4.*max(0., length(L)  - (rad_bubl-.2) ) ) ;\n          \/\/float source = 5.* exp(- 2.*max(0., length(L) - (rad_bubl-.2) ) ) ;\n             float sun = 0.2\/size *source, \/\/ \/exp(-smoothstep(0., 1.\/size, Gauss(X,std_dev) )),\n                shadow = 1.,\n                reflec = dif;\n          \/\/  sun = .6;\n            reflec =1.;\n            \n            vec3 emission = vec3(0);   \/\/ <<< $PARAM $PHYS  \n            \n    \t\t                          \/\/ --- add current voxel contribution to ray\n     \/\/     t_acc *= (rgb_t);         \n            c += t_acc* (col_loc* reflec * sun * shadow + emission\/absorb_coef) *  (1.-rgb_t);\n   \t \/\/\t\tc += t_acc * col_loc* (prof) *.3; \/\/ * rgb_t;\n            t_acc *= (rgb_t);    \n            \n        }            \n\n        \/\/if it will never be in the shape anymore, return;\n        \n        if(length(p-cam.pos) >(dist_center+m.radius) || \n           (t_acc.x+t_acc.y+t_acc.z < 0.001 && t_acc.x+t_acc.y+t_acc.z > 40. ))\n        {\n         \tbreak;\n        }\n        \n        p += r.dir*k;\n\n        k = uniform_step;\n    }\n    \n\n    \/\/c =float(s)\/vec3(50,150,20); return;\n\n    transp_tot = t_acc;\n\n}\n\t\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    init_camera();\n    \n    vec2 R = iResolution.xy, \n        uv = (2.*fragCoord- R )\/R.y,\n         M =  iMouse.xy\/R;\n        \n    float degree = 2.*PI * M.x - PI;\n\tfloat degree2 = 2.*PI * M.y - PI;\n     if ( iMouse.z<=0. || KeyParam(0)>0. ) degree = iTime, degree2 = 0.;\n   \n    vec3 color = vec3(0.), transp_tot=vec3(1);\n    vec3 ray_dir = vec3(uv, -1.);\n\n    m.pos = normalize(vec3(-10, 20., m.pos.z));\n    \n \/\/ vec2 m = 2.*PI * iMouse.xy\/R - PI;\n    vec3 C = cam.pos, ray = normalize(ray_dir);\n    C.xz *= rot2(degree); C.yz *= rot2(degree2);\n    ray.xz *= rot2(degree); ray.yz *= rot2(degree2);\n    \n    cam.pos = C;\n    ray_march_scene(Ray(C, normalize(ray)), .1, color, transp_tot);  \n    vec3 sky = vec3(0);\n    \/\/sky =   .6* texture(iChannel0,fragCoord\/R+vec2(degree,degree2)).rgb;\n  sky =   .6*pow(texture(iChannel1,fragCoord*2.+vec2(degree,degree2)).rgb, vec3(7));\n  \/\/sky =   max(texture(iChannel0,fragCoord\/256.+vec2(degree,degree2)).rrr -.8,0.)\/.2;\n    color += transp_tot * sky;\n    \n    fragColor = vec4(pow(color, vec3(1.\/2.2)), 1.);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\/\/ KeyParam(ascii) gives value of tuner #ascii\n\/\/ KeyToggle(ascii) gives toggle state for key #ascii\n\/\/ KeyParam(0) tells whether any key is currently pressed (e.g. to prevent mouse-move object) \n#define KeyParam(ascii)    texelFetch( iChannel0, ivec2(ascii,0), 0 ).a \n#define KeyToggle(ascii) ( texelFetch( iChannel0, ivec2(ascii+256,0), 0 ).a > .5 )\n\n#define PI \t\t\t\t\t3.1415926\n\n\/\/most of \"noise stuff\" comes from iq\n\n\/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 *\/\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n\/* skew constants for 3d simplex functions *\/\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\nvec3 hash( vec3 p ) \/\/ replace this by something better\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n\/* 3d simplex noise *\/\nfloat snoise(vec3 p) {\n\t \/* 1. find current tetrahedron T and it's four vertices *\/\n\t \/* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices *\/\n\t \/* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*\/\n\t \n\t \/* calculate s and x *\/\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t \/* calculate i1 and i2 *\/\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t \/* x1, x2, x3 *\/\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t \/* 2. find four surflets and store them in d *\/\n\t vec4 w, d;\n\t \n\t \/* calculate surflet weights *\/\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t \/* w fades from 0.6 at the center of the surflet to 0.0 at the margin *\/\n\t w = max(0.6 - w, 0.0);\n\t \n\t \/* calculate surflet components *\/\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t \/* multiply d by w^4 *\/\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t \/* 3. return the sum of the four surflets *\/\n\t return dot(d, vec4(52.0));\n}\n\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\nfloat cloud( in vec3 p )\n{\n\tvec3 q = p - vec3(0.0,0.1,1.0);\n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q ); q = q*2.03;\n    f += 0.12500*noise( q ); q = q*2.01;\n    f += 0.06250*noise( q ); q = q*2.02;\n    f += 0.03125*noise( q );\n\treturn clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\n}\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/\/Transformations\n\n\/\/translation\n\nmat4 translate(vec3 k)\n{\n    mat4 mat = mat4(\n        vec4(1., vec3(0.)),\n        vec4(0., 1., vec2(0.)), \n        vec4(vec2(0.), 1., 0.),\n        vec4(k, 1.) );\n    \n    return mat;\n}\n\n\n\nmat2 rot2(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2( c, -s, s, c);\n}\n\n\/\/rotation around the x axis\nmat3 rotateX(float degree)\n{\n    float rad = PI*degree\/180.;\n \tmat3 rot = mat3(1., 0., 0.,\n                    0., cos(rad), -sin(rad),\n                    0., sin(rad), cos(rad));\n    return rot;\n}\n\n\/\/rotation axis-angle\nmat4 rotation_matrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nstruct Ray\n{\n    vec3 origin; \/\/origin\n    vec3 dir; \/\/direction of the ray\n};\n\n\/\/ Sphere intersection\nfloat intersect_sphere( Ray r, vec3 sphere, float rad )\n{\n\tvec3 oc = r.origin - sphere;\n\tfloat b = dot( oc, r.dir );\n\tfloat c = dot( oc, oc ) - rad*rad;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/","name":"Common","description":"","type":"common"},{"inputs":[{"id":30,"src":"\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":33,"src":"\/presets\/tex00.jpg","ctype":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":257,"channel":0}],"code":"void mainImage( out vec4 O, vec2 U )\n{    vec2 R = iResolution.xy; \n\n    \/\/ --- .rgb: backbround sky. [ do we really need to recompute this at every frame ? ]\n    \n    O = texture(iChannel1,U\/256.); \n  \/\/O = vec4( pow( O.r, 20. ) );             \/\/ BW stars\n  \/\/O = pow( O, vec4(20) );                  \/\/ color stars\n    O *= pow( max(O.r,max(O.g,O.b)), 100.);  \/\/ faint color stats\n    \n    \/\/ --- .a: could be used to implement parameter persistant states ( for mouse or keyboard tuning ).\n    if (U.y>.5) return;\n \n    if (iFrame==0) {                         \/\/ init values\n        O.a = .5;\n                    \n    } else {                                 \/\/ tuning\n        O.a = texelFetch(iChannel0, ivec2(U), 0).a;\n\n#define keyToggle(ascii)  ( texelFetch(iChannel3,ivec2(ascii,2),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n        \n        if (U.x<256.) {\n            if ( keyClick(U.x) && iMouse.z>0. )\n                O.a = iMouse.y\/R.y; }        \/\/ tune value of parameter #ascii\n        else if(U.x<512.) \n            O.a = float(keyToggle(U.x-256.));\/\/ register the toggle on\/off for #ascii\n       \n                                             \/\/ -> use KeyParam(ascii) to get it\n        if (U.x<1.) {                        \/\/        KeyParam(0) tells where any key is used\n            O.a = 0.;\n            for (int i=0; i<256; i++) \n                if keyClick(i) { O.a = 1.; break; }\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}}