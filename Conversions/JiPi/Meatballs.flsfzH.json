{"Shader":{"ver":"0.1","info":{"id":"flsfzH","date":"1650623023","viewed":55,"name":"Meatballs","username":"kristemmerman","description":"An attempt at meat :)\n\n","likes":5,"published":3,"flags":0,"usePreview":1,"tags":["3d","noise","meat"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"id":37,"channel":0}],"code":"float sdSphere(vec3 p, float r )\n{\n  return length(p) - r;\n}\n\nfloat hash1( vec2 p )\n{\n    p  = 50.0*fract( p*0.3183099 );\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat hash1( float n )\n{\n    return fract( n*17.0*fract( n*0.3183099 ) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    #if 1\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    #else\n    vec3 u = w*w*(3.0-2.0*w);\n    #endif\n    \n\n\n    float n = 111.0*p.x + 317.0*p.y + 157.0*p.z;\n    \n    float a = hash1(n+(  0.0+  0.0+  0.0));\n    float b = hash1(n+(111.0+  0.0+  0.0));\n    float c = hash1(n+(  0.0+317.0+  0.0));\n    float d = hash1(n+(111.0+317.0+  0.0));\n    float e = hash1(n+(  0.0+  0.0+157.0));\n\tfloat f = hash1(n+(111.0+  0.0+157.0));\n    float g = hash1(n+(  0.0+317.0+157.0));\n    float h = hash1(n+(111.0+317.0+157.0));\n\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return -1.0+2.0*(k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z);\n}\nconst mat3 m3  = mat3( 0.00,  0.80,  0.60,\n                      -0.80,  0.36, -0.48,\n                      -0.60, -0.48,  0.64 );\nfloat fbm_4( in vec3 x )\n{\n    float f = 2.0;\n    float s = 0.5;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=0; i<4; i++ )\n    {\n        float n = noise(x);\n        a += b*n;\n        b *= s;\n        x = f*m3*x;\n    }\n\treturn a;\n}\nfloat fbm_2( in vec3 x )\n{\n    float f = 2.0;\n    float s = 0.5;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=0; i<2; i++ )\n    {\n        float n = noise(x);\n        a += b*n;\n        b *= s;\n        x = f*m3*x;\n    }\n\treturn a;\n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)\/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)\/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n    \nfloat map(vec3 p){\n\n\n  float s;\n\n  float s1 =sdSphere(p+vec3(1.0,0.1,0.0), 1.7*(sin(iTime+p.x)*0.005+1.0));\n  float s2 =sdSphere(p+vec3(-1.0,0.0,0.1), 1.8*(sin(iTime+p.x+1.0)*0.005+1.0));\n  s = opSmoothUnion(s1,s2,0.5);\n  \n  vec3 noiseP =p*0.7;\n\n  float n =smoothstep(-0.2,1.0,fbm_4(noiseP*2.0+fbm_4(noiseP*2.0)*1.5))*0.1;\n  s-=n;\n  \n  float skin = smoothstep(0.5,1.0,1.0-n*5.0);\n  s+=skin*smoothstep(-1.0,1.0,fbm_2(noiseP*50.0)*fbm_2(noiseP*4.0))*0.02;\n\n  return s;\n\n}\nvec4 getColor(vec3 p){\n\n  vec3 noiseP =p*0.7;\n  float n1=abs(fbm_2(noiseP*1.0));\n \n  float n =smoothstep(-0.2,1.0,fbm_4(noiseP*2.0+fbm_4(noiseP*2.0)*1.5));\n  vec3 base1 = mix(vec3(0.2,0,0.1),vec3(0.9,0.2,0.3),vec3(n));\n  vec3 lum = vec3(0.299, 0.587, 0.114);\n  vec3 gray = vec3(dot(lum, base1));\n   vec4 color =vec4(0,0,0,0);\n  color.xyz = mix(base1, gray, vec3(pow(n1,2.0)));\n  color.w =40.0;\n  float s = smoothstep(0.2,0.4,n);\n  color.w -=s*20.0;\n  color.xyz+=vec3(s)*vec3(0.7,0.7,0.4)*0.5;\n  return color;\n}\n\nvec3 calcNormal(vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005; \/\/ epsilon\n    float r = 1.; \/\/ radius of sphere\n    return normalize(\n      e.xyy * map(p + e.xyy) +\n      e.yyx * map(p + e.yyx) +\n      e.yxy * map(p + e.yxy) +\n      e.xxx * map(p + e.xxx));\n}\n\n\n\nfloat rayMarch(vec3 ro, vec3 rd, float start, float end) {\n  float depth = start;\n\n  for (int i = 0; i < 256; i++) {\n    vec3 p = ro + depth * rd;\n    \n    float d =map(p);\n    \n    depth += d;\n    if (d < 0.001 || depth > end) break;\n  }\n\n  return depth;\n}\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; \/\/ big, such that y = 0 on the first iteration\n    \n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t );\n\n      \n            \/\/ use this if you are getting artifact on the first iteration, or unroll the\n            \/\/ first iteration out of the loop\n            \/\/float y = (i==0) ? 0.0 : h*h\/(2.0*ph); \n\n            float y = h*h\/(2.0*ph);\n            float d = sqrt(h*h-y*y);\n            res = min( res, 10.0*d\/max(0.0,t-y) );\n            ph = h;\n       \n        \n        t += h;\n        \n        if( res<0.0001 || t>tmax ) break;\n        \n    }\n    res = clamp( res, 0.0, 1.0 );\n    return res*res*(3.0-2.0*res);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n  float time =sin( iTime*0.2)*0.2+1.3;\n  \/\/ camera\t\n  vec3 ta = vec3( 0.0, 0.0, 0.0 );\n  vec3 ro = ta + vec3( 10.0*cos(time ), 0, 10.0*sin(time ) );\n  \/\/ camera-to-world transformation\n  mat3 ca = setCamera( ro, ta, 0.0 );\n  vec2 p = (2.0*fragCoord-iResolution.xy)\/iResolution.y;\n\n\n  \/\/ focal length\n  const float fl = 3.5;\n        \n  \/\/ ray direction\n  vec3 rd = ca * normalize( vec3(p,fl) );\n\n  vec3 col = vec3(0);\n\n\n  float d = rayMarch(ro, rd, 0., 100.); \n\n  if (d > 100.0) \n  {\n    col = vec3(0.2,0.2,0.4)*0.5*(1.0-pow(length(p)*0.5,2.0)); \/\/ ray didn't hit anything\n  } \n  else \n  {\n    vec3 p = ro + rd * d; \/\/ point on sphere we discovered from ray marching\n    vec3 N = calcNormal(p);\n    vec4 colin = getColor(p);\n    vec3 albedo = colin.xyz;\n    vec3 lightpos =vec3(2.0,3.0,3.0);\n    vec3 L = normalize(lightpos - p);\n    \n    float shadow = calcSoftshadow(p,L, 0.01, 3.0);\n    vec3 irr =vec3(max(0.0,dot(N,L))*2.0)*shadow+vec3(0.1,0.1,0.2);\n    col =irr*albedo;\n    \n    vec3  ref = reflect(rd,N);            \n    float fre = clamp(1.0+dot(N,rd),0.0,1.0);\n    float spe = (colin.w\/15.0)*pow( clamp(dot(ref,L),0.0, 1.0), colin.w )*2.0*(0.5+0.5*pow(fre,42.0));\n    col += spe*shadow;\n   \n    col +=vec3(pow(1.0+dot(rd,N),2.0))*vec3(0.2,0.1,0.1);\n\n  }\n\n  \/\/ Output to screen\n  fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}}