{"Shader":{"ver":"0.1","info":{"id":"3lc3DH","date":"1576133238","viewed":494,"name":"Stop Polluting!","username":"TimoKinnunen","description":"Fluid particles, use mouse to clear some. There are also secret keyboard functions!","likes":29,"published":3,"flags":48,"usePreview":0,"tags":["sdf","fluid","dynamics","diffusion","buffer"],"hasliked":0},"renderpass":[{"inputs":[{"id":33,"src":"\/presets\/tex00.jpg","ctype":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":49,"src":"\/media\/a\/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","ctype":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":258,"src":"\/media\/previz\/buffer01.png","ctype":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":37,"channel":0}],"code":"\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\n\/\/ As Easy As ABC! (Stop Polluting!)\n\/\/\n\/\/ by Timo Kinnunen 2019\n\/\/\n\/\/ Based on https:\/\/www.shadertoy.com\/view\/wsjXWh\n\/\/\n\/\/ Use mouse to clear some stuff\n\/\/ and press space bar to reinitialize\n\/\/ the screen (useful after going fullscreen)!\n\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\nvec4 A(vec2 U) {return texture(iChannel0,U\/R);}\nvec4 B(vec2 U) {return texture(iChannel1,U\/R);}\nvec4 K(vec2 U) {return texture(iChannel2,(U+.5)\/vec2(256,3));}\nvec4 F(vec2 U) {return textureLod(iChannel3,U,0.);}\n\/\/vec4 F(vec2 U) {return texture(iChannel3,U);}\n\nfloat ln (vec3 p, vec3 a, vec3 b) {return length(p-a-(b-a)*dot(p-a,b-a)\/dot(b-a,b-a));}\n\n\/\/ linear white point\nconst float W = 11.2;\n\n\/\/ Filmic Reinhard, a simpler tonemapping\n\/\/ operator with a single coefficient\n\/\/ regulating the toe size.\n\n\/\/ The operator ensures that f(0.5) = 0.5\n\n\/\/ T = 0: no toe, classic Reinhard\nconst float T = 0.01;\n\nfloat filmic_reinhard_curve (float x) {\n    float q = (T + 1.0)*x*x;    \n\treturn q \/ (q + x + T);\n}\n\nfloat inverse_filmic_reinhard_curve (float x) {\n    float q = -2.0 * (T + 1.0) * (x - 1.0);\n    return (x + sqrt(x*(x + 2.0*T*q))) \/ q;\n}\n\nvec3 filmic_reinhard(vec3 x) {\n    float w = filmic_reinhard_curve(W);\n    return vec3(\n        filmic_reinhard_curve(x.r),\n        filmic_reinhard_curve(x.g),\n        filmic_reinhard_curve(x.b)) \/ w;\n}\n\nvec3 inverse_filmic_reinhard(vec3 x) {\n    x *= filmic_reinhard_curve(W);\n    return vec3(\n        inverse_filmic_reinhard_curve(x.r),\n        inverse_filmic_reinhard_curve(x.g),\n        inverse_filmic_reinhard_curve(x.b));\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/\/ ACES fitted\n\/\/ from https:\/\/github.com\/TheRealMJP\/BakingLab\/blob\/master\/BakingLab\/ACES.hlsl\n\nconst mat3 ACESInputMat = mat3(\n    0.59719, 0.35458, 0.04823,\n    0.07600, 0.90834, 0.01566,\n    0.02840, 0.13383, 0.83777\n);\n\n\/\/ ODT_SAT => XYZ => D60_2_D65 => sRGB\nconst mat3 ACESOutputMat = mat3(\n     1.60475, -0.53108, -0.07367,\n    -0.10208,  1.10813, -0.00605,\n    -0.00327, -0.07276,  1.07602\n);\n\nvec3 RRTAndODTFit(vec3 v)\n{\n    vec3 a = v * (v + 0.0245786) - 0.000090537;\n    vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n    return a \/ b;\n}\n\nvec3 ACESFitted(vec3 color)\n{\n    color = color * ACESInputMat;\n\n    \/\/ Apply RRT and ODT\n    color = RRTAndODTFit(color);\n\n    color = color * ACESOutputMat;\n\n    \/\/ Clamp to [0, 1]\n    color = clamp(color, 0.0, 1.0);\n\n    return color;\n}\n\nfloat impulse(float k, float x) {\n    float h = k* x;\n    return h* exp(1.- h);\n}\nfloat cubicPulse(float c, float w, float x) {\n    x = abs(x - c);\n    if(x > w) return 0.;\n    x \/= w;\n    return 1.0 - x*x*(3.0-2.0*x);\n}\nvec3 hsv2rgb(float h, float s, float v) {\n\treturn v* mix(vec3(1),clamp(abs(mod(h* 6.+ vec3(0,4,2),6.)- 3.)- 1.,0.,1.),s);\n}\n\nvec2 map(vec3 U) {\n    return vec2(dist(U.xz,B(U.xz))-U.y*.0625*.0625,1);\n}\n\nconst float maxHei = 10.0;\n#define ZERO 0\n\nvec2 castRay( in vec3 ro, in vec3 rd) {\n    vec2 res = vec2(-1.0,-1.0);\n    \n    float t = .0001;\n    for( int i=0; i<70; i++ ) {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.00001*t) ) {\n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    return res;\n}\n\n\/\/ http:\/\/iquilezles.org\/www\/articles\/rmshadows\/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    \/\/ bounding volume\n    float tp = (maxHei-ro.y)\/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h\/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n\/\/ http:\/\/iquilezles.org\/www\/articles\/normalsSDF\/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n#if 1\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    \/\/ inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).x;\n    }\n    return normalize(n);\n#endif    \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)\/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n\n\nvec3 render(vec3 pos, vec3 rd, vec3 upv, vec3 nor, vec3 col, float occ, vec3 lig, vec3 blg, float bla, vec3 ligc) {\n    vec3 ref = reflect(rd, nor);\n    vec3 hal = normalize(lig-rd);\n    \n    float NoH = dot(nor, hal);\n    float HoV = dot(hal, rd);\n    float NoV = dot(nor, rd);\n    float RoY = dot(ref, upv);\n    float NoY = dot(nor, upv);\n    float NoL = dot(nor, lig);\n    float NoB = dot(nor, blg);\n\n    \/\/ lighting\n    float amb = clamp(0.5+0.5*NoY, 0.0, 1.0);\n    float dif = clamp(NoL, 0.0, 1.0);\n    float bac = clamp(NoB, 0.0, 1.0)*bla;\n    float dom = smoothstep(-0.2, 0.2, RoY);\n    float fre = pow(clamp(1.0-abs(NoV),0.0,1.0), 8.0);\n    \n    \/\/dif *= calcSoftshadow(pos, lig, 0.02, 2.5);\n    \/\/dom *= calcSoftshadow(pos, ref, 0.02, 2.5);\n    \n    float speN = pow(clamp(NoH,0.0,1.0),4.*4.);\n    float speV = pow(clamp(1.0+HoV,0.0,1.0),4.*1.0);\n    \/\/speV = 0.04+0.96*speV;\n    float spe = speN*dif*speV;\n    \n    vec3 bacc = vec3(0.25,0.25,0.25)+vec3(0,.125,.25)*ligc;\n    vec3 lin = vec3(0.0);\n    lin += 0.30*dif*vec3(1.00,0.80,0.55);\n    lin += 0.05*amb*vec3(0.40,0.60,1.00)*occ;\n    lin += 0.05*dom*vec3(0.40,0.60,1.00)*occ;\n    lin += 0.25*bac*bacc*occ;\n    lin += 0.05*fre*vec3(1.00,1.00,1.00)*occ;\n    col *= lin*1.;\n    \/\/col += vec3(speV,dif,speN); \n    col += 90.0*spe*ligc;\n    \/\/col += spe;\n    return col;\n}\n\n\nvoid mainImage( out vec4 Q, in vec2 U) {\n    vec4 a = A(U);\n    vec4 b = B(U);\n    vec4 df = distN(U,b);\n    float s = df.x;\n    vec2 sGrad = s - vec2(dist(U-vec2(1,0),b),dist(U-vec2(0,1),b));\n    vec2 azGrad = a.z - vec2(A(U-vec2(1,0)).z, A(U-vec2(0,1)).z);\n    \/\/float m000 = smoothstep(-0.1,1.1,s-a.z*1.995);\n    float m000 = smoothstep(-0.1,1.1,s);\n    float m001 = 1.-m000;\n    float m010 = smoothstep(-0.1-a.z*12.995,1.1-a.z*12.995,s);\n    float m011 = 1.-m010;\n    float m100 = m010-m000;\n    \n    float m0 = smoothstep(-0.1,1.1,0.+s-a.z*1.995);\n    float m1 = 1.-m0;\n    float m2 = smoothstep(.25,-.95,s);\n    float m3 = 1.-m2;\n    float pulse = dot(sGrad,a.xy);\n    float pulse1 = impulse(2.,max(.0,pulse));\n    float pulse2 = cubicPulse(-1.,.95,min(.0,pulse));\n    float am0 = exp2(-1.-.125*.125*s);\n    float am1 = exp2(-1.-.125*s)*(1.+1.25*pulse1-.875*pulse2);\n    float am2 = 0.5-0.5*cos(1.53*s);\n    float am3 = m1*m2;\n    float am4 = 0.5-0.5*cos(1.131*s);\n\n    float wave = pow(pow(abs(s),.9),.9);\n    wave *= 1.+.5*pulse1;\n    wave *= 1.-.75*pulse2;\n    wave -= 2.*fract(2.*iTime-8.*length((iMouse.xy-U)\/R));\n\n    float hue = fract(.41+b.z*300.61)*.75-.0625;\n    hue = decodeColor(b.z)*.75-.0625;\n    float hueM = 1.-2.*fract(.41+b.z*33.61);\n    hueM = .03*hueM + .01*sign(hueM);\n    hueM = mod(hueM,.0625*.5);\n    float sat = 1.-fract(.31+b.z*211.5)*.25;\n    float val = 1.0;\n    Q = vec4(0);\n    \/\/Q = 0.5+0.5*sin(1.6*dist(U,b)+A(U).z*vec4(1,2,3,4));\n    \n\n    vec4 col0 = vec4(1,2,3,4);\n    vec4 col1 = vec4(1,1,1,1)*(0.5+0.5*sin(PI*wave));\n    vec4 col2 = (0.5+0.5*sin(PI*.5*s+a.z*vec4(1,2,3,4)*3.5));\n    vec4 col3 = (0.5+0.5*sin(.31+b.z*vec4(1,2,3,4)*41.5));\n    vec4 col4 = (0.5+0.5*sin(.91+b.z*vec4(1,2,3,4)*41.5));\n    col3 = hsv2rgb(hue+hueM,.5+.5*sat,.1+.6*val).xyzz;\n    col4 = hsv2rgb(hue-hueM,.1+.9*sat,.3+.7*val).xyzz;\n    \/\/Q += .25*m000*vec4(0,1,0,0);\n    \/\/Q += .25*m010*vec4(1,0,1,0);\n    \n    float outline = smoothstep(0.5,2.,abs(s-.75));\n    vec4 colWater = vec4(0);\n    colWater += .5*am0*col0;\n    vec4 test = clamp(2.+sin(33.*a.z)-vec4(1,2,0,0),0.,1.);\n    float rippleWaves = .5*exp2(-1.-.125*s)*(1.+1.25*pulse1-.875*pulse2)*(0.5+0.5*sin(PI*wave))*smoothstep(-.9,.1,s);\n    float rippleWavesMask = smoothstep(0.0,0.0625,a.z);\n    colWater += rippleWaves* rippleWavesMask;\n    colWater += 8.*length(azGrad)*sin(33.*a.z);\n    colWater *= .5+.5*outline;\n    vec4 colShape = vec4(0);\n    colShape += .5*m1*am2*col2;\n    colShape += mix(col3,col4,am4);\n    colShape *= outline;\n    colShape += .5*(1.-outline);\n    \n    vec3 ro = vec3(R*.5,max(R.x,R.y));\n    vec3 pos = vec3(U,0);\n    float rz = distance(pos,ro);\n    vec3 rd = normalize(pos-ro);\n    vec2 sun2D = rot(R, iTime*1.0025);\n    vec3 sunO = vec3(iMouse.xy,.125*ro.z); \n    vec3 sunD = sunO-pos;\n    float submerge = cubicPulse(2.1,.2,a.z)*(0.0+1.5*sin(54.01*a.z+iTime)*sin(54.01*a.z+iTime));\n    submerge = (a.z-1.9375)*1.-2.*max(-.0625*s-.5,0.);\n    submerge = clamp(submerge,0.,1.);\n    vec3 res;\n    {\n        vec3 axis = sunO;\n        vec3 nor = normalize(df.yzw);\n        vec4 alb = colShape;\n        vec3 lig = normalize(sunD);\n        vec3 blg = normalize(vec3(-1,-1,.5)*lig);\n        float bla = clamp(-10.+15.0*nor.z,0.0,1.0);\n        vec3 upv = vec3(0,0,1);\n        float occ = clamp(1.-dot(vec2(1),exp2(32.*(abs(2.*U\/R-1.)-1.))),0.0,1.0);\n        vec4 colShape2 = vec4(0);\n        vec3 ligc = vec3(1);\n        vec3 col = res = render(pos, rd, upv, nor, colShape.rgb, occ, lig, blg, bla, ligc);\n        for(float i = 0.; i < 1.; i += 1.\/8.) {\n            sunD = sunO- pos;\n            sunD += vec3(450.*rot(normalize(sunD.xy+.00001),i*2.*PI),.0625*ro.z);\n            lig = normalize(sunD);\n            blg = normalize(vec3(-1,-1,.5)*lig);\n            ligc = hsv2rgb(i,.875,1.);\n            vec3 rend = render(pos, rd, upv, nor, colShape.rgb, occ, lig, blg, bla, ligc);\n            \/\/res *= exp(-\n            colShape2 += vec4(rend,1);\/\/max(vec3(0),res*8.-7.-col);\n        }\n        colShape.rgb = \n            \/\/col + \n            colShape2.rgb \/ max(1.,colShape2.a-50.);\n            \/\/col + (sqrt(1.+1.*colShape2)-1.)\/1.;\n    }\n    float h001 = submerge;\n    float h000 = smoothstep(-.09,2.9,s)*(1.-h001);\n    float h002 = (1.-h000)*(1.-h001);\n\n    Q += 1.*h000*colWater;\n    Q += 1.*h001*.6*colWater;\n    Q += 1.*h001*.3*colShape;\n    Q += 1.*h002*colShape;\n    \n\n            \n    Q.rgb = pow(Q.rgb, vec3(0.833*2.));\n    Q.rgb *= 1.07*.99968;\n    Q.rgb = ACESFitted(Q.rgb);\n    Q.rgb = clamp(linear_srgb(Q.rgb), 0.0, 1.0);\n\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define R iResolution.xy\n#define PI acos(-1.)\n\n\nuint decodeAscii(float b_z) {\n    return uint(fract(b_z)*256.);\n}\nfloat decodeColor(float b_z) {\n    return fract(b_z*256.);\n}\nfloat decodeSize(float b_z) {\n    return floor(b_z);\n}\nfloat ln (vec2 p, vec2 a, vec2 b) {return length(p-a-(b-a)*clamp(dot(p-a,b-a)\/dot(b-a,b-a),0.,1.));}\n\n\n\/\/---------------------------------------------------------------------------------\n\nfloat linear_srgb(float x) {\n    return mix(1.055*pow(x, 1.\/2.4) - 0.055, 12.92*x, step(x,0.0031308));\n}\nvec3 linear_srgb(vec3 x) {\n    return mix(1.055*pow(x, vec3(1.\/2.4)) - 0.055, 12.92*x, step(x,vec3(0.0031308)));\n}\n\nfloat srgb_linear(float x) {\n    return mix(pow((x + 0.055)\/1.055,2.4), x \/ 12.92, step(x,0.04045));\n}\nvec3 srgb_linear(vec3 x) {\n    return mix(pow((x + 0.055)\/1.055,vec3(2.4)), x \/ 12.92, step(x,vec3(0.04045)));\n}\n\n\/\/---------------------------------------------------------------------------------\n\n\n\/\/ https:\/\/www.shadertoy.com\/view\/4djSRW\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * 443.8975);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 pModPolar(vec2 p, float repetitions) {\n\tfloat angle = 2.*PI\/repetitions;\n\tfloat a = atan(p.y, p.x) + angle\/2.;\n\tfloat r = length(p);\n\ta = mod(a,angle) - angle\/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\treturn p;\n}\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\nfloat vmin(vec2 v) {\n\treturn min(v.x, v.y);\n}\nfloat fBox(vec2 p, vec2 b) {\n\tvec2 d = abs(p) - b;\n\treturn length(max(d, vec2(0))) + vmax(min(d, vec2(0)));\n}\n\nfloat StarPolygon(vec2 p, float repetitions, float radius, float inner) {\n    float angle = PI\/repetitions;\n    vec2 p2 = pModPolar(p.yx, repetitions);\n    float x = abs(p2.y);\n    float y = p2.x - radius;\n    float offset = (PI*.5 - angle)*inner;\n    float uvRotation = angle + offset;\n    vec2 uv = cos(uvRotation)*vec2(x, y) + sin(uvRotation)*vec2(-y, x);\n    \n    float corner = radius*sin(angle)\/cos(offset);\n    float li = length(vec2(max(uv.x - corner, 0.0), uv.y));\n    float lo = length(vec2(min(uv.x, 0.0), uv.y));\n    return mix(-li, lo, step(0.0, uv.y));\n}\nfloat something(vec2 u, float z) {\n    float a = 36.4*z;\n    u = abs(u)-.25*z;\n    u *= mat2(cos(a),-sin(a),sin(a),cos(a));\n    u = abs(u)-z*vec2(.3,1);\n    return max(u.x,u.y);\n}\n\nfloat starPolys(vec2 u, vec4 b) {\n    float df = StarPolygon(u,3.+floor(4.*fract(b.z*1.601)),b.z,fract(b.z*2.601));\n    return df;\n}\nfloat almostIdentityLo(float x, float m) {\n    return (x >= m) ? x : (-(1. \/ 3.) * (1. \/ m) * (1. \/ m) * x + (1. \/ m)) * x * x + (1. \/ 3.) * m;\n}\nvec4 sampleCharacter(uint ch, vec2 chUV, sampler2D sampler) {\n    uvec2 chPos = uvec2(ch % 16u, ch \/ 16u);\n    vec2 cchUV = clamp(chUV, vec2(0.0078125), vec2(0.9921875));\n    cchUV = 0.5+(0.5-0.0078125)*(chUV-0.5)\/max(0.5-0.0078125,max(abs(chUV.x-0.5),abs(chUV.y-0.5)));\n    vec2 uv = (vec2(chPos) + cchUV) \/ 16.;\n\n    float l = distance(cchUV, chUV);\n    l = fBox(chUV-0.5,vec2(0.5-0.0078125))-0.-0.0078125*0.;\n    vec4 s = textureLod(sampler,uv,0.);\n    s.gb = s.gb*2.- 1.;\n    s.b = -s.b; \/\/ texture sampler is VFlipped\n    s.a = s.a- .5+ s.r\/ 256.;\n    \/\/s.a = s.a+ (l >= 0. ? 1.0 : max(0.,s.a*1.-0.5)) * l;\n    s.a = s.a + l * max(step(0.,l),s.a);\n    return s;\n}\nvec2 rot(vec2 v, float a) {\n    return v * mat2(cos(a),-sin(a),sin(a),cos(a));\n}\nmat3 rotAA(vec3 u, float a) {\n    float c = cos(a), s = sin(a), o = 1.-c;\n    return mat3(\n        u.x*u.x*o+1.0*c, u.x*u.y*o-u.z*s, u.x*u.z*o+u.y*s,\n        u.y*u.x*o+u.z*s, u.y*u.y*o+1.0*c, u.y*u.z*o-u.x*s,\n        u.z*u.x*o-u.y*s, u.z*u.y*o+u.x*s, u.z*u.z*o+1.0*c);\n}\nvec4 alphabet(vec2 u, vec4 b, sampler2D sampler) {\n    uint id = decodeAscii(b.z);\n    if(id == 208u || id == 80u || id == 93u || id == 143u) id = 252u;\n    \/\/else if(id == 0u) id = 80u;\n    \/\/else if(id >= 143u) id = 0u;\n    float sizev = 16.+ 2.5* b.z;\n    vec4 df = sampleCharacter(id,u\/sizev+ .5, sampler)*sizev;\n    \/\/df.x -= max(.125-df.w,.0);\n    \/\/df.w *= sizev;\n    df.yz = rot(df.yz, -b.w);\n    return df.wyzx;\n}\nvec2 distRot(vec2 U, vec4 b) {\n    return rot(U-b.xy,b.w);\n}\n\/\/#define distN(U,b) vec3(something(distRot(U,b), b.z),0,0);\n\/\/#define distN(U,b) vec3(starPolys(distRot(U,b), b),0,0);\n#define distN(U,b) alphabet(distRot(U,b),b,iChannel3)\n#define dist(U,b) distN(U,b).x\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":33,"src":"\/presets\/tex00.jpg","ctype":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":49,"src":"\/media\/a\/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","ctype":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":258,"src":"\/media\/previz\/buffer01.png","ctype":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":257,"channel":0}],"code":"vec4 A(vec2 U) {return texture(iChannel0,U\/R);}\nvec4 B(vec2 U) {return texture(iChannel1,U\/R);}\nvec4 K(vec2 U) {return texture(iChannel2,(U+.5)\/vec2(256,3));}\nvec4 F(vec2 U) {return textureLod(iChannel3,U,0.);}\n\nvec4 T (vec2 U) {\n\treturn A(U-A(U).xy);\n}\nvoid mainImage( out vec4 Q, in vec2 U ) {\n    vec4 mo = A(vec2(0));\n    if(U.x < 1. && U.y < 1.) {\n        if (iMouse.z > 0.) {\n            if (mo.z > 0.) {\n                Q = vec4(iMouse.xy\/R, mo.xy);\n            } else {\n                Q =  vec4(iMouse.xy\/R, iMouse.xy\/R);\n            }\n        } else {\n            Q = vec4(0.);\n        }\n        return;\n    }\n    Q = T(U);\n    vec4 b = B(U);\n    vec4 q = T(b.xy);\n    float p = smoothstep(2.,0.,dist(U,b));\n    vec2 r = normalize(U-b.xy);\n    \/\/vec2 k = vec2(-r.y,r.x);\n    float o = 1.+2.*p;\n    vec4 \n        n = T(U+vec2(0,o)),\n        e = T(U+vec2(o,0)),\n        s = T(U-vec2(0,o)),\n        w = T(U-vec2(o,0)),\n        m = n+e+s+w;\n    Q.x -= .25*(e.z-w.z+Q.w*(n.w-s.w));\n    Q.y -= .25*(n.z-s.z+Q.w*(e.w-w.w));\n    Q.z  = .25*((s.y-n.y+w.x-e.x)+m.z);\n    Q.w  = .25*((n.x-s.x+w.y-e.y)-Q.w);\n    \n    Q.xy += p*(0.25*m.xy-Q.xy);\n    Q.z += .05*p;\n    Q.z*=0.975;\n    if (mo.z > 0. && mo.xy != mo.zw) {\n        float l = ln(U, mo.xy*R, mo.zw*R);\n        Q.xy += .006*(mo.xy*R - mo.zw*R)*smoothstep(40.,0.,l);\n    }\n    \n    if (R.x-U.x < 5.) Q.x = -abs(Q.x)*.999;\n    if (R.y-U.y < 5.) Q.y = -abs(Q.y)*.999;\n    if (U.x < 5.) Q.x = abs(Q.x)*.999;\n    if (U.y < 5.) Q.y = abs(Q.y)*.999;\n    if(mod(float(iFrame), 60.) == 1. && (R.x-U.x < 1. && R.y < U.y+U.y || U.x < 1. && R.y >= U.y+U.y)) {\n        Q.xy = vec2(.6*(1.-2.*smoothstep(.45,.55,U.y\/R.y)),.0);\n    }\n    \n    \/\/if (R.x-U.x<1.) Q.xy=vec2(-.3,.0);\n    \n    \/\/if (R.x-U.x < 5.||U.y < 5.||R.y-U.y<5.) Q.xy *= 0.5;\n    \n    if (iFrame < 1 || K(vec2(32,1)).x > 0.1) {\n        Q = vec4(.3-.6*smoothstep(.45,.55,U.y\/R.y),0,0,0)*0.0;\n    }\n    if (iFrame < 240) {\n        Q.xy *= smoothstep(200.,300.,clamp(float(240 - iFrame)\/150.-1.,0.,1.)*100. + distance(R*.5,U));\n    }\n}\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":33,"src":"\/presets\/tex00.jpg","ctype":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":49,"src":"\/media\/a\/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","ctype":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":258,"src":"\/media\/previz\/buffer01.png","ctype":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":258,"channel":0}],"code":"vec4 A(vec2 U) {return texture(iChannel0,U\/R);}\nvec4 B(vec2 U) {return texture(iChannel1,U\/R);}\nvec4 K(vec2 U) {return texture(iChannel2,(U+.5)\/vec2(256,3));}\nvec4 F(vec2 U) {return textureLod(iChannel3,U,0.);}\nvoid swap (vec2 U, inout vec4 A, vec4 B) {if (A.z == 0. || !(dist(U,B) >= dist(U,A))) A = B;}\nfloat ascii2id(float Q_z) {return\n\/\/ ((15.-floor(Q_z\/16.))*16.+(15.-mod(Q_z,16.))*1. )\n\/\/ ((    floor(Q_z\/16.))*16.+(15.-mod(Q_z,16.))*1. )\n\/\/ ((15.-floor(Q_z\/16.))*1. +(15.-mod(Q_z,16.))*16.)\n\/\/ ((    floor(Q_z\/16.))*1. +(15.-mod(Q_z,16.))*16.)\n   ((15.-floor(Q_z\/16.))*16.+(    mod(Q_z,16.))*1. )\n\/\/ ((    floor(Q_z\/16.))*16.+(    mod(Q_z,16.))*1. )\n\/\/ ((15.-floor(Q_z\/16.))*1. +(    mod(Q_z,16.))*16.)\n\/\/ ((    floor(Q_z\/16.))*1. +(    mod(Q_z,16.))*16.)\n;\n}\nfloat uv2color(vec2 rnd) {\n    return mod(rnd.x*.5+rnd.y*2.+float(iFrame % 1024)+iDate.w,32.)\/32.;\n}\nfloat encodeSizeAsciiColor(float size, float ascii, float color) {\n    return size+(ascii2id(ascii)+color)\/256.;\n}\n    \nvoid mainImage( out vec4 Q, in vec2 U ) {\n    Q = B(U);\n\n    swap(U,Q,B(U+vec2(8,8)));\n    swap(U,Q,B(U+vec2(8,-8)));\n    swap(U,Q,B(U-vec2(8,8)));\n    swap(U,Q,B(U-vec2(8,-8)));\n\n    swap(U,Q,B(U+vec2(4,0)));\n    swap(U,Q,B(U+vec2(0,-4)));\n    swap(U,Q,B(U-vec2(4,0)));\n    swap(U,Q,B(U-vec2(0,-4)));\n\n    swap(U,Q,B(U+vec2(2,2)));\n    swap(U,Q,B(U+vec2(2,-2)));\n    swap(U,Q,B(U-vec2(2,2)));\n    swap(U,Q,B(U-vec2(2,-2)));\n\n    swap(U,Q,B(U+vec2(1,0)));\n    swap(U,Q,B(U+vec2(0,-1)));\n    swap(U,Q,B(U-vec2(1,0)));\n    swap(U,Q,B(U-vec2(0,-1)));\n\n    Q.xyw += A(Q.xy).xyw;\n    \/*\n    if((R.x-U.x < 1. && R.y < U.y+U.y || U.x < 1. && R.y >= U.y+U.y)) {\n        float key = -1.;\n        for(float i = 0.; i < 256.; i++) {\n            if(K(vec2(i,0)).x > 0.1) key = i;\n        }\n        if(key >= 0. || mod(float(iFrame), 60.) == 1.) {\n            float y = floor(U.y\/32.)*32.+16.;\n            float prog = 1.+floor(R.y\/(40.+iTime*2.));\n            if(mod(floor(U.y\/32.),prog) == mod(-floor(float(iFrame)\/60.),prog)) {\n                Q.x = U.x < 1. ? -1. : R.x;\n                Q.y = y;\n                Q.z = -2.5*log(1e-5+(0.5+0.5*sin(y+(y+.45)*mod(float(iFrame),1e3)))*(.0625+.9375*smoothstep(120.,10.,min(100.,iTime))));\n                Q.w = 0.;\n                if(key>=0.) {\n                    Q.z = encodeSizeAsciiColor(floor(Q.z),key,fract(fract(float(iFrame)\/256.)+.0*Q.z*256.));\n                }\n            }\n        }\n    }\n    *\/\n    if(mod(float(iFrame), 60.) == 1. && (R.x-U.x < 1. && R.y < U.y+U.y || U.x < 1. && R.y >= U.y+U.y)) {\n        \/\/float y = round((U.y+5.)\/20.)*20.-5.;\n        float y = floor(U.y\/32.)*32.+16.;\n        float prog = 1.+floor(R.y\/(40.+iTime*2.));\n        if(mod(floor(U.y\/32.),prog) == mod(-floor(float(iFrame)\/60.),prog)) {\n            float key = -1.;\n            float rnd = hash13(vec3(U.x-501.61,y+101.61,float(iFrame)\/60.));\n            float rnd2 = fract(PI*(PI+rnd));\n            float beg = 0.;\n            float expo = 10.-mod(floor(float(iFrame)\/240.),10.);\n            float expoKey = -1.;\n\n            vec2 seg = vec2(0);\n            seg = vec2(  0,  3);expo--;if(expo > 0.0)expoKey = seg.x+rnd2*seg.y;if(K(vec2(49,2)).x < .1 && rnd >= beg\/(beg+seg.y)) {key = seg.x+rnd2*seg.y;beg+=seg.y;}\n            seg = vec2(  3,  2);expo--;if(expo > 0.0)expoKey = seg.x+rnd2*seg.y;if(K(vec2(50,2)).x < .1 && rnd >= beg\/(beg+seg.y)) {key = seg.x+rnd2*seg.y;beg+=seg.y;}\n            seg = vec2(  5,  4);expo--;if(expo > 0.0)expoKey = seg.x+rnd2*seg.y;if(K(vec2(51,2)).x < .1 && rnd >= beg\/(beg+seg.y)) {key = seg.x+rnd2*seg.y;beg+=seg.y;}\n            seg = vec2(  9,  7);expo--;if(expo > 0.0)expoKey = seg.x+rnd2*seg.y;if(K(vec2(52,2)).x < .1 && rnd >= beg\/(beg+seg.y)) {key = seg.x+rnd2*seg.y;beg+=seg.y;}\n            seg = vec2( 16, 12);expo--;if(expo > 0.0)expoKey = seg.x+rnd2*seg.y;if(K(vec2(53,2)).x < .1 && rnd >= beg\/(beg+seg.y)) {key = seg.x+rnd2*seg.y;beg+=seg.y;}\n            seg = vec2( 28,  1);expo--;if(expo > 0.0)expoKey = seg.x+rnd2*seg.y;if(K(vec2(54,2)).x < .1 && rnd >= beg\/(beg+seg.y)) {key = seg.x+rnd2*seg.y;beg+=seg.y;}\n            seg = vec2( 29,  1);expo--;if(expo > 0.0)expoKey = seg.x+rnd2*seg.y;if(K(vec2(55,2)).x < .1 && rnd >= beg\/(beg+seg.y)) {key = seg.x+rnd2*seg.y;beg+=seg.y;}\n            seg = vec2( 30,  2);expo--;if(expo > 0.0)expoKey = seg.x+rnd2*seg.y;if(K(vec2(56,2)).x < .1 && rnd >= beg\/(beg+seg.y)) {key = seg.x+rnd2*seg.y;beg+=seg.y;}\n            seg = vec2( 32, 96);expo--;if(expo > 0.0)expoKey = seg.x+rnd2*seg.y;if(K(vec2(57,2)).x < .1 && rnd >= beg\/(beg+seg.y)) {key = seg.x+rnd2*seg.y;beg+=seg.y;}\n            seg = vec2(128,128);expo--;if(expo > 0.0)expoKey = seg.x+rnd2*seg.y;if(K(vec2(48,2)).x < .1 && rnd >= beg\/(beg+seg.y)) {key = seg.x+rnd2*seg.y;beg+=seg.y;}\n            key = floor(key);\n            float anyKey = -1.;\n            for(float i = 0.; i < 256.; i++) {\n                if(K(vec2(i,0)).x > 0.1) anyKey = i;\n            }\n            if(key < 0.) {\n                key = anyKey;\n            }\n            if(anyKey < 0.0) {\n\t            key = floor(expoKey);\n            }\n            Q.x = U.x < 1. ? -1. : R.x;\n            Q.y = y;\n            Q.z = -2.5*log(1e-5+(0.5+0.5*sin(y+(y+.45)*mod(float(iFrame),1e3)))*(.0625+.9375*smoothstep(100.,10.,min(100.,iTime))));\n                           Q.w = 0.;\n            if(key>=0.) {\n                Q.z = encodeSizeAsciiColor(floor(Q.z),key,fract(fract(float(iFrame)\/256.)+.0*Q.z*256.));\n            }\n        }\n    }\n\/*\n    if (R.x-U.x < 1. && mod(float(iFrame) , 60.) == 1.) {\n        float y = round((U.y+5.)\/20.)*20.-5.;\n        Q = vec4(\n            R.x,y,\n        0.5+0.5*sin(y+(y+.45)*mod(float(iFrame),1e3)),0.\n       );\n       Q.z = -1.5*log(1e-4+Q.z);\n    }\n    \n*\/    \n    \n    if(iFrame < 1 || K(vec2(32,1)).x > 0.1) {\n        vec4 q = vec4(floor((U+2.-R*.5)\/4.\/5.),0,0);\n        if(q.y == 5.) {\n            q.z = (q.x == -8.) ? 80.  :\/\/ P\n            \/* *\/ (q.x == -6.) ? 111. :\/\/ o\n            \/* *\/ (q.x == -4.) ? 108. :\/\/ l\n            \/* *\/ (q.x == -2.) ? 108. :\/\/ l\n            \/* *\/ (q.x ==  0.) ? 117. :\/\/ u\n            \/* *\/ (q.x ==  2.) ? 116. :\/\/ t\n            \/* *\/ (q.x ==  4.) ? 105. :\/\/ i\n            \/* *\/ (q.x ==  6.) ? 110. :\/\/ n\n            \/* *\/ (q.x ==  8.) ? 103. :\/\/ g\n            0.0;\n        } else if(q.y == -1.) {\n            q.z = (q.x == -9.) ? 73.  :\/\/ I\n            \/* *\/ (q.x == -7.) ? 115. :\/\/ s\n            \/* *\/ (q.x == -3.) ? 101. :\/\/ e\n            \/* *\/ (q.x == -1.) ? 97.  :\/\/ a\n            \/* *\/ (q.x ==  1.) ? 115. :\/\/ s\n            \/* *\/ (q.x ==  3.) ? 121. :\/\/ y\n            \/* *\/ (q.x ==  7.) ? 97.  :\/\/ a\n            \/* *\/ (q.x ==  9.) ? 115. :\/\/ s\n            0.0;\n        } else if(q.y == -5.) {\n            q.z = (q.x == -11.) ? 65.  :\/\/ A\n            \/* *\/ (q.x ==  -9.) ? 45.  :\/\/ -\n            \/* *\/ (q.x ==  -7.) ? 66.  :\/\/ B\n            \/* *\/ (q.x ==  -5.) ? 45.  :\/\/ -\n            \/* *\/ (q.x ==  -3.) ? 116. :\/\/ t\n            \/* *\/ (q.x ==  -2.) ? 111. :\/\/ o\n            \/* *\/ (q.x ==  -1.) ? 115. :\/\/ s\n            \/* *\/ (q.x ==   0.) ? 115. :\/\/ s\n            \/* *\/ (q.x ==   2.) ? 45.  :\/\/ -\n            \/* *\/ (q.x ==   4.) ? 105. :\/\/ i\n            \/* *\/ (q.x ==   5.) ? 110. :\/\/ n\n            \/* *\/ (q.x ==   7.) ? 45.  :\/\/ -\n            \/* *\/ (q.x ==   9.) ? 67.  :\/\/ C\n            \/* *\/ (q.x ==  11.) ? 33.  :\/\/ !\n            0.0;\n        } else { q.z = 0.; }\n        if(q.z > 0.) {\n            Q = vec4(q.xy*5.*4.-2.+R*.5,encodeSizeAsciiColor(30.,q.z,uv2color(q.xy)),0);\n        } else {\n            Q = vec4(-R,0,0);\n        }\n    } else if(iMouse.z>0.) {\n        vec2 pa = iMouse.xy;\n        vec2 pb = A(vec2(0)).zw*R;\n        if(ln(U, pa, pb) < 40. + distance(pa,pb)*0.5) {\n        \tQ = vec4(-R,0,0);\n        }\n    }\n}\n","name":"Buffer B","description":"","type":"buffer"}]}}