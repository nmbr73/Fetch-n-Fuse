{
 "ver": "0.1",
 "info": {
  "id": "7ljyD3",
  "date": "0",
  "viewed": 0,
  "name": "OceanTerrain JiPi706",
  "description": "Ocean terrain with raymarch.",
  "likes": 0,
  "published": "Private",
  "usePreview": 0,
  "tags": [
   "terrain",
   "water"
  ],
  "hasliked": 0,
  "parentid": "NtjcW3",
  "parentname": "Ocean terrain"
 },
 "renderpass": [
  {
   "inputs": [
    {
     "id": "4dfGRn",
     "filepath": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg",
     "type": "texture",
     "channel": 0,
     "sampler": {
      "filter": "mipmap",
      "wrap": "repeat",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    }
   ],
   "outputs": [
    {
     "id": "4dfGRr",
     "channel": 0
    }
   ],
   "code": "\nfloat t=0.;\n\nfloat map(vec3 p) {\n  \n   float pl = p.y +\n  \t0.1 * texture(iChannel0, sin(t*.008)+t*.008+p.xz*.5).r +\n  \t0.2 * texture(iChannel0, cos(-t*.004)-t*.004+p.xz*.15).r +\n  \t0.9 * texture(iChannel0, sin( t*.020)+t*.010+p.xz*.05).r;\n\n  \treturn pl;\n}\n\n\nvec3 raymarch(vec3 ro,  vec3 rd) {\n  \tfloat d = 0.;\n  \tvec3 p = ro;\n  \tfloat li=0.;\n  \tfor(float i=0.; i<2000.; i++) {\n    \tfloat h = map(p); \n    \tif(abs(h)<.002*d) return vec3(d,i,1);\n    \tif(d>100.) return vec3(d,i,0);\n    \td+=h;\n    \tp+=rd*h;\n        li = i;\n  \t}\n  \treturn vec3(d, li, 0);\n}\n\nvec3 destroyed_normals(vec3 p) {\n    const vec2 e = vec2(0.3,0.0);\n    return normalize(map(p)-vec3(map(p-e.xyy), map(p-e.yxy), map(p-e.yyx)));\n}\n\nvec3 cam(vec2 uv, vec3 cameraPos, vec3 lookAtPoint, float z) {\n  \tvec3 cd = normalize(lookAtPoint - cameraPos); // camera direction\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd)); // camera right\n\tvec3 cu = normalize(cross(cd, cr));\n  \treturn normalize(cd*z+uv.x*cr+uv.y*cu);\n}\n\n\nvec3 phong(vec3 lightDir, vec3 normal, vec3 rd) {\n  // ambient\n  float k_a = 0.6;\n  vec3 i_a = vec3(0.2, 0.5, 0.8);\n  vec3 ambient = k_a * i_a;\n\n  // diffuse\n  float k_d = 0.7;\n  float dotLN = clamp(dot(lightDir, normal), 0., 1.);\n  vec3 i_d = vec3(0., 0.3, 0.7);\n  vec3 diffuse = k_d * dotLN * i_d;\n\n  // specular\n  float k_s = 0.6;\n  float dotRV = clamp(dot(reflect(lightDir, normal), -rd), 0., 1.);\n  vec3 i_s = vec3(.2, 0.8, 1.);\n  float alpha = 12.;\n  vec3 specular = k_s * pow(dotRV, alpha) * i_s;\n\n  return ambient + diffuse + specular;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    t = mod(iTime, 100.)-50.;\n    vec2 uv = ((fragCoord/iResolution.xy)-0.5) / vec2(iResolution.y / iResolution.x, 1);\n    \n    vec3 ro = vec3(0,0.5,-2);\n  \tvec3 rd = vec3(0);\n  \tvec3 dir = cam(uv,ro,rd,.9);\n  \n  \tvec3 lp = vec3(1,2,2);\n  \n  \tvec3 col = vec3(0);\n  \tvec3 m = raymarch(ro, dir);\n  \tif(m.z == 1.) {\n    \tvec3 p = ro+dir*m.x;\n    \tvec3 n = destroyed_normals(p);\n    \tvec3 ld = normalize(lp-p);\n        \n      vec3 lightPosition1 = vec3(8, 2, -20);\n      vec3 lightDirection1 = normalize(lightPosition1 - m);\n      float lightIntensity1 = 0.75;\n      \n      col = lightIntensity1 * phong(lightDirection1, n, dir); \n      \n  \t} else {\n    \tcol = cos(dir)*vec3(.8, .7, 1.1)*smoothstep(0.,.1,dir.y);\n  \t}\n  \tcol += pow(m.y/70., 3.);\n    \n    fragColor = vec4(col,1.0);\n}",
   "name": "Image",
   "description": "",
   "type": "image"
  }
 ]
}