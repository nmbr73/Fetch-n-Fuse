{
 "ver": "0.1",
 "info": {
  "id": "slcfWn",
  "date": "0",
  "viewed": 0,
  "name": "Infinite Sadness JiPi",
  "description": "Comment a line somewhere for the yummier version\nUncomment another for the milky one",
  "likes": 0,
  "published": "Private",
  "usePreview": 0,
  "tags": [
   "fluid",
   "particles"
  ],
  "hasliked": 0,
  "parentid": "tldcW7",
  "parentname": "Infinite Sadness"
 },
 "renderpass": [
  {
   "inputs": [
    {
     "id": "4dXGR8",
     "filepath": "/media/previz/buffer00.png",
     "type": "buffer",
     "channel": 0,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    },
    {
     "id": "XsXGR8",
     "filepath": "/media/previz/buffer01.png",
     "type": "buffer",
     "channel": 1,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    },
    {
     "id": "4sXGR8",
     "filepath": "/media/previz/buffer02.png",
     "type": "buffer",
     "channel": 2,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    }
   ],
   "outputs": [
    {
     "id": "4dfGRr",
     "channel": 0
    }
   ],
   "code": "// Fork of \"Paint streams\" by michael0884. https://shadertoy.com/view/WtfyDj\n// 2020-12-16 10:30:33\n\nvec3 normals(vec2 pos, sampler2D sampler)\n{\n    float c = texel(sampler, pos).z;\n    float l = texel(sampler, pos + vec2(-1.0, 0.0)).z;\n    float r = texel(sampler, pos + vec2(1.0, 0.0)).z;\n    float d = texel(sampler, pos + vec2(0.0, -1.0)).z;\n    float u = texel(sampler, pos + vec2(0.0, 1.0)).z;\n    \n    \n    vec3 va = normalize(vec3(vec2(2.0, 0.0), r-l));\n    vec3 vb = normalize(vec3(vec2(0.0, 2.0), u-d));\n    //return cross(va,vb);\n    \n    float ld = texel(sampler, pos + vec2(-1.0, -1.0)).z;\n    float ru = texel(sampler, pos + vec2(1.0, 1.0)).z;\n    float rd = texel(sampler, pos + vec2(1.0, -1.0)).z;\n    float lu = texel(sampler, pos + vec2(-1.0, 1.0)).z;\n    \n    float me = (l+r+u+d+ld+ru+rd+ld)/8.0;\n    me = l * 0.25\n        +r * 0.25\n        +d * 0.25\n        +u * 0.25;\n\n    //return normalize(vec3(l-r, d-u, c/c) * vec3(c, c, 1.0));\n    return normalize(vec3(l-r, d-u, saturate(me-c)+c*0.3) * vec3(c, c, 1.0));\n}\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{\n\tR = iResolution.xy; time = iTime;\n    ivec2 p = ivec2(pos);\n    \n    vec4 data = texel(ch0, pos);\n    particle P = getParticle(data, pos);\n    \n    \n    // Velocity Color\n    vec2 V = P.V*0.2*Rot(2.7+iTime*0.1);\n\n    vec3 vc = vec3(V, length(V)-0.5*length(V) ) * 0.5 + 0.5;\n    vc = mix(vec3(1.0), vc, length(V));\n    vc.z = 1.0;\n    vc -= P.M.y*0.25;\n    \n    vc = vec3(1.0); //Here yumminess <-----\n   \n    \n    // Mass Color\n    vec3 mc = vc;\n    mc *= pow(P.M.x*0.5, 0.75);\n    mc = pow(mc, vec3(0.75)); \n    \n    \n    // Water Color\n    vec3 NN = normals(pos, ch0);\n    \n    float d = dot(NN, normalize(vec3(-1.5, 1.5, 1.5)))*0.5+0.5;\n    float s = pow(d, 50.0);\n    float c = pow(s * 0.75, 1.0);\n    \n    float sd = dot(NN, normalize(vec3(1.5, -1.5, 10.5)));\n    \n    vec3 wc = mix(vec3(1.0), vc, saturate(P.M.x/1.5)); \n    wc *= vec3(pow(sd*0.5, 0.25));   \n    wc += vec3(c*0.8 * P.M.x);  \n    \n    float test = dot(NN, normalize(vec3(1.5, -1.5, 2.5)))*0.5+0.5;\n    test = pow(test, 70.0);\n    wc += vec3(test*P.M.x);\n\n    //===\n    col.xyz = wc;\n    //col.xyz = mc; //And here milkyness <-----\n    \n    col.xyz = pow(col.xyz, vec3(0.9));\n}",
   "name": "Image",
   "description": "",
   "type": "image"
  },
  {
   "inputs": [],
   "outputs": [],
   "code": "\n\nvec2 R;\n\n#define Bf(p) p\n#define Bi(p) ivec2(p)\n//#define texel(a, p) texelFetch(a, Bi(p), 0)\n#define texel(a, p) texture(a, (vec2(Bi(p))+0.5f)/R)\n\n#define texelLoop(a, p) texelFetch(a, Bi(mod(p,R)), 0)\n#define pixel(a, p) texture(a, (p)/R)\n#define textureLoop(a, p) texture(a, mod(p,R)/R)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n\n#define PI 3.14159265\n\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define Gn(x) exp(-dot(x,x))\n#define G0n(x) exp(-length(x))\n\n#define dt 1.0\n\n#define UP vec3(1.0, 0.0, 0.0)\n#define RED UP\n\n#define fluid_rho 1.5\n#define particle_rad 1.5\n\n\n\n\n\n\nvec4 Mouse;\nfloat time;\n\n\nfloat Pf(float den, float rest)\n{\n    return 0.4*(den-rest);\n    //return 0.05*den*(den/rest- 1.);\n}\n\nfloat W(vec2 r, float h)\n{\n\treturn (length(r) > 0.0 && h >= length(r)) ?\n\t\t(315.0 / (64.0 * PI * pow(h, 9.0))) * pow((pow(h, 2.0) - pow(length(r), 2.0)), 3.0) :\n\t\t0.0;\n}\n\nvec2 WS(vec2 r, float h)\n{\n\treturn (length(r) > 0.0 && h >= length(r)) ?\n\t\t-(45.0 / (PI * pow(h, 6.0))) * pow((h - length(r)), 2.0) * (r / length(r)) :\n\t\tvec2(0.0);\n}\n\nmat2 Rot(float ang)\n{\n    return mat2(cos(ang), -sin(ang), sin(ang), cos(ang)); \n}\n\nvec2 Dir(float ang)\n{\n    return vec2(cos(ang), sin(ang));\n}\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat border(vec2 p)\n{\n    float bound = -sdBox(p - R*0.5, R*vec2(0.5, 0.5)); \n    float box = sdBox(Rot(0.0*time-0.0)*(p - R*vec2(0.5, 0.5)) , R*vec2(0.15, 0.01));\n    float drain = -sdBox(p - R*vec2(0.5, 0.7), R*vec2(1.5, 0.5));\n    return bound;\n    return min(bound, box);\n    return max(drain,min(bound, box));\n}\n\n#define hh 1.\nvec3 bN(vec2 p)\n{\n    vec3 dx = vec3(-hh,0,hh);\n    vec4 idx = vec4(-1./hh, 0., 1./hh, 0.25);\n    vec3 r = idx.zyw*border(p + dx.zy)\n           + idx.xyw*border(p + dx.xy)\n           + idx.yzw*border(p + dx.yz)\n           + idx.yxw*border(p + dx.yx);\n    return vec3(normalize(r.xy), r.z + 1e-4);\n}\n\nuint pack(vec2 x)\n{\n    x = 65534.0*clamp(0.5*x+0.5, 0., 1.);\n    return uint(round(x.x)) + 65535u*uint(round(x.y));\n}\n\nvec2 unpack(uint a)\n{\n    vec2 x = vec2(a%65535u, a/65535u);\n    return clamp(x/65534.0, 0.,1.)*2.0 - 1.0;\n}\n\nvec2 decode(float x)\n{\n    uint X = floatBitsToUint(x); \n    \n    //return unpackSnorm2x16(X);\n    return unpackHalf2x16(X);\n    //return unpack(X); \n}\n\nfloat encode(vec2 x)\n{\n    //uint X = packSnorm2x16(x);\n    uint X = packHalf2x16(x);\n    //uint X = pack(x); \n   \n    return uintBitsToFloat(X); \n}\n\nstruct particle\n{\n    vec2 X;\n    vec2 V;\n    vec2 M;\n};\n    \nparticle getParticle(vec4 data, vec2 pos)\n{\n    particle P; \n    P.X = decode(data.x) + pos;\n    P.V = decode(data.y);\n    P.M = data.zw;\n    return P;\n}\n\nvec4 saveParticle(particle P, vec2 pos)\n{\n    P.X = P.X - pos;\n    return vec4(encode(P.X), encode(P.V), (P.M));\n}\n\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat G(vec2 x)\n{\n    //return pow(50.0, -dot(x,x));\n    //return exp(-length(x)*length(x));\n    return exp(-dot(x,x));\n}\n\nfloat G0(vec2 x)\n{\n    //return pow(2.0, -length(x));\n    return exp(-length(x));\n}\n\n\nfloat GT(vec2 d, float h)\n{\nif (length(d)>h || length(d)<0.0)\n    return 0.0;\n    return pow(h - pow(length(d), 2.0), 3.0);\n}\n\nfloat GT0(vec2 d, float h)\n{\nif (length(d)>h || length(d)<0.0)\n    return 0.0;\n    return pow(h - length(d), 2.0);\n}\n\n\n\n\n\n",
   "name": "Common",
   "description": "",
   "type": "common"
  },
  {
   "inputs": [
    {
     "id": "4sXGR8",
     "filepath": "/media/previz/buffer02.png",
     "type": "buffer",
     "channel": 0,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    }
   ],
   "outputs": [
    {
     "id": "4dXGR8",
     "channel": 0
    }
   ],
   "code": "\nvec3 distribution(vec2 x, vec2 p, float K)\n{\n    vec2 omin = clamp(x - K*0.5, p - 0.5, p + 0.5);\n    vec2 omax = clamp(x + K*0.5, p - 0.5, p + 0.5); \n    return vec3(0.5*(omin + omax), (omax.x - omin.x)*(omax.y - omin.y)/(K*K));\n}\n\n\n//diffusion and advection basically\nvoid Reintegration(sampler2D ch, inout particle P, vec2 pos)\n{\n    int I = 6; \n    range(i, -I, I) range(j, -I, I)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n       \n        particle P0 = getParticle(data, tpos);\n        \n        P0.X += P0.V*dt;// * (1.0 + (P0.M.x) * length(P0.V));\n\n        float difR = 1.8 + (P0.M.x/fluid_rho);\n\n        vec3 D = distribution(P0.X, pos, difR);\n        float m = P0.M.x*D.z; //the deposited mass into this cell\n\n        P.X += mix(P0.X, D.xy, saturate( pow(texel(ch, pos).z, 1.25)*1.5) )*m;  \n        P.V += P0.V*m;\n        P.M.y += P0.M.y*m;\n        \n        //add mass\n        P.M.x += m;\n    }\n    \n    //normalization\n    if (P.M.x != 0.0)\n    {\n        P.X /= P.M.x;\n        P.V /= P.M.x;\n        P.M.y /= P.M.x;\n    }\n    \n    //-----     \n    float prevM = P.M.x;\n    P.M.x = max(0.002, P.M.x);\n    P.V = P.V * prevM/P.M.x;\n      \n    P.M.y = mix(0.0, P.M.x, 0.5);\n\n    P.X = clamp(P.X - pos, -0.5, 0.5) + pos;\n}\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse;\n    ivec2 p = ivec2(pos);\n\n    vec4 data = texel(ch0, pos); \n    \n    particle P;// = getParticle(data, pos);\n       \n    Reintegration(ch0, P, pos);\n   \n    if (iFrame < 1)\n    {\n        vec3 rand = hash32(pos);\n        \n        P.X = pos;\n        P.V = vec2(0.0) + (0.5*(rand.xy-0.5))*0.5;\n        P.M = vec2(rand.y*0.02, 0.0);\n    }\n    \n    U = saveParticle(P, pos);\n}",
   "name": "Buffer A",
   "description": "",
   "type": "buffer"
  },
  {
   "inputs": [
    {
     "id": "4dXGR8",
     "filepath": "/media/previz/buffer00.png",
     "type": "buffer",
     "channel": 0,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    },
    {
     "id": "XsXGR8",
     "filepath": "/media/previz/buffer01.png",
     "type": "buffer",
     "channel": 1,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    }
   ],
   "outputs": [
    {
     "id": "4sXGR8",
     "channel": 0
    }
   ],
   "code": "//force calculation and integration\nvoid Simulation(sampler2D ch, inout particle P, vec2 pos)\n{\n    vec2 F = vec2(0.);\n    int I = 3;\n    range(i, -I, I) range(j, -I, I)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n        particle P0 = getParticle(data, tpos);\n              \n        vec2 dx = P0.X - P.X;\n        float d = length(dx);         \n                      \n        //fluid\n        float L = particle_rad;\n        if (d < L && d > 0.001)\n            F -= normalize(dx) * (L - d)\n            * P0.M.x\n            * G0(dx*4.0/L)\n            //* (Pf(P0.M.y, fluid_rho)+Pf(P.M.y, fluid_rho))\n            * (Pf(P0.M.x, fluid_rho)+Pf(P.M.x, fluid_rho))\n            * 0.5;   \n         \n        //viscosity\n        F += G(dx*2.0/1.5) * (P0.V - P.V) * 0.8;\n    }\n    \n    float l = length(P.V);\n    float v = ( l< 1.0)\n                ? pow(l, 1.0)\n                : pow(l, 0.25);\n                \n    F += vec2(0.0, -0.04) * P.M.x * P.M.y * v;\n    \n    if (iMouse.z > 0.)\n    {\n        vec2 dx = pos - iMouse.xy;\n        float d = length(dx);\n        \n        if (d < 30.0)\n            F += dx * (30.0-d)\n            * Rot(PI*0.0*iTime)\n            * 0.002;\n    }    \n    \n                 \n    // Border\n    vec2 pd = P.X + P.V*dt;\n    if (pd.y - 5.0 < 0.0)\n    {\n        P.V.y *= 1.0 + ((pd.y - 5.0)/5.0);\n        //P.V.x /= 1.0 + ((pd.y - 5.0)/5.0)*0.5 *(1.0+P.M.x);\n\n        P.X += vec2(0.0, 1.0) * abs(pd.y - 5.0);\n        P.V += vec2(0.0, 1.0) * abs(pd.y - 5.0)*0.1*P.M.x;\n        P.M.x = max(P.M.x - 0.001, 0.0);\n    }\n    \n    // Scale\n    /*if (P.M.x > fluid_rho && distance(pos, P.X) != 0.0)\n        F += normalize(pos - P.X) * max(P.M.x - fluid_rho, 0.0) * 0.05;*/\n        \n    //integrate\n    P.V += F;\n    \n    P.V /= 1.0 + pow(length(P.V)*0.1, 3.0);\n}\n\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse;\n    ivec2 p = ivec2(pos);\n        \n    vec4 data = texel(ch0, pos); \n    \n    particle P = getParticle(data, pos);\n\n    \n    if(P.M.x != 0.) //not vacuum\n    {\n        Simulation(ch0, P, pos);\n    }\n    \n    if (iTime < 30.0)\n    {   \n        if(length(P.X - R*vec2(0.9, 0.85)) < 15.0 * (R.x/600.0))\n        {\n            P.X = pos;\n            P.V = 0.5*Dir(-PI*0.25 - PI*0.5 + 0.3*sin(0.4*time));\n            P.M.x = 1.75;\n        }\n        if(length(P.X - R*vec2(0.1, 0.85)) < 15.0 * (R.x/600.0)) \n        {\n            P.X = pos;\n            P.V = 0.5*Dir(-PI*0.25 + 0.3*sin(0.3*time));\n            P.M.x = 1.75;\n        }\n    }\n\n    U = saveParticle(P, pos);\n}",
   "name": "Buffer C",
   "description": "",
   "type": "buffer"
  }
 ]
}