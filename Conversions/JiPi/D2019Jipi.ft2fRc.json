{
 "ver": "0.1",
 "info": {
  "id": "ft2fRc",
  "date": "0",
  "viewed": 0,
  "name": "2019 JiPi",
  "description": "Recycling shader. Happy new year !",
  "likes": 0,
  "published": "Private",
  "usePreview": 0,
  "tags": [
   "2019"
  ],
  "hasliked": 0,
  "parentid": "WdXGDN",
  "parentname": "2019"
 },
 "renderpass": [
  {
   "inputs": [
    {
     "id": "4dXGzr",
     "filepath": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png",
     "type": "texture",
     "channel": 0,
     "sampler": {
      "filter": "mipmap",
      "wrap": "repeat",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    }
   ],
   "outputs": [
    {
     "id": "4dfGRr",
     "channel": 0
    }
   ],
   "code": "//-----------------------------------------------------\n// Created by sebastien durand - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n// Lightening, essentially based on one of incredible TekF shaders:\n// https://www.shadertoy.com/view/lslXRj\n\n//-----------------------------------------------------\n\n\n// Change this to improve quality (3 is good)\n\n#define ANTIALIASING 1\n\n#define iTime (1.5*iTime)\n\n// consts\nconst float tau = 6.2831853;\nconst float phi = 1.61803398875;\n\n// Isosurface Renderer\nconst int g_traceLimit=240;\nconst float g_traceSize=.004;\n\n\nconst vec3 g_boxSize = vec3(.4);\n\nconst vec3 g_ptOnBody = vec3(g_boxSize.x*.5, g_boxSize.y*.15, g_boxSize.z*.5); \nconst vec3 g_ptOnBody2 = vec3(g_boxSize.x*.5, -g_boxSize.y*.5, -g_boxSize.z*.5); \n\n// Data to read in Buf A\nvec3 g_posBox;\nmat3 g_rotBox;\n\nvec3 g_envBrightness = vec3(.5,.6,.9); // Global ambiant color\nvec3 g_lightPos1, g_lightPos2;\nvec3 g_vConnexionPos, g_posFix; \nvec3 g_vConnexionPos2;\nconst vec3 g_posFix2 = vec3(0.,1.,0.);\nfloat g_rSpring, g_rSpring2;\nbool g_WithSpring2;\n\n// -----------------------------------------------------------------\n\n\nfloat hash( float n ) { return fract(sin(n)*43758.5453123); }\n\n// ---------------------------------------------\n\n// Distance from ray to point\nfloat dista(vec3 ro, vec3 rd, vec3 p) {\n\treturn length(cross(p-ro,rd));\n}\n\n// Intersection ray / sphere\nbool intersectSphere(in vec3 ro, in vec3 rd, in vec3 c, in float r, out float t0, out float t1) {\n    ro -= c;\n\tfloat b = dot(rd,ro), d = b*b - dot(ro,ro) + r*r;\n    if (d<0.) return false;\n\tfloat sd = sqrt(d);\n\tt0 = max(0., -b - sd);\n\tt1 = -b + sd;\n\treturn (t1 > 0.);\n}\n\n\n// -- Modeling Primitives ---------------------------------------------------\n// [iq] https://www.shadertoy.com/view/lsccR8\nfloat sdfStar5( in vec2 p )\n{\n    // using reflections\n    const vec2 k1 = vec2(0.809016994375, -0.587785252292); // pi/5\n    const vec2 k2 = vec2(-k1.x,k1.y);\n    p.x = abs(p.x);\n    p -= 2.0*max(dot(k1,p),0.0)*k1;\n    p -= 2.0*max(dot(k2,p),0.0)*k2;\n    // draw triangle\n    const vec2 k3 = vec2(0.951056516295,  0.309016994375); // pi/10\n    return dot( vec2(abs(p.x)-0.3,p.y), k3);\n}\n\nfloat sdPlane( vec3 p ) {\n\treturn p.y;\n}\n\n//const int[] txt = int[] (50,48,49,57,0,2,2,2,2,0);\n\n\n//----------------------------------------------------------\n// Adapted from\n//  [iq] https://www.shadertoy.com/view/4lyfzw\n//       https://iquilezles.org/articles/distfunctions\n//----------------------------------------------------------\n\nfloat opExtrusion( in vec3 p, in float d )\n{\n    vec2 w = vec2( d, p.z );\n    return max(p.z, min(max(w.x,w.y),0.0) + length(max(w,0.0)));\n}\n\n//----------------------------------------------------------\n// FONT\n//----------------------------------------------------------\n\n\n//----------------------------------------------------------\n// Adapted from\n//  [FabriceNeyret2] https://www.shadertoy.com/view/llyXRW\n//----------------------------------------------------------\n\nfloat sdFont(vec2 p, int c) {\n    vec2 uv = (p + vec2(float(c%16), float(15-c/16)) + .5)/16.;\n    return max(max(abs(p.x) - .25, max(p.y - .35, -.38 - p.y)), textureLod(iChannel0, uv, 0.).w - 127./255.);\n}\n\nfloat sdMessage(vec2 p, float scale) { \n    p /= scale;\n    float d;\n    d = sdFont(p, 50);\n    p.x-=.5;\n    d = min(d, sdFont(p, 48));\n    p.x-=.5;\n    d = min(d, sdFont(p, 49));\n    p.x-=.5;\n    d = min(d, sdFont(p, 57));\n    return d*scale;\n}\n\n\nfloat map(vec3 p) { \n\n    p.y -=1.2;\n    float z = iTime + p.z;\n    p.x += .01*cos(z);\n\tfloat k = .1*z+.5*cos(z*.2)*(.5+.5*cos(z));\n    float c = cos(4.*k);\n    float s = sin(4.*k);\n    mat2  m = mat2(c,-s,s,c);\n    p.xy*=m;\n    float sc = .6+.5*cos(z);\n    float d2D = sdMessage(p.xy, sc);\n    \n    vec2 p2 = p.xy-vec2(.5,.75);\n    p2 *= m*m;\n    sc = 4.+5./sc;\n    float sc2 = (.9 +.1*sc)*.5;\n    float fstar = sdfStar5((p2+sc2*vec2(.1,.15))*sc)/sc;\n     fstar = min(fstar, sdfStar5((p2+sc2*vec2(.1,-.15))*sc)/sc);\n     fstar = min(fstar, sdfStar5((p2+sc2*vec2(-.1,0.))*sc)/sc);\n    return opExtrusion(p, min(fstar,d2D));\n}\n\n\n\n//----------------------------------------------------------------------\n\n\n\n\nfloat isGridLine(vec2 p, vec2 v) {\n    vec2 k = smoothstep(.0,1.,abs(mod(p+v*.5, v)-v*.5)/.01);\n    return k.x * k.y;\n}\n\n\n// render for color extraction\nvec3 colorField(vec3 p) {\n    p.y -= 1.2;\n    float z = iTime + p.z;\n    \n    p.x += .01*cos(z);\n\tfloat k = .1*z+.5*cos(z*.2)*(.5+.5*cos(z));\n    float c = cos(4.*k);\n    float s = sin(4.*k);\n    mat2  m = mat2(c,-s,s,c);\n    p.xy*=m;\n    float sc = .6+.5*cos(z);\n    \n    float d2D = sdMessage(p.xy, sc);\n    \n    vec2 p2 = p.xy-vec2(.5,.75);\n    p2 *= m*m;\n    float sc1 = 4.+5./sc;\n    float sc2 = (.9 +.1*sc1)*.5;\n    float fstar = sdfStar5((p2+sc2*vec2(.1,.15))*sc1)/sc1;\n    fstar = min(fstar, sdfStar5((p2+sc2*vec2(.1,-.15))*sc1)/sc1);\n    fstar = min(fstar, sdfStar5((p2+sc2*vec2(-.1,0.))*sc1)/sc1);\n   \n    return (d2D < fstar) ? vec3(p.xy/sc,z) : vec3(.05,2.05,z);\n}\n\n\n// ---------------------------------------------------------------------------\n\nfloat SmoothMax( float a, float b, float smoothing ) {\n\treturn a-sqrt(smoothing*smoothing + pow(max(.0,a-b),2.0));\n}\n\nvec3 Sky( vec3 ray) {\n\treturn g_envBrightness*mix( vec3(.8), vec3(0), exp2(-(1.0/max(ray.y,.01))*vec3(.4,.6,1.0)) );\n}\n\n// -------------------------------------------------------------------\n\n\nvec3 Shade( vec3 pos, vec3 ray, vec3 normal, vec3 lightDir1, vec3 lightDir2, vec3 lightCol1, vec3 lightCol2, float shadowMask1, float shadowMask2, float distance )\n{\n\n\tvec3 ambient = g_envBrightness*mix( vec3(.2,.27,.4), vec3(.4), (-normal.y*.5+.5) ); // ambient\n    \n    // ambient occlusion, based on my DF Lighting: https://www.shadertoy.com/view/XdBGW3\n\tfloat aoRange = distance/20.0;\n\t\n\tfloat occlusion = max( 0.0, 1.0 - map( pos + normal*aoRange )/aoRange ); // can be > 1.0\n\tocclusion = exp2( -2.0*pow(occlusion,2.0) ); // tweak the curve\n    \n\tambient *= occlusion*.8+.2; // reduce occlusion to imply indirect sub surface scattering\n\n\tfloat ndotl1 = max(.0,dot(normal,lightDir1));\n\tfloat ndotl2 = max(.0,dot(normal,lightDir2));\n    \n\tfloat lightCut1 = smoothstep(.0,.1,ndotl1);\n\tfloat lightCut2 = smoothstep(.0,.1,ndotl2);\n\n\tvec3 light = vec3(0);\n    \n\n\tlight += lightCol1*shadowMask1*ndotl1;\n\tlight += lightCol2*shadowMask2*ndotl2;\n\n    \n\t// And sub surface scattering too! Because, why not?\n    float transmissionRange = distance/10.0; // this really should be constant... right?\n    float transmission1 = map( pos + lightDir1*transmissionRange )/transmissionRange;\n    float transmission2 = map( pos + lightDir2*transmissionRange )/transmissionRange;\n    \n    vec3 sslight = lightCol1 * smoothstep(0.0,1.0,transmission1) + \n                   lightCol2 * smoothstep(0.0,1.0,transmission2);\n    vec3 subsurface = vec3(1,.8,.5) * sslight;\n\n    float specularity = .012; \n\tvec3 h1 = normalize(lightDir1-ray);\n\tvec3 h2 = normalize(lightDir2-ray);\n    \n\tfloat specPower;\n    specPower = exp2(3.0+5.0*specularity);\n\n    vec3 albedo;\n\n    if (pos.y<-.48) {  \n        pos.z+=iTime;\n       \tfloat f = mod( floor(2.*pos.z) + floor(2.*pos.x), 2.0);\n        albedo = (0.4 + 0.1*f)*vec3(.7,.6,.8);\n        albedo *= .2*(.3+.5*isGridLine(pos.xz, vec2(.5)));\n      \tspecPower *= 5.;\n\n    } else {\n    \tvec3 colorId = colorField(pos);\n        vec3 col = colorId.y > .5 ? vec3(.96,.96,0) : \n        \t\t\tcolorId.x < .2 ? vec3(.6,.3,.0) : \n                   colorId.x < .7 ? vec3(.3,.6,.0) : \n        \t\t\tcolorId.x < 1.2 ? vec3(0.,.6,.3) : vec3(0,.3,.6);\n        float grid = .7+.3*isGridLine(vec2(colorId.z),vec2(.1))*isGridLine(colorId.xy,vec2(.1));\n        albedo = grid * 2.*col; \n    }       \n    \n\tvec3 specular1 = lightCol1*shadowMask1*pow(max(.0,dot(normal,h1))*lightCut1, specPower)*specPower/32.0;\n\tvec3 specular2 = lightCol2*shadowMask2*pow(max(.0,dot(normal,h2))*lightCut2, specPower)*specPower/32.0;\n    \n\tvec3 rray = reflect(ray,normal);\n\tvec3 reflection = Sky( rray );\n\t\n\t// specular occlusion, adjust the divisor for the gradient we expect\n\tfloat specOcclusion = max( 0.0, 1.0 - map( pos + rray*aoRange )/(aoRange*max(.01,dot(rray,normal))) ); // can be > 1.0\n\tspecOcclusion = exp2( -2.0*pow(specOcclusion,2.0) ); // tweak the curve\n\t\n\t// prevent sparkles in heavily occluded areas\n\tspecOcclusion *= occlusion;\n\n\treflection *= specOcclusion; // could fire an additional ray for more accurate results\n    \n\tfloat fresnel = pow( 1.0+dot(normal,ray), 5.0 );\n\tfresnel = mix( mix( .0, .01, specularity ), mix( .4, 1.0, specularity ), fresnel );\n\n    light += ambient;\n\tlight += subsurface;\n\n    vec3 result = light*albedo;\n\tresult = mix( result, reflection, fresnel );\n\tresult += specular1;\n    result += specular2;\n\n\treturn result;\n}\n\n\nfloat Trace( vec3 pos, vec3 ray, float traceStart, float traceEnd ) {\n    float t0=0.,t1=100.;\n    float t2=0.,t3=100.;\n    // trace only if intersect bounding spheres\n  \n\tfloat t = max(traceStart, min(t2,t0));\n\ttraceEnd = min(traceEnd, max(t3,t1));\n\tfloat h;\n\tfor( int i=0; i < g_traceLimit; i++) {\n\t\th = map( pos+t*ray );\n\t\tif (h < g_traceSize || t > traceEnd)\n\t\t\treturn t>traceEnd?100.:t;\n\t\tt = t+h*.45;\n\t}\n        \n\treturn 100.0;\n}\n\n\n\nvec3 Normal( vec3 pos, vec3 ray, float t) {\n\n\tfloat pitch = .2 * t / iResolution.x;   \n\tpitch = max( pitch, .005 );\n\tvec2 d = vec2(-1,1) * pitch;\n\n\tvec3 p0 = pos+d.xxx; // tetrahedral offsets\n\tvec3 p1 = pos+d.xyy;\n\tvec3 p2 = pos+d.yxy;\n\tvec3 p3 = pos+d.yyx;\n\n\tfloat f0 = map(p0), f1 = map(p1), f2 = map(p2),\tf3 = map(p3);\n\tvec3 grad = p0*f0+p1*f1+p2*f2+p3*f3 - pos*(f0+f1+f2+f3);\n\t// prevent normals pointing away from camera (caused by precision errors)\n\treturn normalize(grad - max(.0,dot (grad,ray ))*ray);\n}\n\n// Camera\nvec3 Ray( float zoom, in vec2 fragCoord) {\n\treturn vec3( fragCoord.xy-iResolution.xy*.5, iResolution.x*zoom );\n}\n\n\n// Camera Effects\n\nvoid BarrelDistortion( inout vec3 ray, float degree ){\n\t// would love to get some disperson on this, but that means more rays\n\tray.z /= degree;\n\tray.z = ( ray.z*ray.z - dot(ray.xy,ray.xy) ); // fisheye\n\tray.z = degree*sqrt(ray.z);\n}\n\n\nmat2 matRot(in float a) {\n    float ca = cos(a), sa = sin(a);\n    return mat2(ca,sa,-sa,ca);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr) {\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 m = iMouse.xy/iResolution.y - .5;\n\n \tfloat time = 15.0 + iTime;\n\n    \n\n// Positon du point lumineux\n    float distLightRot =  .7;\n                              \n    float lt = 3.*(time-1.);\n    \n   \n    g_lightPos1 = g_posBox + distLightRot*vec3(cos(lt*.5), .4+.15*sin(2.*lt), sin(lt*.5));\n    g_lightPos2 = g_posBox + distLightRot*vec3(cos(-lt*.5), .4+.15*sin(-2.*lt), sin(-lt*.5));\n\t\n\t// Ambiant color\n\tg_envBrightness = vec3(.6,.65,.9);\n    \n// intensitee et couleur du point\n    vec3 lightCol1 = vec3(1.05,.95,.95)*.5;//*.2*g_envBrightness;\n\tvec3 lightCol2 = vec3(.95,1.,1.05)*.5;//*.2*g_envBrightness;\n\t\n\n    \n\tfloat lightRange1 = .4, \n          lightRange2 = .4; \n\tfloat traceStart = .2;\n\n    float t, s1, s2;\n    \n    vec3 col, colorSum = vec3(0.);\n\tvec3 pos;\n    vec3 ro, rd;\n\t\n#if (ANTIALIASING == 1)\t\n\tint i=0;\n        vec2 q = (fragCoord.xy)/iResolution.xy;\n#else\n\tfor (int i=0;i<ANTIALIASING;i++) {\n        float randPix = hash(iTime);\n        vec2 subPix = .4*vec2(cos(randPix+6.28*float(i)/float(ANTIALIASING)),\n                              sin(randPix+6.28*float(i)/float(ANTIALIASING)));        \n    \t// camera\t\n        vec2 q = (fragCoord.xy+subPix)/iResolution.xy;\n#endif\n        vec2 p = -1.0+2.0*q;\n        p.x *= iResolution.x/iResolution.y;\n\n        float dis = 7.*(1.2+.6*cos(.41*iTime)); \n        ro = vec3( dis*cos(.2*time),6.5, dis*sin(.2*time) );\n        vec3 ta = vec3( -1., 1., 0. );\n\n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta, 0.0);\n\n        // ray direction\n         rd = ca * normalize( vec3(p.xy,4.5) );\n\n        float tGround = -(ro.y+.5) / rd.y;\n        float traceEnd = min(tGround+1.,100.); \n        col = vec3(0);\n        vec3 n;\n        t = Trace(ro, rd, traceStart, traceEnd);\n        if ( t > tGround ) {\n            pos = ro + rd*tGround;   \n            n = vec3(0,1.,0);\n            t = tGround;\n        } else {\n            pos = ro + rd*t;\n            n = Normal(pos, rd, t);\n        }\n\n        // Shadows\n        vec3 lightDir1 = g_lightPos1-pos;\n        float lightIntensity1 = length(lightDir1);\n        lightDir1 /= lightIntensity1;\n        \n        vec3 lightDir2 = g_lightPos2-pos;\n        float lightIntensity2 = length(lightDir2);\n        lightDir2 /= lightIntensity2;\n\n        s1 = Trace(pos, lightDir1, .04, lightIntensity1 );\n        s2 = Trace(pos, lightDir2, .01, lightIntensity2 );\n\n        lightIntensity1 = lightRange1/(.1+lightIntensity1*lightIntensity1);\n        lightIntensity2 = lightRange2/(.1+lightIntensity2*lightIntensity2);\n\n        col = Shade(pos, rd, n, lightDir1, lightDir2, lightCol1*lightIntensity1, lightCol2*lightIntensity2,\n                    (s1<40.0)?0.0:1.0, (s2<40.0)?0.0:1.0, t );\n\n#if (ANTIALIASING > 1)\t\n        colorSum += col;\n\t}\n    \n    col = colorSum/float(ANTIALIASING);\n#endif\n    \n    // fog\n    float f = 100.0;\n    col = mix( vec3(.8), col, exp2(-t*vec3(.4,.6,1.0)/f) );\n    \n    // Draw light\n    s1 = .5*max(dista(ro, rd, g_lightPos1)+.05,0.);\n    float dist = .5*length(g_lightPos1-ro);\n    if (dist < t*.5) {\n        vec3 col1 = 2.*lightCol1*exp( -.03*dist*dist );\n        float BloomFalloff = 50000.;\n        col += col1*col1/(1.+s1*s1*s1*BloomFalloff);\n    }\n\n    s2 = .5*max(dista(ro, rd, g_lightPos2)+.05,0.);\n    dist = .5*length(g_lightPos2-ro);\n    if (dist < t*.5) {\n        vec3 col2 = 2.*lightCol2*exp( -.03*dist*dist );\n        float BloomFalloff = 50000.;\n        col += col2*col2/(1.+s2*s2*s2*BloomFalloff);\n    }\n        \n    // Compress bright colours, (because bloom vanishes in vignette)\n    vec3 c = (col-1.0);\n    c = sqrt(c*c+.05); // soft abs\n    col = mix(col,1.0-c,.48); // .5 = never saturate, .0 = linear\n\t\n\t// compress bright colours\n\tfloat l = max(col.x,max(col.y,col.z));//dot(col,normalize(vec3(2,4,1)));\n\tl = max(l,.01); // prevent div by zero, darker colours will have no curve\n\tfloat l2 = SmoothMax(l,1.0,.01);\n\tcol *= l2/l;\n    \n\tfragColor =  vec4(pow(col,vec3(1./2.)),1);\n}\n",
   "name": "Image",
   "description": "",
   "type": "image"
  }
 ]
}