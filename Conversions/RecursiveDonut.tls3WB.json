{"Shader":{"ver":"0.1","info":{"id":"tls3WB","date":"1557704405","viewed":590,"name":"Recursive Donut","username":"ShnitzelKiller","description":"Everything is chrome in the future. Also mousable.","likes":30,"published":3,"flags":0,"usePreview":0,"tags":["fractal","interactive","torus","mousable"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"id":37,"channel":0}],"code":"#define PI 3.1415926\n#define fdist 0.3\n#define iters 40\n#define tol 0.005\n#define maxdist 5.\n#define gradient_eps 0.01\n\n\/\/shape parameters\n\/\/#define ring_count 7\n\/\/#define ringdiff 5.\n#define min_rings 3.\n#define max_rings 10.\n#define levels 4\n#define ratio 0.4\n#define ring_offset 1.5\n#define offsetdiff 0.8\n#define indent 0.2\n#define base_radius 2.\n#define ao_radius 0.05\n#define ao_min 0.2\n#define repeat_offset 8.\n#define laplace_factor 100.\n#define reflections 1\n#define reflection_eps 0.01\n#define reflection_albedo 0.3\n#define light_dir vec3(0.436436,0.872872,0.218218)\n#define n1 1.0\n#define n2 1.0\n#define plane_height -2.\n#define shadow_step 0.05\n#define shadow_eps 0.01\n#define shadow_iters 10\n#define shadow_maxdist 1.5\n#define shadow_sharpness 2.\n#define ambient 0.2\n\n\nfloat R0 = (n1-n2)\/(n1+n2);\n\nvec3 viridis_quintic( float x )\n{\n\tx = clamp( x, 0.,1. );\n\tvec4 x1 = vec4( 1.0, x, x * x, x * x * x ); \/\/ 1 x x2 x3\n\tvec4 x2 = x1 * x1.w * x; \/\/ x4 x5 x6 x7\n\treturn vec3(\n\t\tdot( x1.xyzw, vec4( +0.280268003, -0.143510503, +2.225793877, -14.815088879 ) ) + dot( x2.xy, vec2( +25.212752309, -11.772589584 ) ),\n\t\tdot( x1.xyzw, vec4( -0.002117546, +1.617109353, -1.909305070, +2.701152864 ) ) + dot( x2.xy, vec2( -1.685288385, +0.178738871 ) ),\n\t\tdot( x1.xyzw, vec4( +0.300805501, +2.614650302, -12.019139090, +28.933559110 ) ) + dot( x2.xy, vec2( -33.491294770, +13.762053843 ) ) );\n}\n\nvec2 sdTorus( vec3 p, vec2 t)\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    float d = length(q)-t.y;\n    \n    float theta = atan(p.x, p.z); \/\/outer angle\n    return vec2(d, theta);\n}\n\nfloat delay_sin(float t) {\n    return cos(PI*((abs(mod(t, 2.)-1.)+t)*0.5-0.5));\n}\nfloat map(vec3 p) {\n    \/\/p = mod(p+0.5*repeat_offset, repeat_offset)-0.5*repeat_offset;\n    \/\/time-varying parameters (maybe replace with some inputs, or remove)\n    float final_offset;\n    if (iMouse.z < 1.)\n        final_offset = offsetdiff*delay_sin(iTime*0.5+1.) + ring_offset;\n    else\n        final_offset = (iMouse.y\/iResolution.y-0.5)*3.+2.;\n    float final_ratio = ratio\/final_offset;\n    \n    float ringdiff = (max_rings-min_rings)*0.5;\n    float ring_count = (max_rings+min_rings)*0.5;\n    float final_ringcount;\n    if (iMouse.z < 1.)\n    \tfinal_ringcount = ringdiff*delay_sin(iTime*0.5)+ring_count;\n    else\n    \tfinal_ringcount = ringdiff*(iMouse.x\/iResolution.x-0.5)*2. + ring_count;\n    float sector = 2.*PI\/(final_ringcount);\n    float outerrad = base_radius;\n    float innerrad = outerrad*final_ratio;\n    vec2 h = sdTorus(p, vec2(outerrad, innerrad));\n    int i;\n    float currindent = indent;\n    vec2 minh = h;\n    \n    for (i=0; i<levels; i++) {\n        \n        \/\/mod polar coordinates\n        float theta = mod(abs(h.y), sector)-sector\/2.;\n        \n        \/\/new cartesian coords\n        float s = length(p.zx);\n        p.z = cos(theta)*s - outerrad;\n        p.x = sin(theta)*s;\n        p = p.zxy;\n        \n        \/\/new torus\n        outerrad = innerrad*final_offset;        \n        innerrad = outerrad*final_ratio;\n        h = sdTorus(p, vec2(outerrad, innerrad));\n        \n        minh.x = max(minh.x, currindent-h.x);\n        if (h.x < minh.x) {\n            minh = h;\n        }\n        \n        currindent = currindent * final_ratio * final_offset;\n    }\n    return minh.x;\n}\n\nvec4 gradient(in vec3 pos) {\n    vec3 offset = vec3(-gradient_eps, 0.0, gradient_eps);\n    float dx0 = map(pos+offset.xyy);\n    float dxf = map(pos+offset.zyy);\n    float dy0 = map(pos+offset.yxy);\n    float dyf = map(pos+offset.yzy);\n    float dz0 = map(pos+offset.yyx);\n    float dzf = map(pos+offset.yyz);\n    float ddd = map(pos);\n    return vec4(normalize(vec3(dxf - dx0, dyf - dy0, dzf - dz0)), dx0+dxf+dy0+dyf+dz0+dzf-6.*ddd);\n}\n\nvec2 raymarch(vec3 pos, vec3 dir) {\n    int i;\n    float d = 0.;\n    float dist;\n    for (i=0; i<iters; i++) {\n        dist = map(pos+d*dir);\n        d += dist;\n        if (dist < tol) {\n            return vec2(d, 2.);\n        } else if (dist > maxdist) {\n            break;\n        }\n    }\n\td = (plane_height-pos.y) \/ dir.y;\n    return vec2(d, step(-d, 0.)*step(length((pos+d*dir).zx), 50.));\n}\n\n\/\/softer soft shadows\n\/\/see https:\/\/www.shadertoy.com\/view\/4tBcz3\nfloat shadowtrace(vec3 pos, vec3 dir) {\n    int i;\n    float d = shadow_eps;\n    float dist = map(pos+d*dir);\n    float fac = 1.0;\n    for (i=0; i<shadow_iters; i++) {\n        d += max(0.01, dist);\n        dist = map(pos+d*dir);\n        fac = min(fac, dist * shadow_sharpness \/ d);\n    }\n    return mix(mix(0.5, 0., -fac), mix(0.5, 1., fac), step(fac, 0.));\n}\n\nvec3 skycol(vec3 rd) {\n    return vec3(0.6, 0.7, 0.8)*(1.+pow(max(dot(rd, light_dir), 0.), 2.)) + pow(max(0.,dot(rd, light_dir)), 5.);\n}\n\nfloat schlick(vec3 rd, vec3 n) {\n    return 1.-(R0+(1.-R0)*pow(max(dot(n.xyz, -rd), 0.), 5.0));\n}\n\nvec3 material(vec3 ro, vec3 rd, vec4 n, vec2 record) {\n    if (record.y > 1.5) {\n        float edgefac = abs(n.w*laplace_factor);\n        vec3 color = 1.-viridis_quintic(edgefac).yxz*0.5;\n        float fac = max(ambient, dot(light_dir, n.xyz));\n        \/\/float ao = min(1.,ao_min+(record.z > ao_radius ? 1. : record.z\/(ao_radius)));\n        return fac*color;\n    } else if (record.y > 0.5) {\n        vec2 uv = (ro+rd*record.x).zx;\n        uv = abs(mod(uv, 4.)-2.);\n        float checker = abs(step(uv.x, 1.) - step(uv.y, 1.));\n        return vec3(light_dir.y*(0.5+0.5*checker));\n    } else {\n        return skycol(rd);\n    }\n}\n\n\/\/materials with reflections\nvec3 shade(vec3 ro, vec3 rd, vec4 n, vec2 record) {\n    vec3 shadedcolor = material(ro, rd, n, record);\n    if (record.y > 0.5) {\n        float fac = shadowtrace(ro+rd*record.x, light_dir);\n        shadedcolor *= max(ambient, fac);\n    }\n    if (record.y > 1.5) {\n        int i;\n        float final_albedo = reflection_albedo;\n        for (i=0; i<reflections; i++) {\n            if (record.y < 1.5) break;\n            final_albedo *= schlick(rd, n.xyz);\n            ro = ro+rd*record.x;\n            rd = reflect(rd, n.xyz);\n            ro += reflection_eps*rd;\n            record = raymarch(ro, rd);\n            n = gradient(ro+rd*record.x);\n            shadedcolor += final_albedo * material(ro, rd, n, record);\n        }\n        \/\/compute last reflections with just envmap\n        if (record.y > 1.5) {\n            final_albedo *= schlick(rd, n.xyz);\n            shadedcolor += final_albedo * skycol(reflect(rd, n.xyz));\n        }\n    }\n    return shadedcolor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    R0*=R0;\n    \/\/camera position\n    float s = sin(iTime*0.5);\n    float ww = iTime*0.2;\n    vec3 ro = (3.-s)*vec3(cos(ww),0.5+0.5*s,sin(ww));\n    vec3 w = normalize(vec3(0.,-1.5-s,0.)-ro);\n    vec3 u = normalize(cross(w, vec3(0., 10., 0.)));\n    vec3 v = cross(u, w);\n    vec3 rd = normalize(w*fdist+(fragCoord.x\/iResolution.x-0.5)*u+(fragCoord.y-iResolution.y\/2.0)\/iResolution.x*v);\n\t\n    vec2 record = raymarch(ro, rd);\n    vec4 n = gradient(ro+rd*record.x);\n    vec3 shadedcolor = shade(ro, rd, n, record);\n    \n    fragColor = vec4(shadedcolor, 1.);\n}","name":"Image","description":"","type":"image"}]}}