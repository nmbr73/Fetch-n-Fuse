{
 "ver": "0.1",
 "info": {
  "id": "sddfzM",
  "date": "0",
  "viewed": 0,
  "name": "Variable Blobs JiPi",
  "description": "A combination of the tutorial \"HOWTO Get Started With Ray Marching\" with \"Blob physics (forked from LeWIZ)\". Easy to edit. Has lots of effects including raymarching, ambient occlusion, anisotropic scattering, Fresnel, reflection etc.",
  "likes": 0,
  "published": "Private",
  "usePreview": 0,
  "tags": [
   "raymarching",
   "blobs",
   "reflection",
   "transparency",
   "shadow",
   "sphere",
   "fog",
   "scattering",
   "ambientocclusion",
   "fresnel",
   "anisotropic",
   "schlick"
  ],
  "hasliked": 0,
  "parentid": "NdtfzM",
  "parentname": "Variable Blobs"
 },
 "renderpass": [
  {
   "inputs": [
    {
     "id": "4dfGRn",
     "filepath": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg",
     "type": "texture",
     "channel": 0,
     "sampler": {
      "filter": "mipmap",
      "wrap": "repeat",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    }
   ],
   "outputs": [
    {
     "id": "4dfGRr",
     "channel": 0
    }
   ],
   "code": "// I combined the shaders from the tutorial \"HOWTO Get Started With Ray Marching\"\n// https://www.shadertoy.com/view/XllGW4 /with Blob physics (forked from LeWIZ)\n// https://www.shadertoy.com/view/3lVfzR, which is a simplified version of \n// Refraction Blobs https://www.shadertoy.com/view/4ll3R7. I simplified the tutorial\n// by taking out transformations and functions which were not relevant. \n// Supports texture backgrounds currently \n// Click on the shader to move the camera\n// Edit content under float makeScene(vec3 pos) to change how the blobs look or add more blobs\n// Disclaimer - im new to this. \n\n#ifdef GL_ES\nprecision mediump float;\n#endif \n\nuniform vec2 u_resolution;\nuniform float u_time;\n\n\n#define AUTO_ROTATE     // uncomment to stop auto camera rotation\n//#define BACKGROUND_BLUE // uncomment for blue background, else cubemap background\n//#define VIEW_ZERO       // uncomment to default OpenGL look down z-axis view\n//#define VIEW_ISOMETRIC  // Nice isometric camera angle\n//#define LOW_Q // uncomment for low quality if your GPU is a potato\n\n#ifdef LOW_Q\n    #define MARCHSTEPS 25\n#else\n    #define MARCHSTEPS 50\n    #define AMBIENT_OCCLUSION\n    #define DOUBLE_SIDED_TRANSPARENCY\n#endif\n\n#define MAX_DIST 10.0\n\n#define SPECULAR\n#define REFLECTIONS\n#define TRANSPARENCY\n#define SHADOWS\n#define FOG\n\n#define DIRECTIONAL_LIGHT\n#define DIRECTIONAL_LIGHT_FLARE\n\n#define PI 3.141592654\n\n#define kNt  -1.0 //no trans\n#define kTt   1.0 //yes trans\n#define kIt   0.0 //inverse trans\n\nconst float MATERIAL_1 = 1.0;\nconst float MATERIAL_2 = 2.0;\n/* */ float gMaterial  = MATERIAL_1;\n\n\n// rd Ray Direction\n// rl Ray Length\nstruct sRay   { vec3 ro ; vec3  rd ; float sd; float rl; };\nstruct sHit   { vec3 hp ; float hd ; vec3 oid; };\nstruct sSurf  { vec3 nor; vec3  ref; vec3 tra; };\nstruct sMat   { vec3 ctc; float frs; float smt; vec2 par; float trs; float fri; };\nstruct sShade { vec3 dfs; vec3  spc; };\nstruct sLight { vec3 rd ; vec3  col; };\n\n\n\n\n\n    vec4 opUt( vec4 a, vec4 b, float fts ){\n        vec4 vScaled = vec4(b.x * (fts * 2.0 - 1.0), b.yzw);\n        return mix(a, vScaled, step(vScaled.x, a.x) * step(0.0, fts));\n}\n\n\n\nfloat sphere(vec3 pos) {\n    float distanceFromCenter = length(pos);\n    float sphereRadius = 1.0;\n\treturn distanceFromCenter - sphereRadius; \n}\n\nfloat makeBlobs(float s1, float s2, float s3, float s4) {\n    float k = -6.0;\n    return log( exp(k*s1) + exp(k*s2) + exp(k*s3) + exp(1.5*k*s4)) / k; // THE MAIN EQUATION THAT MAKES THE BLOBS BUD OFF OF EACH OTHER\n}\n\nfloat makeScene(vec3 pos) {\n    float blobVelocity = 1.0;\n    \n    // BECAUSE THIS IS THE CENTER BLOB, THE POSITION IS LEFT EXACTLY AS IT IS\n    vec3 posOffset0 = pos + blobVelocity * vec3(sin(iTime * 0.9),cos(iTime *1.9),cos(iTime * 2.0)+sin(0.5));\n    float s1 = sphere(posOffset0);\n    \n    // BECAUSE THIS BLOB ROTATES AROUND THE CENTER BLOB, ITS POSITION IS OFFSET USING SIN/COS OSCILLATION.\n    // IF THE CENTER OF THE NEW BLOB IS, FOR EXAMPLE, (2,1) AWAY FROM THE TRUE CENTER, THEN WE CALL THE\n    // \"SPHERE\" FUNCTION AGAIN USING THE NEW OFFSET VALUE OF (2,1).\n    vec3 posOffset = pos + 0.1*blobVelocity * vec3(cos(iTime * 0.7),cos(iTime *3.4),cos(iTime * 2.6));\n    float s2 = sphere(posOffset);\n\n    vec3 posOffset2 = pos/0.6 + 1.5*blobVelocity * vec3(sin(iTime * 0.6),cos(iTime *2.9),cos(iTime * 1.3)+0.3);\n    float s3 = sphere(posOffset2);\n    \n    vec3 posOffset3 = pos/1.1 + blobVelocity * vec3(sin(iTime * 1.2),cos(iTime *1.9),cos(iTime * 1.2)+0.1);\n    float s4 = sphere(posOffset3);\n    \n    return makeBlobs(s1, s2, s3, s4);\n}\n\n\n// ========================================\nvec4 DE( vec3 hp, float fts ) {\n    vec4 vResult = vec4(MAX_DIST, -1.0, 0.0, 0.0);\n    vec4 vDist = vec4( makeScene(hp), MATERIAL_1, hp.xz);\n    vDist.y = gMaterial; // v0.42 draw may over-ride material\n    return opUt(vResult, vDist, fts);\n}\n\n// ========================================\n\n\nsMat getMaterial( sHit hitInfo ) {\n    sMat mat;\n    if(hitInfo.oid.x == MATERIAL_1) {\n        mat.frs = 0.31;\n        mat.smt = 1.0;\n        mat.trs = 1.0;\n        mat.fri = 0.75;\n        const float fExtinctionScale = 2.0;\n        vec3 tc = vec3(0.93,0.96,1.0);        //tex/col\n        mat.ctc = (vec3(1.0) - tc) * fExtinctionScale; \n    } else\n    if(hitInfo.oid.x == MATERIAL_2) {\n        mat.frs = 0.0;\n        mat.smt = 1.0;\n        mat.trs = 0.0;\n        mat.fri = 0.0;\n        mat.ctc = vec3(0.25,0.5,0.75); // Beautiful Baby Blue\n    }\n    return mat;\n}\n\n// ========================================\nvec3 getBackground( vec3 rd ) {\n#ifdef BACKGROUND_BLUE\n    const vec3  tc = vec3(0.8824, 0.8824, 0.8824);\n    const vec3  cc = tc * 0.5;\n          float f  = clamp(rd.y, 0.0, 1.0);\n    return mix(cc, tc, f);\n#else\n    return texture(iChannel0, rd.xy).xyz;\n#endif\n}\n\n// ========================================\nsLight getDirLight() {\n    sLight result;\n    result.rd  = normalize(vec3(-0.2, -0.3, 0.5));\n    result.col = vec3(8.0, 7.5, 7.0);\n    return result;\n}\n\n// ========================================\nvec3 getAmbient( vec3 nor ) {\n    return getBackground(nor);\n}\n\n// ========================================\nvec3 normal( vec3 p, float fts ) {\n    vec3 e = vec3(0.01,-0.01,0.0);\n    return normalize( vec3(\n        e.xyy*DE(p+e.xyy,fts).x +\n        e.yyx*DE(p+e.yyx,fts).x +\n        e.yxy*DE(p+e.yxy,fts).x +\n        e.xxx*DE(p+e.xxx,fts).x)\n    );\n}\n \n// ========================================\nvoid march( sRay ray, out sHit res, int maxIter, float fts ) {\n    res.hd = ray.sd;\n    res.oid.x = 0.0;\n\n    for( int i=0;i<=MARCHSTEPS;i++ ) {\n        res.hp = ray.ro + ray.rd * res.hd;\n        vec4 r = DE( res.hp, fts );\n        res.oid = r.yzw;\n        if((abs(r.x) <= 0.01) || (res.hd >= ray.rl) || (i > maxIter))\n            break;\n        res.hd = res.hd + r.x;\n    }\n    if(res.hd >= ray.rl) {\n        res.hd = MAX_DIST;\n        res.hp = ray.ro + ray.rd * res.hd;\n        res.oid.x = 0.0;\n    }\n}\n\n// ========================================\nfloat getShadow( vec3 hp, vec3 nor, vec3 lrd, float d ) {\n#ifdef SHADOWS\n    sRay ray;\n    ray.rd = lrd;\n    ray.ro = hp;\n    ray.sd = 0.05 / abs(dot(lrd, nor));\n    ray.rl = d - ray.sd;\n    sHit si;\n    march(ray, si, 32, kNt);\n    float s = step(0.0, si.hd) * step(d, si.hd );\n    return s;\n#else\n    return 1.0;\n#endif\n}\n\n// ========================================\nfloat getAmbientOcclusion( sHit hi, sSurf s ) {\n#ifdef AMBIENT_OCCLUSION\n    vec3 hp = hi.hp;\n    vec3 nor = s.nor;\n    float ao = 1.0;\n\n    float d = 0.0;\n    for( int i=0; i<=5; i++ ) {\n        d += 0.1;\n        vec4 r = DE(hp + nor * d, kNt);\n        ao *= 1.0 - max(0.0, (d - r.x) * 0.2 / d );\n    }\n    return ao;\n#else\n    return 1.0;\n#endif\n}\n\n// ========================================\nvec3 getFog( vec3 color, sRay ray, sHit hi ) {\n#ifdef FOG\n    float a = exp(hi.hd * - 0.05);\n    vec3 fog = getBackground(ray.rd);\n\n    #ifdef DIRECTIONAL_LIGHT_FLARE\n        sLight lig = getDirLight();\n        float f = clamp(dot(-lig.rd, ray.rd), 0.0, 1.0);\n        fog += lig.col * pow(f, 10.0);\n    #endif \n\n    color = mix(fog, color, a);\n#endif\n\n    return color;\n}\n\n// http://en.wikipedia.org/wiki/Schlick's_approximation\n// Anisotropic scattering Schlick phase function\n// \"Interactive Manycore Photon Mapping\"\n// See: https://www.scss.tcd.ie/publications/tech-reports/reports.11/TCD-CS-2011-04.pdf\n//\n// More complex empirically motivated phase functions are efficiently approximated by the Schluck function [BLS93].\n// ========================================\nfloat getSchlick(vec3 nor, vec3 v, float frs, float sf) {\n    float f = dot(nor, -v);\n    f = clamp((1.0 - f), 0.0, 1.0);\n    float fDotPow = pow(f, 5.0);\n    return frs + (1.0 - frs) * fDotPow * sf;\n}\n\n// http://en.wikipedia.org/wiki/Fresnel_equations\n// ========================================\nvec3 getFresnel( vec3 dif, vec3 spe, vec3 nor, vec3 v, sMat m ) {\n    float f = getSchlick(nor, v, m.frs, m.smt * 0.9 + 0.1);\n    return mix(dif, spe, f);\n}\n\n// ========================================\nfloat getPhong( vec3 ird, vec3 lrd, vec3 nor, float smt ) {\n    vec3  v  = normalize(lrd - ird);\n    float f  = max(0.0, dot(v, nor));\n    float sp = exp2(4.0 + 6.0 * smt);\n    float si = (sp + 2.0) * 0.125;\n    return pow(f, sp) * si;\n}\n\n// ========================================\nsShade setDirLight( sLight l, vec3 p, vec3 d, vec3 nor, sMat m ) {\n    sShade s;\n    vec3 lrd = -l.rd;\n    float sf = getShadow( p, nor, lrd, 8.0 );\n    vec3 il = l.col * sf * max(0.0, dot(lrd, nor));\n    s.dfs = il;\n    s.spc = getPhong( d, lrd, nor, m.smt ) * il;\n    return s;\n}\n\n// ========================================\nvec3 setColor( sRay ray, sHit hi, sSurf sc, sMat m ) {\n    vec3 color;\n    sShade s;\n    s.dfs = vec3(0.0);\n    s.spc = vec3(0.0);\n    float ao = getAmbientOcclusion(hi, sc);\n    vec3 al = getAmbient(sc.nor) * ao;\n    s.dfs += al;\n    s.spc += sc.ref;\n\n#ifdef DIRECTIONAL_LIGHT\n    sLight dl = getDirLight();\n    sShade sh = setDirLight(dl, hi.hp, ray.rd, sc.nor, m);\n    s.dfs += sh.dfs;\n    s.spc += sh.spc;\n#endif\n\n    vec3 dr = s.dfs * m.ctc;\n\n    dr = mix(dr, sc.tra, m.trs);\n\n#ifdef SPECULAR\n    color = getFresnel(dr , s.spc, sc.nor, ray.rd, m);\n#else\n    color = dr;\n#endif\n\n    return color;\n}\n\n// ========================================\nvec3 getColor( sRay ray ) {\n    sHit hi;\n    march(ray, hi, 32, kNt);\n    vec3 color;\n\n    if(hi.oid.x < 0.5) {\n        color = getBackground(ray.rd);\n    } else {\n        sSurf s;\n        s.nor  = normal(hi.hp, kNt);\n        sMat m = getMaterial( hi );\n        s.ref  = getBackground(reflect(ray.rd, s.nor));\n        m.trs  = 0.0;\n        color  = setColor(ray, hi, s, m);\n    }\n\n    color = getFog(color, ray, hi);\n    return color;\n}\n\n// ========================================\nvec3 getReflection( sRay ray, sHit hitInfo, sSurf s ) {\n#ifdef REFLECTIONS\n    sRay rRay;\n    rRay.rd = reflect(ray.rd, s.nor);\n    rRay.ro = hitInfo.hp;\n    rRay.rl = 16.0;\n    rRay.sd = 0.1 / abs(dot(rRay.rd, s.nor));\n    return getColor(rRay);\n#else\n    return getBackground(reflect(ray.rd, s.nor));\n#endif\n}\n\n// ========================================\nvec3 getTransparency( sRay ray, sHit hit, sSurf s, sMat m ) {\n#ifdef TRANSPARENCY\n    sRay rRay;\n    rRay.rd = refract(ray.rd, s.nor, m.fri);\n    rRay.ro = hit.hp;\n    rRay.rl = 16.0;\n    rRay.sd = 0.05 / abs(dot(rRay.rd, s.nor));\n\n    #ifdef DOUBLE_SIDED_TRANSPARENCY\n        sHit hit2;\n        march(rRay, hit2, 32, kIt);\n        vec3 nor = normal(hit2.hp, kIt);\n            sRay rRay2;\n            rRay2.rd = refract(rRay.rd, nor, 1.0 / m.fri);\n            rRay2.ro = hit2.hp;\n            rRay2.rl = 16.0;\n            rRay2.sd = 0.0;\n        float ed = hit2.hd;\n        vec3 color = getColor( rRay2 );\n    #else\n        vec3 color = getColor( rRay );\n        float ed = 0.5;\n    #endif\n\n    return color * clamp(exp(-(m.ctc * ed)),0.0,1.0);\n#else\n    return getBackground(reflect(ray.rd, s.nor));\n#endif\n}\n\n// ========================================\nvec3 getRayColor( sRay ray ) {\n    sHit i;\n    march(ray, i, MARCHSTEPS, kTt); //256\n\n    vec3 color;\n    if(i.oid.x < 0.5) {\n        color = getBackground(ray.rd);\n    } else  {\n        sSurf s;\n        s.nor  = normal(i.hp, kTt);\n        sMat m = getMaterial( i );\n        s.ref  = getReflection(ray, i, s);\n        if(m.trs > 0.0) s.tra = getTransparency(ray, i, s, m);\n        color  = setColor(ray, i, s, m);\n    }\n\n    getFog(color, ray, i); // BUG? Is this intentional that color is not updated??\n    return color;\n}\n\n// ========================================\nsRay setCameraRay( vec3 hp, vec3 i , vec2 fragCoord) {\n    float fRatio = iResolution.x / iResolution.y; // Aspect Ratio\n\n    vec3 f   = normalize(i - hp);\n    vec3 vUp = vec3(0.0, 1.0, 0.0);\n    vec2 vvc = 2.*fragCoord.xy/iResolution.xy-1.;\n    vvc.y /= fRatio;\n\n    sRay ray;\n    ray.ro = hp;\n    vec3 r = normalize(cross(f, vUp));\n    vUp    = cross(r, f);\n    ray.rd = normalize( r * vvc.x + vUp * vvc.y + f);\n    ray.sd = 0.0;\n    ray.rl = MAX_DIST;\n    return ray;\n}\n\n// ========================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 m = vec2(0.0); // Default OpenGL camera: Look down -z axis\n\n#ifdef VIEW_ISOMETRIC\n    m = vec2( 3.5, 1.0 ) / PI; // fake isoemetric\n#else\n  #ifdef VIEW_ZERO\n    // m.x = 0.0; // +z // h -> 0      =   0\n    // m.x =+1.0;; //-z // h -> PI     = 180\n    // m.x = 0.5; // +x // h -> PI  /2 =  90\n    // m.x =-0.5; // -x // h -> PI*3/2 = 270\n    //m.y = iMouse.y / iResolution.y; // uncomment to allow Y rotation\n  #else\n    m += 2.* iMouse.xy / iResolution.xy;\n    m.x += 1.;\n  #endif // ZERO\n#endif // ISOMETRIC\n\n    float nRotate = 0.0; // no rotation\n#ifdef AUTO_ROTATE\n    nRotate = iTime *0.05; // slow rotation\n#endif\n\n    //float h  = mix(0.0, PI , m.x - nRotate);\n    float h  = PI * (m.x - nRotate);\n    float e  = mix(0.0, 2.5, m.y                ); // eye\n    // Hold down mouse button to zoom out & rotate the camera!\n    float d  = mix(2.5, 2.5 + (iMouse.z > 0.0 ? 0.1 : 0.1), m.y); // eye distance\n\n    // ro RayOrigin\n    vec3 ro  = vec3(sin(h) *cos(e), sin(e), cos(h) * cos(e)) * d*2.0;\n    vec3 ta  = vec3(0.0, 0.0, 0.0);\n\n    sRay ray = setCameraRay( ta + ro, ta, fragCoord);\n    vec3 col = getRayColor( ray );\n    fragColor = vec4( col, 1.0 );\n}",
   "name": "Image",
   "description": "",
   "type": "image"
  }
 ]
}