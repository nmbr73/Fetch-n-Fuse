{
 "ver": "0.1",
 "info": {
  "id": "ftjBRD",
  "date": "0",
  "viewed": 0,
  "name": "Cave Exploration JiPi",
  "description": "Exploring a deep cave by following a will o' the wisp.",
  "likes": 0,
  "published": "Private",
  "usePreview": 0,
  "tags": [
   "procedural",
   "3d",
   "raymarching",
   "noise",
   "tunnel",
   "water",
   "cave",
   "wisp",
   "stalactites",
   "moss"
  ],
  "hasliked": 0,
  "parentid": "stXfWB",
  "parentname": "Cave Exploration"
 },
 "renderpass": [
  {
   "inputs": [
    {
     "id": "4sfGRn",
     "filepath": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg",
     "type": "texture",
     "channel": 0,
     "sampler": {
      "filter": "mipmap",
      "wrap": "repeat",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    },
    {
     "id": "Xsf3zn",
     "filepath": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
     "type": "texture",
     "channel": 1,
     "sampler": {
      "filter": "mipmap",
      "wrap": "repeat",
      "vflip": "false",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    }
   ],
   "outputs": [
    {
     "id": "4dfGRr",
     "channel": 0
    }
   ],
   "code": "// Based on \"Stalactite Cave\" by mazander - https://www.shadertoy.com/view/ldV3W1\n\n// =================================== General functions ===================================\n\n// Grey scale.\nfloat getGrey(vec3 p){ return p.x*0.299 + p.y*0.587 + p.z*0.114; }\n\nfloat noise(in vec3 p){\n    vec3 i = floor(p); \n    p -= i; \n    p *= p*(3. - 2.*p); //from linear to smooth - derivatives at 0 and 1 are zero.\n    // The RGBA noise satisfies G(x+37,y+17) = R(x,y), though only when VFLIP is unchecked.\n\tp.xy = texture(iChannel1, (p.xy + i.xy + vec2(37, 17)*i.z + .5)/256., -100.).yx;\n\treturn mix(p.x, p.y, p.z);\n}\n\n// Project the 2D texture from the three main directions and mix them together to create a 3D texture.\nvec4 texcube(sampler2D sam, in vec3 p, in vec3 n){\n    p *= 1.5;    \n\tvec4 x = texture( sam, p.yz );\n\tvec4 y = texture( sam, p.zx );\n\tvec4 z = texture( sam, p.xy );\n\treturn x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\n}\n\n// =================================== Scene ===================================\n\n// The path for the center of the cave\nvec3 path(float time) {\n    return vec3(cos(0.51 * time) + sin(0.14 * time), 0.8 * sin(0.27 * time), time); \n}\n\n// Your friendly random orthogonal (rotation) matrix.\nconst mat3 m = mat3( 0.00, -0.80, -0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\n// Distance to the inside of the cave\nfloat mapTerrain(vec3 position) {\n    float initialCaveSize = 0.00;\n\n    // an approximation to the distance vector from the path.\n    vec3 xyDifference = position - path(position.z);\n    \n    // stretching the distance - the smaller a coordinate is (X or Y), the larger the cave is along that axis.\n    vec3 stretchFactor = 1.2 * vec3(sin(position.z * 0.32), cos(position.z * 0.77), 1.0);\n    float d = initialCaveSize-length(xyDifference * stretchFactor);\n    \n    // Add stalactites by adding noise which has lower frequency along the y-direction (So it changes faster\n    // along the XZ plane).\n    vec3 stalactites = vec3(6.0, 0.15, 6.0);\n    d += 0.7500 * noise(stalactites * position); \n    \n    // Add more random noise to add the smaller details\n    float strength = 0.5;\n    for (int i=0; i<5; i++){\n        position = m*position*2.04;\n        d += strength * noise( position );\n        strength *= 0.5;\n    }\n        \n    return d;\n}\n\n// moss color for a given point and normal.\nvec3 moss(vec3 position, vec3 normal){\n    // I have no idea how moss works...\n    float moss_noise = noise(position*100.);\n    vec3 moss_color = mix(vec3(0., 0.1, 0.0), vec3(0.3, 0.3, 0.0), moss_noise*moss_noise);\n    moss_noise = noise(position*210.+100.);\n    moss_color = mix(moss_color, vec3(0.3, 0.6, 0.3)*0.8, pow(moss_noise, 5.));\n    moss_color*=2.*texture(iChannel1,position.xz).x;\n    \n    return moss_color;\n}\n\n// =================================== Compute position and normal ===================================\n\n// Sets the orientation of the camera given its position and viewing target.\nvoid camera(in vec3 origin, in vec3 target, out vec3 forward, out vec3 right, out vec3 up){\n    forward = normalize(target-origin);\n    right = normalize(vec3(forward.z, 0., -forward.x)); // Perpendicular to the forward direction ~ approx (1,0,0).\n    up = normalize(cross(forward, right));\n}\n\n// Standard ray marching\nfloat rayMarch(in vec3 ro, in vec3 rd){\n\tfloat maxd = 20.0;\n    float t = 0.1;\n    for( int i = 0; i< 160; i++ )\n    {\n\t    float h = mapTerrain( ro + rd * t );\n        if( h < (0.001 * t) || t > maxd ) break;\n        t += (step(h, 1.) * .05 + 0.1) * h;\n    }\n\n    if( t>maxd ) t=-1.0;\n    return t;\n}\n\nvec3 calcNormal( in vec3 pos, in float t ){\n    vec3 eps = vec3( max(0.02,0.001*t),0.0,0.0);\n\treturn normalize( vec3(\n           mapTerrain(pos+eps.xyy) - mapTerrain(pos-eps.xyy),\n           mapTerrain(pos+eps.yxy) - mapTerrain(pos-eps.yxy),\n           mapTerrain(pos+eps.yyx) - mapTerrain(pos-eps.yyx) ) );\n\n}\n\n// Perturb the normal using a texture to add more details.\nvec3 doBumpMap( sampler2D tex, in vec3 p, in vec3 nor, float bumpfactor){\n   \n    const float eps = 0.001;\n    float ref = getGrey(texcube(tex,  p , nor).xyz);                 \n    vec3 grad = vec3( getGrey(texcube(tex, vec3(p.x - eps, p.y, p.z), nor).xyz) - ref,\n                      getGrey(texcube(tex, vec3(p.x, p.y - eps, p.z), nor).xyz) - ref,\n                      getGrey(texcube(tex, vec3(p.x, p.y, p.z - eps), nor).xyz) - ref )/eps;\n             \n    // get the gradient's projection to the plane.\n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize(nor + grad*bumpfactor);\t\n}\n\n\n// =================================== Light ===================================\n\n/**\n * Look for the closest object along the given ray.\n * The closer this object is to the ray, and the quicker we get close to it,\n * we expect the shadow to be harder.\n * See Inigo Quilez tutorial - https://iquilezles.org/articles/rmshadows/\n */\nfloat softshadow( in vec3 rayOrigin, in vec3 rayDirection, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<100; i++ )\n    {\n        float h = mapTerrain(rayOrigin + rayDirection*t);\n        res = min( res, k*max(h,0.0)/t );\n        t += clamp( h, 0.01, 0.4 );\n\t\tif( res<0.001 || t>=maxt) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\n// Compute light value at the given point.\nfloat lightValue(vec3 rayOrigin, vec3 position, vec3 normal, vec3 lightPosition){\n    // diffuse\n    vec3 lightDir = lightPosition - position;\n    \n    float diffuseFactor = clamp(dot(lightDir, normal), 0., 1.);\n    float shadow = softshadow(position, normalize(lightDir), 0., length(lightDir), 2.); \n    \n    return shadow * diffuseFactor / pow(length(lightDir),2.5);\n}\n\nfloat wisp(vec3 rayOrigin, vec3 rayDirection, float hitDistance, vec3 lightPosition){\n    vec3 lightDirection = lightPosition - rayOrigin;\n\tfloat lightValue = pow(dot(normalize(lightDirection),normalize(rayDirection)),2000.0); // maybe add flickering?\n    float distanceToLight = length(lightDirection);\n    // return the light value if it is before the cave wall.\n    return step(distanceToLight, hitDistance) * lightValue;\n}\n\n// =================================== Main ===================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    // normalize coordinates.\n    vec2 q = fragCoord.xy / iResolution.xy;\n\tvec2 p = -1.0 + 2.0*q;\n\tp.x *= iResolution.x / iResolution.y;\n    \n\tfloat time = 3.8 + 0.6 * iTime;\n    vec3 rayOrigin = path(time);\n    // look further a head, and move head left and right along the way to see the scenery.\n    vec3 target = path(time+1.6)+vec3((sin(time)+cos(time/2.))/2.,0,0); \n    // light moves before us\n    vec3 lightPosition = path( time+2.5 + cos(time) + sin(1.2*time));\n    \n\t// camera to world transform        \n    vec3 forward, right, up;\n    camera(rayOrigin, target, forward, right, up);\n    vec3 rayDirection = normalize(2.*forward + right*p.x + up*p.y);\n    \n    vec3 col = vec3(0.0);\n    float t = rayMarch(rayOrigin, rayDirection);\n    if (t>0.){\n        vec3 position = rayOrigin + t * rayDirection;\n        vec3 normal = calcNormal(position, t);\n        normal = doBumpMap(iChannel0 ,position, normal, 0.005);\n        \n        vec3 wall_col = texcube( iChannel0, 0.5*position, normal ).xyz;\n        vec3 moss_color = moss(position, normal);\n        \n        float lValue = lightValue(rayOrigin, position, normal, lightPosition);\n        wall_col *= lValue;        \n        moss_color *= clamp(lValue, 0., 3.); // moss a bit less shiney, I think...\n        \n        // add more moss when normal is pointing up\n        col = mix(wall_col, moss_color, smoothstep(0.1, 0.7, normal.y)); \n        \n        // add water\n        if(position.y < -1.0) {\n         \tcol.z += 0.005;   // blue tint            \n            col *= pow(0.4, position.y * position.y);    // darken when deep\n        }\n        \n        col += wisp(rayOrigin, rayDirection, t, lightPosition);\n    }    \n    \n    fragColor = vec4(col , 1.);    \n}",
   "name": "Image",
   "description": "",
   "type": "image"
  }
 ]
}