{"Shader":{"ver":"0.1","info":{"id":"MdfcRs","date":"1511979803","viewed":1221,"name":"glass and metal hearts","username":"keim","description":"Distance function for heart shaped brilliant cut and simple chain. Render function for glass and metal. thats all.","likes":22,"published":3,"flags":0,"usePreview":1,"tags":["reflection","refraction","glass","heart","diamond"],"hasliked":0},"renderpass":[{"inputs":[{"id":21,"src":"\/media\/a\/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3","ctype":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":37,"channel":0}],"code":"\/\/ Constants ----------\n#define PI 3.14159265358979\n#define P2 6.28318530717959\n\n\/\/ -- tracing parameters\nconst int   MAX_TRACE_STEP = 90;\nconst float MAX_TRACE_DIST = 80.;\nconst float NO_HIT_DIST    = 100.; \/\/ must be NO_HIT_DIST > MAX_TRACE_DIST\nconst float TRACE_PRECISION = .001;\nconst float FUDGE_FACTOR = .9;\nconst int   RAY_TRACE_COUNT = 5;\nconst vec3  GAMMA = vec3(1.\/2.2);\n\n\/\/ -- rendering parameters\nconst int   GI_TRACE_STEP = 5;\nconst float GI_LENGTH = 1.6;\nconst float GI_STRENGTH = .2;\nconst float AO_STRENGTH = .4;\nconst int   SS_MAX_TRACE_STEP = 4;\nconst float SS_MAX_TRACE_DIST = 10.;\nconst float SS_MIN_MARCHING = .4;\nconst float SS_SHARPNESS = 1.;\nconst float CS_STRENGTH = .4;\nconst float CS_SHARPNESS = .3;\n\n\n\/\/ Structures ----------\nstruct Surface {\n  float d;              \/\/ distance\n  vec3  kd, tc, rl, rr; \/\/ diffusion, transparent-color, reflectance, refractive index\n};\nSurface near(Surface s,Surface t) { if (s.d<t.d) return s; return t; }\n\nstruct Ray {\n  vec3  org, dir, col;     \/\/ origin, direction, color\n  float len, stp, rr, sgn; \/\/ length, marching step, refractive index of current media, sign of distance function\n};\nRay ray(vec3 o, vec3 d) { return Ray(o,d,vec3(1),0.,0.,1.,1.); }\nRay ray(vec3 o, vec3 d, vec3 c, float rr, float s) { return Ray(o,d,c,0.,0.,rr,s); }\nvec3 _pos(Ray r) { return r.org+r.dir*r.len; }\n\nstruct Hit {\n  vec3 pos,nml; \/\/ position, normal\n  Ray ray;      \/\/ ray\n  Surface srf;  \/\/ surface\n  bool isTransparent, isReflect;  \/\/ = (len2(srf.tc) > 0.001, len2(srf.rl) > 0.001)\n};\nHit nohit(Ray r) { return Hit(vec3(0), vec3(0), r, Surface(NO_HIT_DIST, vec3(1), vec3(0), vec3(0), vec3(0)), false, false); }\n\nstruct Camera {\n  vec3 pos, tgt;  \/\/ position, target\n  float rol, fcs; \/\/ roll, focal length\n};\nmat3 _mat3(Camera c) {\n  vec3 w = normalize(c.pos-c.tgt);\n  vec3 u = normalize(cross(w,vec3(sin(c.rol),cos(c.rol),0)));\n  return mat3(u,normalize(cross(u,w)),w);\n}\n\nstruct AABB { vec3 bmin, bmax; };\nstruct Light { vec3 dir, col; };\nvec3 _diff(vec3 n, Light l){ return clamp((dot(n, l.dir)+1.)*.5, 0., 1.)*l.col; }\n\n\n\/\/ Grobal valiables ----------\nconst float bpm = 126.0;\nconst Light amb = Light(vec3(0,-1,0), vec3(0.4));\nconst Light dif = Light(normalize(vec3(0,-1,0)), vec3(1));\nfloat phase;\n\n\n\/\/ Utilities ----------\nvec3  _hsv(float h, float s, float v) { return ((clamp(abs(fract(h+vec3(0,2,1)\/3.)*6.-3.)-1.,0.,1.)-1.)*s+1.)*v; }\nmat3  _smat(vec2 a) { float x=cos(a.y),y=cos(a.x),z=sin(a.y),w=sin(a.x); return mat3(y,w*z,-w*x,0,x,z,w,-y*z,y*x); }\nmat3  _pmat(vec3 a) {\n  float sx=sin(a.x),sy=sin(a.y),sz=sin(a.z),cx=cos(a.x),cy=cos(a.y),cz=cos(a.z);\n  return mat3(cz*cy,sz*cy,-sy,-sz*cx+cz*sy*sx,cz*cx+sz*sy*sx,cy*sx,sz*sx+cz*sy*cx,-cz*sx+sz*sy*cx,cy*cx);\n}\nfloat _checker(vec2 uv, vec2 csize) { return mod(floor(uv.x\/csize.x)+floor(uv.y\/csize.y),2.); }\nfloat _checker3(vec3 uvt, vec3 csize) { return mod(floor(uvt.x\/csize.x)+floor(uvt.y\/csize.y)+floor(uvt.z\/csize.z),2.); }\nfloat len2(vec3 v) { return dot(v,v); }\nfloat smin(float a, float b, float k) { return -log(exp(-k*a)+exp(-k*b))\/k; }\nfloat smax(float a, float b, float k) { return log(exp(k*a)+exp(k*b))\/k; }\nfloat vmin(vec3 v) { return min(v.x, min(v.y, v.z)); }\nfloat vmax(vec3 v) { return max(v.x, max(v.y, v.z)); }\nvec2  cycl(float t, vec2 f, vec2 r) { return vec2(cos(t*f.x)*r.x+cos(t*f.y)*r.y,sin(t*f.x)*r.x+sin(t*f.y)*r.y); }\nvec3  fresnel(vec3 f0, float dp) { return f0+(1.-f0)*pow(1.-abs(dp),5.); }\nfloat rr2rl(float rr) { float v=(rr-1.)\/(rr+1.); return v*v; }\nfloat rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\n\n\/\/ Intersect functions ----------\nvec2 hitAABB(Ray r, AABB b) { \n  vec3 t1=(b.bmin-r.org)\/r.dir, t2=(b.bmax-r.org)\/r.dir;\n  return vec2(vmax(min(t1, t2)), vmin(max(t1, t2)));\n}\n\nfloat ifBox(Ray r, vec3 b) {\n  vec2 v = hitAABB(r, AABB(-b,b));\n  return (0.<=v.y&&v.x<=v.y)?v.x:NO_HIT_DIST;\n}\n\n\/\/ Distance functions ----------\nfloat dfPln(vec3 p, vec3 n, float d) { return dot(p,n) + d; }\nfloat dfBox(vec3 p, vec3 b, float r) { return r-length(max(abs(p)-b,0.));}\n\nconst float vtx[11] = float[11](1.10, 1.39, 1.75, 2.32, 2.68, 2.08, 1.44, 1.12, 0.98, 0.95, 1.00);\nconst float vcnt = 5.0;\nfloat dfFreeDSBC(in vec3 p, in float r, in float t) {\n  p = vec3(p.x, abs(p.y)-t, abs(p.z*2.0));\n  float at = atan(p.z,p.x)\/(PI\/vcnt);\n  float a = floor(at+.5)*(PI\/vcnt), c = cos(a), s = sin(a);\n  int   i = int(at*2.);\n  float v0 = vtx[i]   + textureLod(iChannel0, vec2(1.05-float(i)  \/12., 0), 0.).x*2.;\n  float v1 = vtx[i+1] + textureLod(iChannel0, vec2(1.05-float(i+1)\/12., 0), 0.).x*2.;\n  float rf = mix(v0,v1,fract(at*2.)) * r;\n  vec3  q = vec3((c*p.x+s*p.z)\/rf, p.y\/r, abs(-c*p.z+s*p.x)\/rf);\n  float fcBezel = dot(q, vec3(.544639035, .8386705679, 0))           - .544639035;\n  float fcUGird = dot(q, vec3(.636291199, .7609957358, .1265661887)) - .636291199;\n  float fcStar  = dot(q, vec3(.332894535, .9328278154, .1378894313)) - .448447409;\n  float fcTable =   q.y - .2727511892 - .05;\n  float fcCulet = - q.y - .8692867378 * .96;\n  float fcGirdl = length(q.xz) - .975;\n  return max(fcGirdl, max(fcCulet, max(fcTable, max(fcBezel, max(fcStar, fcUGird)))));\n}\n\nfloat sdChain(vec3 p, float r, float l, float w){\n  float a=(l+r-w)*2., x0=mod(p.x, a*2.), x1=mod(p.x+a, a*2.);\n  return min(length(vec2(length(vec2(max(abs(x0-a)-l,0.),p.z))-r,p.y))-w,\n             length(vec2(length(vec2(max(abs(x1-a)-l,0.),p.y))-r,p.z))-w);\n}\n\n\n\/\/ Domain Operations ----------\nvec3 doXZ(vec3 p, vec2 r){\n  vec2 hr = r*.5;\n  return vec3(mod(p.x+hr.x, r.x)-hr.x, p.y, mod(p.z+hr.y, r.y)-hr.y);\n}\n\n\n\/\/ Deforimng function ----------\nvec3 foXZCircle(vec3 p, float l, float r){\n  return vec3(atan(p.z,p.x)*l\/P2,p.y,length(p.xz)-r);\n}\n\n\n\/\/ Easing Functions ----------\n\n\n\/\/ Ray calcuatoins ----------\nRay rayScreen(in vec2 p, in Camera c) {\n  return ray(c.pos, normalize(_mat3(c) * vec3(p.xy, -c.fcs)));\n}\n\nRay rayReflect(in Hit h, in vec3 rl) {\n  return ray(h.pos + h.nml*.01, reflect(h.ray.dir, h.nml), h.ray.col*rl, h.ray.rr, h.ray.sgn);\n}\n\nRay rayRefract(in Hit h, in float rr) {\n  vec3 r = refract(h.ray.dir, h.nml, h.ray.rr\/rr);\n  if (len2(r)<.001) return rayReflect(h, vec3(1));\n  return ray(h.pos - h.nml*.01, r, h.ray.col*h.srf.tc, rr, -h.ray.sgn);\n}\n\n\n\/\/ Sphere tracing ----------.\nSurface map(in vec3 p){\n  float t = exp(cos(phase\/2.0)*5.0)*0.001;\n  float isGlass = sign(p.x) * 0.5 + 0.5; \/\/ glass=1, mirror=0\n  vec3 rr = vec3(isGlass*1.8),\n       rl = vec3(rr2rl(rr.x)),\n       col = vec3(0),\n       tc = vec3(1.0,0.2,0.2)*isGlass;\n  return near(\n    Surface(dfFreeDSBC(vec3(abs(p.x)-2.7,p.y-2.0,p.z)*_pmat(vec3(phase\/32.0,0.0,0.5*PI)), 1.6, 0.1), col, tc, rl, rr),\n    Surface(sdChain(foXZCircle((p-vec3(0,2,0))*_pmat(vec3(0,sin(phase\/32.0)*P2,phase\/32.0)),30.6,6.0), 0.35, 0.1+t, 0.1+t), \n            vec3(0), vec3(1.0), rl, rr)\n  );\n}\n\/\/doXZ(p, vec2(1.5*8.-0.4*16.))*mat\n\n\/\/ Lighting ----------\nvec4 _cs(in vec3 pos, in vec3 dir) {\n  vec4 col;\n  float len = SS_MIN_MARCHING;\n  for (int i=SS_MAX_TRACE_STEP; i!=0; --i) {\n    Surface s = map(pos + dir*len);\n    col = vec4(s.tc, min(col.a, SS_SHARPNESS*s.d\/len));\n    len += max(s.d, SS_MIN_MARCHING);\n    if (s.d<TRACE_PRECISION || len>SS_MAX_TRACE_DIST) break;\n  }\n  col.a = clamp(col.a, 0., 1.);\n  col.rgb = pow((1.-col.a), CS_SHARPNESS) * col.rgb * CS_STRENGTH;\n  return col;\n}\n\nvec4 _gi(in vec3 pos, in vec3 nml) {\n  vec4 col = vec4(0);\n  for (int i=GI_TRACE_STEP; i!=0; --i) {\n    float hr = .01 + float(i) * GI_LENGTH \/ 4.;\n    Surface s = map(nml * hr + pos);\n    col += vec4(s.kd, 1.) * (hr - s.d);\n  }\n  col.rgb *= GI_STRENGTH \/ GI_LENGTH;\n  col.a = clamp(1.-col.a * AO_STRENGTH \/ GI_LENGTH, 0., 1.);\n  return col;\n}\n\nvec3 _back(in Ray ray) {\n  ray.len = ifBox(ray, vec3(22));\n  vec3 p = _pos(ray);\n  vec3 ap = abs(p);\n  float c = len2(fract(p*0.5)-0.5)-0.25;\n  float ct = 0.7 + p.y\/33.0;\n  return (fract(c*cos(phase\/16.)*16.0)*0.2+ct)*vec3(1.0-(ap.x+ap.y+ap.z-vmin(ap))\/44.2);\n}\n\nvec3 lighting(in Hit h) {\n  if (h.ray.len > MAX_TRACE_DIST) return _back(h.ray);\n  vec4 fgi = _gi(h.pos, h.nml);    \/\/ Fake Global Illumination\n  vec4 fcs = _cs(h.pos, dif.dir);  \/\/ Fake Caustic Shadow\n  \/\/   lin = ([Ambient]        + [Diffuse]        * [SS]  + [CS])    * [AO]  + [GI]\n  vec3 lin = (_diff(h.nml, amb) + _diff(h.nml, dif) * fcs.w + fcs.rgb) * fgi.w + fgi.rgb;\n  return  h.srf.kd * lin;\n}\n\n\n\/\/ Ray tracing ----------\nvec3 _calcNormal(in vec3 p){\n  vec3 v=vec3(.001,0,map(p).d);\n  return normalize(vec3(map(p+v.xyy).d-v.z,map(p+v.yxy).d-v.z,map(p+v.yyx).d-v.z));\n}\n\nHit sphereTrace(in Ray r) {\n  Surface s;\n  for(int i=0; i<MAX_TRACE_STEP; i++) {\n    s = map(_pos(r));\n    s.d *= r.sgn;\n    r.len += s.d * FUDGE_FACTOR;\n    r.stp = float(i);\n    if (s.d < TRACE_PRECISION) break;\n    if (r.len > MAX_TRACE_DIST) return nohit(r);\n  }\n  vec3 p = _pos(r);\n  float interior = .5-r.sgn*.5;\n  s.rr = mix(s.rr, vec3(1), interior);\n  s.tc = max(s.tc, interior);\n  return Hit(p, _calcNormal(p)*r.sgn, r, s, (len2(s.tc)>.001), (len2(s.rl)>.001));\n}\n\nHit trace(in Ray r) {\n  return sphereTrace(r);\n}\n\n\n\/\/ Rendering ----------\nvec3 _difColor(inout Hit h) {\n  if (len2(h.srf.kd) < .001) return vec3(0);\n  vec3 col = lighting(h) * h.ray.col;\n  h.ray.col *= 1. - h.srf.kd;\n  return col;\n}\n\nRay _nextRay(Hit h) {\n  if (h.isTransparent) return rayRefract(h, h.srf.rr.x);\n  return rayReflect(h, fresnel(h.srf.rl, dot(h.ray.dir, h.nml)));\n}\n\nvec4 render(in Ray r){\n  vec3 col = vec3(0), rl, c;\n  Hit h0, h1;\n  float l0;\n\n  \/\/ first trace\n  h0 = trace(r);\n  l0 = h0.ray.len;\n\n  \/\/ first diffusion surface\n  col += _difColor(h0);\n  if (!h0.isReflect) return vec4(col, l0);\n\n  \/\/ first reflection\n  rl = fresnel(h0.srf.rl, dot(h0.ray.dir, h0.nml));\n  h1 = trace(rayReflect(h0, rl));\n  col += _difColor(h1);\n  h0.ray.col *= 1. - rl;\n  if (!h0.isTransparent) h0 = h1;\n \n  \/\/ repeating trace\n  for (int i=RAY_TRACE_COUNT; i!=0; --i) {\n    if (!h0.isReflect) return vec4(col, l0);\n    h0 = trace(_nextRay(h0));\n    col += _difColor(h0);\n  }\n\n  \/\/ cheap trick\n  c = h0.ray.col;\n  if (len2(c) >= .25) col += _back(h0.ray) * c * c;\n\n  return vec4(col, l0);\n}\n\nvec4 gamma(in vec4 i) {\n  return vec4(pow(i.xyz, GAMMA), i.w);\n}\n\n\n\/\/ Entry point ----------\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  phase = iTime * bpm \/ 60. * P2;\n\n  vec2   m = vec2(cos(phase\/128.), sin(phase\/128.))*15.;\n  Camera c = Camera(vec3(m.x,sin(phase\/32.)*10.,m.y), vec3(0,2,0), 0., 1.73205081);\n  \/\/Camera c = Camera(vec3(0,10,1),vec3(0,1,0), 0., 1.73205081);\n  Ray    r = rayScreen((fragCoord.xy * 2. - iResolution.xy) \/ iResolution.x, c);\n\n  vec4 res = render(r);\n  res.w = min(abs(res.w - length(c.pos)+15.)\/100., 1.);\n\n  fragColor = gamma(res);\n}\n","name":"Image","description":"","type":"image"}]}}