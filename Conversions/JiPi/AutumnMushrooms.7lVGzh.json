{"Shader":{"ver":"0.1","info":{"id":"7lVGzh","date":"1637616224","viewed":281,"name":"Autumn mushrooms","username":"iapafoto","description":"Leprechauns love mushrooms, when they find an owl they party a lot\nWith party sound on, they only dance when there is music!","likes":27,"published":3,"flags":0,"usePreview":1,"tags":["bezier","automn","elf","lutin","leprechaun"],"hasliked":0},"renderpass":[{"inputs":[{"id":6,"src":"\/media\/a\/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":10,"src":"\/media\/a\/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":20,"src":"\/media\/a\/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3","ctype":"music","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":37,"channel":0}],"code":"\/\/ Created by sebastien durand - 11\/2021\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\/\/ *****************************************************************************\n\/\/ Based on\n\/\/ iq - Quadratic Bezier - https:\/\/www.shadertoy.com\/view\/ldj3Wh\n\/\/ *****************************************************************************\n\n#define AA 1\n\n#define ZERO (min(iFrame,0))\n\n#define nose 2.\n#define hat 3.\n#define dress 4.\n#define leg 5.\n#define foot 6.\n#define bear 7.\n#define mushrom 9.\n\n\/\/-----------------------------------------------------------------------------------\n\nvec3 getPtOnBez(vec3 p0, vec3 p1, vec3 p2, float t) {\n    return (1. - t) * (1. - t) * p0 + 2. * (1. - t) * t * p1 + t * t * p2;\n}\n\n\/\/-----------------------------------------------------------------------------------\n\/\/ Mercury\nfloat fOpUnionRound(float a, float b, float r) {\n\treturn max(r, min (a, b)) - length(max(vec2(r - a,r - b), vec2(0)));\n}\n\nfloat pModPolar(inout vec2 p, float rep) {\n\tfloat an = 3.141592\/rep,\n         a = atan(p.y, p.x) + an,\n         r = length(p),\n         c = floor(.5*a\/an);\n\ta = mod(a,2.*an) - an;\n\tp = vec2(cos(a), sin(a))*r;\n\tif (abs(c) >= rep*.5) c = abs(c);\n\treturn c;\n}\n\n\/\/-----------------------------------------------------------------------------------\n\/\/ iq - https:\/\/www.shadertoy.com\/view\/ldj3Wh\nvec2 sdBezier(in vec3 p,in vec3 b0,in vec3 b1,in vec3 b2 ) {\n    b0 -= p; b1 -= p; b2 -= p;\n    vec3 b01 = cross(b0,b1), b12 = cross(b1,b2), b20 = cross(b2,b0),\n         n =  b01+b12+b20;\n    float a = -dot(b20,n), b = -dot(b01,n), d = -dot(b12,n), m = -dot(n,n);\n    vec3  g =  (d-b)*b1 + (b+a*.5)*b2 + (-d-a*.5)*b0;\n    float t = clamp((a*.5+b-.5*(a*a*.25-b*d)*dot(g,b0-2.*b1+b2)\/dot(g,g))\/m, 0., 1.);\n    return vec2(length(mix(mix(b0,b1,t), mix(b1,b2,t),t)),t);\n}\n\nvec2 sdCapsule(in vec3 p,in vec3 a,in vec3 b) {\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp(dot(pa,ba)\/dot(ba,ba), 0., 1.);\n  return vec2(length(pa - ba*h), h);\n}\n\nfloat sdEllipsoid(in vec3 p,in vec3 r) {\n  float k0 = length(p\/r);\n  return k0*(k0-1.)\/length(p\/(r*r));\n}\n\n\/\/-----------------------------------------------------------------------------------\n\/\/ Scene modeling\nvec2 sdMush(in vec3 p) {\n    float d = .5*(sdBezier(p, vec3(0,0,0), vec3(.4,3,0), vec3(.2,4.2,.3)).x-.1);\n\td = fOpUnionRound(d,max(sdEllipsoid(p-vec3(.3,3.3,.3), vec3(1.2,.7,1.2)),\n                    -sdEllipsoid(p-vec3(.27,3.,.25), vec3(1.3,.7,1.5))),.5);\n\td = min(d,sdEllipsoid(p-vec3(-3.,.6,6.), vec3(.8,.6,.8)));\n\td = min(d,sdEllipsoid(p-vec3(4.5,.5,2.5), vec3(.6,.5,.6)));\n\td = min(d,sdEllipsoid(p-vec3(-6.5,.5,-8.5), vec3(.6,.5,.6)));\n\treturn vec2(d, mushrom);\n}\n\nvec2 sdHand(vec3 p, vec3 p10, vec3 p11, vec3 n) {\n    vec3 knee = .5*(p11+p10) + n,\n         p2 = getPtOnBez(p10, knee, p11, .2),\n         nn = normalize(p10-p2);\n    \/\/ harm     \n    vec2 h = sdBezier(p, p11, knee, p10);\n    float d,\n          dm = max(h.x - .1 - .05*h.y, -length(p-p10)+.2),\n          hm=h.y;\n    \/\/ fingers\n    d = sdCapsule(p, p10+vec3(.03*sign(n.x),0,0), p2).x;\n    p += nn*.05;\n    d = min(d, sdCapsule(p, p10+vec3(0,.05,0), p2+vec3(0,.05,0)).x);\n    d = min(d, sdCapsule(p, p10-vec3(-.02*sign(n.x),.05,0), p2-vec3(0,.05,0)).x);\n    p += nn*.05;\n    d = min(d, sdCapsule(p, p10-vec3(0,.1,0), p2-vec3(0,.1,0)).x);\n    d -= .05;\n    return d < dm ? vec2(d, nose) : vec2(dm, dress);\n}\n\nvec2 sdLeg(vec3 p, vec3 foot10, vec3 foot11, vec3 n) {\n    vec3 knee = .5*(foot11+foot10) + n,\n         p4 = getPtOnBez(foot10, knee, foot11, .2);\n    vec2 h = sdBezier(p, foot11, knee, foot10);\n    float d,dm = h.x - .1, \n          hm = leg + h.y;\n    \/\/ foot\n    h = sdCapsule(p, foot10, p4);\n    d = max(h.x - .2, -length(p- mix(foot10, p4, 2.5)) + .4);\n    if (d<dm) { dm=d; hm=dress;}\n    p.y += .1; \n    h = sdCapsule(p, foot10, foot10 + n);\n    d = h.x - .2;\n    if (d<dm) { dm=d; hm=hat; }\n    return vec2(dm,hm);\n}\n\nfloat invMix(float v0, float v1, float v) {\n    return v1 == v0 ? 1. : (v-v0)\/(v1-v0);\n}\n\nfloat getAmp(float frequency) { return texture(iChannel2, vec2(frequency \/ 512.0, 0)).x; }\n\n#define BPM 127.\nvec2 sdLutin(in vec3 p, in float lid) {\n    float t = iChannelTime[2]*2.11666,\n          a1 = (getAmp(lid*lid * 20.)*.5+.5)*cos(9.*t+1.57 * lid),\n          anim = (getAmp(lid*lid * 40.)*.5+.5)*cos(6.*t+1.57 * lid),\n          gg = .5*cos(lid*110.);\n          \n    vec3 head = vec3(0,2.5+gg,0),\n         hips = vec3(0,1.2+gg,0);\n   \n    head += .2*vec3(.5,.5,.2)*(a1 + .5*anim);\n    hips += .3*vec3(.5,.2,.2)*anim;   \n    \n    vec3 epaule = head - vec3(0,.7,0),\n         c = head + vec3(0,.9,-.8),\n         b = head + vec3(0,.65,-.3);\n\n    float d, dm, hm = nose;\n    \n    \/\/ nez\n    dm = sdEllipsoid(p- head - vec3(0,0,.5), vec3(.3,.15,.3));\n    \n    \/\/ bras\n    float s = p.x>0.?1.:-1.;\n    vec2 h = sdHand(p, epaule + vec3(s*1.,-.7+s*.3*anim- .3*gg,.5+ .4*gg), epaule+vec3(s*.4,0.,-.05), vec3(s*.2,-.2,-.2));\n    if( h.x<dm ) { dm=h.x; hm = h.y; }\n \n    \/\/ body\n    vec3 pb = p;\n    pb.z \/= .7;\n    pb.z -= .2*cos(p.y)*smoothstep(epaule.y,hips.y,invMix(epaule.y,hips.y, p.y));\n    h = sdCapsule(pb, epaule+vec3(0,-.15,0), hips-vec3(0,.7,0));\n    d = max(h.x - mix(.4,.6,h.y), -length(pb-hips+vec3(0,.8,0)) + .7);\n    if (d<dm) { hm = dress; }\n    dm = .7*fOpUnionRound(d, dm, .15);\n    \n    \/\/ legs  \n    h = sdLeg(p, vec3(s*.5,-.7,0), hips + vec3(s*.25,-.2,0), vec3(s*.2,0,.3));\n    if (h.x<dm) { dm=h.x; hm=h.y; }\n    \n     \/\/ bonet\n    vec3 p3 = p + vec3(0,.1,-.1);\n    h = sdBezier( p3, head-vec3(0,.05,0), b, c );\n    d = .7*max( h.x - .5 + .5*h.y, -length(p3-(head-vec3(0,.8,-.6))) + 1.);\n    if( d<dm ) { dm=d; hm=hat; }\n\n    \/\/ barbe\n    vec3 p4 = p;\n    float k = mix(1.,3.,smoothstep(head.y, head.y-1., p4.y));\n    p4.z*=k;\n    h = sdBezier( p4, head, head - vec3(0,1.,.0), vec3(head.x, head.y, head.z*k) - vec3(-.2*anim,1,-3.));\n    d = .7*fOpUnionRound(h.x - .3*sin(3.14*h.y), length(p-(head-vec3(0,.4,-.2)))-.5, .15);\n    if (d<dm) { dm=d; hm=bear; }\n\n\treturn vec2(dm*.9, 10.*lid + hm );\n}\n\nvec2 map(in vec3 p) {\n\tvec2 h2, h1 = sdMush(p-vec3(0,-1.05,0));\n    float id = pModPolar(p.xz, 6.),\n          d = sdEllipsoid(p-vec3(3,1.35,0), vec3(1.3,2.9,1.6));\n    if (d>0.) h2 = vec2(d+.1,0);\n    else      h2 = sdLutin((p - vec3(3,0,0)).zyx, id);\n    return h1.x<h2.x ? h1 : h2;\n}\n\n\/\/-------------------------------------------------------\n\/\/ Ray marching\nvec3 intersect( in vec3 ro, in vec3 rd ) {\n    vec3 res = vec3(-1.);\n    float maxd = 25.;\n    \/\/ plane\n    float tp = (-.85-ro.y)\/rd.y;\n    if (tp>0.) {\n        res = vec3(tp,0,0);\n        maxd = min(maxd,tp);\n    }\n    \/\/ Lutins\n    float t = 2., l = 0.;\n    for( int i=ZERO; i<92; i++ ) {\n\t    vec2 h = map(ro+rd*t);\n        if (h.x<.004 || t>maxd) break;\n        t += h.x;\n\t\tl = h.y;\n    }\n    return t<maxd ? vec3(t, l, 1.) : res;\n}\n\nvec3 calcNormal( in vec3 pos ) {\n \/\/ inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0);\n    for( int i=ZERO; i<4; i++) {\n        vec3 e = .5773*(2.*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.);\n        n += e*map(pos+.002*e).x;\n    }\n    return normalize(n);\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k ) {\n    float res = 1., t = mint, h = 1.;\n    for( int i=ZERO; i<48; i++ ) {\n        h = map(ro + rd*t).x;\n        res = min( res, k*h\/t );\n\t\tt += clamp( h, .002, 2. );\n        if( res<.001 ) break;\n    }\n    return clamp(res,0.,1.);\n}\n\nfloat map2( in vec3 pos ) {\n    return min(pos.y+.85, map(pos).x);\n}\n\n\nfloat calcAO( in vec3 pos, in vec3 nor) {\n    float h,d,ao = 0.;\n    for( int i=ZERO; i<8; i++ ) {\n        h = .02 + .5*float(i)\/7.;\n        d = map2( pos + h*nor );\n        ao += h-d;\n    }\n    return clamp( 1.5 - ao*.6, 0., 1. );\n}\n\n\n\/\/------------------------------------------------------------------------\n\/\/ [Shane] - Desert Canyon - https:\/\/www.shadertoy.com\/view\/Xs33Df\n\/\/------------------------------------------------------------------------\n\/\/ Tri-Planar blending function. Based on an old Nvidia writeup:\n\/\/ GPU Gems 3 - Ryan Geiss: http:\/\/http.developer.nvidia.com\/GPUGems3\/gpugems3_ch01.html\nvec3 tex3D(sampler2D tex, in vec3 p, in vec3 n){\n    n = max(n*n, .001);\n    n \/= (n.x + n.y + n.z );  \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n\n\/\/ Grey scale.\nfloat grey(vec3 p){ return dot(p, vec3(.299, .587, .114)); }\n\n\/\/ Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total.\nvec3 doBumpMap( sampler2D tex, in vec3 p, in vec3 n, float k){\n    const float ep = .001;\n    vec3 grad = vec3( grey(tex3D(tex, vec3(p.x-ep, p.y, p.z), n)),\n                      grey(tex3D(tex, vec3(p.x, p.y-ep, p.z), n)),\n                      grey(tex3D(tex, vec3(p.x, p.y, p.z-ep), n)));\n    grad = (grad - grey(tex3D(tex, p, n)))\/ep;             \n    grad -= n*dot(n, grad);          \n    return normalize(n + grad*k);\n}\n\n\/\/ iq palette\nvec3 pal(in float t) {\n    return .5 + .5*cos(6.28318*(t+vec3(.0,.33,.67)) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    vec4 tot = vec4(0);\n    \n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        \/\/ pixel coordinates\n        vec2 o = vec2(float(m),float(n)) \/ float(AA) - .5,\n             p = (-iResolution.xy + 2.*(fragCoord+o))\/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.*fragCoord)\/iResolution.y;\n#endif\n\n        \/\/-----------------------------------------------------\n        \/\/ camera\n        \/\/-----------------------------------------------------\n        float an = 2. + .3*iTime + 3.*smoothstep(.9,.95, sin(.32*iTime)) +  3.*smoothstep(.9,.95, sin(.06*iTime));\n\n        vec3 ro = mix(1.75,1.2,smoothstep(-.9,-.8, cos(.15*iTime+.001*iTime*iTime)))*vec3(10.0*sin(an),5.0,10.0*cos(an)),\n             ta = vec3(.02*an,0,0);\n\n        \/\/ camera matrix\n        float a = .1*cos(.1*iTime);\n        vec3 ww = normalize(ta - ro),\n             uu = normalize(cross(ww,normalize(vec3(sin(a),cos(a),0)))),\n             vv = normalize(cross(uu,ww));\n\n        \/\/ create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 2.5*ww );\n\n        \/\/-----------------------------------------------------\n        \/\/ render\n        \/\/-----------------------------------------------------\n\n        vec3 lig = normalize(vec3(-.2,.6,.9));\n        float sun = pow( clamp( dot(rd,lig), 0., 1. ), 8. );\n\n        \/\/ raymarch\n        vec3 tmat = intersect(ro,rd);\n\n        \/\/ geometry\n        vec3 nor, pos = ro + tmat.x*rd;\n        if( tmat.z<.5)\n             nor = vec3(0,1,0);\n        else nor = calcNormal(pos);\n        \n        vec3 ref = reflect( rd, nor );\n\n        \/\/ materials\n        vec3 mate = vec3(.5);\n\n        float lid = floor(tmat.y*.1);\n        tmat.y = mod(tmat.y,10.);\n        vec3 col, \n             col1 = pal(lid\/6.),\n             col2 = pal(lid\/6. + .33);\n\n        if (tmat.y < nose) {\n            float k = texture(iChannel1, .051*pos.xz).x;\n            mate = texture(iChannel1, .2*pos.xz).xyz;\n            mate = .12*pow(mate,vec3(.3));\n            mate = .5*mix(mate, vec3(.65,.5,.0), .2*smoothstep(.5,.6,k));\n            nor = doBumpMap(iChannel1, .2*pos, nor, .02);\n        } else if (tmat.y < hat) {\n            mate = vec3(.68,.475,.446);\n        } else if (tmat.y < dress) {\n            mate = col2;\n        } else if (tmat.y < leg) {\n            mate = col1;\n        } else if (tmat.y < bear) {\n            mate = mix(col2, vec3(.2), smoothstep( -0.1, 0.1, cos( 40.0*tmat.y )));\n        } else if (tmat.y < mushrom) {\n            vec3 p2 = pos;\n            float lid2 = pModPolar(p2.xz, 6.),\n            a1 = cos(6.*iTime+1.57 * lid2),\n            anim = cos(4.*iTime+1.57 * lid2);\n            vec3 head = vec3(0,2.5,0) + vec3(0,.5*cos(lid2*110.),0),\n            hips = vec3(0,1.2,0) + vec3(0,.5*cos(lid2*110.),0);\n            head += .2*vec3(.5,.5,.2)*(a1 + .5*anim);\n            nor = doBumpMap(iChannel0, 1.5*(pos-head)*vec3(1,.2,1), nor, .12);\n            mate = lid2<0. ? vec3(211,110,76)\/256. : vec3(1.);\n        } else {\n            vec3 p = pos - vec3(.2,4.2,.3);\n            float r = length(p.xz);\n            if (r<2.) {\n                mate = mix(vec3(.7), .5*vec3(1,.5,1), smoothstep(.5,1.5,pos.y));\n                nor = doBumpMap(iChannel0, vec3(.1*atan(p.x,p.z),.1*r,0), nor, .01);\n            } else {\n                mate = vec3(.7);\n            }\n            mate = 2.*mix(.25*vec3(1,.7,.6),mate,smoothstep(.2,.3,tex3D(iChannel1, .5*pos, nor).x));\n        }\n\n        float occ = calcAO(pos, nor);\n\n        \/\/ lighting\n        float sky = clamp(nor.y,0.,1.),\n             bou = clamp(-nor.y,0.,1.),\n             dif = max(dot(nor,lig),0.),\n             bac = max(.3 + .7*dot(nor,-lig),0.),\n             fre = pow( clamp( 1. + dot(nor,rd), 0., 1. ), 5.),\n             spe = .5*max( 0., pow( clamp( dot(lig,reflect(rd,nor)), 0., 1.), 8.)),\n             sha = 0.; \n        if (dif>.001) sha=softshadow(pos+.01*nor, lig, .0005, 32.);\n\n        \/\/ lights\n        vec3 brdf = 2.*dif*vec3(1.25,.9,.6)*sha;\n        brdf += 1.5*sky*vec3(.1,.15,.35)*occ;\n        brdf += bou*vec3(.3)*occ;\n        brdf += bac*vec3(.3,.25,.2)*occ;\n        brdf += fre*occ*dif;\n\n        \/\/ surface-light interacion\n        col = mate.xyz* brdf;\n        col += (1.-mate.xyz)*spe*vec3(1,.95,.9)*sha*2.*(.2+.8*fre)*occ;\n\n        \/\/ fog\n        col = mix( col, 3.*vec3(.09,.13,.15), smoothstep(7.,30.,tmat.x) );\n\t\tcol += .4*vec3(1,.68,.7)*sun;\n        tot += vec4(col, tmat.x);\n#if AA>1\n    }\n    tot \/= float(AA*AA);\n#endif\n\n    \/\/ Gamma\n\ttot.xyz = pow(clamp(tot.xyz,0.,1.), vec3(0.5));\n    \/\/ Vigneting\n    vec2 q = fragCoord\/iResolution.xy;\n    tot.xyz *= pow(16.*q.x*q.y*(1.-q.x)*(1.-q.y), .32); \n    fragColor = vec4(tot.xyz,1.);\n}\n","name":"Image","description":"","type":"image"}]}}