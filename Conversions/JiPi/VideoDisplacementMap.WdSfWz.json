{"Shader":{"ver":"0.1","info":{"id":"WdSfWz","date":"1589801204","viewed":433,"name":"Video displacement map","username":"Mipmap","description":"TomF's Displacement map on rast mesh with video for displacement map\n([url]https:\/\/www.shadertoy.com\/view\/wsSBzw[\/url]) ","likes":4,"published":3,"flags":0,"usePreview":0,"tags":["animated","displacementmap","rasterize","mesh"],"hasliked":0},"renderpass":[{"inputs":[{"id":29,"src":"\/media\/a\/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","ctype":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":29,"src":"\/media\/a\/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","ctype":"video","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":37,"channel":0}],"code":"\/\/ TomF's Displacement map on rast mesh with video for displacement map\n\/\/ (https:\/\/www.shadertoy.com\/view\/wsSBzw) \n\n#define BACKFACE_CULL false\n#define TEXTURED true\n#define PHASES false\n\n\nstruct Vertex\n{\n    vec4 Pos;\n    vec3 Uvh;\n};\n    \n\n\/\/ Test a position against a triangle and return\n\/\/ the perspective-correct barycentric coordinates in the triangle\n\/\/ Note the z value in the vertex is ignored, it's the w that matters.\nvec2 BaryTri3D ( vec2 pos, Vertex v1, Vertex v2, Vertex v3 )\n{\n    vec2 posv1 = pos - vec2(v1.Pos);\n    \n    vec2 v21 = vec2(v2.Pos) - vec2(v1.Pos);\n    vec2 v31 = vec2(v3.Pos) - vec2(v1.Pos);\n    \n    float scale = v21.x * v31.y - v21.y * v31.x;\n    if ( BACKFACE_CULL && ( scale < 0.0 ) )\n    {\n        return vec2 ( -1.0, -1.0 );\n    }\n\n    float rscale = 1.0 \/ scale;\n    float baryi = ( posv1.x * v31.y - posv1.y * v31.x ) * rscale;\n    float baryj = ( posv1.x * v21.y - posv1.y * v21.x ) * -rscale;\n    \n    \/\/ Now interpolate the canonical coordinates (0,0,1,v1.w), (1,0,1,v2.w) and (0,1,1,v3.w)\n    \/\/ with perspective correction\n    \/\/ So we project all three by their respective w:\n    \/\/ (0,0,v1.w) -> (0,     0,     1\/v1.w)\n    \/\/ (1,0,v2.w) -> (1\/v2.w,0,     1\/v2.w)\n    \/\/ (0,1,v3.w) -> (0,     1\/v3.w,1\/v3.w)\n    \/\/ Then interpolate those values linearly to produce (nx,ny,nw),\n    \/\/ then divide by nw again.\n    vec3 recipw = vec3 ( 1.0\/v1.Pos.w, 1.0\/v2.Pos.w, 1.0\/v3.Pos.w );\n    \n    float baryk = 1.0 - baryi - baryj;\n    float newi = recipw.y * baryi;\n    float newj = recipw.z * baryj;\n    \/\/float neww = recipw.x * baryk + recipw.y * baryi + recipw.z * baryj;\n    float neww = recipw.x * baryk + newi + newj;\n    \n    \/\/ ...and project back.\n    float rneww = 1.0\/neww;\n    float perspi = newi * rneww;\n    float perspj = newj * rneww;\n        \n    return vec2 ( perspi, perspj );\n}\n\nconst int GridW = 4;\nconst int GridH = 4;\nconst int NumVerts = GridH*GridW*2;\nconst int NumTris = (GridH-1)*(GridW-1)*2*2 + ((GridH-1)*2+(GridW-1)*2)*2;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ NDC (-1 to +1)\n    vec2 uv = -1.0 + 2.0f * (fragCoord\/iResolution.xy);\n    \n    int Phase = 0;\n    if(PHASES)\n    {\n    \tPhase = (int(floor(0.2*(iTime-1.0*fragCoord.x\/iResolution.x))))%3;\n    }\n    \n    \n    float wobble = 0.0;\/\/float(iTime);\n    \n    \/\/ Create the mesh. This would of course be done offline.\n    Vertex Verts[NumVerts];\n    for ( int w = 0; w < GridW; w++ )\n    {\n        for ( int h = 0; h < GridH; h++ )\n        {\n            Vertex Vert0, Vert1;\n            Vert0.Pos.x = float(w - GridW\/2);\n            Vert0.Pos.y = float(h - GridH\/2);\n            float wf = -2.0 + float(w);\n            float hf = -3.0 + float(h);\n            float d = sqrt(wf*wf + hf*hf);\n            Vert0.Pos.z = 0.3 * cos (d * 0.8 + wobble) - 1.0;\n            Vert0.Pos.w = 1.0f;\n            Vert0.Uvh.x = float(w) \/ float(GridW-1);\n            Vert0.Uvh.y = float(h) \/ float(GridH-1);\n            Vert0.Uvh.z = 0.0;\n            \n            Vert1.Pos = Vert0.Pos;\n            Vert1.Pos.z += 1.0;\n            Vert1.Uvh = Vert0.Uvh;\n            Vert1.Uvh.z = 1.0;\n            \n            int Index = (w*GridH+h)*2;\n            Verts[Index+0] = Vert0;\n            Verts[Index+1] = Vert1;\n        }\n    }\n\n    int Indices0[NumTris];\n    int Indices1[NumTris];\n    int Indices2[NumTris];\n    for ( int w = 0; w < GridW-1; w++ )\n    {\n        for ( int h = 0; h < GridH-1; h++ )\n        {\n            int VertIndex = (w*GridH+h)*2;\n            int TriIndex = (w + (GridH-1)*h) * 2 * 2;\n            Indices0[TriIndex+0] = VertIndex  ;\n            Indices1[TriIndex+0] = VertIndex  +GridH*2;\n\t\t\tIndices2[TriIndex+0] = VertIndex  +2;\n            Indices0[TriIndex+1] = VertIndex+1;\n            Indices2[TriIndex+1] = VertIndex+1+GridH*2;\n\t\t\tIndices1[TriIndex+1] = VertIndex+1+2;\n            \n            Indices2[TriIndex+2] = VertIndex  +GridH*2;\n            Indices0[TriIndex+2] = VertIndex  +GridH*2+2;\n\t\t\tIndices1[TriIndex+2] = VertIndex  +2;\n            Indices1[TriIndex+3] = VertIndex+1+GridH*2;\n            Indices0[TriIndex+3] = VertIndex+1+GridH*2+2;\n\t\t\tIndices2[TriIndex+3] = VertIndex+1+2;\n        }\n    }\n    \/\/ Now do the edges.\n    int CurTri  = (GridH-1)*(GridW-1)*2*2;\n    for ( int w = 0; w < GridW-1; w++ )\n    {\n        int VertIndex = (w*GridH)*2;\n        Indices0[CurTri+0] = VertIndex;\n        Indices1[CurTri+0] = VertIndex+1;\n\t\tIndices2[CurTri+0] = VertIndex+GridH*2;\n        Indices0[CurTri+1] = VertIndex+1;\n        Indices1[CurTri+1] = VertIndex+GridH*2;\n\t\tIndices2[CurTri+1] = VertIndex+GridH*2+1;\n\n        VertIndex = (w*GridH+GridH-1)*2;\n        Indices0[CurTri+2] = VertIndex;\n        Indices1[CurTri+2] = VertIndex+1;\n\t\tIndices2[CurTri+2] = VertIndex+GridH*2;\n        Indices0[CurTri+3] = VertIndex+1;\n        Indices1[CurTri+3] = VertIndex+GridH*2;\n\t\tIndices2[CurTri+3] = VertIndex+GridH*2+1;\n        \n        CurTri += 4;\n    }\n    for ( int h = 0; h < GridH-1; h++ )\n    {\n        int VertIndex = (h)*2;\n        Indices0[CurTri+0] = VertIndex;\n        Indices1[CurTri+0] = VertIndex+1;\n\t\tIndices2[CurTri+0] = VertIndex+2;\n        Indices0[CurTri+1] = VertIndex+1;\n        Indices1[CurTri+1] = VertIndex+2;\n\t\tIndices2[CurTri+1] = VertIndex+2+1;\n\n        VertIndex = (h+GridH*(GridW-1))*2;\n        Indices0[CurTri+2] = VertIndex;\n        Indices1[CurTri+2] = VertIndex+1;\n\t\tIndices2[CurTri+2] = VertIndex+2;\n        Indices0[CurTri+3] = VertIndex+1;\n        Indices1[CurTri+3] = VertIndex+2;\n\t\tIndices2[CurTri+3] = VertIndex+2+1;\n        \n        CurTri += 4;\n    }\n   \n    \n    float hfov = 0.6;\n    float vfov = hfov * iResolution.y \/ iResolution.x;\n    float zfar = 10.0f;\n    float znear = 1.0f;\n    float q = zfar\/(zfar-znear);\n    \n    mat4 ProjMat;\n    ProjMat[0] = vec4 ( 1.0\/hfov, 0.0f, 0.0f, 0.5f );\n    ProjMat[1] = vec4 ( 0.0f, 1.0\/vfov, 0.0f, 0.5f );\n    ProjMat[2] = vec4 ( 0.0f, 0.0f, q, 1.0f );\n    ProjMat[3] = vec4 ( 0.0f, 0.0f, -q*znear, 0.0f );\n    \n    \n    mat4 TotalMat;\n    mat4 ObjMat1;\n    mat4 ObjMat2;\n    \n    \/\/ Mouse -> eye\n    float a1 = iMouse.x * 0.01 + 3.0;\n    float a2 = iMouse.y * 0.01 + 2.8;\n    float zdist = 4.0;\n    \n    ObjMat1[0] = vec4 ( cos(a1),  sin(a1), 0.0, -0.8 );\n    ObjMat1[1] = vec4 ( sin(a1), -cos(a1), 0.0, 0.8 );\n    ObjMat1[2] = vec4 ( 0.0,          0.0, 1.0, 0.0 );\n    ObjMat1[3] = vec4 ( 0.0,          0.0, 0.0, 1.0 );\n    ObjMat2[0] = vec4 ( 1.0, 0.0,          0.0, 0.0 );\n    ObjMat2[1] = vec4 ( 0.0, cos(a2),  sin(a2), 0.0 );\n    ObjMat2[2] = vec4 ( 0.0, sin(a2), -cos(a2), zdist );\n    ObjMat2[3] = vec4 ( 0.0, 0.0,          0.0, 1.0 );\n    \n    TotalMat = ObjMat1 * ObjMat2;\n    TotalMat = TotalMat * ProjMat;\n\n    \/\/ Background colour\n    vec3 col;\n    \/\/col.xy = uv.xy;\n    col.x = 0.7;\n    col.y = 0.7;\n    col.z = 0.7;\n\n    Vertex ScreenVert[NumVerts];\n    for ( int VertNum = 0; VertNum < NumVerts; VertNum++ )\n    {\n        vec4 Pos = Verts[VertNum].Pos;\n        \n        vec4 ScrPos = Pos * TotalMat;\n        float rw = 1.0\/ScrPos.w;\n        ScrPos.x *= rw;\n        ScrPos.y *= rw;\n        ScrPos.z *= rw;\n        \n        ScreenVert[VertNum].Pos = ScrPos;\n        ScreenVert[VertNum].Uvh = Verts[VertNum].Uvh;\n    }\n    \n    float NearestZ = 10000000.0f;\n    float FarthestZ = -10000000.0f;\n    vec3 NearUvh;\n    vec3 FarUvh;\n    \n    for ( int TriNum = 0; TriNum < NumTris; TriNum++ )\n    {\n        Vertex v1 = ScreenVert[Indices0[TriNum]];\n        Vertex v2 = ScreenVert[Indices1[TriNum]];\n        Vertex v3 = ScreenVert[Indices2[TriNum]];\n        vec3 bary;\n        bary.xy = BaryTri3D ( uv, v1, v2, v3 );\n        bary.z = 1.0 - bary.x - bary.y;\n\n        vec3 uvh = bary.z * v1.Uvh + bary.x * v2.Uvh + bary.y * v3.Uvh;\n        \n        if ( ( bary.x >= 0.0 ) &&\n             ( bary.y >= 0.0 ) &&\n             ( bary.z >= 0.0 ) &&\n             ( uvh.x + uvh.y + uvh.z > -1000.0 ) ) \/\/ see above\n        {\n            \/\/ Interpolate Z\n            \/\/ Note this is linear Z, not the strange Z that most rasteriser use\n            \/\/ In this case, that's fine.\n            float Z = bary.z * v1.Pos.z + bary.x * v2.Pos.z + bary.y * v3.Pos.z;\n            if ( NearestZ >= Z )\n            {\n                NearestZ = Z;\n                NearUvh = uvh;\n                \n                if ( Phase == 1 )\n                {\n                    \/\/ Wireframe!\n                    float maxbary = min ( bary.x, min ( bary.y, bary.z ) );\n                    maxbary = maxbary * 100.0;\n                    if ( maxbary < 1.0 )\n                    {\n                        col.x = 1.0 - maxbary;\n                    }\n                }  \n            }\n            \n            if ( FarthestZ <= Z )\n            {\n                FarthestZ = Z;\n                FarUvh = uvh;\n            }\n            \n        }        \n    }\n    \n    if ( NearestZ < FarthestZ )\n    {\n        if ( Phase == 0 )\n        {\n            \/\/ Now \"trace\" from NearUV to FarUV and\n            \/\/ see where it intersects the heightfield.\n            \/\/ Ideally the heightfield would store an SDF rather than a simple height,\n            \/\/ so you could step through it quickly, but I don't have that, so this is\n            \/\/ just a brute-force step, although it is at leats proportional to the\n            \/\/ number of texels to traverse.\n            float Dist = length(NearUvh.xy - FarUvh.xy);\n            int NumSteps = int(Dist*64.0+5.0); \/\/ texture size?\n            vec3 LastUvh = NearUvh;\n            float LastTexH = NearUvh.z;\n            for ( int StepNum = 0; StepNum <= NumSteps; StepNum++ )\n            {\n                float Lerp = float(StepNum)\/float(NumSteps);\n                vec3 uvh = NearUvh + (FarUvh-NearUvh)*Lerp;\n                float height = 1.0 - texture ( iChannel0, uvh.xy ).x;\n                if ( uvh.z >= height )\n                {\n                    \/\/ We crossed from one side to the other,\n                    \/\/ so interpolate to the intersection.\n                    float h0 = LastUvh.z - LastTexH;\n                    float h1 = uvh.z - height;\n                    float ThisLerp = h0 \/ (h0-h1);\n                    vec3 uvh2 = LastUvh + (uvh-LastUvh)*ThisLerp;\n                    vec4 tex2 = texture ( iChannel0, uvh2.xy ).xxxx * texture ( iChannel1, uvh2.xy );\n                    col.xyz = tex2.xyz;\n                    break;\n                }\n                else\n                {\n                    LastUvh = uvh;\n                    LastTexH = height;\n                }\n            }\n        }\n        else if ( Phase == 1 )\n        {\n            \/\/col.xyz = NearUvh.xyz;\n        }\n        else if ( Phase == 2 )\n        {\n            col.xyz = texture ( iChannel0, NearUvh.xy ).xxx;\n        }\n    }\n    \n    \/\/ Output to screen\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}}