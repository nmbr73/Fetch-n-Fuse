{"Shader":{"ver":"0.1","info":{"id":"sdcBWs","date":"1657865248","viewed":167,"name":"Boiling Mercury Hourglass 3D","username":"fenix","description":"* Ray marching inspired by Liquid in Glass by tmst https:\/\/www.shadertoy.com\/view\/3tfcRS\n* Click the center to drag the hourglass\n* Click not-the-center to tilt the hourglass\n* Honestly it's not really supposed to be boiling but I am a n00b.","likes":9,"published":3,"flags":48,"usePreview":0,"tags":["3d","simulation","sdf","particles","sph","fluiddynamics"],"hasliked":0},"renderpass":[{"inputs":[{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":258,"src":"\/media\/previz\/buffer01.png","ctype":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":259,"src":"\/media\/previz\/buffer02.png","ctype":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":37,"channel":0}],"code":"\/\/ ---------------------------------------------------------------------------------------\n\/\/\tCreated by fenix in 2022\n\/\/\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\/\/\n\/\/  3D smoothed particle hydrodynamics, or at least a \n\/\/\n\/\/  Particles are attenuated by 2D distance to line segment for motion blur.\n\/\/ \n\/\/  Buffer A computes the particle positions and a 3D voronoi\n\/\/  Buffer B performs a traditional 2D voronoi\n\/\/  Buffer C renders and maitains persistent state\n\/\/\n\/\/ ---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel2, fragCoord\/iResolution.xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PARTICLE_DEBUG_RENDER_SIZE = 0.03;\nconst float PARTICLE_VORONOI_CULL_DIST = 0.3;\nconst float PARTICLE_SDF_CULL_DIST = 0.06;\nconst int MAX_PARTICLES = 1000;\nconst vec3 GRAVITY = vec3(-0.00, -0.15, -0.1);\nconst float DENSITY_SMOOTH_SIZE = 0.5;\nconst float PARTICLE_REPEL_SIZE = 0.1;\nconst float PARTICLE_COLLISION_SIZE = 0.2;\nconst float PARTICLE_MASS = 1.0;\nconst float PARTICLE_STIFFNESS = 1.0;\nconst float IDEAL_DENSITY = 30.0;\nconst float PARTICLE_VISCOSITY = 3.5;\nconst float PARTICLE_REPEL = 0.8;\n\n\/\/ ===============================\n\/\/ Generic Helpers\/Constants\n\/\/ ===============================\n\n#define PI 3.141592653589793\n#define TWOPI 6.283185307179586\n#define HALFPI 1.570796326794896\n#define SQRT2INV 0.7071067811865475\n\n#define POLAR(theta) vec3(cos(theta), 0.0, sin(theta))\n#define SPHERICAL(theta, phi) (sin(phi)*POLAR(theta) + vec3(0.0, cos(phi), 0.0))\n\n\/\/ Same as built-in 'refract' (cf. link) but replaces the case which would\n\/\/ normally result in 0 with a reflection (for total internal reflection)\n\/\/ https:\/\/www.khronos.org\/registry\/OpenGL-Refpages\/gl4\/html\/refract.xhtml\nvec3 refractFix(vec3 I, vec3 N, float eta) {\n    float k = 1.0 - eta * eta * (1.0 - dot(N, I) * dot(N, I));\n    return k < 0.0\n        ? reflect(I, N) \/\/ <- 'refract' returns 0 here\n    \t: eta * I - (eta * dot(N, I) + sqrt(k)) * N;\n}\n\nvec4 blendOnto(vec4 cFront, vec4 cBehind) {\n    return cFront + (1.0 - cFront.a)*cBehind;\n}\n\nvec4 blendOnto(vec4 cFront, vec3 cBehind) {\n    return cFront + (1.0 - cFront.a)*vec4(cBehind, 1.0);\n}\n\nfloat length2(vec2 v)\n{\n    return dot(v, v);\n}\n\nfloat length2(vec3 v)\n{\n    return dot(v, v);\n}\n\n\/\/ ===============================\n\/\/ Quaternion helpers\n\/\/ (Unit quaternions: w+xi+yj+zk)\n\/\/ ===============================\n\n#define QID vec4(0.0, 0.0, 0.0, 1.0)\n\nvec4 slerp(vec4 a, vec4 b, float t) {\n    float d = dot(a, b);\n    vec4 a2 = a;\n\n    if (d < 0.0) {\n        d = -d;\n        a2 = -a;\n    }\n    if (d > 0.999) {\n        return normalize(mix(a2, b, t));\n    }\n\n    float theta = acos(d);\n    return (sin((1.-t)*theta)*a2 + sin(t*theta)*b) \/ sin(theta);\n}\n\nvec4 qMul(vec4 a, vec4 b) {\n    return vec4(\n        a.w*b.x + a.x*b.w + a.y*b.z - a.z*b.y,\n        a.w*b.y - a.x*b.z + a.y*b.w + a.z*b.x,\n        a.w*b.z + a.x*b.y - a.y*b.x + a.z*b.w,\n        a.w*b.w - a.x*b.x - a.y*b.y - a.z*b.z\n    );\n}\n\nvec4 qConj(vec4 q) {\n    return vec4(-q.xyz, q.w);\n}\n\nvec4 qRot(vec3 nvAxis, float angle) {\n    return vec4(nvAxis*sin(angle*0.5), cos(angle*0.5));\n}\n\nmat3 qToMat(vec4 q) {\n    float wx = q.w*q.x, wy = q.w*q.y, wz = q.w*q.z;\n    float xx = q.x*q.x, xy = q.x*q.y, xz = q.x*q.z;\n    float yy = q.y*q.y, yz = q.y*q.z, zz = q.z*q.z;\n    return mat3(\n        1. - 2.*(yy + zz),\n             2.*(xy + wz),\n             2.*(xz - wy),\n\n             2.*(xy - wz),\n        1. - 2.*(xx + zz),\n             2.*(yz + wx),\n\n             2.*(xz + wy),\n             2.*(yz - wx),\n        1. - 2.*(xx + yy)\n    );\n}\n\n\/\/ ===============================\n\/\/ Reading\/writing state\n\/\/ ===============================\n\nstruct state {\n    vec3 p; \/\/ Pendulum pivot\n    vec3 q; \/\/ Accelerate p toward this point\n    vec3 v; \/\/ Pendulum \"bob\" (relative to pivot)\n    vec3 L; \/\/ Angular momentum\n    vec4 pr; \/\/ Object rotation (unit quaternion)\n};\n\nstate readStateInternal(int iFrame, sampler2D sampler) {\n    state s = state(\n        vec3(0.0),\n        vec3(0.0),\n        vec3(0.0, -cos(0.25*PI), sin(0.25*PI)),\n        vec3(0.0, 0.5, 0.0),\n        QID\n    );\n    if (iFrame > 0) {\n        s.p = texelFetch(sampler, ivec2(0, 0), 0).xyz;\n        s.q = texelFetch(sampler, ivec2(1, 0), 0).xyz;\n        s.v = texelFetch(sampler, ivec2(2, 0), 0).xyz;\n        s.L = texelFetch(sampler, ivec2(3, 0), 0).xyz;\n        s.pr = texelFetch(sampler, ivec2(4, 0), 0);\n    }\n    return s;\n}\n\n#define readState() readStateInternal(iFrame, iChannel2)\n\nvoid writeState(in state s, in vec2 fragCoord, inout vec4 fragColor) {\n    if (abs(fragCoord.y - 0.0-0.5) < 0.5) {\n        if (abs(fragCoord.x - 0.0-0.5) < 0.5) {\n            fragColor = vec4(s.p, 1.0);\n        } else if (abs(fragCoord.x - 1.0-0.5) < 0.5) {\n            fragColor = vec4(s.q, 1.0);\n        } else if (abs(fragCoord.x - 2.0-0.5) < 0.5) {\n            fragColor = vec4(s.v, 1.0);\n        } else if (abs(fragCoord.x - 3.0-0.5) < 0.5) {\n            fragColor = vec4(s.L, 1.0);\n        } else if (abs(fragCoord.x - 4.0-0.5) < 0.5) {\n            fragColor = s.pr;\n        }\n    }\n}\n\n\/\/ ===============================\n\/\/ Camera setup\n\/\/ ===============================\n\n#define RES iResolution\n#define TAN_HALF_FOVY 0.5773502691896257\n\nvec3 nvCamDirFromClip(vec3 iResolution, vec3 nvFw, vec2 clip) {\n    vec3 nvRt = normalize(cross(nvFw, vec3(0.,1.,0.)));\n    vec3 nvUp = cross(nvRt, nvFw);\n    return normalize(TAN_HALF_FOVY*(clip.x*(RES.x\/RES.y)*nvRt + clip.y*nvUp) + nvFw);\n}\n\nvoid getCameraInternal(in state s, in vec2 uv, in float iTime, in vec3 iResolution, out vec3 camPos, out vec3 nvCamDir) {\n    vec2 mouseAng = vec2(HALFPI*0.75, PI*0.45) + 0.2*vec2(cos(0.5*iTime),sin(0.5*iTime));\n    camPos = vec3(2.0, 1.0, 2.0) + 5.0 * SPHERICAL(mouseAng.x, mouseAng.y);\n\n    vec3 lookTarget = mix(vec3(0.0), s.p, 0.05);\n    vec3 nvCamFw = normalize(lookTarget - camPos);\n\n    nvCamDir = nvCamDirFromClip(iResolution, nvCamFw, uv*2. - 1.);\n}\n\n#define getCamera(X, Y, Z, W) getCameraInternal(X, Y, iTime, iResolution, Z, W)\n\n\/\/ ===============================\n\/\/ Physics, reading\/writing state\n\/\/ ===============================\n\nvoid updateStateInternal(inout state s, in vec4 iMouse, in int iFrame, in float iTime, in vec3 iResolution) {\n\n    \/\/ pr (object rotation unit quaternion) gets \"slerped\" towards qr\n    float tmod = mod(float(iFrame) \/ 120.0, 46.0);\n    \n#if 0 \/\/ Stop auto-flip\n    vec4 qr = QID;\n#else\n    vec4 qr = (\n        tmod < 20.0 ? QID :\n        tmod < 23.0 ? qRot(vec3(-SQRT2INV, 0.0, SQRT2INV), 0.5*PI):\n        tmod < 43.0 ? qRot(vec3( 1.0, 0.0, 0.0), PI):\n        qRot(vec3(-SQRT2INV, 0.0, SQRT2INV), -0.5*PI)\n    );\n#endif\n\n    \/\/ p (object displacement) gets \"lerped\" towards q\n    if (iMouse.z > 0.5) {\n        vec2 uvMouse = iMouse.xy \/ iResolution.xy;\n        vec3 camPos;\n        vec3 nvCamDir;\n        getCamera(s, uvMouse, camPos, nvCamDir);\n\n        float t = -camPos.z\/nvCamDir.z;\n        if (t > 0.0 && t < 50.0) {\n            vec3 center = vec3(0.0);\n            vec3 hit = camPos + t*nvCamDir;\n            float qToCenter = distance(center, s.q);\n            vec3 delta = hit - s.q;\n            if (length2(delta) < 1.0)\n            {\n                s.q = hit;\n            }\n            else\n            {\n                float angle = -atan(delta.x, delta.y);\n                float angle2 = length(delta.xy);\n                qr = qRot(vec3(0.0, 0.0, 1.0), angle);\n                qr = qMul(qr, qRot(vec3(1.0, 0.0, 0.0), angle2));\n            }\n        }\n    }\n\n   \/\/ apply lerp p -> q and slerp pr -> qr\n    vec3 vel = 0.25*(s.q - s.p);\n    s.v = vel;\n    s.p += vel;\n    s.pr = normalize(slerp(s.pr, qr, 0.075));\n\n    \/\/ object acceleration\n    vec3 a = -0.25*(s.q - s.p) + vec3(0.0, -1.0, 0.0);\n    mat3 prMatInv = qToMat(qConj(s.pr));\n    a = prMatInv*a;\n\n    \/\/ hand-wavy torque and angular momentum\n    vec3 T = cross(s.v, a);\n    s.L = 0.96*s.L + 0.2*T;\n}\n\n#define updateState(X) updateStateInternal(X, iMouse, iFrame, iTime, iResolution)\n\n\/\/ ===============================\n\/\/ Geometry definitions\n\/\/ ===============================\n\n#define BOUNDING_SPHERE_RADIUS 4.0\n#define GLASS_THICKNESS 0.1\n\nfloat sdfPlane(vec3 planePoint, vec3 nvPlaneN, vec3 p) {\n    return dot(p - planePoint, nvPlaneN);\n}\n\nfloat sdfInterval(float a, float b, float x) {\n    return abs(x - 0.5*(a+b)) - 0.5*(b-a);\n}\n\n\/\/ From https:\/\/iquilezles.org\/articles\/distfunctions\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)\/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)\/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n    \nfloat sdfContainer(vec3 p, state s) {\n    vec3 d0 = abs(p - s.p - vec3(0.0, 2.09, 0.0));\n    vec3 d1 = abs(p - s.p + vec3(0.0, 2.09, 0.0));\n    float s0 = length(d0) - 1.7;\n    float s1 = length(d1) - 1.7;\n    return opSmoothUnion(s0, s1, 1.5);\n}\n\nfloat sdfGlass(vec3 p, state s) {\n    float etchDepth = 0.0; \/\/ Can sample from e.g. cubemap here for some texture\n    return sdfInterval(0.0, GLASS_THICKNESS - etchDepth, sdfContainer(p, s));\n}\n\n#define SDF_N_EPS 0.005\n#define SDF_NORMAL(sdfFn, p, s) \\\n    normalize(vec3( \\\n        sdfFn( p+vec3(SDF_N_EPS,0.0,0.0), s ) - sdfFn( p-vec3(SDF_N_EPS,0.0,0.0), s ), \\\n        sdfFn( p+vec3(0.0,SDF_N_EPS,0.0), s ) - sdfFn( p-vec3(0.0,SDF_N_EPS,0.0), s ), \\\n        sdfFn( p+vec3(0.0,0.0,SDF_N_EPS), s ) - sdfFn( p-vec3(0.0,0.0,SDF_N_EPS), s )  \\\n    ))\n    \n\/\/returns the ids of the four closest particles from the input\nivec4 fxGetClosestInternal(sampler2D sampler, ivec2 xy)\n{\n    return ivec4(texelFetch(sampler, xy, 0));\n}\n\n#define fxGetClosest(X) fxGetClosestInternal(iChannel1, X)\n\n#define FUL_NEIGHBORS 0\n#define FUR_NEIGHBORS 1\n#define FLL_NEIGHBORS 2\n#define FLR_NEIGHBORS 3\n#define BUL_NEIGHBORS 4\n#define BUR_NEIGHBORS 5\n#define BLL_NEIGHBORS 6\n#define BLR_NEIGHBORS 7\n#define POS 8\n#define VEL 9\n#define NUM_PARTICLE_DATA_TYPES 10\n\n\/\/returns the location of the particle within the particle buffer corresponding with the input id \nivec2 fxLocFromIDInternal(int width, int id, int dataType)\n{\n    int index = id * NUM_PARTICLE_DATA_TYPES + dataType;\n    return ivec2( index % width, index \/ width);\n}\n\n#define fxLocFromID(X, Y) fxLocFromIDInternal(int(iResolution.x), X, Y)\n\nstruct fxParticle\n{\n    vec3 pos;\n    float density;\n    vec3 vel;\n    float pressure;\n    \n    ivec4 neighbors[8];\n};\n\n\/\/get the particle corresponding to the input id\nfxParticle fxGetParticleInternal(sampler2D sampler, int resolutionWidth, int id)\n{\n    vec4 particleData0 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, FUL_NEIGHBORS), 0);\n    vec4 particleData1 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, FUR_NEIGHBORS), 0);\n    vec4 particleData2 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, FLL_NEIGHBORS), 0);\n    vec4 particleData3 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, FLR_NEIGHBORS), 0);\n    vec4 particleData4 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, BUL_NEIGHBORS), 0);\n    vec4 particleData5 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, BUR_NEIGHBORS), 0);\n    vec4 particleData6 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, BLL_NEIGHBORS), 0);\n    vec4 particleData7 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, BLR_NEIGHBORS), 0);\n    vec4 particleData8 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, POS), 0);\n    vec4 particleData9 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, VEL), 0);\n\n    fxParticle particle;\n    particle.pos = particleData8.xyz;\n    particle.density = particleData8.w;\n    particle.vel = particleData9.xyz;\n    particle.pressure = particleData9.w;\n    particle.neighbors[0] = ivec4(particleData0);\n    particle.neighbors[1] = ivec4(particleData1);\n    particle.neighbors[2] = ivec4(particleData2);\n    particle.neighbors[3] = ivec4(particleData3);\n    particle.neighbors[4] = ivec4(particleData4);\n    particle.neighbors[5] = ivec4(particleData5);\n    particle.neighbors[6] = ivec4(particleData6);\n    particle.neighbors[7] = ivec4(particleData7);\n    \n    return particle;\n}\n\n\nvec4 fxSaveParticle(fxParticle p, int dataType)\n{    \n    switch(dataType)\n    {\n    case FUL_NEIGHBORS:\n        return vec4(p.neighbors[0]);\n    case FUR_NEIGHBORS:\n        return vec4(p.neighbors[1]);\n    case FLL_NEIGHBORS:\n        return vec4(p.neighbors[2]);\n    case FLR_NEIGHBORS:\n        return vec4(p.neighbors[3]);\n    case BUL_NEIGHBORS:\n        return vec4(p.neighbors[4]);\n    case BUR_NEIGHBORS:\n        return vec4(p.neighbors[5]);\n    case BLL_NEIGHBORS:\n        return vec4(p.neighbors[6]);\n    case BLR_NEIGHBORS:\n        return vec4(p.neighbors[7]);\n    case POS:  \n        return vec4(p.pos, p.density);\n    case VEL:\n        return vec4(p.vel, p.pressure);\n    }\n}\n\n#define fxGetParticle(X) fxGetParticleInternal(iChannel0, int(iResolution.x), X)\n\nvec4 fxGetParticleDataInternal(sampler2D sampler, int resolutionWidth, int id, int dataType)\n{\n    return texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, dataType), 0);\n}\n\n#define fxGetParticleData(X, Y) fxGetParticleDataInternal(iChannel0, int(iResolution.x), X, Y)\n\nfloat distanceSquared(vec3 a, vec3 b)\n{\n    vec3 delta = a - b;\n    return dot(delta, delta);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash( int k ) {\n    uint n = uint(k);\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\nuvec4 hash(uvec4 x){\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    \/\/x = (x >> 16u) ^ x;\n    return x;\n}\nuvec4 hash(uvec3 x0){\n    uvec4 x = x0.xyzz;\n    x = ((x >> 16u) ^ x.yzxy) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzxz) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzxx) * 0x45d9f3bu;\n    \/\/x = (x >> 16u) ^ x;\n    return x;\n}\n\nvec4 noise(ivec4 p){\n    const float scale = pow(2., -32.);\n    uvec4 h = hash(uvec4(p));\n    return vec4(h)*scale;\n}\n\nvec4 noise(ivec3 p){\n    const float scale = 1.0\/float(0xffffffffU);\n    uvec4 h = hash(uvec3(p));\n    return vec4(h)*scale;\n}\n\nvec4 noise(ivec2 p){\n    return noise(ivec3(p, 0));\n}\n\nfloat SPHKernel (float x)\n{\n    x *= (1.0 \/ DENSITY_SMOOTH_SIZE);\n    if (x < 1.0)\n        return 4.0 * cos(x*PI) + cos((x + x) * PI) + 3.0;\n    else\n        return 0.0;\n}\n\n\nfloat SPHKernel (vec3 deltaPos)\n{\n    float x = length(deltaPos);\n    return SPHKernel(x);\n}\n\nfloat SPHgradKernel (float x)\n{\n    x *= (1.0 \/ PARTICLE_REPEL_SIZE);\n\n    if (x < 4.0)\n    {\n        float xx = x*x;\n        float xxx = xx*x;\n        float xxxx = xxx*x;\n        return PARTICLE_REPEL * (0.000 + 3.333 * x + -3.167 * xx + 0.917 * xxx + -0.083 * xxxx);\n    }\n    else\n        return 0.0;\n}\n\nbool intersectSphere(in vec3 ro, in vec3 rd, in vec3 center, in float radius2, out float t) \n{ \n    float t0, t1;  \/\/solutions for t if the ray intersects \n    \/\/ geometric solution\n    vec3 L = center - ro; \n    float tca = dot(L, rd); \n    \/\/ if (tca < 0) return false;\n    float d2 = dot(L, L) - tca * tca; \n    if (d2 > radius2) return false; \n    float thc = sqrt(radius2 - d2); \n    t0 = tca - thc; \n    t1 = tca + thc; \n\n    if (t0 > t1)\n    {\n        float temp = t0;\n        t0 = t1;\n        t1 = temp;\n    }\n    if (t0 < 0.0) { \n        t0 = t1;  \/\/if t0 is negative, let's use t1 instead \n        if (t0 < 0.0) return false;  \/\/both t0 and t1 are negative \n    } \n\n    t = t0; \n\n    return true; \n} \n\nfloat linePointDist2(in vec3 newPos, in vec3 oldPos, in vec3 point, out vec3 closest)\n{\n    vec3 pDelta = (point - oldPos);\n    vec3 delta = newPos - oldPos;\n    float deltaLen2 = dot(delta, delta);\n\n    \/\/ Find the closest point on the line segment from old to new\n    if (deltaLen2 > 0.0000001)\n    {\n        float deltaInvSqrt = inversesqrt(deltaLen2);\n        vec3 deltaNorm = delta * deltaInvSqrt;\n        closest = oldPos + deltaNorm * max(0.0, min(1.0 \/ deltaInvSqrt, dot(deltaNorm, pDelta)));\n    }\n    else\n    {\n        closest = oldPos;\n    }\n\n    \/\/ Distance to closest point on line segment\n    vec3 closestDelta = closest - point;\n    return dot(closestDelta, closestDelta);\n}\n\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\nvoid insertion_sort(inout ivec4 i, inout vec4 d, int i_, float d_){\t\n    if(any(equal(ivec4(i_),i))) return;\n    if     (d_ < d[0])             \n        i = ivec4(i_,i.xyz),    d = vec4(d_,d.xyz);\n    else if(d_ < d[1])             \n        i = ivec4(i.x,i_,i.yz), d = vec4(d.x,d_,d.yz);\n    else if(d_ < d[2])            \n        i = ivec4(i.xy,i_,i.z), d = vec4(d.xy,d_,d.z);\n    else if(d_ < d[3])           \n        i = ivec4(i.xyz,i_),    d = vec4(d.xyz,d_);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":33,"src":"\/presets\/tex00.jpg","ctype":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":259,"src":"\/media\/previz\/buffer02.png","ctype":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":257,"channel":0}],"code":"\/\/ ---------------------------------------------------------------------------------------\n\/\/ Computes the position of each particle, one per texture fragment.\n\/\/ ---------------------------------------------------------------------------------------\n\nvoid sort0(inout ivec4 bestIds, inout vec4 bestDists, int id, int searchId, int dataType, in vec3 myPos);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 iFragCoord = ivec2(fragCoord);\n    state s = readState();\n    mat3 prMatInv = qToMat(qConj(s.pr));\n    mat3 prMat = inverse(prMatInv);\n\n    \/\/we only simulate PARTICLES amount of particles\n    int index = iFragCoord.x + iFragCoord.y*int(iResolution.x);\n    int id = index \/ NUM_PARTICLE_DATA_TYPES;\n    int dataType = index - id * NUM_PARTICLE_DATA_TYPES;\n    if (id >= MAX_PARTICLES) return;\n    \n    fxParticle data = fxGetParticle(id);\n    \n    if (dataType == POS || dataType == VEL)\n    {\n        if (iFrame == 0 || data.pos != data.pos || keyDown(32))\n        {\n            const vec3 INIT_CENTER = vec3(0.0, 2.0, 0.0);\n            const vec3 INIT_EXTENTS = vec3(2.0, 2.0, 2.0);\n            vec3 initPos = (noise(ivec4(int(fragCoord.x) \/ 2, fragCoord.y, int(fragCoord.x) \/ 2 + 2, fragCoord.y + 2.0)).xyz - 0.5) * INIT_EXTENTS + INIT_CENTER;\n\n            data.pos = prMat*initPos + s.p;\n            data.vel = vec3(0.0, 0.0, 0.0);\n        }\n        else\n        {\n            float myDensity = PARTICLE_MASS * SPHKernel(vec3(0));\n            float newDensity = SPHKernel(vec3(0));\n            vec3 force = GRAVITY;\n            vec3 densityGrad = vec3(0);\n            \n            vec3 avgVel = data.vel * myDensity;\n\n            \/\/ Compute neighborhood density and density gradient, and init solver particles\n            for(int i = 0; i < 8; i++){\n                ivec4 neighbors = data.neighbors[i];\n                for (int j = 0; j < 4; ++j)\n                {\n                    int cid = neighbors[j];\n                    if(cid==id || cid==-1 || cid == 0 || cid >= MAX_PARTICLES) continue;\n                    \n                    vec4 otherPosDensity = fxGetParticleData(cid, POS);\n                    vec4 otherVelPressure = fxGetParticleData(cid, VEL);\n                    vec3 deltaPos = data.pos - otherPosDensity.xyz;\n                    float dist = length(deltaPos) + 0.001;\n                    vec3 dir = deltaPos \/ dist;\n                                            \n                    float neighborDensity = PARTICLE_MASS * SPHKernel(deltaPos);\n                    newDensity += neighborDensity;\n                    avgVel += otherVelPressure.xyz * neighborDensity;\n                    densityGrad += neighborDensity * deltaPos;\n                    \n                    force -= dir * SPHgradKernel(dist);\n                }\n            }       \n            \n            force += 0.1 * avgVel \/ newDensity - data.vel * 0.3;\n            float overDensity = max(0.0, newDensity - IDEAL_DENSITY);\n            force += overDensity * densityGrad * 0.0001;\n            \n            \/\/ Record misc solver results\n            data.density = newDensity;\n            data.pressure = PARTICLE_STIFFNESS * (newDensity - IDEAL_DENSITY);            \n\n            \/\/ Boundary\n            vec3 objectPoint = prMatInv * (data.pos - s.p) + s.p;\n            float sd = sdfContainer(objectPoint, s);\n\n            if (sd > -PARTICLE_REPEL_SIZE)\n            {\n                data.density += SPHKernel(sd) * 0.2;\n            }\n            if (sd > 0.0)\n            {\n                vec3 normal = SDF_NORMAL(sdfContainer, objectPoint, s);\n                normal = prMat * normal;\n                data.pos = data.pos - (sd) * normal;\n                data.vel += s.v;\n                if(dot(data.vel, normal) > 0.0)\n                {\n                    data.vel = reflect(data.vel, normal);\n                    \/\/data.vel -= normal * dot(data.vel, normal);\n                    data.vel += -0.3 * data.vel;\n                }\n            }\n\n            \/\/ Apply force\n            data.vel = data.vel + force;\n\n            \/\/ Damping\n            data.vel -= data.vel * 0.1;\n            data.vel -= data.vel * length2(data.vel) * 0.1;\n            data.vel -= data.vel * 0.4 * smoothstep(10.0, 40.0, data.density);\n\n            \/\/ Clamping\n            float maxSpeed = 20000.0 \/ (iResolution.x + iResolution.y); \/\/ Dictated by voronoi update speed\n            float velLength2 = length2(data.vel);\n            if (velLength2 > maxSpeed * maxSpeed)\n            {\n                data.vel *= inversesqrt(velLength2) * maxSpeed;\n            }\n\n            \/\/ Integrate position\n            data.pos = data.pos + data.vel \/ myDensity;\n        }\n    }\n    else\n    {\n        \/\/ Nearest particle sort inspired by michael0884's Super SPH: https:\/\/www.shadertoy.com\/view\/tdXBRf\n        \/\/sort neighbors and neighbor neighbors\n        ivec4 nb0 = ivec4(fxGetParticleData(id, dataType));\n        ivec4 bestIds = ivec4(-1);\n        vec4 bestDists = vec4(1e6);\n        \n        for (int i = 0; i < 4; ++i)\n        {\n            sort0(bestIds, bestDists, id, nb0[i], dataType, data.pos);\n        }\n        \n        \/\/random sorts\n        for (int i = 0; i < 16; ++i)\n        {\n            int searchId = int(float(MAX_PARTICLES) * hash13(vec3(iFrame, id, i)));\n            sort0(bestIds, bestDists, id, searchId, dataType, data.pos);\n        }\n        \n        fragColor = vec4(bestIds);\n        \n        return;\n    }\n    \n    fragColor = fxSaveParticle(data, dataType);\n}\n\nbool iscoincidence(in ivec4 bestIds, int currentId, int id)\n{\n    return id <= 0 ||\n      \tid == currentId ||\n        any(equal(bestIds,ivec4(id)));\n}\n\nvoid sort0(inout ivec4 bestIds, inout vec4 bestDists, int currentId, int searchId, int dataType, in vec3 myPos)\n{\n    if (searchId >= MAX_PARTICLES) return; \/\/ particle recycled\n    if(iscoincidence(bestIds, currentId, searchId)) return; \/\/particle already sorted\n    \n    vec3 nbX = fxGetParticleData(searchId, POS).xyz; \n\n    vec3 dx = nbX - myPos;\n    int dir = int((sign(dx.x) * 0.5 + 1.0) + 2.0 * (sign(dx.y) * 0.5 + 1.0) + 4.0 * (sign(dx.z) * 0.5 + 1.0));\n\n    if(dir != dataType) return; \/\/not in this sector\n    \n    float t = length2(dx);\n    \n    \/\/if (t > PARTICLE_REPEL_SIZE * 20.0) return;\n   \n    insertion_sort(bestIds, bestDists, searchId, t);\n}\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":258,"src":"\/media\/previz\/buffer01.png","ctype":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":259,"src":"\/media\/previz\/buffer02.png","ctype":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":258,"channel":0}],"code":"\/\/ Gijs's Basic : Voronoi Tracking: https:\/\/www.shadertoy.com\/view\/WltSz7\n\n\/\/ Voronoi Buffer\n\/\/ every pixel stores the 4 closest particles to it\n\/\/ every frame this data is shared between neighbours\n\nconst float PARTICLE_CULL_DIST_2 = PARTICLE_VORONOI_CULL_DIST * PARTICLE_VORONOI_CULL_DIST;\n\nfloat particleDistance(in int id, in vec3 ro, in vec3 rd)\n{\n    if(id==-1) return 1e6;\n\n    vec3 pos = fxGetParticleData(id, POS).xyz;\n    \n    float t;\n    if (intersectSphere(ro, rd, pos, PARTICLE_CULL_DIST_2, t))\n    {\n        return t;\n    }\n    else\n    {\n        return 1e6;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n   \tivec2 iFragCoord = ivec2(fragCoord);\n    state s = readState();\n\n    vec3 camPos;\n    vec3 nvCamDir;\n    vec2 uv = fragCoord \/ RES.xy;\n    getCamera(s, uv, camPos, nvCamDir);\n    \n    \/\/in this vector the four new closest particles' ids will be stored\n    ivec4 new = ivec4(-1);\n    vec4 dis = vec4(1e6);\n        \n    ivec4 old = fxGetClosest(ivec2(fragCoord));\n    for (int i = 0; i < 4; ++i)\n    {\n        float dis2 = particleDistance(old[i], camPos, nvCamDir);\n        insertion_sort(new, dis, old[i], dis2);\n    }\n    \n    for(int x=-2; x<=2; x++){\n        for(int y=-2; y<=2; y++){\n            ivec4 old   = fxGetClosest( iFragCoord + ivec2( x, y) );      \n\n            for(int j=0; j<4; j++){\n                int id = old[j];\n                float dis2 = particleDistance(id, camPos, nvCamDir);\n                insertion_sort( new, dis, id, dis2 );\n            }\n        }\n    }\n    \n    int searchIterations = 3;\n    if (iFrame < 5)\n    {\n        searchIterations = 100;\n    }\n    for(int k = 0; k < searchIterations; k++){\n        \/\/random hash. We should make sure that two pixels in the same frame never make the same hash!\n        float h = hash(\n            iFragCoord.x + \n            iFragCoord.y*int(iResolution.x) + \n            iFrame*int(iResolution.x*iResolution.y) +\n            k\n        );\n        \/\/pick random id of particle\n        int p = int(h * float(MAX_PARTICLES));\/\/int(h*float(MAX_PARTICLES));\n        insertion_sort(new, dis, p, particleDistance(p, camPos, nvCamDir));\n    }\n    \n    fragColor = vec4(new); \n    \n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":26,"src":"\/media\/a\/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","ctype":"cubemap","channel":3,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":258,"src":"\/media\/previz\/buffer01.png","ctype":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":259,"src":"\/media\/previz\/buffer02.png","ctype":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":259,"channel":0}],"code":"\/\/ Ray marching inspired by Liquid in Glass by tmst https:\/\/www.shadertoy.com\/view\/3tfcRS\n\n\/\/ ===============================\n\/\/ Marching, lighting\/materials\n\/\/ ===============================\n\n#define SDF_EPS 0.01\n#define DSTEP_ADJUST_EPS 0.02\n#define STEPS 80\n\n#define LIGHT_COLOR vec3(1.0)\n\n#define GLASS_COLOR vec3(0.0, 0.0, 0.0)\n#define GLASS_OPACITY 0.6\n\n#define IR_AIR 1.0\n#define IR_GLASS 1.5\n\n\/\/ Increase this few fewer artifacts to give your gfx card a workout\nconst int MAX_CACHED_PARTICLES = 12;\n\n\/\/ Enums\n#define SUBSTANCE_AIR 0\n#define SUBSTANCE_GLASS 1\n\nvec4 computeSpecular(\n    in float specularCoefficient,\n    in float specularExponent,\n    in vec3 nvNormal,\n    in vec3 nvFragToLight,\n    in vec3 nvFragToCam)\n{\n    vec3 blinnH = normalize(nvFragToLight + nvFragToCam);\n    float valSpecular = pow(max(0.0, dot(nvNormal, blinnH)), specularExponent);\n    valSpecular *= specularCoefficient;\n\n    return valSpecular*vec4(LIGHT_COLOR, 1.0);\n}\n\nvec4 cachedParticles[MAX_CACHED_PARTICLES];\nint numCachedParticles = 0;\n\nconst float PARTICLE_CULL_DIST_2 = PARTICLE_SDF_CULL_DIST * PARTICLE_SDF_CULL_DIST;\n\nfloat particleDistance(vec3 pos, in vec3 ro, in vec3 rd)\n{\n    float t;\n    if (intersectSphere(ro, rd, pos, PARTICLE_CULL_DIST_2, t))\n    {\n        return t;\n    }\n    else\n    {\n        return 1e6;\n    }\n}\n\nvoid cacheParticle(vec3 pos, vec3 camPos, vec3 nvCamDir)\n{\n    vec3 closest;\n    float dist2 = particleDistance(pos, camPos, camPos + nvCamDir);\n\n    for (int i = 0; i < numCachedParticles; ++i)\n    {\n        if (length2(cachedParticles[i].xyz - pos) < 0.01)\n        {\n            return;\n        }\n    }\n\n    if (numCachedParticles < MAX_CACHED_PARTICLES)\n    {\n        cachedParticles[numCachedParticles++] = vec4(pos, dist2);\n    }\n    else\n    {\n        for (int i = 0; i < MAX_CACHED_PARTICLES; ++i)\n        {\n            if (cachedParticles[i].w > dist2)\n            {\n                cachedParticles[i] = vec4(pos, dist2);\n                \n                return;\n            }\n        }\n    }\n}\n\nvoid cacheParticlesNearRay(vec2 fragCoord, vec3 camPos, vec3 nvRayDir)\n{\n    numCachedParticles = 0;\n    \n    \/\/ Disable fluid surface\n\/\/return;\n    ivec4 nb0 = fxGetClosest(ivec2(fragCoord));\n    \n    for (int i = 0; i < 4; ++i)\n    {\n        int particleIndex = nb0[i];\n        if (particleIndex == -1) continue;\n        fxParticle p = fxGetParticle(particleIndex);\n\n        cacheParticle(p.pos, camPos, nvRayDir);\n        \n        for (int n = 0; n < 8; ++n)\n        {\n            ivec4 neighborhood = p.neighbors[n];\n            for (int j = 0; j < 2; ++j)\n            {\n                int particleIndex = neighborhood[j];\n                if (particleIndex == -1) continue;\n                vec3 nPos = fxGetParticleData(particleIndex, POS).xyz;\n\n                cacheParticle(nPos, camPos, nvRayDir);\n            }\n        }\n    }\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/smin\/\nfloat smin( float a, float b, float k )\n{\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )\/k;\n}\n\nfloat sdfMercury(vec3 p, state s) {\n    float dglass = sdfContainer(p, s);\n    mat3 prMatInv = qToMat(qConj(s.pr));\n\n    float minDist = 1e20;\n    for (int i = 0; i < numCachedParticles; ++i)\n    {\n        minDist = smin(minDist, distance(p, prMatInv*(cachedParticles[i].xyz - s.p) + s.p) - 0.1, 8.0);\n    }\n\n    return opSubtraction(opSubtraction(minDist, dglass), dglass);\n}\n\nvoid march(in state s, in vec2 fragCoord, in vec3 pRay, in vec3 nvRayIn, out vec4 color, out vec3 nvRayOut)\n{\n    \/\/ Light (in world coordinates)\n    vec3 pLightO = pRay + vec3(0.0, 10.0, 0.0);\n\n    \/\/ Light and camera (in object coordinates)\n    mat3 prMatInv = qToMat(qConj(s.pr));\n    vec3 pCam = prMatInv*(pRay - s.p) + s.p;\n    vec3 pLight = prMatInv*(pLightO - s.p) + s.p;\n\n    \/\/ Ray while marching (in object coordinates)\n    vec3 pCur = pCam;\n    vec3 nvRayCur = prMatInv*nvRayIn;\n\n    cacheParticlesNearRay(fragCoord, pRay, nvRayIn);\n\n    color = vec4(0.0);\n    int curSubstance = SUBSTANCE_AIR;\n\n    int i=0;\n    for (; i<STEPS; i++) {\n\n        \/\/ Quick exits\n        \/\/ ----------------\n        vec3 centerToCur = pCur - s.p;\n        if (\n            (length(centerToCur) > BOUNDING_SPHERE_RADIUS) &&\n            (dot(nvRayCur, centerToCur) > 0.0)\n        ) { break; }\n\n        if (color.a > 0.95) { break; }\n\t\t\/\/ ----------------\n        \n        float sdGlass = sdfGlass(pCur, s);\n        float sdMercury = sdfMercury(pCur, s);\n        vec3 dpStep = abs(min(sdGlass, sdMercury))*nvRayCur;\n\n        vec3 nvGlass = SDF_NORMAL(sdfGlass, pCur, s);\n        vec3 nvMercury = SDF_NORMAL(sdfMercury, pCur, s);\n\n        if (curSubstance == SUBSTANCE_AIR)\n        {\n            if (sdGlass < SDF_EPS && dot(nvGlass,nvRayCur) < 0.0)\n            {\n                curSubstance = SUBSTANCE_GLASS;\n\n                vec4 sColor = computeSpecular(\n                    0.8, 80.0, nvGlass, normalize(pLight-pCur), normalize(pCam-pCur)\n                );\n                color = blendOnto(color, sColor);\n\n                \/\/ Schlick approximation\n                float cosHitAngle = clamp(dot(nvGlass, -nvRayCur), 0.0, 1.0);\n                float r0 = pow((IR_GLASS-IR_AIR)\/(IR_GLASS+IR_AIR), 2.0);\n                float valRefl = mix(r0, 1.0, pow(clamp(1.0 - cosHitAngle, 0.0, 1.0), 3.0)); \/\/ Modified exponent 5 -> 3\n\n                vec3 nvRefl = reflect(nvRayCur, nvGlass);\n                color = blendOnto(color, valRefl*vec4(texture(iChannel3, nvRefl).rgb, 1.0));\n\n                dpStep = sdGlass*nvRayCur;\n                dpStep += -DSTEP_ADJUST_EPS*nvGlass;\n                nvRayCur = refractFix(nvRayCur, nvGlass, IR_AIR\/IR_GLASS);\n            }\n            else if (sdMercury < SDF_EPS && dot(nvMercury, nvRayCur) < 0.0)\n            {\n                vec4 sColor = computeSpecular(\n                    1.0, 40.0, nvMercury, normalize(pLight-pCur), normalize(pCam-pCur)\n                );\n                color = blendOnto(color, sColor);\n\n                nvRayCur = reflect(nvRayCur, nvMercury);\n            }\n        }\n        else if (curSubstance == SUBSTANCE_GLASS)\n        {\n            float sdGlassInv = -sdGlass;\n            vec3 nvGlassInv = -nvGlass;\n\n            dpStep = abs(sdGlassInv)*nvRayCur;\n\n            color = blendOnto(color, clamp(GLASS_OPACITY*sdGlassInv,0.0,1.0)*vec4(GLASS_COLOR, 1.0));\n\n            if (sdGlassInv < SDF_EPS && dot(nvGlassInv,nvRayCur) < 0.0)\n            {\n                curSubstance = SUBSTANCE_AIR;\n\n                dpStep = sdGlassInv*nvRayCur;\n                dpStep += -DSTEP_ADJUST_EPS*nvGlassInv;\n                nvRayCur = refractFix(nvRayCur, nvGlassInv, IR_GLASS\/IR_AIR);\n            }\n\n        } \n        pCur += dpStep;\n    }\n\n    \/\/ Convert ray direction from object to world coordinates\n    nvRayOut = qToMat(s.pr)*nvRayCur;\n}\n\nvoid renderParticle(in vec3 pos, in vec3 camPos, in vec3 nvCamDir, in vec3 color, inout vec4 fragColor)\n{    \n    float t;\n    if (intersectSphere(camPos, nvCamDir, pos, PARTICLE_DEBUG_RENDER_SIZE * PARTICLE_DEBUG_RENDER_SIZE, t))\n    {\n        fragColor.xyz = color;\n    }\n}\n\nvoid renderAllParticles(vec2 fragCoord, vec3 camPos, vec3 nvCamDir, inout vec4 fragColor)\n{\n#if 1 \/\/ Render particles from voronoi buffer\n    ivec4 nb0 = fxGetClosest(ivec2(fragCoord));\n    \n    for (int i = 0; i < 4; ++i)\n    {\n        int particleIndex = nb0[i];\n        if (particleIndex == -1) continue;\n        vec4 pos = fxGetParticleData(particleIndex, POS);\n        \n        vec3 color = vec3(pos.w * pos.w * 0.001, 0.8, 0.0);\n        renderParticle(pos.xyz, camPos, nvCamDir, color, fragColor);\n    }\n#else \/\/ Render all particles (slow)\n    for (int particleIndex = 0; particleIndex < MAX_PARTICLES; ++particleIndex)\n    {\n        vec4 pos = fxGetParticleData(particleIndex, POS);\n        \n        vec3 color = vec3(pos.w * pos.w * 0.001, 0.8, 0.0);\n        renderParticle(pos.xyz, camPos, nvCamDir, color, fragColor);\n    }\n#endif\n}\n\n\/\/ ===============================\n\/\/ Main render\n\/\/ ===============================\n\nvec4 mainColor(vec2 fragCoord, state s) {\n    vec3 camPos;\n    vec3 nvCamDir;\n    vec2 uv = fragCoord \/ RES.xy;\n    getCamera(s, uv, camPos, nvCamDir);\n\n    vec4 color;\n    vec3 nvRayOut;\n    march(s, fragCoord, camPos, nvCamDir, color, nvRayOut);\n    \n    \/\/ Debug draw particles\n    \/\/renderAllParticles(fragCoord, camPos, nvCamDir, color);\n\n    return blendOnto(color, texture(iChannel3, nvRayOut).rgb);\n\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    state s = readState();\n\n    fragColor = mainColor(fragCoord, s);\n\n    updateState(s);\n    writeState(s, fragCoord, fragColor);\n}\n","name":"Buffer C","description":"","type":"buffer"}]}}