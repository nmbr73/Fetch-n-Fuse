{"Shader":{"ver":"0.1","info":{"id":"7dcBDs","date":"1657440555","viewed":173,"name":"basic planet","username":"takahiroando","description":"A planet with land, sea, cloud.  I would be happy if I could make it shorter.","likes":7,"published":3,"flags":0,"usePreview":0,"tags":["noise","planet"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"id":37,"channel":0}],"code":"float hash(vec3 v3) {\n\treturn fract(sin(dot(v3, vec3(12.3, 45.6, 78.9))) * 987654.321);\n}\n\nfloat noise(vec3 v3) {\n\tvec3 i = floor(v3);\n\tvec3 f = fract(v3);\n\tvec3 b = smoothstep(0.0, 1.0, f);\n\tvec2 bin = vec2(0.0, 1.0);\n\treturn 2.0 * mix(\n\t\tmix(\n\t\t\tmix(hash(i + bin.xxx), hash(i + bin.yxx), b.x),\n\t\t\tmix(hash(i + bin.xyx), hash(i + bin.yyx), b.x),\n\t\t\tb.y\n\t\t),\n\t\tmix(\n\t\t\tmix(hash(i + bin.xxy), hash(i + bin.yxy), b.x),\n\t\t\tmix(hash(i + bin.xyy), hash(i + bin.yyy), b.x),\n\t\t\tb.y\n\t\t),\n\t\tb.z\n\t) - 1.0;\n}\n\nvec3 rotate_y(vec3 p, float t) {\n    vec3 a = vec3(0.0, 1.0, 0.0);\n\treturn mix(dot(a, p) * a, p, cos(t)) + cross(a, p) * sin(t);\n}\n\n\nconst float RS = 5.0;\nconst float C = 0.1; \/\/ height of cloud\nconst float RC = RS + C;\nconst float H = 1.0;\n\nfloat fbm_core(vec3 p, float amp, float freq, float mul_amp, float mul_freq) {\n\tfloat h = 0.0;\n\tfor (int i = 0; i < 6; ++i) {\n\t\th += amp * noise(p * freq);\n\t\tamp *= mul_amp;\n\t\tfreq *= mul_freq;\n\t}\n\treturn h;\n}\n\nfloat height(vec3 p) {\n\tif (length(p) > RC) return 0.0;\n\tp = normalize(p) * RS;\n\tp = rotate_y(p, iTime * 0.1);\n\treturn fbm_core(p, 0.8, 0.2, 0.4, 2.7) * H;\n}\n\nfloat d_sea(vec3 p) {\n\treturn length(p) - RS;\n}\n\nfloat d_ground(vec3 p) {\n\treturn length(p) - (max(height(p), 0.0) + RS);\n}\n\nfloat d_sphere(vec3 p, float radius) {\n\treturn length(p) - radius;\n}\n\nvec4 rt_sphere(vec3 p, vec3 rd, float radius) {\n\tfloat hit = 0.0;\n\tfor(int i = 0; i < 100; ++i) {\n\t\tfloat d = d_sphere(p, radius);\n\t\tp += d * rd;\n\t\tif (d < 0.01) {\n\t\t\thit = 1.0;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn vec4(p, hit);\n}\n\nvec3 normal_ground(vec3 p) {\n\tmat3 k = mat3(p, p, p) - mat3(0.001);\n\treturn normalize(d_ground(p) - vec3(d_ground(k[0]), d_ground(k[1]), d_ground(k[2])));\n}\n\nvec3 light_dir() {\n    return normalize(vec3(0.6 * sin(0.1 * iTime), 0.5, 1.0));\n}\n\nvec3 shade_star(vec3 p, vec3 rd) {\n\tfloat h = height(p);\n\tvec3 snow = vec3(1.0);\n\tvec3 sand = vec3(0.7, 0.66, 0.53);\n\tvec3 grass = vec3(0.1, 0.7, 0.3);\n\tfloat snow_r = exp(-abs(h - 0.5 * H) * 20.0);\n\tfloat sand_r = exp(-abs(h - 0.25 * H) * 20.0);\n\tfloat grass_r = exp(-abs(h) * 20.0);\n\tfloat sum_r = snow_r + sand_r + grass_r;\n\tvec3 dif_mat = (snow * snow_r + sand * sand_r + grass * grass_r) \/ sum_r;\n\tvec3 ng = normal_ground(p);\n    vec3 L = light_dir();\n\tfloat dif_pow = max(0.0, dot(L, ng));\n\tvec3 ground = vec3(0.1) + dif_mat * dif_pow;\n\n\tvec3 ns = normalize(p);\n\tvec3 rs = reflect(rd, ns);\n\n\tvec3 sea = vec3(0.1, 0.4, 0.9) * (0.1 * dif_pow - 2.0 * h \/ H + 0.9 * exp(max(dot(L, rs), 0.0))) + 0.1 * sin(h\/H);\n\treturn h < 0.0 ? sea : ground;\n}\n\nfloat cloud(vec3 p) {\n\tp = rotate_y(p, iTime * -0.1);\n\tp += 0.1 * iTime;\n\treturn pow(clamp(abs(fbm_core(p, 1.1, 0.3, 0.5, 2.2)), 0.0, 1.0), 2.0);\n}\n\nfloat cloud_shadow(vec3 p) {\n\tp -= light_dir() * H;\n\treturn 1.0 - cloud(p) * 0.1;\n}\n\nvec3 bg(vec2 uv) {\n\tfloat t = iTime * 0.0001;\n\tvec3 from = vec3(t * 2.0, t, -1.0);\n\tfloat s = 0.1, fade = 1.0;\n\tvec3 v = vec3(0.0);\n\tfor (int r = 0; r < 20; ++r) {\n\t\tvec2 rot_uv = uv * mat2(cos(s), sin(s), -sin(s), cos(s));\n\t\tvec3 p = vec3(rot_uv, -s) * 0.25 + from;\n\t\tfloat repeat = 2.0;\n\t\tp = mod(p + 0.5 * repeat, repeat) - 0.5 * repeat;\n\t\tp *= 10.0;\n\t\tfloat pa = 0.0, a = 0.0;\n\t\tfor (int i = 0; i < 17; ++i) {\n\t\t\tp = abs(p) \/ dot(p, p) - 0.53;\n\t\t\ta += abs(length(p) - pa);\n\t\t\tpa = length(p);\n\t\t}\n\t\ta *= a * a;\n\t\tv += vec3(s, s*s, s*s*s*s) * a * 0.0015 * fade;\n\t\tfade *= 0.75;\n\t\ts += 0.1;\n\t}\n\treturn v * 0.005;\n}\n\nvec3 render_base(vec2 uv, vec3 p, vec3 rd) {\n\tvec4 rt = rt_sphere(p, rd, RS);\n\tif (rt.w > 0.0) {\n\t\treturn shade_star(rt.xyz, rd) * cloud_shadow(rt.xyz);\n\t} else {\n\t\tvec3 sky_base_color = vec3(0.1, 0.4, 0.8);\n\t\tfloat sky_mix = smoothstep(RS, RS + 10.0 * C, length(rd.xy * 10.0));\n\t\treturn mix(sky_base_color, bg(uv), sky_mix);\n\t}\n}\n\nvec3 render(vec2 uv, vec3 p, vec3 rd) {\n\tvec4 rt = rt_sphere(p, rd, RC);\n\tfloat ccol = rt.w > 0.0 ? cloud(rt.xyz) : 0.0;\n\treturn mix(render_base(uv, p, rd), vec3(1.0), ccol);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tvec2 uv = (2.0 * fragCoord - iResolution.xy) \/ min(iResolution.x, iResolution.y);\n\tvec3 p = vec3(0.0, 0.0, 10.0);\n\tvec3 rd = normalize(vec3(uv, -1.));\n\n\n\tfragColor = vec4( render(uv, p, rd), 1.0 );\n\n}","name":"Image","description":"","type":"image"}]}}