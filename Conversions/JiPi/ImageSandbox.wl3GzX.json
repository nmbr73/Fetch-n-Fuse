{"Shader":{"ver":"0.1","info":{"id":"wl3GzX","date":"1577643531","viewed":495,"name":"Image Sandbox","username":"athlete","description":"Each pixel represented by a SDF box - inspired by LAS+ light installation at Kraftwerk, Berlin, 2019.","likes":13,"published":3,"flags":32,"usePreview":0,"tags":["sdf","domainrepetition","heightmap","mouseinput","las"],"hasliked":0},"renderpass":[{"inputs":[{"id":6,"src":"\/media\/a\/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":37,"channel":0}],"code":"#define BOXDEPTH 2.0\n#define MAXBOXHEIGHT 3.5\n#define PLANEDIST 5.0\n#define BOXX 16.5\n#define BOXY 9.\n#define SHADOWPASSES 128\n#define NUMBOXESX iResolution.x\/5.\n#define NUMBOXESY iResolution.y\/5.\n\/\/#define NUMBOXESX 20.0\n\/\/#define NUMBOXESY 10.0\n#define pixSizeX BOXX\/NUMBOXESX\n#define pixSizeY BOXY\/NUMBOXESY\n\nfloat vmax(vec3 v)\n{\n\treturn max(max(v.x, v.y), v.z);\n}\n\n\/\/ Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b)\n{\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n\/\/ Plane with normal n (n is normalized) at some distance from the origin\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin)\n{\n\treturn dot(p, n) + distanceFromOrigin;\n}\n\n\/\/ Repeat in two dimensions\nvec2 pMod2(inout vec2 p, vec2 size)\n{\n    vec2 c = floor((p + size*0.5)\/size);\n    p = mod(p + size*0.5,size) - size*0.5;\n    return c;\n}\n\nfloat mapImage(vec3 p)\n{\n    p.x += BOXX - pixSizeX;\n    p.y += BOXY + pixSizeY;\n    p.z += PLANEDIST + 2.*BOXDEPTH;\n    \n    \/\/limit the domain repitition to just the inner box. \n    \/\/this is done so that the sand can be higher than the box\n    \/\/without showing up outside the box\n    if(p.x < - pixSizeX || p.y < pixSizeY || p.x > 2.*BOXX -pixSizeX || p.y > 2.*BOXY + pixSizeY)\n        return 1.0;\n    \n    vec2 cell = pMod2(p.xy, vec2(pixSizeX*2., pixSizeY*2.));    \n    \n    vec2 uv = vec2(cell.x\/NUMBOXESX, cell.y\/NUMBOXESY);\n    vec3 col = texture(iChannel0, uv).rgb;\n    \n    float retVal = fBox(p, vec3(pixSizeX, pixSizeY, BOXDEPTH + col.r*MAXBOXHEIGHT));\n    \n    return retVal;\n}\n\nvec2 map(in vec3 pos)\n{    \n    float plane = fPlane(pos, vec3(.0, .0, 1.0), PLANEDIST);\n    float box = fBox(pos, vec3(BOXX, BOXY, PLANEDIST + 2.*BOXDEPTH));\n    \n    vec2 staticScene = vec2(max(plane, -box), -0.5);\n    \n    vec2 imageTerrain = vec2(mapImage(pos), 0.5);\n    \n    return vec2(min(staticScene.x, imageTerrain.x),\n                staticScene.x < imageTerrain.x ? staticScene.y : imageTerrain.y);\n}\n\n\/\/calc gradient by looking at the local neighborhood\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 nor;\n    \n    vec2 e = vec2(0.01, 0.0);\n    \n    nor.x = map(pos + e.xyy).x - map(pos - e.xyy).x;\n    nor.y = map(pos + e.yxy).x - map(pos - e.yxy).x;\n    nor.z = map(pos + e.yyx).x - map(pos - e.yyx).x;\n    \n    return normalize(nor);\n}\n\nfloat calcShadowAdv( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; \/\/ big, such that y = 0 on the first iteration\n    \n    for( int i=0; i<SHADOWPASSES; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        \n        float y = (i==0) ? 0.0 : h*h\/(2.0*ph);\n        \n        float d = sqrt(h*h-y*y);\n        res = min( res, 10.0*d\/max(0.0,t-y) );\n        ph = h;\n        \n        t += h;\n        \n        if( res<0.0005 || t>tmax ) break;\n        \n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nmat3 rotationXY( vec2 angle )\n{\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x);\n}\n\nvec2 rayMarch(in vec3 ro, in vec3 rd, float tmax)\n{\n\t\/\/marching\n    float t = 0.01;\/\/progress along the ray\n    \n    float objectID = 0.0;\n    \n    for(int i=0; i<256; i++)\n    {\n    \tvec3 pos = ro + rd*t;\n        \n        vec2 h = map(pos); \/\/returns positive or negative value\n        \n        if(h.x<0.0005 || t>tmax) \/\/clipping planes\n            break;\n        \n        \/\/t += h.x; \/\/variable distance to object, faster but less accurate than using constant step width\n        t += max(h.x*0.05, t * 0.0001); \/\/less artifacts than the above method\n        \n        objectID = h.y;\n    }\n    \n    return vec2(t, objectID);\n}\n\nvec3 render(in vec3 ro, in vec3 rd, in vec3 initCol)\n{\n    vec3 col = initCol;\n    \n\t\/\/marching\n    float tmax = 25.0;\n    vec2 t = rayMarch(ro, rd, tmax);\n   \n    \/\/if we are inside the view frustum to render\n    if(t.x<tmax)\n    {\n        \/\/define light\n        vec3 light = normalize(vec3(0.5, 5., 10.0)); \/\/light direction\n\n        \/\/move light source with the mouse\n        {\n        vec2 xy = (iMouse.xy - iResolution.xy * 0.5)\/iResolution.xy;\n        mat3 rot = rotationXY(vec2(xy.y, -xy.x) );\n        light = rot * light;\n        }\n        \n        vec3 pos = ro + rd*t.x;\n        vec3 nor = calcNormal(pos);\n        \n        \/\/ray march soft shadows\n        float sha = calcShadowAdv(pos, light, 0.5, 5.0);\n        \n        vec3 materialCol = vec3(0.80, 0.67, 0.53); \/\/sand\n        if(t.y < 0.0)\n        {\n            if(nor.y > .0)\n        \t\tmaterialCol = texture(iChannel1, pos.xz*0.2).rgb*0.3; \/\/box frame inner top\/bottom\n            else if(nor.z > .0)\n            \tmaterialCol = texture(iChannel1, pos.xy*0.2).rgb*0.3;  \/\/box frame top\n            else\n                materialCol = texture(iChannel1, pos.yz*0.2).rgb*0.3;  \/\/box frame inner left\/right\n        }\n        \n        vec3 lightColor = vec3(0.9, 0.9, 0.9);\n            \n        \/\/lighting:\n        float dif = clamp( dot( nor, light ), 0.0, 1.0 );\n        vec3 lig = lightColor* dif * sha;\n        \/\/adding light\n        \tlig += vec3(0.8, 0.8, 0.8)*nor.y*1.5; \/\/base illumination\n        \n        vec3 material = materialCol;\n        material = mix(material, lightColor\/2.0, smoothstep(0.7, 0.9, (nor.y+nor.x+nor.z)\/3.));\n\t\t\n        col = lig * material;\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \tvec2 p = fragCoord.xy \/ iResolution.xy;\n    vec2 q = -1.0 + 2.0*p; \/\/move origin to center of screen\n    q.x *= 1.777; \/\/make square pixels\n    \n    \/\/ray\n    vec3 ro = vec3(.0, .0, 5.0); \/\/camera origin\n    vec3 rd = normalize( vec3(q, -1.0) ); \/\/camera view direction\n    \n    \/\/mat3 rot = rotationXY( ( iMouse.xy - iResolution.xy * 0.5 ).yx * vec2( 0.01, -0.01 ) );\n\t\/\/ro = rot * ro;\n    \/\/rd = rot * rd;\n        \n    \/\/init color.. 'sky'\n    vec3 sky = vec3(0.0, 0.0, 0.0);\n    \n    \/\/the magic happens here!\n    vec3 col = render(ro, rd, sky);\n    \n    \/\/moving color space in preparation for lighting .. gamma\n    col = sqrt(col);\n    \n\tfragColor = vec4(col,1.0);  \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":12,"src":"\/media\/a\/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","ctype":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":257,"channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    vec2 uv = fragCoord.xy \/ iResolution.xy;\n\n   \tfragColor = texture(iChannel0,uv)\/BLURAMOUNT + (BLURAMOUNT-1.)*texture(iChannel1,uv)\/BLURAMOUNT;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\/\/minimum amount is 1.0\n#define BLURAMOUNT 30.0","name":"Common","description":"","type":"common"}]}}