{
 "ver": "0.1",
 "info": {
  "id": "7lGXRD",
  "date": "0",
  "viewed": 0,
  "name": "Fork Chain Thin JiPi 644",
  "description": "Click and drag with the mouse.",
  "likes": 0,
  "published": "Private",
  "usePreview": 0,
  "tags": [
   "string",
   "path",
   "following"
  ],
  "hasliked": 0,
  "parentid": "Nl3XWX",
  "parentname": "Chain Thing"
 },
 "renderpass": [
  {
   "inputs": [
    {
     "id": "4dXGR8",
     "filepath": "/media/previz/buffer00.png",
     "type": "buffer",
     "channel": 0,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    }
   ],
   "outputs": [
    {
     "id": "4dfGRr",
     "channel": 0
    }
   ],
   "code": "float sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\n#define drawSDF(dist, color) fragColor.rgb = mix(fragColor.rgb, color, smoothstep(unit, 0.0, dist))\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 iR = iResolution.xy;\n    \n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float unit = 2.0 / iResolution.y;\n    fragColor = vec4(1.0);\n\n    vec2[JOINTS] joints;\n    for (int n=0; n < JOINTS; n++) {\n        joints[n] = load(ivec2(n, 0)).xy;\n    }\n\n    vec2 prev = joints[0];\n    drawSDF(length(uv - prev) - 0.01, vec3(0.0));\n    for (int n=1; n < JOINTS; n++) {\n        vec2 cur = joints[n];\n        drawSDF(length(uv - joints[n]) - 0.01, vec3(0.0));\n        drawSDF(sdLine(uv, prev, cur) - 0.001, vec3(0.0));\n        prev = cur;\n    }\n}",
   "name": "Image",
   "description": "",
   "type": "image"
  },
  {
   "inputs": [
    {
     "id": "4dXGR8",
     "filepath": "/media/previz/buffer00.png",
     "type": "buffer",
     "channel": 0,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    }
   ],
   "outputs": [
    {
     "id": "4dXGR8",
     "channel": 0
    }
   ],
   "code": "void mainImage(out vec4 state, in vec2 addr) {\n    \n    vec2 iR = iResolution.xy;\n    \n    state = vec4(0.0);\n    ivec2 iAddr = ivec2(addr);\n    if (iFrame == 0) {\n        if (iAddr.x < JOINTS && iAddr.y == 0) {\n            state.x = -addr.x / 50.0;\n            if (iAddr.x == 0) state.z = 0.01;\n        }\n    }\n\n    if (iFrame > 0) {\n        if (iAddr.x < JOINTS && iAddr.y == 0) {\n            vec2 mouse = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y;\n            vec2 corner = vec2(0.5 * iResolution.x / iResolution.y, 0.5) - 0.02;\n\n            vec4[JOINTS] joints;\n            for (int n=0; n < JOINTS; n++) {\n                joints[n] = load(ivec2(n, 0));\n            }\n\n            joints[0].xy += (mouse - joints[0].xy) * 0.1;\n            joints[0] = restrain(joints[0], -corner, corner);\n\n            for (int n=1; n < JOINTS; n++) {\n                //joints[n].zw.y -= GRAVITY * dt;\n                //joints[n].w -= GRAVITY * dt;\n                joints[n].w -= GRAVITY * dt;\n                \n                \n                joints[n].xy += joints[n].zw * dt;\n\n                vec4 next = load(ivec2(iAddr.x - 1, 0));\n                vec2 toNext = joints[n - 1].xy - joints[n].xy;\n\n                vec2 dirToNext = normalize(toNext);\n                vec2 tangent = vec2(-dirToNext.y, dirToNext.x);\n                joints[n].zw = tangent * dot(joints[n].zw, tangent) * JOINT_FRICTION;\n\n                joints[n].xy = joints[n - 1].xy - normalize(toNext) * SPACING;\n                joints[n] = restrain(joints[n], -corner, corner);\n            }\n\n            state = joints[iAddr.x];\n        }\n    }\n}",
   "name": "Buffer A",
   "description": "",
   "type": "buffer"
  },
  {
   "inputs": [],
   "outputs": [],
   "code": "//#define load(frag) texelFetch(iChannel0, frag, 0)\n#define load(frag) texture(iChannel0, (vec2(frag)+0.5)/iR )\n\n#define JOINTS 10\n#define SPACING 0.1\n#define GRAVITY 0.05\n\n#define BOUNDARY_FRICTION 1.0\n#define JOINT_FRICTION 0.85\n\n#define dt 0.2\n\nvec4 restrain(in vec4 p, in vec2 a, in vec2 b) {\n    if (p.x < a.x) {\n        p.x = a.x;\n        if (p.z < 0.0) p.z = -BOUNDARY_FRICTION * p.z;\n    }\n\n    if (p.x > b.x) {\n        p.x = b.x;\n        if (p.z > 0.0) p.z = -BOUNDARY_FRICTION * p.z;\n    }\n\n    if (p.y < a.y) {\n        p.y = a.y;\n        if (p.w < 0.0) p.w = -BOUNDARY_FRICTION * p.w;\n    }\n\n    if (p.y > b.y) {\n        p.y = b.y;\n        if (p.w > 0.0) p.w = -BOUNDARY_FRICTION * p.w;\n    }\n\n    return p;\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat Hash11(in float x) {\n    x = fract(x * 0.1031);\n    x *= x + 33.33;\n    x *= x + x;\n    return fract(x);\n}\n\nfloat snoise(in float x) {\n    return mix(Hash11(floor(x)), Hash11(ceil(x)), smoothstep(0.0, 1.0, fract(x)));\n}\n\nfloat fbm(in float x, in float scale, in int octaves) {\n    x *= scale;\n\n    float value = 0.0;\n    float nscale = 1.0;\n    float tscale = 0.0;\n\n    for (int o=0; o < octaves; o++) {\n        value += snoise(x) * nscale;\n        tscale += nscale;\n        nscale *= 0.5;\n        x *= 2.0;\n    }\n\n    return value / tscale;\n}",
   "name": "Common",
   "description": "",
   "type": "common"
  }
 ]
}