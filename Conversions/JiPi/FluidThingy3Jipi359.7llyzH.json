{
 "ver": "0.1",
 "info": {
  "id": "7llyzH",
  "date": "0",
  "viewed": 0,
  "name": "fluid_thingy_3 JiPi 359",
  "description": "A fluid is feeding a reaction-diffusion wich in turn feed the fluid. \nfluid made using this tutorial : http://wyattflanders.com/MeAndMyNeighborhood.pdf\ncubemap rendering taken from flockaroo at : https://www.shadertoy.com/view/WdVXWy\n",
  "likes": 0,
  "published": "Private",
  "usePreview": 0,
  "tags": [
   "2d",
   "fluid",
   "diffusion",
   "reaction"
  ],
  "hasliked": 0,
  "parentid": "WslfWr",
  "parentname": "fluid_thingy_3"
 },
 "renderpass": [
  {
   "inputs": [
    {
     "id": "XdX3zn",
     "filepath": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg",
     "type": "cubemap",
     "channel": 2,
     "sampler": {
      "filter": "nearest",
      "wrap": "clamp",
      "vflip": "false",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    },
    {
     "id": "4dXGR8",
     "filepath": "/media/previz/buffer00.png",
     "type": "buffer",
     "channel": 1,
     "sampler": {
      "filter": "nearest",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    },
    {
     "id": "XsXGR8",
     "filepath": "/media/previz/buffer01.png",
     "type": "buffer",
     "channel": 0,
     "sampler": {
      "filter": "nearest",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    }
   ],
   "outputs": [
    {
     "id": "4dfGRr",
     "channel": 0
    }
   ],
   "code": "\n/*\n** License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n** Created by bal-khan\n**\n** This is rendering\n** I took rendering from flockaroo at : https://www.shadertoy.com/view/WdVXWy\n*/\n\n#define FANCY_REFLECTIVE   // undef to see the reac-diff in 2 colors only, I like it too\n#define MOTION_SICKNESS 1. // change to 0 to stop mooving the cubemap\n\nvoid mainImage( out vec4 o, in vec2 f )\n{\n    iR = iResolution.xy;\n\n\tvec2 uv = f / R.xy;\n    vec4 ret = texture(iChannel0, uv);\n\t#ifdef FANCY_REFLECTIVE\n    vec2 d  = vec2(1./R.y, .0);\n    vec2 gd = vec2( (A(uv+d.xy)-A(uv-d.xy) ).x , (A(uv+d.yx)-A(uv-d.yx)).x )/R.y;\n    vec3 n  = normalize( vec3(gd*500., 1.) );\n    vec3 rd = normalize( vec3((f-R*.5-MOTION_SICKNESS*vec2( (sin(iTime*.25)+.5)*30.,.0))/R, -.25) );\n    rd = reflect(rd, n);\n    vec3 rf = C(rd.xyz).xyz;\n    //rf = sin(length(rf)*1.+.0*vec3(.0, 1.04, 2.08));\n    ret.xyz = rf*ret.x;\n    #endif \n\to = vec4(ret.xyz, 1.0);\n}",
   "name": "Image",
   "description": "",
   "type": "image"
  },
  {
   "inputs": [
    {
     "id": "4dXGRr",
     "filepath": "/presets/tex00.jpg",
     "type": "keyboard",
     "channel": 2,
     "sampler": {
      "filter": "nearest",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    },
    {
     "id": "4dXGR8",
     "filepath": "/media/previz/buffer00.png",
     "type": "buffer",
     "channel": 1,
     "sampler": {
      "filter": "nearest",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    },
    {
     "id": "XsXGR8",
     "filepath": "/media/previz/buffer01.png",
     "type": "buffer",
     "channel": 0,
     "sampler": {
      "filter": "nearest",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    }
   ],
   "outputs": [
    {
     "id": "XsXGR8",
     "channel": 0
    }
   ],
   "code": "\n/* Linear Filtering Shim by Theron Tarigo, 2019.\n   https://www.shadertoy.com/view/tssXWf\n\n   The following codes may be used and copied freely,\n   with or without attribution.  However, please do not\n   remove the URL, so that others may find the explanation\n   provided here, which may be expanded in future.\n   This is not a legal requirement.\n*/\n\n#define LINEAR_FILTER_CONFIG  true,true,true,true\n//#define LINEAR_FILTER_CONFIG  false,false,false,false\n\nconst struct LINEARFILTER_T {\n  bool iChannel0, iChannel1, iChannel2, iChannel3;\n} LINEARFILTER = LINEARFILTER_T(LINEAR_FILTER_CONFIG);\n\nconst struct SAMPLERINDEX_T {\n  int iChannel0, iChannel1, iChannel2, iChannel3;\n} SAMPLERINDEX = SAMPLERINDEX_T(0,1,2,3);\n\n\n#ifdef ORG\nvec4 textureLinearPix (sampler2D sampler, vec2 U) {\n  return mix(mix(\n      texelFetch(sampler,ivec2(U)+ivec2(0,0),0),\n      texelFetch(sampler,ivec2(U)+ivec2(1,0),0),\n    fract((U).x)),mix(\n      texelFetch(sampler,ivec2(U)+ivec2(0,1),0),\n      texelFetch(sampler,ivec2(U)+ivec2(1,1),0),\n    fract((U).x)),fract((U).y));\n}\n#endif\n\n\nvec4 textureLinearPix (sampler2D sampler, vec2 U) {\n  return mix(mix(\n      texture(sampler,(vec2(ivec2(U)+ivec2(0,0))+0.5)/iR),\n      texture(sampler,(vec2(ivec2(U)+ivec2(1,0))+0.5)/iR),\n    fract((U).x)),mix(\n      texture(sampler,(vec2(ivec2(U)+ivec2(0,1))+0.5)/iR),\n      texture(sampler,(vec2(ivec2(U)+ivec2(1,1))+0.5)/iR),\n    fract((U).x)),fract((U).y));\n}\n\n\n\n#define textureLinear(sampler,P) textureLinearPix(sampler, \\\n    (P)*iChannelResolution[SAMPLERINDEX.sampler].xy-vec2(.5))\n\n#define texture(sampler,P) ( LINEARFILTER.iChannel0 ? \\\n    textureLinear(sampler,P) \\\n  : texture(sampler,P) )\n// End of Linear Filtering Shim\n\n/*\n** This is reaction diffusion\n** Taken from me at : https://www.shadertoy.com/view/XlKXDm\n*/\n\n#define FEED_DEFAULT (.030550 + .0105*bvar*.0  )\n#define KILL_DEFAULT (.0620   + .060205*bvar*.0)\n\nvec2 texsize;\nvec2\tlaplacian_convolution(vec2 uv)\n{\n\tvec2\tret = vec2(0.);\n    \n    if (uv.x == 0. || uv.y == 0. || uv.x== 1. || uv.y ==1.)\n        return (ret);\n    ret += texture(iChannel0, vec2(uv.x , uv.y) ).xy * -1.;\n    \n    ret += texture(iChannel0, vec2(uv.x -texsize.x, uv.y) ).xy * (.2);\n    ret += texture(iChannel0, vec2(uv.x +texsize.x, uv.y) ).xy * (.2);\n    ret += texture(iChannel0, vec2(uv.x , uv.y -texsize.y) ).xy * (.2);\n    ret += texture(iChannel0, vec2(uv.x , uv.y +texsize.y) ).xy * (.2);\n    \n    ret += texture(iChannel0, vec2(uv.x -texsize.x, uv.y -texsize.y) ).xy * (.05);\n    ret += texture(iChannel0, vec2(uv.x +texsize.x, uv.y -texsize.y) ).xy * (.05);\n    ret += texture(iChannel0, vec2(uv.x +texsize.x, uv.y +texsize.y) ).xy * (.05);\n    ret += texture(iChannel0, vec2(uv.x -texsize.x, uv.y +texsize.y) ).xy * (.05);\n    return (ret);\n}\n\nvoid mainImage( out vec4 o, in vec2 f )\n{\n    iR = iResolution.xy;\n\n    vec2 uv = f / R;\n    texsize = 1./R;\n    vec4\tret = texture(iChannel0, uv);\n    float\tbvar = B(uv).w;\n    vec2\tab = ret.xy+vec2(.0, 1.)*bvar*iTimeDelta*1.;\n    vec2\tmouse = iMouse.xy / iResolution.xy;\n    float\tkb = C(vec2(32.5/256., 0.25)).x;\n    if (iMouse.z > .5 && length(f-iMouse.xy) < 50.) \n    {\n\t    o.y = 1.;\n        return;\n\t}\n    if (kb >.5 || abs(iTime) <= .5)\n    {\n        o.x = 1.;\n        o.y = 0.;\n        if (sin(uv.x) <0.5 && sin(uv.y-.4) < .5 && sin(uv.x) > .45 && sin(uv.y-.4) > .45)\n            o = vec4(1., 1., 0., 1.);\n    }\n    else\n    {\n     o.x = clamp(ab.x + (1. * (laplacian_convolution(uv).x) - ab.x * ab.y * ab.y + FEED_DEFAULT * (1. - ab.x) ) ,-1.,1.);\n     o.y = clamp(ab.y + (.5 * (laplacian_convolution(uv).y) + ab.x * ab.y * ab.y - (FEED_DEFAULT + KILL_DEFAULT) * ab.y ),-1.,1.);\n    }\n}\n",
   "name": "Buffer B",
   "description": "",
   "type": "buffer"
  },
  {
   "inputs": [
    {
     "id": "4dXGRr",
     "filepath": "/presets/tex00.jpg",
     "type": "keyboard",
     "channel": 2,
     "sampler": {
      "filter": "nearest",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    },
    {
     "id": "4dXGR8",
     "filepath": "/media/previz/buffer00.png",
     "type": "buffer",
     "channel": 0,
     "sampler": {
      "filter": "nearest",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    },
    {
     "id": "XsXGR8",
     "filepath": "/media/previz/buffer01.png",
     "type": "buffer",
     "channel": 1,
     "sampler": {
      "filter": "nearest",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    }
   ],
   "outputs": [
    {
     "id": "4dXGR8",
     "channel": 0
    }
   ],
   "code": "/* Linear Filtering Shim by Theron Tarigo, 2019.\n   https://www.shadertoy.com/view/tssXWf\n\n   The following codes may be used and copied freely,\n   with or without attribution.  However, please do not\n   remove the URL, so that others may find the explanation\n   provided here, which may be expanded in future.\n   This is not a legal requirement.\n*/\n\n#define LINEAR_FILTER_CONFIG  true,true,true,true\n\nconst struct LINEARFILTER_T {\n  bool iChannel0, iChannel1, iChannel2, iChannel3;\n} LINEARFILTER = LINEARFILTER_T(LINEAR_FILTER_CONFIG);\n\nconst struct SAMPLERINDEX_T {\n  int iChannel0, iChannel1, iChannel2, iChannel3;\n} SAMPLERINDEX = SAMPLERINDEX_T(0,1,2,3);\n\n#ifdef ORG\nvec4 textureLinearPix (sampler2D sampler, vec2 U) {\n  return mix(mix(\n      texelFetch(sampler,ivec2(U)+ivec2(0,0),0),\n      texelFetch(sampler,ivec2(U)+ivec2(1,0),0),\n    fract((U).x)),mix(\n      texelFetch(sampler,ivec2(U)+ivec2(0,1),0),\n      texelFetch(sampler,ivec2(U)+ivec2(1,1),0),\n    fract((U).x)),fract((U).y));\n}\n#endif\n\n\nvec4 textureLinearPix (sampler2D sampler, vec2 U) {\n  return mix(mix(\n      texture(sampler,(vec2(ivec2(U)+ivec2(0,0))+0.5)/iR),\n      texture(sampler,(vec2(ivec2(U)+ivec2(1,0))+0.5)/iR),\n    fract((U).x)),mix(\n      texture(sampler,(vec2(ivec2(U)+ivec2(0,1))+0.5)/iR),\n      texture(sampler,(vec2(ivec2(U)+ivec2(1,1))+0.5)/iR),\n    fract((U).x)),fract((U).y));\n}\n#define textureLinear(sampler,P) textureLinearPix(sampler, \\\n    (P)*iChannelResolution[SAMPLERINDEX.sampler].xy-vec2(.5))\n\n#define texture(sampler,P) ( LINEARFILTER.iChannel0 ? \\\n    textureLinear(sampler,P) \\\n  : texture(sampler,P) )\n// End of Linear Filtering Shim\n\n/*\n** This is fluid\n** Following this tutorial : http://wyattflanders.com/MeAndMyNeighborhood.pdf\n*/\n\nconst vec2 n = vec2(+.0, +1.);\nconst vec2 s = -n;\nconst vec2 w = vec2(+1., +0.);\nconst vec2 e = -w;\n\nvec4 F(vec2 p)\n{\n\tvec2 r = A(p/R).xy;\n    r = p - r;\n    return A(r/R);\n}\n\nvoid mainImage( out vec4 o, in vec2 f )\n{\n    iR = iResolution.xy;\n\n    if (f.x < 10. || f.y < 10. || -f.x+R.x < 10. || -f.y+R.y < 10.) {o = vec4(0.); return;}\n\n    float kb = C(vec2(32.5/256., 0.25)).x;\n    if (kb > .5 || iFrame < 10) {o = vec4(0); return;}\n\n    o = F(f);\n    vec4 En = F(f+n);\n    vec4 Es = F(f+s);\n    vec4 Ew = F(f+w);\n    vec4 Ee = F(f+e);\n\n    o.z = (En + Es + Ew + Ee).z * .25;//06125;\n\n    o.xy += vec2(Ee.z - Ew.z, Es.z - En.z) * .25;\n\n    o.z += (Es.y - En.y + Ee.x - Ew.x) *.25;\n\n    //o.xy += (B(f/R).xy -.5)/400.;\n    //o.y += -o.w*sin(1.57+1.*g(D(f/R)))/400.;//*iTimeDelta*1.;\n\n    o.y += -o.w*iTimeDelta*.75;\n//    o.y += -o.w/400.;\n    //o.xy += -o.w*(cs(length(o.w)*6.28)/200.);\n\to.w += B(f/R).y*iTimeDelta*1.;\n    o.w += (Ee.x*Ee.w-Ew.x*Ew.w+Es.y*Es.w-En.y*En.w) * .25;\n\n    //o.xy += o.w*cs(o.w*50.*1.0+g(B(f/R))*5000. )*.505;\n    //o.xy += o.w*cs( (o.w*10./(1.0001+g(B(f/R)))) * 100.)*.10501;\n    //o.xy += -NA(f/R).xy*1./8.;\n    //o.w += .001001 * (g(B(f/R))*2.-1.);\n\n    //if (iMouse.z > .5 && length(f-iMouse.xy) < 100.) o.w = .5;\n\n    //if (f.x < 9. || f.y < 9. || -f.x+R.x < 9. || -f.y+R.y < 9.) o *= .0;\n\n    o = clamp(o, -1.0, 1.);\n}\n\n",
   "name": "Buffer A",
   "description": "",
   "type": "buffer"
  },
  {
   "inputs": [],
   "outputs": [],
   "code": "\n#define R iResolution.xy\n\nvec2 iR;\n\n//code shortcuts\n#define A(u) texture(iChannel0, u)\n#define B(u) texture(iChannel1, u)\n#define C(u) texture(iChannel2, u)\n#define D(u) texture(iChannel3, u)\n",
   "name": "Common",
   "description": "",
   "type": "common"
  }
 ]
}