{
 "ver": "0.1",
 "info": {
  "id": "Ndtfzn",
  "date": "0",
  "viewed": 0,
  "name": "Moana Water JiPi",
  "description": "Water shader inspired by Moana\nControls:\nr  - Reset settings to default\nq/a - Lower/Raise absorption\ns/w - Lower/Raise the index of refraction\ne/d - Lower/Raise turbulence\n\nWater Color\nh/y - Lower/Raise red\nj/u - Lower/Raise green\nk/i - Lower/Raise blue\n",
  "likes": 0,
  "published": "Private",
  "usePreview": 0,
  "tags": [
   "refraction",
   "water",
   "moana"
  ],
  "hasliked": 0,
  "parentid": "wlsyzH",
  "parentname": "Moana Water Shader"
 },
 "renderpass": [
  {
   "inputs": [
    {
     "id": "4dXGR8",
     "filepath": "/media/previz/buffer00.png",
     "type": "buffer",
     "channel": 0,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    }
   ],
   "outputs": [
    {
     "id": "4dfGRr",
     "channel": 0
    }
   ],
   "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = vec4(texture(iChannel0, uv).rgb, 1.0);\n}",
   "name": "Image",
   "description": "",
   "type": "image"
  },
  {
   "inputs": [
    {
     "id": "4dXGRr",
     "filepath": "/presets/tex00.jpg",
     "type": "keyboard",
     "channel": 1,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    },
    {
     "id": "4dXGR8",
     "filepath": "/media/previz/buffer00.png",
     "type": "buffer",
     "channel": 0,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    }
   ],
   "outputs": [
    {
     "id": "4dXGR8",
     "channel": 0
    }
   ],
   "code": "// Written by Chris Wallis (@chriskwallis)\n#define PERFORMANCE_MODE 0\n#define ULTRA_MODE 0 \n\n#if PERFORMANCE_MODE\n#define ALLOW_KEYBOARD_INPUT 0\n#define SECONDARY_REFLECTION 0\n#define ADD_WHITE_WATER 0\n#define MAX_SDF_SPHERE_STEPS 12\n#define SDF_START_STEP_SIZE 3.0\n#define SDF_END_STEP_SIZE 15.0\n#define MAX_VOLUME_MARCH_STEPS 10\n#define BINARY_SEARCH_STEPS 5\n#define MAX_OPAQUE_SHADOW_MARCH_STEPS 4\n#define SHADOW_FACTOR_STEP_SIZE 10.0\n#else\n#if ULTRA_MODE\n#define MAX_VOLUME_ENTRIES 2\n#else\n#define MAX_VOLUME_ENTRIES 1\n#endif\n#define MAX_VOLUME_ENTRIES 1\n#define ALLOW_KEYBOARD_INPUT 1\n#define SECONDARY_REFLECTION 1\n#define ADD_WHITE_WATER 1\n#define MAX_SDF_SPHERE_STEPS 20\n#define SDF_START_STEP_SIZE 1.5\n#define SDF_END_STEP_SIZE 8.0\n#define MAX_VOLUME_MARCH_STEPS 20\n#define BINARY_SEARCH_STEPS 6\n#define MAX_OPAQUE_SHADOW_MARCH_STEPS 10\n#define SHADOW_FACTOR_STEP_SIZE 7.0\n#endif\n\n#define GROUND_LEVEL 0.0\n#define WATER_LEVEL 22.0\n#define PI 3.14\n#define LARGE_NUMBER 1e20\n#define EPSILON 0.0001\n\n#define NUM_SPHERES 5\n\n#define SAND_FLOOR_OBJECT_ID 0\n#define CORAL_ROCK_BASE_OBJECT_ID 1\n#define NUM_OBJECTS (CORAL_ROCK_BASE_OBJECT_ID + NUM_SPHERES)\n\n#define INVALID_OBJECT_ID int(-1)\n\n#define AIR_IOR 1.0\n\n#define SKY_AMBIENT_MULTIPLIER 0.1\n\n#define MAX_WATER_DISPLACEMENT 15.0\n#define MIN_REFLECTION_COEFFECIENT 0.0\n\n#define SCENE_TYPE_OCEAN 1\n#define SCENE_TYPE_SIMPLIFIED_OCEAN 2\n#define SCENE_TYPE_OPAQUE 3\n\nfloat WaterIor;\nfloat WaterTurbulence;\nfloat WaterAbsorption;\nvec3 WaterColor;\n\n// --------------------------------------------//\n//               Noise Functions\n// --------------------------------------------//\n// Taken from Inigo Quilez's Rainforest ShaderToy:\n// https://www.shadertoy.com/view/4ttSWf\nfloat hash1( float n )\n{\n    return fract( n*17.0*fract( n*0.3183099 ) );\n}\n\n// Taken from Inigo Quilez's Rainforest ShaderToy:\n// https://www.shadertoy.com/view/4ttSWf\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    \n    float n = p.x + 317.0*p.y + 157.0*p.z;\n    \n    float a = hash1(n+0.0);\n    float b = hash1(n+1.0);\n    float c = hash1(n+317.0);\n    float d = hash1(n+318.0);\n    float e = hash1(n+157.0);\n\tfloat f = hash1(n+158.0);\n    float g = hash1(n+474.0);\n    float h = hash1(n+475.0);\n\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return -1.0+2.0*(k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z);\n}\n\nconst mat3 m3  = mat3( 0.00,  0.80,  0.60,\n                      -0.80,  0.36, -0.48,\n                      -0.60, -0.48,  0.64 );\n\n// Taken from Inigo Quilez's Rainforest ShaderToy:\n// https://www.shadertoy.com/view/4ttSWf\nfloat fbm( in vec3 x, int iterations )\n{\n    float f = 2.0;\n    float s = 0.5;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=min(0, iFrame); i<iterations; i++ )\n    {\n        float n = noise(x);\n        a += b*n;\n        b *= s;\n        x = f*m3*x;\n    }\n\treturn a;\n}\n\n// Taken from Inigo Quilez's Rainforest ShaderToy:\n// https://www.shadertoy.com/view/4ttSWf\nfloat fbm_4( in vec3 x )\n{\n    return fbm(x, 4);\n}\n\n// Taken from https://iquilezles.org/articles/distfunctions\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\n// Taken from https://iquilezles.org/articles/distfunctions\nfloat sdSmoothUnion( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\n// Taken from https://iquilezles.org/articles/distfunctions\nfloat sdSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nvec3 sdTranslate(vec3 pos, vec3 translate)\n{\n    return pos -= translate;\n}\n\n// Taken from https://iquilezles.org/articles/distfunctions\nfloat sdSphere( vec3 p, vec3 origin, float s )\n{\n  p = sdTranslate(p, origin);\n  return length(p)-s;\n}\n\n\nstruct Sphere\n{\n    vec3 origin;\n    float radius;\n};\n    \nvoid GetSphere(int index, out vec3 origin, out float radius)\n{\n    Sphere spheres[NUM_SPHERES];\n    spheres[0] = Sphere(vec3(38, GROUND_LEVEL, 32), 12.0);\n    spheres[1] = Sphere(vec3(33, GROUND_LEVEL - 2.0, 20), 8.5);\n    spheres[2] = Sphere(vec3(-25, GROUND_LEVEL - 32.0, 55), 40.0);\n    spheres[3] = Sphere(vec3(-40, GROUND_LEVEL, 25), 12.0);\n    spheres[4] = Sphere(vec3(45, GROUND_LEVEL, 10), 12.0);\n\n    origin = spheres[index].origin;\n    radius = spheres[index].radius;\n\n}\n\nfloat GetWaterWavesDisplacement(vec3 position, float time)\n{\n    return 7.0 * sin(position.x / 15.0 + time * 1.3) +\n        6.0 * cos(position.z / 15.0 + time / 1.1);\n}\n\nfloat GetWaterNoise(vec3 position, float time)\n{\n    return WaterTurbulence * fbm_4(position / 15.0 + time / 3.0);\n}\n\nfloat QueryOceanDistanceField( in vec3 pos, float time)\n{    \n    return GetWaterWavesDisplacement(pos, time) + GetWaterNoise(pos, time) + sdPlane(pos - vec3(0, WATER_LEVEL, 0));\n}\n\nfloat QueryVolumetricDistanceField( in vec3 pos, float time)\n{    \n    float minDist = QueryOceanDistanceField(pos, time);\n    minDist = sdSmoothSubtraction(sdSphere(pos, vec3(0.0, 20.0, 0), 35.0) +  5.0 * fbm_4(pos / vec3(12, 20, 12)  - time / 5.0), minDist, 12.0);   \n    minDist = sdSmoothUnion(minDist, sdPlane(pos - vec3(0, GROUND_LEVEL - 1.0, 0)), 13.0);\n\n    return minDist;\n}\n\nfloat IntersectVolumetric(in vec3 rayOrigin, in vec3 rayDirection, float maxT, float time, int sceneType, out bool intersectFound)\n{\n    float t = 0.0f;\n    float sdfValue = 0.0;\n    float stepSize = SDF_START_STEP_SIZE;\n    float stepIncrement = float(SDF_END_STEP_SIZE - SDF_START_STEP_SIZE) / float(MAX_SDF_SPHERE_STEPS);\n    for(int i=0; i<MAX_SDF_SPHERE_STEPS; i++ )\n    {\n\t    sdfValue = sceneType == SCENE_TYPE_OCEAN ?\n            QueryVolumetricDistanceField(rayOrigin+rayDirection*t, time) :\n        \tQueryOceanDistanceField(rayOrigin+rayDirection*t, time);\n        stepSize += stepIncrement;\n        \n        if( sdfValue < 0.0 || t>maxT ) break;\n        t += max(sdfValue, stepSize);\n    }\n    \n    if(sdfValue < 0.0f)\n    {\n        float start = 0.0;\n        float end = stepSize;\n        t -= stepSize;\n        \n        for(int j = 0; j < BINARY_SEARCH_STEPS; j++)\n        {\n            float midPoint = (start + end) * 0.5;\n            vec3 nextMarchPosition = rayOrigin + (t + midPoint) * rayDirection;\n            float sdfValue = (sceneType == SCENE_TYPE_OCEAN) ?\n                QueryVolumetricDistanceField(nextMarchPosition, time) :\n                QueryOceanDistanceField(nextMarchPosition, time);\n            \n            // Use the SDF to nudget the mid point closer to the actual edge\n            midPoint = clamp(midPoint + sdfValue, start, end);\n            if(sdfValue < 0.0)\n            {\n                end = midPoint;\n            }\n            else\n            {\n                start = midPoint;\n            }\n        }\n        t += end;\n    }\n    \n    intersectFound = t<maxT && sdfValue < 0.0;\n    return t;\n}\n\n// Taken from https://iquilezles.org/articles/normalsSDF\nvec3 GetVolumeNormal( in vec3 pos, float time, int sceneType )\n{\n    vec3 n = vec3(0.0);\n    for( int i=min(0, iFrame); i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*\n            ((sceneType == SCENE_TYPE_OCEAN) ?\n                QueryVolumetricDistanceField(pos+0.5*e, time) :\n                QueryOceanDistanceField(pos+0.5*e, time));\n    }\n    return normalize(n);\n}\n\nstruct CameraDescription\n{\n    vec3 Position;\n    vec3 LookAt;    \n\n    float LensHeight;\n    float FocalDistance;\n};\n    \nCameraDescription Camera = CameraDescription(\n    vec3(0, 10, -20),\n    vec3(0, 10, 0),\n    2.0,\n    1.6\n);\n\nstruct Material\n{\n    vec3 albedo;\n    float shininess;\n};\n\nMaterial GetMaterial(int objectID)\n{\n    if(objectID == SAND_FLOOR_OBJECT_ID)\n    {\n        return Material(0.9 * vec3(1.0, 1.0, 0.8), 50.0);\n    }\n    else // if(objectID >= CORAL_ROCK_BASE_OBJECT_ID) // it's coral\n    {\n        return Material(vec3(0.3, 0.4, 0.2), 3.0);\n    }\n}\n\n// https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-plane-and-ray-disk-intersection\nfloat PlaneIntersection(vec3 rayOrigin, vec3 rayDirection, vec3 planeOrigin, vec3 planeNormal) \n{ \n    float t = -1.0f;\n    float denom = dot(-planeNormal, rayDirection); \n    if (denom > EPSILON) { \n        vec3 rayToPlane = planeOrigin - rayOrigin; \n        return dot(rayToPlane, -planeNormal) / denom; \n    } \n \n    return t; \n} \n    \nfloat SphereIntersection(\n    in vec3 rayOrigin, \n    in vec3 rayDirection, \n    in vec3 sphereCenter, \n    in float sphereRadius)\n{\n      vec3 eMinusC = rayOrigin - sphereCenter;\n      float dDotD = dot(rayDirection, rayDirection);\n\n      float discriminant = dot(rayDirection, (eMinusC)) * dot(rayDirection, (eMinusC))\n         - dDotD * (dot(eMinusC, eMinusC) - sphereRadius * sphereRadius);\n\n      if (discriminant < 0.0) \n         return -1.0;\n\n      float firstIntersect = (dot(-rayDirection, eMinusC) - sqrt(discriminant))\n             / dDotD;\n      \n      float t = firstIntersect;\n      return t;\n}\n\n\nvoid UpdateIfIntersected(\n    inout float t,\n    in float intersectionT, \n    in int intersectionObjectID,\n    out int objectID)\n{    \n    if(intersectionT > EPSILON && intersectionT < t)\n    {\n        objectID = intersectionObjectID;\n        t = intersectionT;\n    }\n}\n\nfloat SandHeightMap(vec3 position)\n{\n    float sandGrainNoise = 0.1 * fbm(position * 10.0, 2);\n    float sandDuneDisplacement = 0.7 * sin(10.0 * fbm_4(10.0 + position / 40.0));\n\treturn sandGrainNoise  + sandDuneDisplacement;\n}\n\nfloat QueryOpaqueDistanceField(vec3 position, int objectID)\n{\n    if(objectID == SAND_FLOOR_OBJECT_ID)\n    {\n        return sdPlane(position) + SandHeightMap(position);\n    }\n    else\n    {\n        vec3 origin;\n        float radius;\n        GetSphere(objectID - CORAL_ROCK_BASE_OBJECT_ID, origin, radius);\n        return sdSphere(position, origin, radius) + fbm_4(position);\n    }\n}\n\n// Taken from https://iquilezles.org/articles/normalsSDF\nvec3 GetOpaqueNormal( in vec3 pos, int objectID )\n{\n    vec3 n = vec3(0.0);\n    for( int i=min(0, iFrame); i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*QueryOpaqueDistanceField(pos+0.5*e, objectID);\n    }\n    return normalize(n);\n}\n\nfloat IntersectOpaqueScene(in vec3 rayOrigin, in vec3 rayDirection, out int objectID)\n{\n    float intersectionT = LARGE_NUMBER;\n\n    float t = LARGE_NUMBER;\n    objectID = INVALID_OBJECT_ID;\n\n    for(int i = min(0, iFrame); i < NUM_SPHERES; i++)\n    {\n        vec3 origin;\n        float radius;\n        GetSphere(i, origin, radius);\n            UpdateIfIntersected(\n            t,\n            SphereIntersection(rayOrigin, rayDirection, origin, radius),\n            CORAL_ROCK_BASE_OBJECT_ID + i,\n            objectID);\n    }\n    \n    UpdateIfIntersected(\n        t,\n        PlaneIntersection(rayOrigin, rayDirection, vec3(0, GROUND_LEVEL, 0), vec3(0, 1, 0)),\n        SAND_FLOOR_OBJECT_ID,\n        objectID);\n    \n    // Optimization for early-out on volume intersections\n    UpdateIfIntersected(\n        t,\n        PlaneIntersection(rayOrigin, rayDirection, vec3(0, WATER_LEVEL + MAX_WATER_DISPLACEMENT, 0), vec3(0, 1, 0)),\n        INVALID_OBJECT_ID,\n        objectID);\n\n    return t;\n}\n\nfloat Specular(in vec3 reflection, in vec3 lightDirection, float shininess)\n{\n    return 0.05 * pow(max(0.0, dot(reflection, lightDirection)), shininess);\n}\n\nvec3 Diffuse(in vec3 normal, in vec3 lightVec, in vec3 diffuse)\n{\n    float nDotL = dot(normal, lightVec);\n    return clamp(nDotL * diffuse, 0.0, 1.0);\n}\n\nvec3 BeerLambert(vec3 absorption, float dist)\n{\n    return exp(-absorption * dist);\n}\n\nvec3 GetShadowFactor(in vec3 rayOrigin, in vec3 rayDirection, in int maxSteps, in float minMarchSize)\n{\n    float t = 0.0f;\n    vec3 shadowFactor = vec3(1.0f);\n    float signedDistance = 0.0;\n    bool enteredVolume = false;\n    for(int i = min(0, iFrame); i < maxSteps; i++)\n    {         \n        float marchSize = max(minMarchSize, abs(signedDistance));\n        t += marchSize;\n\n        vec3 position = rayOrigin + t*rayDirection;\n\n        signedDistance = QueryVolumetricDistanceField(position, iTime);\n        if(signedDistance < 0.0)\n        {\n            // Soften the shadows towards the edges to simulate an area light\n            float softEdgeMultiplier = min(abs(signedDistance / 5.0), 1.0);\n            shadowFactor *= BeerLambert(WaterAbsorption * softEdgeMultiplier / WaterColor, marchSize);\n            enteredVolume = true;\n        }\n        else if(enteredVolume)\n        {\n            // Optimization taking advantage of the shape of the water. The water isn't\n            // concave therefore if we've entered it once and are exiting, we're done\n            break;\n        }\n    }\n    return shadowFactor;\n}\n\nfloat GetApproximateIntersect(vec3 position, vec3 rayDirection)\n{\n    float distanceToPlane;\n    \n    // Special case for rays parallel to the ground plane to avoid divide\n    // by zero issues\n    if(abs(rayDirection.y) < 0.01)\n    {\n        distanceToPlane = LARGE_NUMBER;\n    }\n    else if(position.y < GROUND_LEVEL || position.y > WATER_LEVEL)\n    {\n        distanceToPlane = 0.0f;\n    }\n    else if(rayDirection.y > 0.0)\n    {\n\t\tdistanceToPlane = (WATER_LEVEL - position.y) / rayDirection.y;\n        vec3 intersectPosition = position + distanceToPlane * rayDirection;\n        \n        distanceToPlane = max(0.0, distanceToPlane);\n    }\n    else\n    {\n        distanceToPlane = (position.y - GROUND_LEVEL) / abs(rayDirection.y);\n    }\n    return distanceToPlane;\n}\n\nvec3 GetApproximateShadowFactor(vec3 position, vec3 rayDirection)\n{\n    float distanceToPlane = GetApproximateIntersect(position, rayDirection);\n\treturn BeerLambert(WaterAbsorption / WaterColor, distanceToPlane);\n}\n\nfloat seed = 0.;\nfloat rand() { return fract(sin(seed++ + iTime)*43758.5453123); }\n\nfloat smoothVoronoi( in vec2 x )\n{\n    ivec2 p = ivec2(floor( x ));\n    vec2  f = fract( x );\n\n    float res = 0.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        ivec2 b = ivec2( i, j );\n        vec2  r = vec2( b ) - f + noise( vec3(p + b, 0.0) );\n        float d = length( r );\n\n        res += exp( -32.0*d );\n    }\n    return -(1.0/32.0)*log( res );\n}\n\nvec3 GetSunLightDirection()\n{\n    return normalize(vec3(0.3, 1.0, 1.65));\n}\n\nvec3 GetSunLightColor()\n{\n    return 0.9 * vec3(0.9, 0.75, 0.7);\n}\n\nvec3 GetBaseSkyColor(vec3 rayDirection)\n{\n\treturn mix(\n        vec3(0.2, 0.5, 0.8),\n        vec3(0.7, 0.75, 0.9),\n         max(rayDirection.y, 0.0));\n}\n\nvec3 GetAmbientSkyColor()\n{\n    return SKY_AMBIENT_MULTIPLIER * GetBaseSkyColor(vec3(0, 1, 0));\n}\n\nvec3 GetAmbientShadowColor()\n{\n    return vec3(0, 0, 0.2);\n}\n\nfloat GetCloudDenity(vec3 position)\n{\n    float time = iTime * 0.25;\n    vec3 noisePosition = position + vec3(0.0, 0.0, time);\n    float noise = fbm_4(noisePosition);\n    float noiseCutoff = -0.3;\n    return max(0.0, 3.0f * (noise - noiseCutoff));\n}\n\nvec4 GetCloudColor(vec3 position)\n{\n    float cloudDensity = GetCloudDenity(position);\n    vec3 cloudAlbedo = vec3(1, 1, 1);\n    float cloudAbsorption = 0.6;\n    float marchSize = 0.25;\n\n    vec3 lightFactor = vec3(1, 1, 1);\n    {\n        vec3 marchPosition = position;\n        int selfShadowSteps = 4;\n        for(int i = 0; i < selfShadowSteps; i++)\n        {\n            marchPosition += GetSunLightDirection() * marchSize;\n            float density = cloudAbsorption * GetCloudDenity(marchPosition);\n            lightFactor *= BeerLambert(vec3(density, density, density), marchSize);\n        }\n    }\n\n    return vec4(\n        cloudAlbedo * \n        \t(mix(GetAmbientShadowColor(), 1.3 * GetSunLightColor(), lightFactor) +\n             GetAmbientSkyColor()), \n        min(cloudDensity, 1.0));\n}\n\nvec3 GetSkyColor(in vec3 rayDirection)\n{\n    vec3 skyColor = GetBaseSkyColor(rayDirection);\n    vec4 cloudColor = GetCloudColor(rayDirection * 4.0);\n    skyColor = mix(skyColor, cloudColor.rgb, cloudColor.a);\n\n    return skyColor;\n}\n\nfloat FresnelFactor(\n    float CurrentIOR,\n    float NewIOR,\n    vec3 Normal,\n    vec3 RayDirection)\n{\n    float ReflectionCoefficient = \n        ((CurrentIOR - NewIOR) / (CurrentIOR + NewIOR)) *\n        ((CurrentIOR - NewIOR) / (CurrentIOR + NewIOR));\n    return \n        clamp(ReflectionCoefficient + (1.0 - ReflectionCoefficient) * pow(1.0 - dot(Normal, -RayDirection), 5.0), MIN_REFLECTION_COEFFECIENT, 1.0); \n}\n\nvec3 SandParallaxOcclusionMapping(vec3 position, vec3 view)\n{\n    int pomCount = 6;\n    float marchSize = 0.3;\n    for(int i = 0; i < pomCount; i++)\n    {\n        if(position.y < GROUND_LEVEL -  SandHeightMap(position)) break;\n        position += view * marchSize;\n    }\n    return position;\n}\n\nvoid CalculateLighting(vec3 position, vec3 view, int objectID, inout vec3 color, bool useFastLighting)\n{   \n    Material material = GetMaterial(objectID);\n    float sdfValue = QueryVolumetricDistanceField(position, iTime);\n    bool bUnderWater = sdfValue < 0.0;\n\n    float wetnessFactor = 0.0;\n    if(objectID == SAND_FLOOR_OBJECT_ID && !useFastLighting)\n    {\n        float wetSandDistance = 0.7;\n\t\tif(sdfValue <= wetSandDistance)\n        {\n            // Darken the sand albedo to make it look wet\n            float fadeEdge = 0.2;\n            wetnessFactor = 1.0 - max(0.0, (sdfValue - (wetSandDistance - fadeEdge)) / fadeEdge);\n\t\t\tmaterial.albedo *= material.albedo * mix(1.0, 0.5, wetnessFactor);\n        }\n        \n        position = SandParallaxOcclusionMapping(position, view);\n    }\n\n    vec3 normal = GetOpaqueNormal(position, objectID);\n    vec3 reflectionDirection = reflect(view, normal);\n   \n    int shadowObjectID = INVALID_OBJECT_ID;\n    if(!useFastLighting)\n    {\n        IntersectOpaqueScene(position, GetSunLightDirection(), shadowObjectID);\n    }\n    \n\tvec3 shadowFactor = vec3(0.0, 0.0, 0.0);\n    if(shadowObjectID == INVALID_OBJECT_ID)\n    {\n        float t;\n        shadowFactor = useFastLighting ? \n                GetApproximateShadowFactor(position, GetSunLightDirection()) :\n                GetShadowFactor(position, GetSunLightDirection(), MAX_OPAQUE_SHADOW_MARCH_STEPS, SHADOW_FACTOR_STEP_SIZE);\n        \n        // Small back splash of the sky ambient color to fake a bit of gi\n        color += shadowFactor * material.albedo * mix(0.4 * GetAmbientShadowColor(), GetSunLightColor(), max(0.0, dot(normal, GetSunLightDirection())));\n        \n        color += shadowFactor * GetSunLightColor() * Specular(reflectionDirection, GetSunLightDirection(), material.shininess);\n \t    \n        if(!useFastLighting)\n        {\n            // Fake caustics\n            float waterNoise = fract(GetWaterNoise(position, iTime));\n            float causticMultiplier = bUnderWater ? 7.0 : (1.0 - shadowFactor.r);\n            color += material.albedo * causticMultiplier * 0.027 *  pow(\n                smoothVoronoi(position.xz / 4.0 + \n                          vec2(iTime, iTime + 3.0) + \n                          3.0 * vec2(cos(waterNoise), sin(waterNoise))), 5.0);\n        }\n        \n    }\n    \n    // Add a bit of reflection to wet sand to make it look like \n    // there's some water left over\n    if(!useFastLighting && wetnessFactor > 0.0)\n    {\n        // Water fills in the holes in the sand and generally\n        // makes the surface planar so we can assume the normal is\n        // pointing straight up\n        vec3 wetNormal = vec3(0, 1, 0);\n        vec3 reflectionDirection = reflect(view, wetNormal);\n        float fresnel = FresnelFactor(AIR_IOR, WaterIor, wetNormal, view);\n        color += shadowFactor * wetnessFactor * fresnel * GetSkyColor(reflectionDirection);\n    }\n    \n    color += GetAmbientSkyColor() * material.albedo;\n}\n\nvec3 Render( in vec3 rayOrigin, in vec3 rayDirection)\n{\n    vec3 accumulatedColor = vec3(0.0f);\n    vec3 accumulatedColorMultiplier = vec3(1.0);\n    \n    int materialID = INVALID_OBJECT_ID;\n    float t = IntersectOpaqueScene(rayOrigin, rayDirection, materialID);\n    vec3 opaquePosition = rayOrigin + t*rayDirection;\n    \n    bool outsideVolume = true;\n    for(int entry = 0; entry < MAX_VOLUME_ENTRIES; entry++) \n    { \n        if(!outsideVolume) break;\n        \n        bool firstEntry = (entry == 0);\n        bool intersectFound = false;\n        float volumeStart = \n            IntersectVolumetric(\n                rayOrigin,\n                rayDirection, \n                t, \n                iTime,\n                (firstEntry ? SCENE_TYPE_OCEAN : SCENE_TYPE_SIMPLIFIED_OCEAN),\n                intersectFound);\n        \n        if(!intersectFound) break;\n\t\telse\n        {\n            outsideVolume = false;\n            rayOrigin = rayOrigin + rayDirection * volumeStart;\n            vec3 volumeNormal = GetVolumeNormal(rayOrigin, iTime, SCENE_TYPE_OCEAN);\n            vec3 reflection = reflect( rayDirection, volumeNormal);\n            float fresnelFactor = FresnelFactor(AIR_IOR, WaterIor, volumeNormal, rayDirection);\n            float waterShininess = 100.0;\n\n            float whiteWaterFactor = 0.0;\n            float whiteWaterMaxHeight = 5.0;\n            float groundBlendFactor = min(1.0, (rayOrigin.y - GROUND_LEVEL) * 0.75);\n            #if ADD_WHITE_WATER\n            if(firstEntry && rayOrigin.y <= whiteWaterMaxHeight)\n            {\n                WaterIor = mix(1.0, WaterIor, groundBlendFactor);\n                \n                vec3 voronoisePosition = rayOrigin / 1.5 + vec3(0, -iTime * 2.0, sin(iTime));\n            \tfloat noiseValue = abs(fbm(voronoisePosition, 2));\n            \tvoronoisePosition += 1.0 * vec3(cos(noiseValue), 0.0, sin(noiseValue));\n                \n                float heightLerp =  (whiteWaterMaxHeight - rayOrigin.y) / whiteWaterMaxHeight;\n                whiteWaterFactor = abs(smoothVoronoi(voronoisePosition.xz)) * heightLerp;\n                whiteWaterFactor = clamp(whiteWaterFactor, 0.0, 1.0);\n                whiteWaterFactor = pow(whiteWaterFactor, 0.2) * heightLerp;\n                whiteWaterFactor *= mix(abs(fbm(rayOrigin + vec3(0, -iTime * 5.0, 0), 2)), 1.0, heightLerp);\n                whiteWaterFactor *= groundBlendFactor;\n                \n                vec3 shadowFactor =  GetShadowFactor(rayOrigin, GetSunLightDirection(), MAX_OPAQUE_SHADOW_MARCH_STEPS, SHADOW_FACTOR_STEP_SIZE);\n                vec3 diffuse = 0.5 * shadowFactor * GetSunLightColor() + \n                    0.7 * shadowFactor * mix(GetAmbientShadowColor(), GetSunLightColor(), max(0.0, dot(volumeNormal, GetSunLightDirection())));\n                accumulatedColor += vec3(whiteWaterFactor) * (\n                    diffuse +\n                    shadowFactor * Specular(reflection, GetSunLightDirection(), 30.0) * GetSunLightColor() +\n            \t\tGetAmbientSkyColor());\n            }\n            #endif\n            accumulatedColorMultiplier *= (1.0 - whiteWaterFactor);\n            rayDirection = refract(rayDirection, volumeNormal, AIR_IOR / WaterIor);\n            \n            accumulatedColor += accumulatedColorMultiplier * Specular(reflection, GetSunLightDirection(), waterShininess) * GetSunLightColor();\n            accumulatedColor += accumulatedColorMultiplier * fresnelFactor * GetSkyColor(reflection);\n            accumulatedColorMultiplier *= (1.0 - fresnelFactor);\n            \n            // recalculate opaque depth now that the ray has been refracted\n            t = IntersectOpaqueScene(rayOrigin, rayDirection, materialID);\n            if( materialID != INVALID_OBJECT_ID )\n            {\n                opaquePosition = rayOrigin + t*rayDirection;\n            }\n\n            float volumeDepth = 0.0f;\n            float signedDistance = 0.0;\n            int i = 0;\n            vec3 marchPosition = vec3(0);\n            float minStepSize = SDF_START_STEP_SIZE;\n            float minStepIncrement = float(SDF_END_STEP_SIZE - SDF_START_STEP_SIZE) / float(MAX_VOLUME_MARCH_STEPS);\n            for(; i < MAX_VOLUME_MARCH_STEPS; i++)\n            {\n                float marchSize = max(minStepSize, signedDistance);\n\t\t\t\tminStepSize += minStepIncrement;\n                \n                vec3 nextMarchPosition = rayOrigin + (volumeDepth + marchSize) * rayDirection;\n                signedDistance = QueryOceanDistanceField(nextMarchPosition, iTime);\n                if(signedDistance > 0.0f)\n                {\n                    float start = 0.0;\n                    float end = marchSize;\n\n                    for(int j = 0; j < BINARY_SEARCH_STEPS; j++)\n                    {\n                        float midPoint = (start + end) * 0.5;\n                        vec3 nextMarchPosition = rayOrigin + (volumeDepth + midPoint) * rayDirection;\n                        float sdfValue = QueryVolumetricDistanceField(nextMarchPosition, iTime);\n\n                        // Use the SDF to nudget the mid point closer to the actual edge\n                        midPoint = clamp(midPoint - sdfValue, start, end);\n                        if(sdfValue > 0.0)\n                        {\n                            end = midPoint;\n                        }\n                        else\n                        {\n                            start = midPoint;\n                        }\n                    }\n                    marchSize = end;\n                }\n\n                volumeDepth += marchSize;\n                marchPosition = rayOrigin + volumeDepth*rayDirection;\n\n                if(volumeDepth > t)\n                {\n                    intersectFound = true;\n                    volumeDepth = min(volumeDepth, t);\n                    break;\n                }\n\n                vec3 previousLightFactor = accumulatedColorMultiplier;\n                accumulatedColorMultiplier *= BeerLambert(vec3(WaterAbsorption) / WaterColor, marchSize);\n                vec3 absorptionFromMarch = previousLightFactor - accumulatedColorMultiplier;\n\n                accumulatedColor += accumulatedColorMultiplier * WaterColor * absorptionFromMarch * \n                    GetSunLightColor() * GetApproximateShadowFactor(marchPosition, GetSunLightDirection());\n                accumulatedColor += accumulatedColorMultiplier * absorptionFromMarch * GetAmbientSkyColor();\n\n                if(signedDistance > 0.0)\n                {\n                    intersectFound = true;\n                    outsideVolume = true;\n                    break;\n                }\n            }\n\n            if(intersectFound && outsideVolume)\n            {\n                // Flip the normal since we're coming from inside the volume\n                vec3 exitNormal = -GetVolumeNormal(marchPosition, iTime, SCENE_TYPE_SIMPLIFIED_OCEAN);                    \n\n                #if SECONDARY_REFLECTION\n                float fresnelFactor = max(0.2, FresnelFactor(WaterIor, AIR_IOR, exitNormal, rayDirection));\n                vec3 reflection = reflect(rayDirection, exitNormal);\n                int reflectedMaterialID;\n                float reflectionT = IntersectOpaqueScene(marchPosition, reflection, reflectedMaterialID);\n                if( reflectedMaterialID != INVALID_OBJECT_ID )\n                {\n                    vec3 pos = marchPosition + reflection*reflectionT;\n                    Material material = GetMaterial(reflectedMaterialID);\n                    vec3 color = vec3(0);\n                    CalculateLighting(pos,reflection, reflectedMaterialID, color, true);\n                    accumulatedColor += accumulatedColorMultiplier * fresnelFactor * color;\n                }\n                else\n                {\n                    accumulatedColor += fresnelFactor * accumulatedColorMultiplier * GetSkyColor(rayDirection);\n\n                }\n                accumulatedColorMultiplier *= (1.0 - fresnelFactor);\n                #endif\n                \n                rayDirection = refract(rayDirection, exitNormal, WaterIor / AIR_IOR);\n                rayOrigin = marchPosition;\n                t = IntersectOpaqueScene(marchPosition, rayDirection, materialID);\n                if( materialID != INVALID_OBJECT_ID )\n                {\n                    opaquePosition = rayOrigin + t*rayDirection;\n                }\n                outsideVolume = true;\n            }\n\n            if(!intersectFound)\n            {\n                float t = GetApproximateIntersect(marchPosition, rayDirection);\n                float halfT = t / 2.0;\n                vec3 halfwayPosition = marchPosition + rayDirection * halfT;\n                vec3 shadowFactor = GetApproximateShadowFactor(halfwayPosition, GetSunLightDirection());\n\n                vec3 previousLightFactor = accumulatedColorMultiplier;\n                accumulatedColorMultiplier *= BeerLambert(WaterAbsorption / WaterColor, t);\n                vec3 absorptionFromMarch = previousLightFactor - accumulatedColorMultiplier;\n                accumulatedColor += accumulatedColorMultiplier * WaterColor * shadowFactor * absorptionFromMarch * GetSunLightColor();\n                accumulatedColor += accumulatedColorMultiplier * WaterColor * GetAmbientSkyColor() * absorptionFromMarch;\n\n                volumeDepth += t;\n                rayOrigin = rayOrigin + volumeDepth*rayDirection;\n            }\n        }\n    }\n    \n    vec3 opaqueColor = vec3(0.0f);\n    if(materialID != INVALID_OBJECT_ID)\n    {\n        CalculateLighting(opaquePosition,\n                          rayDirection,\n                          materialID, opaqueColor,\n                          false);\n    }\n    else\n    {\n        opaqueColor = GetSkyColor(rayDirection);\n    }\n    \n    return accumulatedColor + accumulatedColorMultiplier * opaqueColor;\n}\n\nmat3 GetViewMatrix(float xRotationFactor)\n{ \n   float xRotation = ((1.0 - xRotationFactor) - 0.5) * PI * 0.2;\n   return mat3( cos(xRotation), 0.0, sin(xRotation),\n                0.0,           1.0, 0.0,    \n                -sin(xRotation),0.0, cos(xRotation));\n}\n\nfloat GetRotationFactor()\n{\n    return iMouse.x / iResolution.x;\n}\n\nbool IsInputThread(in vec2 fragCoord)\n{\n    return ALLOW_KEYBOARD_INPUT != 0 && int(fragCoord.x) == 0 && int(fragCoord.y) == 0;\n}\n   \n\nbool KeyDown(int char)\n{\n    return int(texelFetch(iChannel1, ivec2(char, 0), 0).x) > 0;\n}\n\nvoid ProcessInput()\n{\n    const float WaterIorChangeRate = 0.35;\n\tif(KeyDown(87)) WaterIor += WaterIorChangeRate * iTimeDelta;\n    if(KeyDown(83)) WaterIor -= WaterIorChangeRate * iTimeDelta;\n    WaterIor = clamp(WaterIor, 1.0, 1.8);\n    \n    const float WaterTurbulanceChangeRate = 7.0;\n\tif(KeyDown(69)) WaterTurbulence += WaterTurbulanceChangeRate * iTimeDelta;\n    if(KeyDown(68)) WaterTurbulence -= WaterTurbulanceChangeRate * iTimeDelta;\n    WaterTurbulence = clamp(WaterTurbulence, 0.0, 50.0);\n       \n    const float WaterAbsorptionChangeRate = 0.03;\n\tif(KeyDown(81)) WaterAbsorption += WaterAbsorptionChangeRate * iTimeDelta;\n    if(KeyDown(65)) WaterAbsorption -= WaterAbsorptionChangeRate * iTimeDelta;\n    WaterAbsorption = clamp(WaterAbsorption, 0.0, 1.0);\n    \n    const float ColorChangeRate = 0.5;\n\tif(KeyDown(89)) WaterColor.r += ColorChangeRate * iTimeDelta;\n    if(KeyDown(72)) WaterColor.r -= ColorChangeRate * iTimeDelta;\n    \n    if(KeyDown(85)) WaterColor.g += ColorChangeRate * iTimeDelta;\n    if(KeyDown(74)) WaterColor.g -= ColorChangeRate * iTimeDelta;\n    \n    if(KeyDown(73)) WaterColor.b += ColorChangeRate * iTimeDelta;\n    if(KeyDown(75)) WaterColor.b -= ColorChangeRate * iTimeDelta;\n    \n    WaterColor = clamp(WaterColor, 0.05, 0.99);\n}\n\nfloat EncodeWaterColor()\n{\n    return float(\n        int(WaterColor.r * 64.0) + \n        (int(WaterColor.g * 64.0) << 6) +\n        (int(WaterColor.b * 64.0) << 12)); \n}\n\nvoid DecodeWaterColor(float data)\n{\n    WaterColor.r = float(int(data) & 63) / 64.0;\n    WaterColor.g = float((int(data) >> 6) & 63) / 64.0;\n\tWaterColor.b = float((int(data) >> 12) & 63) / 64.0;\n}\n\nvoid LoadConstants()\n{\n    if(iFrame == 0 || KeyDown(82) || ALLOW_KEYBOARD_INPUT == 0)\n    {\n        WaterColor = vec3(0.1, 0.82, 1.0);\n        WaterIor = 1.33; // Actual IOR of water\n        WaterTurbulence = 2.5;\n        WaterAbsorption = 0.028;\n    }\n    else\n    {\n        vec4 data = texelFetch(iChannel0, ivec2(0, 0), 0);\n        WaterIor = data.r;\n        WaterTurbulence = data.g;\n        WaterAbsorption = data.b;\n        DecodeWaterColor(data.a);\n    }\n}\n     \nvec3 GammaCorrect(vec3 color) \n{\n    return pow(color, vec3(1.0/2.2));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    LoadConstants();\n    \n    // Sacrafice 1 pixel so that we can save up updates from input\n    if(IsInputThread(fragCoord))\n    {\n        ProcessInput();\n        fragColor = vec4(WaterIor, WaterTurbulence, WaterAbsorption, EncodeWaterColor());\n        return;\n    }\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float aspectRatio = iResolution.x /  iResolution.y; \n    float lensWidth = Camera.LensHeight * aspectRatio;\n    \n    vec3 NonNormalizedCameraView = Camera.LookAt - Camera.Position;\n    float ViewLength = length(NonNormalizedCameraView);\n    vec3 CameraView = NonNormalizedCameraView / ViewLength;\n\n    vec3 lensPoint = Camera.Position;\n    \n    // Pivot the camera around the look at point\n    float rotationFactor = GetRotationFactor();\n    mat3 viewMatrix = GetViewMatrix(rotationFactor);\n    CameraView = CameraView * viewMatrix;\n    lensPoint = Camera.LookAt - CameraView * ViewLength;\n    \n    vec3 CameraRight = cross(CameraView, vec3(0, 1, 0));    \n    vec3 CameraUp = cross(CameraRight, CameraView);\n\n    vec3 focalPoint = lensPoint - Camera.FocalDistance * CameraView;\n    lensPoint += CameraRight * (uv.x * 2.0 - 1.0) * lensWidth / 2.0;\n    lensPoint += CameraUp * (uv.y * 2.0 - 1.0) * Camera.LensHeight / 2.0;\n    \n    vec3 rayOrigin = focalPoint;\n    vec3 rayDirection = normalize(lensPoint - focalPoint);\n    \n    vec3 color = Render(rayOrigin, rayDirection);\n    fragColor=vec4(GammaCorrect(color), 1.0 );\n}\n",
   "name": "Buffer A",
   "description": "",
   "type": "buffer"
  }
 ]
}