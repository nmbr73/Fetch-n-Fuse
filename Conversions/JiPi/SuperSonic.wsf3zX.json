{"Shader":{"ver":"0.1","info":{"id":"wsf3zX","date":"1547016401","viewed":854,"name":"Super Sonic","username":"wyatt","description":"Airfoil accelerates to supersonic speeds.\nYou can set the Mach number to whatever you want in the common tab. \nIn order to accommodate super sonic flow, the simulation is quite viscous. \nAdvection is computed separately\nMouse to reset.","likes":21,"published":3,"flags":32,"usePreview":0,"tags":["test"],"hasliked":0},"renderpass":[{"inputs":[{"id":26,"src":"\/media\/a\/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","ctype":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":259,"src":"\/media\/previz\/buffer02.png","ctype":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":37,"channel":0}],"code":"vec2 R;\nvec4 T ( vec2 U ) {return texture(iChannel0,U\/R);}\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    R = iResolution.xy;\n    vec4 \n        o = T(U),\n        a = T(U+vec2(1,0)),\n        b = T(U-vec2(1,0)),\n        c = T(U+vec2(0,1)),\n        d = T(U-vec2(0,1));\n        \n    vec4 g = vec4(a.zw-b.zw,c.zw-d.zw);\n    vec2 dz = g.xz;\n    vec2 dw = g.yw;\n    vec3 n = normalize(vec3(dz,.05));\n    vec4 tx = texture(iChannel2,reflect(vec3(0,0,1),n));\n    C = abs(cos(o.w*vec4(140,162,175,20)))*(0.7+0.3*tx);\n    vec2 u = U;\n    for (int i = 0; i < 50; i++) {\n        U -= T(U).xy;\n    }\n    U.x-= float(iFrame)*Mach_Number;\n    U = sin(U*.2);\n    vec2 w=fwidth(U)*1.2;\n    C *= smoothstep(-w.x,w.x,abs(U.x))*smoothstep(-w.y,w.y,abs(U.y));\n    U = u;\n   float t = 0.5+0.3*sin(iTime);\n   if (iMouse.z > 0.) t = 0.5+0.3*(iMouse.y\/R.y*2.-1.);\n   float si = sin(t), co = cos(t);\n   mat2 ro = mat2(co,-si,si,co);\n   U = (U-vec2(0.25,0.5)*R)*ro;\n   U.x *= 0.1;\n   U.y -= 20.*exp(-3e-2*U.x*U.x);\n   if (length(U) < 6.) {\n    \tC = abs(sin(10.*o.w+o.z*vec4(1,2,5,4)));\n   }\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":260,"src":"\/media\/previz\/buffer03.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":257,"channel":0}],"code":"\/\/ Fluid\nvec2 R;\nvec4 T (vec2 U) { return texture(iChannel0,U\/R);}\nvec4 X (vec2 U, in vec4 C, vec2 r) {\n\tvec4 n = T(U+r); \/\/ neighbor\n    vec2 rp = vec2(-r.y,r.x); \/\/ perpiduclar to r\n    return vec4(\n        \t r *(n.z-C.z) + \/\/ pressure term\n             rp*(n.w*C.w) + \/\/ spin term \n        \t mix(C.xy,n.xy,0.3),\/\/viscous term\n        dot(r ,n.xy-C.xy)+n.z, \/\/ pressure calculation\n    \tdot(rp,n.xy-C.xy)-(n.w));\/\/ spin calculation\n    \n}\nvoid mainImage( out vec4 C, in vec2 U )\n{\n   R = iResolution.xy;\n   C = T(U);\n   float r2 = sqrt(2.)*0.5; \/\/ without renormalization, the neighborhood needs to be equidistant to the cell\n   \/\/ calculate the sum of all neighbor interactions\n   C = X(U,C,vec2( 1, 0)) + \n       X(U,C,vec2( 0, 1))+\n       X(U,C,vec2(-1, 0))+\n       X(U,C,vec2( 0,-1))+\n       X(U,C,vec2( r2, r2))+\n       X(U,C,vec2(-r2, r2))+\n       X(U,C,vec2(-r2,-r2))+\n       X(U,C,vec2( r2,-r2));\n   C \/= 8.; \/\/ divide by the neighborhood size\n  \t\n    \n    \n   if (iFrame < 1||U.x < 4.||R.x-U.x < 4.)\n       C = vec4(Mach_Number,0,0,0);\n   if (U.y < 4.||R.y-U.y < 4.) C.w = 0.;\n   if (iFrame < 1) C.x = 0.;\n   float t = 0.5+0.3*sin(iTime);\n   if (iMouse.z > 0.) t = 0.5+0.3*(iMouse.y\/R.y*2.-1.);\n   float si = sin(t), co = cos(t);\n   mat2 ro = mat2(co,-si,si,co);\n   U = (U-vec2(0.25,0.5)*R)*ro;\n   U.x *= 0.1;\n   U.y -= 20.*exp(-3e-2*U.x*U.x);\n   if (length(U) < 6.) C.xy *= 0.;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":258,"channel":0}],"code":"\/\/ Advection Step\nvec2 R;\nvec4 T (vec2 U) {return texture(iChannel0,U\/R);}\nvoid mainImage( out vec4 C, in vec2 U )\n{\n   R = iResolution.xy;\n   #define N 16.\n   for (float i = 0.; i < N; i++)\n       U -= T(U).xy\/N;\n   C = T(U);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":258,"src":"\/media\/previz\/buffer01.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":259,"channel":0}],"code":"\/\/ Fluid\nvec2 R;\nvec4 T (vec2 U) { return texture(iChannel0,U\/R);}\nvec4 X (vec2 U, in vec4 C, vec2 r) {\n\tvec4 n = T(U+r); \/\/ neighbor\n    vec2 rp = vec2(-r.y,r.x); \/\/ perpiduclar to r\n    return vec4(\n        \t r *(n.z-C.z) + \/\/ pressure term\n             rp*(n.w*C.w) + \/\/ spin term \n        \t mix(C.xy,n.xy,0.3),\/\/viscous term\n        dot(r ,n.xy-C.xy)+n.z, \/\/ pressure calculation\n    \tdot(rp,n.xy-C.xy)-(n.w));\/\/ spin calculation\n    \n}\nvoid mainImage( out vec4 C, in vec2 U )\n{\n   R = iResolution.xy;\n   C = T(U);\n   float r2 = sqrt(2.)*0.5; \/\/ without renormalization, the neighborhood needs to be equidistant to the cell\n   \/\/ calculate the sum of all neighbor interactions\n   C = X(U,C,vec2( 1, 0)) + \n       X(U,C,vec2( 0, 1))+\n       X(U,C,vec2(-1, 0))+\n       X(U,C,vec2( 0,-1))+\n       X(U,C,vec2( r2, r2))+\n       X(U,C,vec2(-r2, r2))+\n       X(U,C,vec2(-r2,-r2))+\n       X(U,C,vec2( r2,-r2));\n   C \/= 8.; \/\/ divide by the neighborhood size\n  \t\n    \n    \n   if (iFrame < 1||U.x < 4.||R.x-U.x < 4.)\n       C = vec4(Mach_Number,0,0,0);\n   if (U.y < 4.||R.y-U.y < 4.) C.w = 0.;\n   if (iFrame < 1) C.x = 0.;\n   float t = 0.5+0.3*sin(iTime);\n   if (iMouse.z > 0.) t = 0.5+0.3*(iMouse.y\/R.y*2.-1.);\n   float si = sin(t), co = cos(t);\n   mat2 ro = mat2(co,-si,si,co);\n   U = (U-vec2(0.25,0.5)*R)*ro;\n   U.x *= 0.1;\n   U.y -= 20.*exp(-3e-2*U.x*U.x);\n   if (length(U) < 6.) C.xy *= 0.;\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":259,"src":"\/media\/previz\/buffer02.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":260,"channel":0}],"code":"\/\/ Advection Step\nvec2 R;\nvec4 T (vec2 U) {return texture(iChannel0,U\/R);}\nvoid mainImage( out vec4 C, in vec2 U )\n{\n   R = iResolution.xy;\n   #define N 16.\n   for (float i = 0.; i < N; i++)\n       U -= T(U).xy\/N;\n   C = T(U);\n}","name":"Buffer D","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define Mach_Number 1.\n","name":"Common","description":"","type":"common"}]}}