{
 "ver": "0.1",
 "info": {
  "id": "slcXRX",
  "date": "0",
  "viewed": 0,
  "name": "NavierStokeish JiPi",
  "description": "Sortiert",
  "likes": 0,
  "published": "Private",
  "usePreview": 0,
  "tags": [
   "2d",
   "vector"
  ],
  "hasliked": 0,
  "parentid": "",
  "parentname": ""
 },
 "renderpass": [
  {
   "inputs": [
    {
     "id": "4dXGR8",
     "filepath": "/media/previz/buffer00.png",
     "type": "buffer",
     "channel": 2,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    },
    {
     "id": "XsXGR8",
     "filepath": "/media/previz/buffer01.png",
     "type": "buffer",
     "channel": 0,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    },
    {
     "id": "4sXGR8",
     "filepath": "/media/previz/buffer02.png",
     "type": "buffer",
     "channel": 3,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    }
   ],
   "outputs": [
    {
     "id": "4dfGRr",
     "channel": 0
    }
   ],
   "code": "#ifdef FAKETHREED\n\nstruct C_Sample\n{\n\tvec3 vAlbedo;\n\tvec3 vNormal;\n};\n\t\nC_Sample SampleMaterial(const in vec2 vUV, sampler2D sampler,  const in vec2 vTextureSize, const in float fNormalScale)\n{\n\tC_Sample result;\n\t\n\tvec2 vInvTextureSize = vec2(1.0) / vTextureSize;\n\t\n\tvec3 cSampleNegXNegY = texture(sampler, vUV + (vec2(-1.0, -1.0)) * vInvTextureSize.xy).rgb;\n\tvec3 cSampleZerXNegY = texture(sampler, vUV + (vec2( 0.0, -1.0)) * vInvTextureSize.xy).rgb;\n\tvec3 cSamplePosXNegY = texture(sampler, vUV + (vec2( 1.0, -1.0)) * vInvTextureSize.xy).rgb;\n\t\n\tvec3 cSampleNegXZerY = texture(sampler, vUV + (vec2(-1.0, 0.0)) * vInvTextureSize.xy).rgb;\n\tvec3 cSampleZerXZerY = texture(sampler, vUV + (vec2( 0.0, 0.0)) * vInvTextureSize.xy).rgb;\n\tvec3 cSamplePosXZerY = texture(sampler, vUV + (vec2( 1.0, 0.0)) * vInvTextureSize.xy).rgb;\n\t\n\tvec3 cSampleNegXPosY = texture(sampler, vUV + (vec2(-1.0,  1.0)) * vInvTextureSize.xy).rgb;\n\tvec3 cSampleZerXPosY = texture(sampler, vUV + (vec2( 0.0,  1.0)) * vInvTextureSize.xy).rgb;\n\tvec3 cSamplePosXPosY = texture(sampler, vUV + (vec2( 1.0,  1.0)) * vInvTextureSize.xy).rgb;\n\n\t// convert to linear\t\n\tvec3 cLSampleNegXNegY = cSampleNegXNegY * cSampleNegXNegY;\n\tvec3 cLSampleZerXNegY = cSampleZerXNegY * cSampleZerXNegY;\n\tvec3 cLSamplePosXNegY = cSamplePosXNegY * cSamplePosXNegY;\n\n\tvec3 cLSampleNegXZerY = cSampleNegXZerY * cSampleNegXZerY;\n\tvec3 cLSampleZerXZerY = cSampleZerXZerY * cSampleZerXZerY;\n\tvec3 cLSamplePosXZerY = cSamplePosXZerY * cSamplePosXZerY;\n\n\tvec3 cLSampleNegXPosY = cSampleNegXPosY * cSampleNegXPosY;\n\tvec3 cLSampleZerXPosY = cSampleZerXPosY * cSampleZerXPosY;\n\tvec3 cLSamplePosXPosY = cSamplePosXPosY * cSamplePosXPosY;\n\n\t// Average samples to get albdeo colour\n\tresult.vAlbedo = ( cLSampleNegXNegY + cLSampleZerXNegY + cLSamplePosXNegY \n\t\t    \t     + cLSampleNegXZerY + cLSampleZerXZerY + cLSamplePosXZerY\n\t\t    \t     + cLSampleNegXPosY + cLSampleZerXPosY + cLSamplePosXPosY ) / 9.0;\t\n\t\n\tvec3 vScale = vec3(0.3333);\n\t\n\t#ifdef USE_LINEAR_FOR_BUMPMAP\n\t\t\n\t\tfloat fSampleNegXNegY = dot(cLSampleNegXNegY, vScale);\n\t\tfloat fSampleZerXNegY = dot(cLSampleZerXNegY, vScale);\n\t\tfloat fSamplePosXNegY = dot(cLSamplePosXNegY, vScale);\n\t\t\n\t\tfloat fSampleNegXZerY = dot(cLSampleNegXZerY, vScale);\n\t\tfloat fSampleZerXZerY = dot(cLSampleZerXZerY, vScale);\n\t\tfloat fSamplePosXZerY = dot(cLSamplePosXZerY, vScale);\n\t\t\n\t\tfloat fSampleNegXPosY = dot(cLSampleNegXPosY, vScale);\n\t\tfloat fSampleZerXPosY = dot(cLSampleZerXPosY, vScale);\n\t\tfloat fSamplePosXPosY = dot(cLSamplePosXPosY, vScale);\n\t\n\t#else\n\t\n\t\tfloat fSampleNegXNegY = dot(cSampleNegXNegY, vScale);\n\t\tfloat fSampleZerXNegY = dot(cSampleZerXNegY, vScale);\n\t\tfloat fSamplePosXNegY = dot(cSamplePosXNegY, vScale);\n\t\t\n\t\tfloat fSampleNegXZerY = dot(cSampleNegXZerY, vScale);\n\t\tfloat fSampleZerXZerY = dot(cSampleZerXZerY, vScale);\n\t\tfloat fSamplePosXZerY = dot(cSamplePosXZerY, vScale);\n\t\t\n\t\tfloat fSampleNegXPosY = dot(cSampleNegXPosY, vScale);\n\t\tfloat fSampleZerXPosY = dot(cSampleZerXPosY, vScale);\n\t\tfloat fSamplePosXPosY = dot(cSamplePosXPosY, vScale);\t\n\t\n\t#endif\n\t\n\t// Sobel operator - http://en.wikipedia.org/wiki/Sobel_operator\n\t\n\tvec2 vEdge;\n\tvEdge.x = (fSampleNegXNegY - fSamplePosXNegY) * 0.25 \n\t\t\t+ (fSampleNegXZerY - fSamplePosXZerY) * 0.5\n\t\t\t+ (fSampleNegXPosY - fSamplePosXPosY) * 0.25;\n\n\tvEdge.y = (fSampleNegXNegY - fSampleNegXPosY) * 0.25 \n\t\t\t+ (fSampleZerXNegY - fSampleZerXPosY) * 0.5\n\t\t\t+ (fSamplePosXNegY - fSamplePosXPosY) * 0.25;\n\n\tresult.vNormal = normalize(vec3(vEdge * fNormalScale, 1.0));\t\n\t\n\treturn result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 vUV = fragCoord.xy / iResolution.xy;\n\t\n\tC_Sample materialSample;\n\t\t\n\tfloat fNormalScale = 10.0;\n\tmaterialSample = SampleMaterial( vUV, iChannel0, iChannelResolution[0].xy, fNormalScale );\n\t\n\t// Random Lighting...\n\t\n\tfloat fLightHeight = 0.2;\n\tfloat fViewHeight = 2.0;\n\t\n\tvec3 vSurfacePos = vec3(vUV, 0.0);\n\t\n\tvec3 vViewPos = vec3(0.5, 0.5, fViewHeight);\n\t\t\t\n\tvec3 vLightPos = vec3( vec2(sin(iTime),cos(iTime)) * 0.25 + 0.5 , fLightHeight);\n\t\t\n\tif( iMouse.z > 0.0 )\n\t{\n\t\tvLightPos = vec3(iMouse.xy / iResolution.xy, fLightHeight);\n\t}\n\t\n\tvec3 vDirToView = normalize( vViewPos - vSurfacePos );\n\tvec3 vDirToLight = normalize( vLightPos - vSurfacePos );\n\t\t\n\tfloat fNDotL = clamp( dot(materialSample.vNormal, vDirToLight), 0.0, 1.0);\n\tfloat fDiffuse = fNDotL;\n\t\n\tvec3 vHalf = normalize( vDirToView + vDirToLight );\n\tfloat fNDotH = clamp( dot(materialSample.vNormal, vHalf), 0.0, 1.0);\n\tfloat fSpec = pow(fNDotH, 10.0) * fNDotL * 0.5;\n\t\n\tvec3 vResult = materialSample.vAlbedo * fDiffuse + fSpec;\n\t\n\tvResult = sqrt(vResult);\n\t\n\t#ifdef SHOW_NORMAL_MAP\n\tvResult = materialSample.vNormal * 0.5 + 0.5;\n\t#endif\n\t\n\t#ifdef SHOW_ALBEDO\n\tvResult = sqrt(materialSample.vAlbedo);\n\t#endif\n\t\n\tfragColor = vec4(vResult,1.0);\n}\n\n#else\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.xy;\n\n    #ifdef WATERPAINTING\n    \n    fragColor = texture( iChannel0, uv );\n    \n    #else \n    \n    fragColor = texture( iChannel0, uv );// * vec4( 0.5, 0.2, 2.0, 1.0 );\n    \n    #endif\n    \n    //fragColor += 0.2 * texture( iChannel1, uv );// * vec4( 1.5, 0.1, 0.3, 1 );\n    \n}\n\n#endif",
   "name": "Image",
   "description": "",
   "type": "image"
  },
  {
   "inputs": [],
   "outputs": [],
   "code": "// Undefine the next line for camera input.\n//#define WATERPAINTING\n// Heavily bitting P_Malin's https://www.shadertoy.com/view/XdlGz8 for the fake 3D effect.\n#define FAKETHREED\nconst float forceVector = 10.0;\nconst float forceColour = 10.0;\nconst float dx = 0.5;\nconst float dt = dx * dx * 0.5;\nconst float siz = 0.05;\nconst float di = 1.25;\nconst float alp = ( dx * dx ) / dt;\nconst float rbe = 1.0 / ( 4.0 + alp );\nconst float vo = 10.0;\nconst float vf = 0.0025;\nconst float mul = 10.0;\nconst float e = 0.05;\n\nfloat dis( vec2 uv, vec2 mou )\n{\n\n    return length( uv - mou );\n\n}\n\nfloat cir( vec2 uv, vec2 mou, float r )\n{\n\n    float o = smoothstep( r, r - 0.05, dis( uv, mou ) );\n    \n    return o;\n\n}\n",
   "name": "Common",
   "description": "",
   "type": "common"
  },
  {
   "inputs": [
    {
     "id": "4dXGRr",
     "filepath": "/presets/tex00.jpg",
     "type": "keyboard",
     "channel": 3,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    },
    {
     "id": "4dXGR8",
     "filepath": "/media/previz/buffer00.png",
     "type": "buffer",
     "channel": 0,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    },
    {
     "id": "XsXGR8",
     "filepath": "/media/previz/buffer01.png",
     "type": "buffer",
     "channel": 1,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    },
    {
     "id": "4sXGR8",
     "filepath": "/media/previz/buffer02.png",
     "type": "buffer",
     "channel": 2,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    }
   ],
   "outputs": [
    {
     "id": "4dXGR8",
     "channel": 0
    }
   ],
   "code": "#define keyTex iChannel3\n#define KEY_I texture(keyTex,vec2((105.5-32.0)/256.0,(0.5+0.0)/3.0)).x\n\nconst float arrow_density = 0.2;\nconst float arrow_length = 0.95;\n\nconst vec3 luma = vec3(0.2126, 0.7152, 0.0722);\n\nfloat segm(in vec2 p, in vec2 a, in vec2 b) //from iq\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp(dot(pa,ba)/dot(ba,ba), 0., 1.);\n\treturn length(pa - ba*h)*20.*arrow_density;\n}\n\nfloat cur( vec2 uv )\n{\n    \n    float xpi = 1.0 / iResolution.x;\n    float ypi = 1.0 / iResolution.y;\n    \n    float x = uv.x;\n    float y = uv.y;\n    \n    float top = texture( iChannel0, vec2( x, y + ypi ) ).r;\n    float lef = texture( iChannel0, vec2( x - xpi, y ) ).r;\n    float rig = texture( iChannel0, vec2( x + xpi, y ) ).r;\n    float dow = texture( iChannel0, vec2( x, y - ypi ) ).r;\n    \n    float dY = ( top - dow ) * 0.5;\n    float dX = ( rig - lef ) * 0.5;\n    \n    return dX * dY;\n}\n\nvec2 vor( vec2 uv )\n{\n    \n    vec2 pre = uv;\n    \n    float xpi = 1.0 / iResolution.x;\n    float ypi = 1.0 / iResolution.y;\n    \n    float x = uv.x;\n    float y = uv.y;\n\n    vec2 dir = vec2( 0 );\n    dir.y = ( cur( vec2( x, y + ypi ) ) ) - ( cur( vec2( x, y - ypi ) ) );\n    dir.x = ( cur( vec2( x + xpi, y ) ) ) - ( cur( vec2( x - xpi, y ) ) );\n    \n    dir = normalize( dir );\n    \n    if( length( dir ) > 0.0 )\n    \n    uv -= dt * vo * cur( uv ) * dir;\n    \n    return uv;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.y;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 mou = iMouse.xy / iResolution.y;\n    p *= mul;\n    mou *= mul;\n    \n    float fO = 0.0;\n    fO += texture( iChannel1, vor( uv ) ).r + texture( iChannel1, vor( uv ) ).g + texture( iChannel1, vor( uv ) ).b;\n   \tfO *= 0.333;\n    \n    vec2 ep = vec2( e, 0 );\n    vec2 rz= vec2( 0 );\n    vec2 fra = fract( uv );\n\n    float t0 = 0.0, t1 = 0.0, t2 = 0.0;\n    t0 += texture( iChannel0, uv ).a * dt * vf;\n    t1 += texture( iChannel0, uv + ep.xy ).a * dt * vf;\n    t2 += texture( iChannel0, uv + ep.yx ).a * dt * vf;\n    vec2 g = vec2( ( t1 - t0 ), ( t2 - t0 ) ) / ep.xx;\n    vec2 t = vec2( -g.y, g.x );\n\n    p += 0.9 * t + g * 0.3;\n    rz += t;\n    \n    vec2 fld = rz;\n    \n    if( cir( p, mou, siz * mul ) > 0.1 && iMouse.z > 0.5 )\n            \n        fld += forceVector * texture( iChannel2, uv ).xy;\n    \n    float o = 0.0;\n    \n    if( iFrame <= 4 || KEY_I < 0.5 )\n    \n    o = texture( iChannel0, uv ).a * 0.99;\n    \n    fO += o;\n    \n    if( uv.y < 0.00 || uv.x < 0.00 || uv.x > 1.0 || uv.y > 1.0 ) o *= 0.0;\n    \n    fragColor = vec4( 0, fld, fO );\n    \n}",
   "name": "Buffer A",
   "description": "",
   "type": "buffer"
  },
  {
   "inputs": [
    {
     "id": "4dfGRn",
     "filepath": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg",
     "type": "texture",
     "channel": 2,
     "sampler": {
      "filter": "mipmap",
      "wrap": "repeat",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    },
    {
     "id": "4dXGR8",
     "filepath": "/media/previz/buffer00.png",
     "type": "buffer",
     "channel": 1,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    },
    {
     "id": "XsXGR8",
     "filepath": "/media/previz/buffer01.png",
     "type": "buffer",
     "channel": 0,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    },
    {
     "id": "XdfGR8",
     "filepath": "/media/previz/buffer03.png",
     "type": "buffer",
     "channel": 3,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    }
   ],
   "outputs": [
    {
     "id": "XsXGR8",
     "channel": 0
    }
   ],
   "code": "float hash( vec2 a )\n{\n\n    return fract( sin( a.x * 3433.8 + a.y * 3843.98 ) * 45933.8 );\n\n}\n\nfloat noise( vec2 uv )\n{\n    \n    vec2 lv = fract( uv );\n    lv = lv * lv * ( 3.0 - 2.0 * lv );\n    vec2 id = floor( uv );\n    \n    float bl = hash( id );\n    float br = hash( id + vec2( 1, 0 ) );\n    float b = mix( bl, br, lv.x );\n    \n    float tl = hash( id + vec2( 0, 1 ) );\n    float tr = hash( id + vec2( 1 ) );\n    float t = mix( tl, tr, lv.x );\n    \n    float c = mix( b, t, lv.y );\n    \n    return c;\n\n}\n\nfloat fbm( vec2 uv )\n{\n\n\tfloat f = noise( uv * 4.0 );\n    f += noise( uv * 8.0 ) * 0.5;  \n    f += noise( uv * 16. ) * 0.25; \n    f += noise( uv * 32. ) * 0.125; \n    f += noise( uv * 64. ) * 0.0625;\n    f /= 2.0;\n    \n    return f;\n\n}\n\nfloat cur( vec2 uv )\n{\n    \n    float xpi = 1.0 / iResolution.x;\n    float ypi = 1.0 / iResolution.y;\n    \n    float x = uv.x;\n    float y = uv.y;\n    \n    float top = texture( iChannel0, vec2( x, y + ypi ) ).r;\n    float lef = texture( iChannel0, vec2( x - xpi, y ) ).r;\n    float rig = texture( iChannel0, vec2( x + xpi, y ) ).r;\n    float dow = texture( iChannel0, vec2( x, y - ypi ) ).r;\n    \n    float dY = ( top - dow ) * 0.5;\n    float dX = ( rig - lef ) * 0.5;\n    \n    return dX * dY;\n}\n\nvec2 vor( vec2 uv )\n{\n    \n    vec2 pre = uv;\n    \n    float xpi = 1.0 / iResolution.x;\n    float ypi = 1.0 / iResolution.y;\n    \n    float x = uv.x;\n    float y = uv.y;\n\n    vec2 dir = vec2( 0 );\n    dir.y = ( cur( vec2( x, y + ypi ) ) ) - ( cur( vec2( x, y - ypi ) ) );\n    dir.x = ( cur( vec2( x + xpi, y ) ) ) - ( cur( vec2( x - xpi, y ) ) );\n    \n    dir = normalize( dir );\n    \n    if( length( dir ) > 0.0 )\n    \n    uv -= dt * vo * cur( uv ) * dir;\n    \n    return uv;\n    \n}\n\nvec2 dif( vec2 uv )\n{\n\n    float xpi = 1.0 / iResolution.x;\n    float ypi = 1.0 / iResolution.y;\n    \n    float x = uv.x;\n    float y = uv.y;\n    \n    vec2 cen = texture( iChannel0, uv ).xy;\n    vec2 top = texture( iChannel0, vec2( x, y + ypi ) ).xy;\n    vec2 lef = texture( iChannel0, vec2( x - xpi, y ) ).xy;\n    vec2 rig = texture( iChannel0, vec2( x + xpi, y ) ).xy;\n    vec2 dow = texture( iChannel0, vec2( x, y - ypi ) ).xy;\n    \n    return ( di * rbe ) * ( top + lef + rig + dow + alp * cen ) * rbe;\n    \n}\n\nvec2 adv( vec2 uv )\n{\n    \n    // Eulerian.\n    vec2 pre = texture( iChannel1, vor( uv ) ).yz;\n    pre = iTimeDelta * dt * pre;\n    \n    uv -= pre;\n    \n    return uv;\n    \n}\n\nvec4 forc( vec2 uv, vec2 p, vec2 mou, sampler2D tex, out float cen )\n{\n    \n    vec4 col = vec4( 0 );\n    \n    #ifdef WATERPAINTING\n    \n    if( iFrame <= 10 )\n    \n    col += 0.2 * texture( iChannel2, uv );\n    \n    if( iMouse.z > 0.5 )\n\tcol += cir( p, mou, siz );\n    \n    #else\n    float tim = iTime * 0.1;\n    if( iMouse.z > 0.5 && cir( p, mou, siz ) > 0.1 )\n\tcol += forceColour * vec4( noise( uv + tim ), noise( uv + tim + 1.0 ), noise( uv + tim + 2.0 ), 1 );\n    \n    #endif\n    \n    return col;\n\n}\n\nvec2 div( vec2 uv, vec2 p, vec2 mou )\n{\n    \n    float xpi = 1.0 / iResolution.x;\n    float ypi = 1.0 / iResolution.y;\n    \n    float x = uv.x;\n    float y = uv.y;\n    \n    float cen = texture( iChannel0, uv ).a;\n    float top = texture( iChannel0, vec2( x, y + ypi ) ).r;\n    float lef = texture( iChannel0, vec2( x - xpi, y ) ).r;\n    float rig = texture( iChannel0, vec2( x + xpi, y ) ).r;\n    float dow = texture( iChannel0, vec2( x, y - ypi ) ).r;\n    \n    float dX = dt * ( rig - lef ) * 0.5;\n    float dY = dt * ( top - dow ) * 0.5;\n    \n    vec2 vel = vec2( 0 );\n    \n    if( iMouse.z > 0.5 && cir( p, mou, siz ) > 0.1 )\n    \n    vel = forceVector * texture( iChannel3, uv ).xy;\n    \n    return vec2( dX, dY ) + vel;\n\n}\n\nvec2 pre( vec2 uv, vec2 p, vec2 mou )\n{\n\n    vec2 pre = uv;\n    \n    uv -= ( di * dx * dx ) * div( uv, p, mou );\n    \n    return uv;\n\n}\n\nvec2 vel( vec2 uv, vec2 p, vec2 mou )\n{\n    \n    vec2 pr = pre( uv, p, mou );\n    vec2 die = div( uv, p, mou );\n    \n    uv += dt * die - pr;\n   \n    return uv;\n    \n}\n\nvec4 jac( vec2 uv, vec2 p, vec2 mou, out float cen )\n{\n\n    vec4 col = vec4( 0.0 ); float dam = 1.0; vec4 colO = vec4( 0 ); vec2 pre = uv;\n    \n    vec2 tem = uv;\n \n    uv = adv( uv );\n    uv -= dt * ( vel( uv, p, mou ) * dif( uv ) );\n    col += forc( uv, p, mou, iChannel0, cen );\n    colO = texture( iChannel0, uv ) + col * dt;\n    colO *= 0.99;\n    \n    if( pre.y < 0.01 || pre.x < 0.01 || pre.x > 1.0 || pre.y > 1.0 ) colO *= 0.0;\n    \n    return colO;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 p = fragCoord / iResolution.y;\n\n    vec2 mou = iMouse.xy / iResolution.y;\n    \n    float ini = 0.0;\n    \n    float cen = 0.0;\n    \n    vec4 colO = jac( uv, p, mou, cen );\n    \n    fragColor = colO;\n    \n}",
   "name": "Buffer B",
   "description": "",
   "type": "buffer"
  },
  {
   "inputs": [
    {
     "id": "XsXGR8",
     "filepath": "/media/previz/buffer01.png",
     "type": "buffer",
     "channel": 1,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    },
    {
     "id": "4sXGR8",
     "filepath": "/media/previz/buffer02.png",
     "type": "buffer",
     "channel": 0,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    }
   ],
   "outputs": [
    {
     "id": "4sXGR8",
     "channel": 0
    }
   ],
   "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 p = fragCoord / iResolution.y;\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 mou = iMouse.xy / iResolution.y;\n    vec2 last = textureLod( iChannel0, uv, 0.0 ).zw;\n    \n    vec2 acc = vec2( 0 );\n    \n    if( cir( p, mou, siz ) > 0.05 )\n    \n    \tacc += ( mou - last ) * forceVector;\n    \n    fragColor = vec4( acc, mou );\n    \n}",
   "name": "Buffer C",
   "description": "",
   "type": "buffer"
  }
 ]
}