{
 "ver": "0.1",
 "info": {
  "id": "fsscDS",
  "date": "0",
  "viewed": 0,
  "name": "Fork Star Map 1 nmbr73 833",
  "description": "Procedural space background. This is a nice alternative to cube maps, which are static and require a lot of memory at the resolutions needed for representing stars. Drag to rotate.",
  "likes": 0,
  "published": "Private",
  "usePreview": 0,
  "tags": [
   "space",
   "stars",
   "nebula",
   "skybox",
   "starfield",
   "skysphere"
  ],
  "hasliked": 0,
  "parentid": "4sBXzG",
  "parentname": "Star Map 1"
 },
 "renderpass": [
  {
   "inputs": [],
   "outputs": [
    {
     "id": "4dfGRr",
     "channel": 0
    }
   ],
   "code": "// Star map shader...procedural space background\n\n// Uncomment to see the lat-long grid for context\n// #define SHOW_LARGE_GRID\n#define SHOW_SPHERE\n#define SHOW_SPHERE_GRID\n#define SHOW_PLANET\n\nconst float pi = 3.1415927;\nconst float deg = pi / 180.0;\n\n// See derivation of noise functions by Morgan McGuire at https://www.shadertoy.com/view/4dS3Wd\nconst int NUM_OCTAVES = 4;\nfloat hash(float n) { return fract(sin(n) * 1e4); }\nfloat hash(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\n// 1 octave value noise\nfloat noise(float x) { float i = floor(x); float f = fract(x); float u = f * f * (3.0 - 2.0 * f); return mix(hash(i), hash(i + 1.0), u); }\nfloat noise(vec2 x) { vec2 i = floor(x); vec2 f = fract(x);\tfloat a = hash(i); float b = hash(i + vec2(1.0, 0.0)); float c = hash(i + vec2(0.0, 1.0)); float d = hash(i + vec2(1.0, 1.0)); vec2 u = f * f * (3.0 - 2.0 * f); return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y; }\nfloat noise(vec3 x) { const vec3 step = vec3(110, 241, 171); vec3 i = floor(x); vec3 f = fract(x); float n = dot(i, step); vec3 u = f * f * (3.0 - 2.0 * f); return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x), mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y), mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x), mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z); }\n// Multi-octave value noise\nfloat NOISE(float x) { float v = 0.0; float a = 0.5; float shift = float(100); for (int i = 0; i < NUM_OCTAVES; ++i) { v += a * noise(x); x = x * 2.0 + shift; a *= 0.5; } return v; }\nfloat NOISE(vec2 x) { float v = 0.0; float a = 0.5; vec2 shift = vec2(100); mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50)); for (int i = 0; i < NUM_OCTAVES; ++i) { v += a * noise(x); x = rot * x * 2.0 + shift; a *= 0.5; } return v; }\n// Fast hash2 from https://www.shadertoy.com/view/lsfGWH\nfloat hash2(vec2 co) { return fract(sin(dot(co.xy, vec2(12.9898,78.233))) * 43758.5453); }\nfloat maxComponent(vec2 v) { return max(v.x, v.y); }\nfloat maxComponent(vec3 v) { return max(max(v.x, v.y), v.z); }\nfloat minComponent(vec2 v) { return min(v.x, v.y); }\nmat3 rotation(float yaw, float pitch) { return mat3(cos(yaw), 0, -sin(yaw), 0, 1, 0, sin(yaw), 0, cos(yaw)) * mat3(1, 0, 0, 0, cos(pitch), sin(pitch), 0, -sin(pitch), cos(pitch)); }\nfloat square(float x) { return x * x; }\n\n///////////////////////////////////////////////////////////////////////\n\n// Only globals needed for the actual spheremap\n\n// starplane was derived from https://www.shadertoy.com/view/lsfGWH\nfloat starplane(vec3 dir) { \n    float screenscale = 1.0 / iResolution.x;\n\n    // Project to a cube-map plane and scale with the resolution of the display\n    vec2 basePos = dir.xy * (0.5 / screenscale) / max(1e-3, abs(dir.z));\n         \n\tconst float largeStarSizePixels = 20.0;\n    \n    // Probability that a pixel is NOT on a large star. Must change with largeStarSizePixels\n\tconst float prob = 0.97;\n    \t\n\tfloat color = 0.0;\n\tvec2 pos = floor(basePos / largeStarSizePixels);\n\tfloat starValue = hash2(pos);\n    \n    // Big stars\n\tif (starValue > prob) {\n\n        // Sphere blobs\n\t\tvec2 delta = basePos - largeStarSizePixels * (pos + vec2(0.5));\n\t\tcolor = max(1.0 - length(delta) / (0.5 * largeStarSizePixels), 0.0);\n\t\t\n        // Star shapes\n        color *= 1.0 / max(1e-3, abs(delta.x) * abs(delta.y));\n        \n        // Avoid triplanar seams where star distort and clump\n        color *= pow(abs(dir.z), 12.0);\n    } \n\n    // Small stars\n\n    // Stabilize stars under motion by locking to a grid\n    basePos = floor(basePos);\n\n    if (hash2(basePos.xy * screenscale) > 0.997) {\n        float r = hash2(basePos.xy * 0.5);\n        color += r * (0.3 * sin(iTime * (r * 5.0) + r) + 0.7) * 1.5;\n    }\n\t\n    // Weight by the z-plane\n    return color * abs(dir.z);\n}\n\n\nfloat starbox(vec3 dir) {\n\treturn starplane(dir.xyz) + starplane(dir.yzx) + starplane(dir.zxy);\n}    \n\n\nfloat starfield(vec3 dir) {\n    return starbox(dir) + starbox(rotation(45.0 * deg, 45.0 * deg) * dir);\n}\n\n\nvec3 nebula(vec3 dir) {\n    float purple = abs(dir.x);\n    float yellow = noise(dir.y);\n    vec3 streakyHue = vec3(purple + yellow, yellow * 0.7, purple);\n    vec3 puffyHue = vec3(0.8, 0.1, 1.0);\n\n    float streaky = min(1.0, 8.0 * pow(NOISE(dir.yz * square(dir.x) * 13.0 + dir.xy * square(dir.z) * 7.0 + vec2(150.0, 2.0)), 10.0));\n    float puffy = square(NOISE(dir.xz * 4.0 + vec2(30, 10)) * dir.y);\n\n    return clamp(puffyHue * puffy * (1.0 - streaky) + streaky * streakyHue, 0.0, 1.0);\n}\n\n\nvec3 sun(vec3 d) {\n    float angle = atan(d.x, d.y);    \n    float falloff = pow(max(d.z, 0.0), 10.0);\n\tvec3 core = vec3(2.8, 1.5 + 0.5 * noise(iTime * 0.25 + d.xy * 5.0), 1.5) * falloff; \n    float corona = NOISE(vec2(d.z * 250.0 + iTime, iTime * 0.2 + angle * 50.0)) * smoothstep(0.95, 0.92, d.z) * falloff * square(d.z);\n    \n    return core * (1.0 - corona);\n}\n\n\nvec4 planet(vec3 view) {\n#ifdef SHOW_PLANET\n    const float PLANET_RADIUS = 0.65;\n    if (view.y > -PLANET_RADIUS) {\n        return vec4(0.0);\n    } \n    \n    // Compute the point on the planet sphere\n    float angle  = atan(view.x, view.z);\n    float radius = sqrt((1.0 + view.y) / (1.0 - PLANET_RADIUS));\n    \n    vec3 s = vec3(radius * normalize(view.xz), sqrt(1.0 - square(radius)));\n    \n    \n    vec3 dir = s;\n    dir = rotation(0.0, iTime * 0.01) * dir;\n    float latLongLine = 0.0;// (1.0 - pow(smoothstep(0.0, 0.04, min(abs(fract(atan(dir.y, length(dir.xz)) / (15.0 * deg)) - 0.5), abs(fract(atan(dir.x, dir.z) / (15.0 * deg)) - 0.5)) * 2.0), 10.0));\n    \n    // Antialias the edge of the planet\n    vec4 surface = vec4(1.2 * vec3(1.0, 0.3, 0.4) * \n  \t\t\t(noise(dir * 39.0 + 3.5) * 0.5 + noise(dir * 26.0) + 2.0 * noise(dir * 13.0 + 1.0)) *\n         vec3(s.yx * 0.5 + 0.5, 0.0).rbg, smoothstep(0.992, 0.988, radius));\n\n    // Keep the clouds above the planet\n    vec4 cloud = vec4(vec3(1.5),\n                      smoothstep(1.0, 0.995, radius) * \n                      square(NOISE(vec2(iTime * 0.1, 0.0) + dir.xz * 11.0 * square(dir.y) + dir.yx * 3.0 + dir.zy * 1.2)));\n    \n    return vec4(\n        mix(surface.rgb, cloud.rgb, cloud.a) * (max(0.1, s.y) * vec3(1.0 - latLongLine)),\n        max(surface.a, cloud.a));\n#else\n    return vec4(0.0);\n#endif\n}\n\n\nvec3 sphereColor(vec3 dir) {\n    vec3 n = nebula(dir);\n    vec4 p = planet(dir);\n    vec3 color = \n        sun(dir) + \n        mix(vec3(starfield(dir)) * (1.0 - maxComponent(n)) +  // Nebula holds out star\n    \t    n, // nebula\n            p.rgb, p.a); // planet\n    \n\treturn color;\n}\n\n\n////////////////////////////////////////////////////////////////////////////////////////////////////\n// Spheremap visualization code from https://www.shadertoy.com/view/4sSXzG\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float scale = 1.0 / min(iResolution.x, iResolution.y);\n\t// Of the background\n\tconst float verticalFieldOfView = 60.0 * deg;\n\tconst float insetSphereRadius = 0.22;\n\n    float yaw   = -((iMouse.x / iResolution.y) * 2.0 - 1.0) * 3.0;\n    float pitch = ((iMouse.y / iResolution.y) * 2.0 - 1.0) * 3.0;\n    \n\tvec3 dir = rotation(yaw, pitch) * normalize(vec3(fragCoord.xy - iResolution.xy / 2.0, iResolution.y / ( -2.0 * tan(verticalFieldOfView / 2.0))));\n    \n    fragColor.rgb = sphereColor(dir);\n#\tifdef SHOW_LARGE_GRID\n\t    float latLongLine = (1.0 - pow(smoothstep(0.0, 0.04, min(abs(fract(atan(dir.y, length(dir.xz)) / (15.0 * deg)) - 0.5), abs(fract(atan(dir.x, dir.z) / (15.0 * deg)) - 0.5)) * 2.0), 10.0));\n        fragColor.rgb += latLongLine * vec3(0.0, 0.7, 1.5);\n#\tendif\n    \n    \n    #ifdef SHOW_SPHERE\n    // Inset sphere\n    vec2 spherePoint = (fragCoord.xy * scale - insetSphereRadius * 1.1) / insetSphereRadius;\n    if (length(spherePoint) <= 1.0) {\n        \n        // Antialias using many samples\n        vec3 c = vec3(0);\n        for (int x = -3; x <= 3; ++x) {\n\t        for (int y = -3; y <= 3; ++y) {\n\t\t\t    vec2 s = clamp(((fragCoord.xy + vec2(x, y) / 7.0) * scale - insetSphereRadius * 1.1) / insetSphereRadius, vec2(-1.0), vec2(1.0));\n\t\t        dir = rotation(iTime, -iTime * 0.17) * vec3(s.xy, sqrt(max(0.0, 1.0 - dot(s.xy, s.xy))));\n\t\t\t\tc += sphereColor(dir);\n#\t\t\t\tifdef SHOW_SPHERE_GRID\n\t    \t\t\tfloat latLongLine = (1.0 - pow(smoothstep(0.0, 0.04, min(abs(fract(atan(dir.y, length(dir.xz)) / (15.0 * deg)) - 0.5), abs(fract(atan(dir.x, dir.z) / (15.0 * deg)) - 0.5)) * 2.0), 10.0));\n        \t\t\tc += latLongLine * vec3(0.0, 0.7, 1.5);\n#\t\t\t\tendif\n            }\n        }\n        c /= 36.0;\n                    \n        // Fade the inset sphere to antialias its border transition\n        fragColor.rgb = mix(sqrt(fragColor.rgb), c, clamp((1.0 - length(spherePoint)) * 100.0, 0.0, 1.0));\n    }\n    #endif\n    \n    fragColor.rgb = sqrt(fragColor.rgb);\n    fragColor.a = 1.0;\n}",
   "name": "Image",
   "description": "",
   "type": "image"
  }
 ]
}