--- Special purpose Fuse to support shader kernel development.
--
-- Based on the work of Chris Ridings (www.chrisridings.com), Bryan Ray (http://www.bryanray.name/wordpress/opencl-fuses-index/),
-- JiPi (https://youtu.be/dbrPWRldmbs), Igor Riđanović (https://youtu.be/p6IeeWr3FOc), and many others.
--




-- ----------------------------------------------------------------------------------------------------------------------------------------

ShaderParameters       = nil
CompatibilityCode      = nil
KernelInputCtrlDefines = nil
ConversionShaderID     = ""
ConversionFusename     = ""
ConversionKernelname   = ""
ConversionSourcecode   = ""

NUM_INPUT_CHANNELS        = 1
NUM_COLOR_CONTROLS        = 5
NUM_TINYSLIDER_CONTROLS   = 4
NUM_SMALLSLIDER_CONTROLS  = 4
-- ----------------------------------------------------------------------------------------------------------------------------------------

ConversionSourcecode_fallback = nil




-- ----------------------------------------------------------------------------------------------------------------------------------------

FuRegisterClass("ShadertoysIncubator", CT_SourceTool, {
    REGS_Name = "ShadersInc",
	  REGS_Category = "Fuses",
    REGS_OpDescription = "An Incubator for Shadertoys",
	  REGS_OpIconString = "incubus",
    REG_Source_GlobalCtrls = true,
    REG_Source_SizeCtrls = true,
    REG_Source_AspectCtrls = true,
	  REG_TimeVariant = true,
	  REGS_Company = "nmbr73",
	  REGS_URL = "https://nmbr73.github.io/",
	  REG_Version	= 000001,
    REG_Fuse_NoEdit = false,
    REG_Fuse_NoReload = false, -- true,
    })



-------------------------------------------------------------------------------------------------------------------------------------------
-- Print verbose message.
--
-- Use verbose() to print any non-error message just meant to help developing the Incubator.fuse itself.
--
-- @param[type=string] msg The message to output in DaFusions console window.
--
function verbose(msg)
  print(msg)
end



-------------------------------------------------------------------------------------------------------------------------------------------
-- Local structure to manage vaialable source code.
--
-- This table is initialized by getConversions() with filenames, IDs, etc. of the sources found in the
-- repositorie's *'Conversions/'* folder. It is used to proviede these sources i.e. in a ComboBox for
-- selection.
--
-- @table Conversions
-- @field Name Fusename of the conversion.
-- @field Path Full path of the folder the conversion can be found in.
-- @field Filename Full filename (indcluding the ID and '.c' suffix).
-- @field ShadertoyID The ID of the Shadertoy the code originally came from.
-- @field Label Name in human readable form identifying the converson to show in messages, the ComboBox, etc. .
--
Conversions={}



-------------------------------------------------------------------------------------------------------------------------------------------
-- Create a table to initializie in particular `Conversions` with.
--
-- @param[type=string] path Path to where the conversions reside.
-- @return[type=table] conversion information; `{}` if no conversions found
--
function getConversions(path)

  local files={}

  local handle	= bmd.readdir(path.."*.*.c")

  for k, v in pairs(handle) do
    if v.Name and not(v.IsDir) then

      local filename = v.Name
      local fusename, shadertoyid = filename:match('^(.+)%.([^%.]+)%.c$')

      files[k]={
        Name=fusename,
        Path=path,
        Filename=filename,
        ShadertoyID=shadertoyid,
        Label=fusename.." ("..shadertoyid..")",
      }
    end
  end

  return files
end



-------------------------------------------------------------------------------------------------------------------------------------------
-- Callback to initialize the tool.
--
function Create()

  local REPOSITORYPATH=[[]]


  -- create defined to connect input contols to kernel

  KernelInputCtrlDefines =""

  for i=0,NUM_COLOR_CONTROLS-1 do
    KernelInputCtrlDefines=KernelInputCtrlDefines.."#define CONNECT_COLOR"..i.."(NAME) float4 NAME     = to_float4(_shaderParameters->color["..i.."][0],_shaderParameters->color["..i.."][1],_shaderParameters->color["..i.."][2],_shaderParameters->color["..i.."][3])\n"
  end

  for i=0,NUM_TINYSLIDER_CONTROLS-1 do
    KernelInputCtrlDefines=KernelInputCtrlDefines.."#define CONNECT_TINYSLIDER"..i.."(NAME,SMIN,SMAX,SDEFAULT) float NAME = _shaderParameters->tinySlider["..i.."]; if (NAME<SMIN) NAME=(SMIN); if (NAME>SMAX) NAME=(SMAX) \n"
  end

  for i=0,NUM_SMALLSLIDER_CONTROLS-1 do
    KernelInputCtrlDefines=KernelInputCtrlDefines.."#define CONNECT_SMALLSLIDER"..i.."(NAME,SMIN,SMAX,SDEFAULT) float NAME = _shaderParameters->smallSlider["..i.."]; if (NAME<SMIN) NAME=(SMIN); if (NAME>SMAX) NAME=(SMAX) \n"
  end

  verbose("use the folling defines to connect your controls:\n"..KernelInputCtrlDefines)



  -- create fallback kernel code

  local channels=""
  for i=0,NUM_INPUT_CHANNELS-1 do
    channels=channels.."__TEXTURE2D__ iChannel"..i..", "
  end

  ConversionSourcecode_fallback =
  [[__KERNEL__ void IncubatorFallbackKernel(
      __CONSTANTREF__ ShaderParameters *params,
      ]]..channels..[[
      __TEXTURE2D_WRITE__ dst
      )
  {
    DEFINE_KERNEL_ITERATORS_XY(x, y);

    if (x >= params->width || y >= params->height)
      return;

    _tex2DVec4Write(dst, x, y, to_float4(1.0f,0.0f,0.0f,0.0f) );
  }
  ]]



  -- get the list of conversions and read compatibility and params code


  verbose("Create: repository used is "..REPOSITORYPATH)

  Conversions=getConversions(REPOSITORYPATH..'Conversions/')

  f = io.open(REPOSITORYPATH..'.clobber/CompatibilityCode.c', "r")

  if not f then
    CompatibilityCode = nil
    print("failed to read compatibility code")
  else
    CompatibilityCode = f:read("*all")
    f:close()
  end

  ShaderParameters=[[

  float iTime;
  float iMouse[4];

  float color[]]..NUM_COLOR_CONTROLS..[[][4];
  float tinySlider[]]..NUM_TINYSLIDER_CONTROLS..[[];
  float smallSlider[]]..NUM_TINYSLIDER_CONTROLS..[[];

  int   width, height;
  int   compOrder;

  int iChannel0_width;
  int iChannel0_height;
  ]]


  print(ShaderParameters)

  -- combo box with all the conversions + a reload button

  local attrs

  attrs={}

  for k,v in pairs(Conversions) do
    verbose("Create: conversion '"..v.Label.."'")
    table.insert(attrs,{ CCS_AddString = v.Label })
  end

  InFileToUseCombo = self:AddInput("Code Fragment", "FragementFileSelection", {
    LINKID_DataType = "Number",
    INPID_InputControl = "ComboControl",
	  INP_DoNotifyChanged = true,
    INP_Default = 0,
    INP_Integer = true,
    attrs
    })

  InReloadCodeButton= self:AddInput("Reload Code", "ReloadCodeFragment",
    { LINKID_DataType = "Text",
      INPID_InputControl = "ButtonControl",
      INP_DoNotifyChanged = true,
      INP_External = false,
    })

  InShadertoyButton=self:AddInput("Show on shadertoy.com", "ShowOnShadertoy", {
    LINKID_DataType = "Text",
    INPID_InputControl = "ButtonControl",
    INP_DoNotifyChanged = false,
    INP_External = false,
    BTNCS_Execute = 'print("does nothing")',
    INP_Disabled=true,
  })

  InFrequency = self:AddInput("Speedup", "speed", {
    LINKID_DataType    = "Number",
    INPID_InputControl = "SliderControl",
    INP_Default        = 1.0,
    INP_MinScale 	     = 0.0,
    INP_MaxScale 	     = 5.0,
    SLCS_LowName       = "stop",
    SLCS_HighName      = "5x",

  })


  -- some general controls for data passed to the kernel

  self:BeginControlNest("Common Shader Inputs", "shaderInputs", true, {})

		InShaderInputs_iResolution = self:AddInput("iResolution", "iResolution", {
			LINKID_DataType = "Text",
			INPID_InputControl = "TextEditControl",
			INP_External = false,
			IC_NoLabel = false,
			ICD_Width = 1.0,
			INPS_DefaultText = "-",
			TEC_Lines = 1,
			TEC_Wrap = false,
			TEC_ReadOnly = true,
			TEC_CharLimit = 0,
			TEC_DeferSetInputs = false,

			INP_DoNotifyChanged  = false,
      INP_Disabled = true,
      INP_Passive = true,
		  })

		InShaderInputs_iTime = self:AddInput("iTime", "iTime", {
			LINKID_DataType = "Text",
			INPID_InputControl = "TextEditControl",
			INP_External = false,
			IC_NoLabel = false,
			ICD_Width = 1.0,
			INPS_DefaultText = "-",
			TEC_Lines = 1,
			TEC_Wrap = false,
			TEC_ReadOnly = true,
			TEC_CharLimit = 0,
			TEC_DeferSetInputs = false,

			INP_DoNotifyChanged  = false,
      INP_Disabled = true,
      INP_Passive = true,
			})

		InShaderInputs_iMouse = self:AddInput("iMouse", "iMouse", {
			LINKID_DataType = "Text",
			INPID_InputControl = "TextEditControl",
			INP_External = false,
			IC_NoLabel = false,
			ICD_Width = 1.0,
			INPS_DefaultText = "-",
			TEC_Lines = 1,
			TEC_Wrap = false,
			TEC_ReadOnly = true,
			TEC_CharLimit = 0,
			TEC_DeferSetInputs = false,

			INP_DoNotifyChanged  = false,
      INP_Disabled = true,
      INP_Passive = true,
			})



    InMouseXY = self:AddInput("iMouse.xy", "iMouseXY", {
      LINKID_DataType = "Point",
      INPID_InputControl = "OffsetControl",
      INPID_PreviewControl = "CrosshairControl",
    })

    InMouseZW = self:AddInput("iMouse.zw", "iMouseZW", {
      LINKID_DataType = "Point",
      INPID_InputControl = "OffsetControl",
      INPID_PreviewControl = "CrosshairControl",

      INP_DoNotifyChanged  = false,
      INP_Disabled = true,
      INP_Passive = true,
    })

    InMouseDrag = self:AddInput("Mouse Button Pressed", "click", {
      LINKID_DataType = "Number",
      INPID_InputControl = "CheckboxControl",
      INP_Default = 0,
      INP_MinScale = 0,
      INP_MaxScale = 1,
      IC_Visible = true,
    })



  self:EndControlNest()



  -- some color controls to play with colors in the kernel

  self:BeginControlNest("Color Controls", "Colors", false, {})

    InColor={}

    local rgba = {'Red','Green','Blue','Alpha'}

    for i=0,NUM_COLOR_CONTROLS-1 do
      InColor[i]={}
      for j=0,3 do
        InColor[i][j]=self:AddInput(rgba[j+1], string.lower(string.sub(rgba[j+1],1,1))..i , { ICS_Name = "Color "..i, IC_ControlGroup = i+1, IC_ControlID = j, INP_Default  = 0.5, LINKID_DataType = "Number", INPID_InputControl = "ColorControl", INP_MinScale = 0.0, INP_MaxScale = 1.0, })
      end
    end

    self:EndControlNest()


  -- some sliders controls to play with colors in the kernel

  self:BeginControlNest("Slider Controls", "Sliders", false, {})

  InTinySlider={}

  for i=0,NUM_TINYSLIDER_CONTROLS-1 do
    InTinySlider[i] = self:AddInput("Tiny Slider "..i, "tinyslider"..i, {
      LINKID_DataType    = "Number",
      INPID_InputControl = "SliderControl",
      INP_MinScale 	     = -1.0,
      INP_MaxScale 	     = 1.0,
      INP_Default        = 0.0,
    })
  end

  InSmallSlider={}

  for i=0,NUM_SMALLSLIDER_CONTROLS-1 do
    InSmallSlider[i] = self:AddInput("Small Slider "..i, "smallslider"..i, {
      LINKID_DataType    = "Number",
      INPID_InputControl = "SliderControl",
      INP_MinScale 	     = -10.0,
      INP_MaxScale 	     = 10.0,
      INP_Default        = 0.0,
    })
  end

  self:EndControlNest()



  -- controls for the tool itself, not passed to the kernel

  InRebuildCheckBox = self:AddInput("InRebuildCheckBox", "InRebuildCheckBox", {
    LINKID_DataType = "Number",
    INPID_InputControl = "CheckboxControl",
    INP_Default = 0,
    INP_MinScale = 0,
    INP_MaxScale = 1,
    IC_Visible = false,
  })

  -- InVerboseCheckBox = self:AddInput("VERBOSE", "VerboseCheckbox", {
  --   LINKID_DataType = "Number",
  --   INPID_InputControl = "CheckboxControl",
  --   INP_Default = 1,
  --   INP_MinScale = 0,
  --   INP_MaxScale = 1,
  --   IC_Visible = true,
  -- })




  -- node's inputs and its output

  InChannel0 = self:AddInput(   "iChannel0",  "iChannel0",  { LINKID_DataType = "Image", LINK_Main = 1, INP_Required = false  })
	OutImage   = self:AddOutput(  "Output",     "Output",     { LINKID_DataType = "Image", LINK_Main = 1                        })

end






-------------------------------------------------------------------------------------------------------------------------------------------
-- Callback to render the node.
--
function Process(req)

  local rebuild = false

  if InRebuildCheckBox:GetValue(req).Value == 1 then
    verbose("Process: do rebuild and clear the flag")
    InRebuildCheckBox:SetSource(Number(0),0)
    rebuild=true
  end



  if rebuild then
    ConversionSourcecode  = ""
    local item   = Conversions[InFileToUseCombo:GetValue(req).Value + 1]
    ConversionFusename    = item.Name
    ConversionShaderID    = item.ShadertoyID

    InShadertoyButton:SetAttrs({
      BTNCS_Execute = 'bmd.openurl("https://www.shadertoy.com/view/' .. ConversionShaderID ..'")',
      INP_Disabled=  ConversionShaderID=="TEST" and true or false
      })

    verbose("Process: rebuild code for conversion '"..ConversionFusename.."' ("..ConversionShaderID..")")

    file = io.open(item.Path .. item.Filename,"r")

    if file ~= nil then
      ConversionSourcecode = "\n" .. file:read("*all")
      file:close()
    end



    -- Für Incubator-Nodes (und nur für diese) müssen die Kernels über verschiedene
    -- Instanzen hinweg unterschieden werden. Die fertige Fuse braucht das nachher aber
    -- nicht mehr - eine Fuse ist halt eine Fuse und die ändert ihren Kernel nicht einfach
    -- so zwischendurch ... da wird dann nachher einfach nichts mehr an den Namen
    -- drangehaengt.

    ConversionKernelname = ConversionFusename .. "Fuse_" .. self.Name

    -- --------------------------------------------------------------------------------------------------------------

    local kernel_parameters=ConversionSourcecode:match("__KERNEL__%s+void%s+"..ConversionFusename.."Fuse%s*%(([^%)]*)%)%s*%{")
    local count=0



    -- float4 fragColor,
    -- float2 fragCoord,



    local has_param={
      ['iResolution']           = { Type='float3',    Present=false, Code='float2 iResolution = to_float2(_shaderParameters->width, _shaderParameters->height);' },
      ['iTime']                 = { Type='float',     Present=false, Code='float iTime = _shaderParameters->iTime;' },
      ['iMouse']                = { Type='float4',    Present=false, Code='float4 iMouse = to_float4(_shaderParameters->iMouse[0],_shaderParameters->iMouse[1],_shaderParameters->iMouse[2],_shaderParameters->iMouse[3]);' },

      -- ['iTimeDelta']            = { Type='float',     Present=false, Code='float iTimeDelta = _shaderParameters->iTimeDelta;' },
      -- ['iFrame']                = { Type='int',       Present=false, Code='int iFrame = _shaderParameters->iFrame;' },
      -- ['iChannelTime']          = { Type='float*',     Present=false, Code='float4 iChannelTime = to_float4(_shaderParameters->iChannelTime[0],_shaderParameters->iChannelTime[1],_shaderParameters->iChannelTime[2],_shaderParameters->iChannelTime[3]);'  },
      -- ['iChannelResolution']    = { Type='float3*',    Present=false, Code='float3 iChannelResolution[4] = { to_float3(_shaderParameters->iChannelTime[0][0],_shaderParameters->iChannelTime[0][1],_shaderParameters->iChannelTime[0][2] ), to_float3(_shaderParameters->iChannelTime[1][0],_shaderParameters->iChannelTime[1][1],_shaderParameters->iChannelTime[1][2] ), to_float3(_shaderParameters->iChannelTime[2][0],_shaderParameters->iChannelTime[2][1],_shaderParameters->iChannelTime[2][2] ), to_float3(_shaderParameters->iChannelTime[3][0],_shaderParameters->iChannelTime[3][1],_shaderParameters->iChannelTime[3][2] )};'  },
      -- ['iDate']                 = { Type='float4',    Present=false, Code='float4 iDate = to_float4(_shaderParameters->iDate[0],_shaderParameters->iDate[1],_shaderParameters->iDate[2],_shaderParameters->iDate[3]);'},
      -- ['iSampleRate']           = { Type='float',     Present=false, Code='float iSampleRate = _shaderParameters->iSampleRate;' },

      ['iChannel0']             = { Type='sampler2D', Present=false },
      ['iChannel1']             = { Type='sampler2D', Present=false },
      ['iChannel2']             = { Type='sampler2D', Present=false },
      ['iChannel3']             = { Type='sampler2D', Present=false },
    }

    local fragColor_name=nil -- float4
    local fragCoord_name=nil -- float2


    -- ja, okay, jetzt wird's echt bescheuert ...

    local i=-1 -- iteration to allow fragColor and Coord only as the first two parameters
    if kernel_parameters==nil then
      print("no kernel found - unable to determine parameters")
    else
      -- kernel_parameters=kernel_parameters:gsub("^%s*(.-)%s*$", "%1") -- trim
      -- verbose("kernel parameters='"..kernel_parameters.."'")

      for p in kernel_parameters:gmatch('([^,]+)') do

        i=i+1;

        t, n = p:match("^%s*([A-Za-z_][A-Za-z0-9_]*)%s+([A-Za-z_][A-Za-z_0-9]*)%s*$") -- match "type name"
        if t==nil then
          t, n = p:match("^%s*([A-Za-z_][A-Za-z0-9_]*)%s*%*%s*([A-Za-z_][A-Za-z_0-9]*)%s*$") -- match "type * name" (yes, type*name matches, so what)
          if t~=nil then
            t=t..'*'
          else
            t, n = p:match("^%s*([A-Za-z_][A-Za-z0-9_]*)%s+([A-Za-z_][A-Za-z_0-9]*)%s*%[%s*%]%s*$") -- match "type name [ ]"
            if t~=nil then
              t=t..'*'
            end
          end
        end

        if t==nil then
          print("parameter='"..p.."' has bad format")
        else
          verbose("parameter"..i..": type='"..t.."', name='"..n.."'")
          if has_param[n]==nil then
            if i==0 and t=='float4' and fragColor_name==nil then
              fragColor_name=n -- first and only the first parameter can be the color (yes, stupid idea to call that color iDate)
            elseif i<2 and t=='float2' and fragCoord_name==nil then
              fragCoord_name=n -- first or second parameter can be the coord
            else
              print("i don't know '"..t.." "..n.."'")
            end
          else
            if t ~= has_param[n].Type then
              print("bad type '"..t.."' for '"..n.."' ('"..(has_param[n].Type).."' expected)")
            else
              if has_param[n].Present then
                print("multiple occurences of '"..t.." "..n.."'")
              else
                has_param[n].Present=true
              end
            end
          end
        end
      end
    end


    kernel_parameters = "__CONSTANTREF__ ShaderParameters*  _shaderParameters, "
    for i=0,3 do
      if has_param["iChannel"..i].Present then
        if i >= NUM_INPUT_CHANNELS then
          print("iChannel"..i.." not available")
        else
          kernel_parameters = kernel_parameters .. " __TEXTURE2D__ iChannel"..i..", "
        end
      else
        if i<NUM_INPUT_CHANNELS then
          kernel_parameters = kernel_parameters .. " __TEXTURE2D__ iChannel"..i..", " -- ausprobieren, ob hier dummy geht!?!
        end
      end
    end
    kernel_parameters = kernel_parameters .. "__TEXTURE2D_WRITE__ _shaderDestinationTexture"


    local variable_declarations = ""

    if fragColor_name ~= nil then
      variable_declarations=variable_declarations.."float4 "..fragColor_name.."=to_float4_s(0.0f);\n"
    end

    if fragCoord_name ~= nil then
      variable_declarations=variable_declarations.."float2 "..fragCoord_name.."=to_float2(fusion_x,fusion_y);\n"
    end


    for n,p in pairs(has_param) do
      if p.Present and p.Code then
        variable_declarations = variable_declarations .. p.Code .. "\n"
      end
    end


    local count

    ConversionSourcecode, count = string.gsub(ConversionSourcecode,
      "__KERNEL__%s+void%s+"..ConversionFusename.."Fuse%s*%([^%)]*%)%s*%{",

      KernelInputCtrlDefines.."\n\n"..
      "__KERNEL__ void "..ConversionKernelname.."("..kernel_parameters..")\n{\n"..
      [[
          DEFINE_KERNEL_ITERATORS_XY(fusion_x, fusion_y);
          if (fusion_x >= _shaderParameters->width || fusion_y >= _shaderParameters->height)
            return;
      ]]
      ..variable_declarations.."\n\n// --------\n\n"
      )


    -- Vorsicht: Der Test, ob der Kernelname gefunden wurde muss drinbleiben,
    -- weil sonst die kleinste Aenderung im Kernelnamen Fusion auf dem Mac komplett
    -- weghaut. Ist zwar nicht absolut wasserdicht, verhindert aber versehentlich
    -- falsche Namen in 99% der Faelle

    if count ~=1 then
      print("void "..ConversionFusename.."Fuse() found "..count.."x ... there ".. (count<1 and "must be exactly" or "can be only") .. " one!")
      ConversionSourcecode = ""
    else

      ConversionSourcecode, count = string.gsub(ConversionSourcecode,
        "(%s+)SetFragmentShaderComputedColor%s*%(%s*",
        "%1_tex2DVec4Write(_shaderDestinationTexture, fusion_x, fusion_y, "
      )

      -- print(ConversionSourcecode)

      if CompatibilityCode~=nil then
        ConversionSourcecode=CompatibilityCode..ConversionSourcecode
      else
        print("no compatibility code?!?")
      end
    end


  end




  if ConversionSourcecode == ""  then
    print("no shader to render - using some default kernel")
    ConversionSourcecode=ConversionSourcecode_fallback

    -- No need for a '_ShadersIncN' extension across
    -- multiple instances as the fallback kernel code
    -- is always the same.

    ConversionKernelname="IncubatorFallbackKernel"
    ConversionFusename="IncubatorFallback"

    print(ConversionSourcecode)
    rebuild=true
  end

  if ShaderParameters==nil then
    print("this will never ever work")
    return
  end

  if rebuild then
    verbose("Process: '"..ConversionKernelname.."' is now active for "..self.Name)
  end

  local node = DVIPComputeNode(req,
    ConversionKernelname,
    ConversionSourcecode,
    "ShaderParameters",
    ShaderParameters
    )



  local imgattrs = {
    IMG_Document = self.Comp,
    { IMG_Channel = "Red", },
    { IMG_Channel = "Green", },
    { IMG_Channel = "Blue", },
    { IMG_Channel = "Alpha", },
    IMG_Width = Width,
    IMG_Height = Height,
    IMG_XScale = XAspect,
    IMG_YScale = YAspect,
    IMAT_OriginalWidth = realwidth, -- nil !?!
    IMAT_OriginalHeight = realheight, -- nil !?!
    IMG_Quality = not req:IsQuick(),
    IMG_MotionBlurQuality = not req:IsNoMotionBlur(),
    IMG_DeferAlloc = true,
    IMG_ProxyScale = ( (not req:IsStampOnly()) and 1 or nil),
    IMG_Depth = ( (SourceDepth~=0) and SourceDepth or nil   )
  }



  -- Extern Texture or create a new one
  iChannel0 = InChannel0:GetValue(req)

  if (iChannel0 == nil) then
    iChannel0 = Image(imgattrs)
    local p = Pixel({R=0,G=0,B=0,A=0})
    iChannel0:Fill(p)
  end

  local dst = Image {IMG_Like = iChannel0, IMG_DeferAlloc = true}


  if req:IsPreCalc() then
    print("precalc")
    local out = Image({IMG_Like = dst, IMG_NoData = true})
    OutImage:Set(req, out)
    return
  end


  -------------- Parameter für DCTL-Code ---------------------
  local framerate = self.Comp:GetPrefs("Comp.FrameFormat.Rate")

  local params = {}

  params = node:GetParamBlock(ShaderParameters)


  local text  =  nil

  -- iMouse

  local mouse_xy  = InMouseXY:GetValue(req)
  local mouse_zw  = InMouseZW:GetValue(req)

  params.iMouse[0] = mouse_xy.X
  params.iMouse[1] = mouse_xy.Y
  params.iMouse[2] = mouse_zw.X
  params.iMouse[3] = mouse_zw.Y

  -- okay, tut's noch immer nicht - vermutlich muss ich da
  -- mit einem weiteren versteckten feld arbeiten, um mir
  -- die position beim click zu merken

  if InMouseDrag:GetValue(req).Value ~= 0 then
    -- hm, okay ... was mache ich mit einem Mausklick bei Position 0|0 ?!?
    if params.iMouse[2]==0 and params.iMouse[3]==0 then
      params.iMouse[2]=params.iMouse[0]
      params.iMouse[3]=params.iMouse[1]
    end
  else
    params.iMouse[2] = 0
    params.iMouse[3] = 0
  end

  if mouse_zw.X ~= params.iMouse[2] or mouse_zw.Y ~= params.iMouse[3] then
    -- print(mouse_zw.X.." != "..params.iMouse[2])
    InMouseZW:SetAttrs({INP_Disabled=false})
    InMouseZW:SetSource(Point(params.iMouse[2],params.iMouse[3]),0,0)
    InMouseZW:SetAttrs({INP_Disabled=true})
  end

  params.iMouse[0] = params.iMouse[0] * Width
  params.iMouse[1] = params.iMouse[1] * Height
  params.iMouse[2] = params.iMouse[2] * Width
  params.iMouse[3] = params.iMouse[3] * Height

  text = string.format("{%.1f, %.1f, %.1f, %.1f}", params.iMouse[0], params.iMouse[1],params.iMouse[2],params.iMouse[3])

  if InShaderInputs_iMouse:GetValue(req).Value ~= text then
    InShaderInputs_iMouse:SetAttrs({INP_Disabled=false})
    InShaderInputs_iMouse:SetSource(Text( text ),0,0)
    InShaderInputs_iMouse:SetAttrs({INP_Disabled=true})
  end


  -- iTime

  local frequency = InFrequency:GetValue(req).Value

  params.iTime            = (req.Time / framerate) * frequency;

  text = string.format("(%.0f/%.2ffps)*%.3f= %.4f", req.Time,framerate,frequency,params.iTime)

  if InShaderInputs_iTime:GetValue(req).Value ~= text then
    InShaderInputs_iTime:SetAttrs({INP_Disabled=false})
    InShaderInputs_iTime:SetSource(Text( text ),0,0)
    InShaderInputs_iTime:SetAttrs({INP_Disabled=true})
  end


  -- Colors

  for i=0,NUM_COLOR_CONTROLS-1 do
    for j=0,3 do
      params.color[i][j] = InColor[i][j]:GetValue(req).Value
    end
  end

  -- Sliders

  for i=0,NUM_TINYSLIDER_CONTROLS-1 do
    params.tinySlider[i] = InTinySlider[i]:GetValue(req).Value
  end

  for i=0,NUM_SMALLSLIDER_CONTROLS-1 do
    params.smallSlider[i] = InSmallSlider[i]:GetValue(req).Value
  end


  -- Resolution

  params.width  = dst.Width
  params.height = dst.Height
--params.width            = iChannel0.DataWindow:Width()
--params.height           = iChannel0.DataWindow:Height()

  text = string.format("{%.0f, %.0f}", params.width, params.height )

  if InShaderInputs_iResolution:GetValue(req).Value ~= text then
    InShaderInputs_iResolution:SetAttrs({INP_Disabled=false})
    InShaderInputs_iResolution:SetSource(Text( text ),0,0)
    InShaderInputs_iResolution:SetAttrs({INP_Disabled=true})
  end


  params.compOrder        = iChannel0:IsMask() and 1 or 15
  params.iChannel0_width  = iChannel0.Width
  params.iChannel0_height = iChannel0.Height

  node:SetParamBlock(params)

--node:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR,TEX_ADDRESS_MODE_BORDER, TEX_NORMALIZED_COORDS_TRUE)
  node:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR,TEX_ADDRESS_MODE_BORDER, TEX_NORMALIZED_COORDS_TRUE)
	node:AddInput("iChannel0",iChannel0)
	node:AddOutput("dst", dst)

  if rebuild then
    node:ForceRebuild()
  end






  local ok = node:RunSession(req)

	if (not ok) then
		dst = nil
    print("--- Errors ---")
    dump(node:GetErrorLog())
	end


  -- Output our result
  OutImage:Set(req,dst)
  collectgarbage();

end



-------------------------------------------------------------------------------------------------------------------------------------------
-- Callback to handle UI control events.
--
function NotifyChanged(inp, param, time)
	if inp ~= nil and param ~= nil then

		if (inp == InReloadCodeButton) then
			if (param.Value == 1) then
        verbose("NotifyChanged: reload button pressend")
        InRebuildCheckBox:SetSource(Number(1),0)
      end
    end

		if (inp == InFileToUseCombo) then
      verbose("NotifyChanged: file to use changed - set flag for a rebuild")
      InRebuildCheckBox:SetSource(Number(1),0)
    end

	end
end
