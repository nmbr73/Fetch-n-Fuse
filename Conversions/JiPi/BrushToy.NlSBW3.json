{"Shader":{"ver":"0.1","info":{"id":"NlSBW3","date":"1652805483","viewed":250,"name":"Brush toy","username":"leon","description":"Another graphic programming rabbit hole","likes":25,"published":3,"flags":32,"usePreview":0,"tags":["abstract","paint"],"hasliked":0},"renderpass":[{"inputs":[{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":14854,"src":"\/media\/a\/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","ctype":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":37,"channel":0}],"code":"\n\/\/ Brush toy by Leon Denise 2022-05-17\n\n\/\/ I wanted to play further with shading and lighting from 2D heightmap.\n\/\/ I started by generating a heightmap from noise, then shape and curves.\n\/\/ Once the curve was drawing nice brush strokes, I wanted to add motion.\n\/\/ Also wanted to add droplets of paints falling, but that will be\n\/\/ for another sketch.\n\n\/\/ This is the color pass\n\/\/ Click on left edge to see layers\n\n\/\/ The painting pass (Buffer A) is using FBM noise to simulate brush strokes\n\/\/ The curve was generated with a discrete Fourier Transform,\n\/\/ from https:\/\/www.shadertoy.com\/view\/3ljXWK\n\n\/\/ Frame buffer sampling get offset from brush motion,\n\/\/ and the mouse also interact with the buffer.\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = vec3(.0);\n    \n    \/\/ coordinates\n    vec2 uv = fragCoord.xy \/ iResolution.xy;\n    vec3 dither = texture(iChannel1, fragCoord.xy \/ 1024.).rgb;\n    \n    \/\/ value from noise buffer A\n    vec3 noise = texture(iChannel0, uv).rgb;\n    float gray = noise.x;\n    \n    \/\/ gradient normal from gray value\n    vec3 unit = vec3(3.\/iResolution.xy,0);\n    vec3 normal = normalize(vec3(\n        TEX(uv + unit.xz)-TEX(uv - unit.xz),\n        TEX(uv - unit.zy)-TEX(uv + unit.zy),\n        gray*gray));\n    \n    \n    \/\/ specular light\n    vec3 dir = normalize(vec3(0,1,2.));\n    float specular = pow(dot(normal, dir)*.5+.5,20.);\n    color += vec3(.5)*specular;\n    \n    \/\/ rainbow palette\n    vec3 tint = .5+.5*cos(vec3(1,2,3)*1.5+gray*5.+uv.x*5.);\n    dir = normalize(vec3(uv-.5, 0.));\n    color += tint*pow(dot(normal, -dir)*.5+.5, 0.5);\n    \n    \/\/ background blend\n    vec3 background = vec3(.8)*smoothstep(1.5,0.,length(uv-.5));\n    color = mix(background, clamp(color, 0., 1.), smoothstep(.2,.5,noise.x));\n    \n    \/\/ display layers when clic\n    if (iMouse.z > 0.5 && iMouse.x\/iResolution.x < .1)\n    {\n        if (uv.x < .33) color = vec3(gray);\n        else if (uv.x < .66) color = normal*.5+.5;\n        else color = vec3(.2+specular)*gray;\n    }\n\n    fragColor = vec4(color, 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":40,"src":"\/media\/a\/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","ctype":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":14854,"src":"\/media\/a\/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","ctype":"texture","channel":2,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":257,"channel":0}],"code":"\n\/\/ Brush toy by Leon Denise 2022-05-17\n\n\/\/ The painting pass is using FBM noise to simulate brush strokes\n\/\/ The curve was generated with a discrete Fourier Transform,\n\/\/ from https:\/\/www.shadertoy.com\/view\/3ljXWK\n\n\/\/ Frame buffer sampling get offset from brush motion,\n\/\/ and the mouse also interact with the buffer.\n\nconst float speed = .01;\nconst float scale = 0.8;\nconst float falloff = 2.;\n\nvec2 mouse;\n\n\/\/ fractal brownian motion (layers of multi scale noise)\nvec3 fbm(vec3 p)\n{\n    vec3 result = vec3(0);\n    float amplitude = 0.5;\n    for (float index = 0.; index < 3.; ++index)\n    {\n        result += (texture(iChannel0, p\/amplitude).xyz) * amplitude;\n        amplitude \/= falloff;\n    }\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    \/\/ coordinates\n    vec2 uv = (fragCoord.xy - iResolution.xy \/ 2.)\/iResolution.y;\n    mouse = (iMouse.xy - iResolution.xy \/ 2.)\/iResolution.y;\n    \n    \/\/ dithering\n    vec3 dither = texture(iChannel2, fragCoord.xy \/ 1024.).rgb;\n    \n    \/\/ sample curve position\n    float speed = 1.;\n    float t = -iTime*speed+dither.x*.01;\n    vec2 current = cookie(t);\n    \n    \/\/ velocity from current and next curve position\n    vec2 next = cookie(t+.01);\n    vec2 velocity = normalize(next-current);\n    \n    \/\/ move brush cursor along curve\n    vec2 pos = uv-current*1.6;\n    \n    float paint = fbm(vec3(pos, 0.) * scale).x;\n    \n    \/\/ brush range\n    float brush = smoothstep(.3,.0,length(pos));\n    paint *= brush;\n    \n    \/\/ add circle shape to buffer\n    paint += smoothstep(.05, .0, length(pos));\n    \n    \/\/ motion mask\n    float push = smoothstep(.3, .5, paint);\n    push *= smoothstep(.4, 1., brush);\n    \n    \/\/ direction and strength\n    vec2 offset = 10.*push*velocity\/iResolution.xy;\n    \n    \/\/ mouse interaction\n    vec4 data = texture(iChannel1, vec2(0,0));\n    bool wasNotPressing = data.w < 0.5;\n    if (wasNotPressing && iMouse.z > .5) data.z = 0.;\n    else data.z += iTimeDelta;\n    data.z = clamp(data.z, 0., 1.);\n    vec2 mousePrevious = data.xy;\n    float erase = 0.;\n    if (iMouse.z > 0.5)\n    {\n        uv = (fragCoord.xy - iResolution.xy \/ 2.)\/iResolution.y;\n        float mask = fbm(vec3(uv-mouse, 0.) * scale * .5).x;\n        mask = smoothstep(.3,.6,mask);\n        push = smoothstep(.2,.0,length(uv-mouse));\n        push *= mask;\n        vec2 dir = normalize(mousePrevious-mouse+.001);\n        float fadeIn = smoothstep(.0, .5, data.z);\n        float fadeInAndOut = sin(fadeIn*3.1415);\n        offset += 10.*push*normalize(mouse-uv)\/iResolution.xy*fadeInAndOut;\n        erase = (.001 + .01*(1.-fadeIn)) * push;\n        push *= 500.*length(mousePrevious-mouse)*fadeIn;\n        offset += push*dir\/iResolution.xy;\n    }\n    \n    \/\/ sample frame buffer with motion\n    uv = fragCoord.xy \/ iResolution.xy;\n    vec4 frame = texture(iChannel1, uv + offset);\n    \n    \/\/ temporal fading buffer\n    paint = max(paint, frame.x - .0005 - erase);\n    \n    \/\/ print result\n    fragColor = vec4(clamp(paint, 0., 1.));\n    \n    \/\/ save mouse position for next frame\n    if (fragCoord.x < 1. && fragCoord.y < 1.) fragColor = vec4(mouse, data.z, iMouse.z);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n\/\/ shortcut to sample texture\n#define TEX(uv) texture(iChannel0, uv).r\n\n\/\/ rotation matrix\nmat2 rot (float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }\n\n\/\/ generated with discrete Fourier transform\nvec2 cookie(float t) {\n\treturn vec2(0.08+cos(t-1.58)*0.23+cos(t*2.-1.24)*0.14+cos(t*3.-1.12)*0.09+cos(t*4.-0.76)*0.06+cos(t*5.-0.59)*0.05+cos(t*6.+0.56)*0.03+cos(t*7.-2.73)*0.03+cos(t*8.-1.26)*0.02+cos(t*9.-1.44)*0.02+cos(t*10.-2.09)*0.03+cos(t*11.-2.18)*0.01+cos(t*12.-1.91)*0.02,cos(3.14)*0.05+cos(t+0.35)*0.06+cos(t*2.+0.54)*0.09+cos(t*3.+0.44)*0.03+cos(t*4.+1.02)*0.07+cos(t*6.+0.39)*0.03+cos(t*7.-1.48)*0.02+cos(t*8.-3.06)*0.02+cos(t*9.-0.39)*0.07+cos(t*10.-0.39)*0.03+cos(t*11.-0.03)*0.04+cos(t*12.-2.08)*0.02);\n}\n","name":"Common","description":"","type":"common"}]}}