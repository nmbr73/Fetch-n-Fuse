{"Shader":{"ver":"0.1","info":{"id":"3s3cWr","date":"1601129713","viewed":1181,"name":"CA Molecular dynamics","username":"michael0884","description":"Implementing perfect particle number conservation with cellular automaton particle tracking\nTook me some time to realize that the edge conditions in the step functions actually had a large effect, thus there are 2 Heaviside step functions here. ","likes":47,"published":3,"flags":48,"usePreview":0,"tags":["particles","ca"],"hasliked":0},"renderpass":[{"inputs":[{"id":33,"src":"\/presets\/tex00.jpg","ctype":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":258,"src":"\/media\/previz\/buffer01.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":37,"channel":0}],"code":"\/\/ Fork of \"Landau Ginzburg fluid\" by michael0884. https:\/\/shadertoy.com\/view\/WlXBDf\n\/\/ 2020-09-21 21:03:05\n\n\/\/ Fork of \"Everflow\" by michael0884. https:\/\/shadertoy.com\/view\/ttBcWm\n\/\/ 2020-07-19 18:18:22\n\n\/\/ Fork of \"Paint streams\" by michael0884. https:\/\/shadertoy.com\/view\/WtfyDj\n\/\/ 2020-07-11 22:38:47\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); \/\/ cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nconst int KEY_SPACE = 32;\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,2), 0 ).x > 0.5;\n}\n\n\n#define radius 1.0\n#define zoom 0.3\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{    \n    \/\/zoom in\n    if(isKeyPressed(KEY_SPACE))\n    {\n    \tpos = iMouse.xy + pos*zoom - R*zoom*0.5;\n    }\n    float rho = 0.001;\n    vec2 vel = vec2(0., 0.);\n\n    \/\/compute the smoothed density and velocity\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = floor(pos) + vec2(i,j);\n        vec4 data = T(tpos);\n\n        vec2 X0 = DECODE(data.x) + tpos;\n        vec2 V0 = DECODE(data.y);\n        float M0 = data.z;\n        vec2 dx = X0 - pos;\n\n        float K = GS(dx\/radius)\/(radius*radius);\n        rho += M0*K;\n        vel += M0*K*V0;\n    }\n\n   vel \/= rho;\n   vec3 vc = hsv2rgb(vec3(6.*atan(vel.x, vel.y)\/(2.*PI), 1.0, rho*length(vel.xy)));\n   col.xyz = cos(0.9*vec3(3,2,1)*rho) + 0.*vc;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define T(p) texelFetch(iChannel0, ivec2(mod(p,R)), 0)\n#define P(p) texture(iChannel0, mod(p,R)\/R)\n#define C(p) texture(iChannel1, mod(p,R)\/R)\n\n#define PI 3.14159265\n#define dt 0.5\n#define R iResolution.xy\n\n\/\/useful functions\n#define GS(x) exp(-dot(x,x))\n#define GS0(x) exp(-length(x))\n#define CI(x) smoothstep(1.0, 0.9, length(x))\n#define Dir(ang) vec2(cos(ang), sin(ang))\n#define Rot(ang) mat2(cos(ang), sin(ang), -sin(ang), cos(ang))\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n\/\/Wyatt thermostat\n#define cooling 1.5\n\n\/\/MD force\nfloat MF(vec2 dx)\n{\n    return -GS(0.75*dx) + 0.13*GS(0.4*dx);\n}\n\n\n\/\/the step functions need to be exactly like this!! step(x,0) does not work!\nfloat Ha(vec2 x)\n{\n    return ((x.x >= 0.)?1.:0.)*((x.y >= 0.)?1.:0.);\n}\n\nfloat Hb(vec2 x)\n{\n    return ((x.x > 0.)?1.:0.)*((x.y > 0.)?1.:0.);\n}\n\n\/\/particle grid\n\n\n\/\/data packing\n#define PACK(X) ( uint(round(65534.0*clamp(0.5*X.x+0.5, 0., 1.))) + \\\n           65535u*uint(round(65534.0*clamp(0.5*X.y+0.5, 0., 1.))) )   \n               \n#define UNPACK(X) (clamp(vec2(X%65535u, X\/65535u)\/65534.0, 0.,1.)*2.0 - 1.0)              \n\n#define DECODE(X) UNPACK(floatBitsToUint(X))\n#define ENCODE(X) uintBitsToFloat(PACK(X))","name":"Common","description":"","type":"common"},{"inputs":[{"id":258,"src":"\/media\/previz\/buffer01.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":257,"channel":0}],"code":"\/\/particle distribution\nvec3 PD(vec2 x, vec2 pos)\n{\n    return vec3(x, 1.0)*Ha(x - (pos - 0.5))*Hb((pos + 0.5) - x);\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    \n    vec2 X = vec2(0);\n    vec2 V = vec2(0);\n    float M = 0.;\n    \n    \/\/basically integral over all updated neighbor distributions\n    \/\/that fall inside of this pixel\n    \/\/this makes the tracking conservative\n    range(i, -1, 1) range(j, -1, 1)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = T(tpos);\n       \n        vec2 X0 = DECODE(data.x) + tpos;\n    \tvec2 V0 = DECODE(data.y);\n    \tint M0 = int(data.z);\n        int M0H = M0\/2;\n        \n        X0 += V0*dt; \/\/integrate position\n        \n        \/\/the deposited mass into this cell\n        vec3 m = (M0 >= 2)?\n            (float(M0H)*PD(X0+vec2(0.5, 0.0), pos) + float(M0 - M0H)*PD(X0-vec2(0.5, 0.0), pos))\n            :(float(M0)*PD(X0, pos)); \n        \n        \/\/add weighted by mass\n        X += m.xy;\n        V += V0*m.z;\n      \n        \/\/add mass\n        M += m.z;\n    }\n    \n    \/\/normalization\n    if(M != 0.)\n    {\n        X \/= M;\n        V \/= M;\n    }\n    \n    \/\/initial condition\n    if(iFrame < 1)\n    {\n        X = pos;\n        V = vec2(0.);\n        M = Ha(pos - (R*0.5 - R.x*0.15))*Hb((R*0.5 + R.x*0.15) - pos);\n    }\n    \n    X = X - pos;\n    U = vec4(ENCODE(X), ENCODE(V), M, 0.);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":259,"src":"\/media\/previz\/buffer02.png","ctype":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":258,"channel":0}],"code":"float sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat border(vec2 p)\n{\n    float bound = -sdBox(p - R*0.5, R*vec2(0.49, 0.49)); \n    float box = sdBox((p - R*vec2(0.5, 0.6)) , R*vec2(0.05, 0.01));\n    float drain = -sdBox(p - R*vec2(0.5, 0.7), R*vec2(0.0, 0.0));\n    return bound;\n}\n\n#define h 1.\nvec3 bN(vec2 p)\n{\n    vec3 dx = vec3(-h,0,h);\n    vec4 idx = vec4(-1.\/h, 0., 1.\/h, 0.25);\n    vec3 r = idx.zyw*border(p + dx.zy)\n           + idx.xyw*border(p + dx.xy)\n           + idx.yzw*border(p + dx.yz)\n           + idx.yxw*border(p + dx.yx);\n    return vec3(normalize(r.xy), r.z + 1e-4);\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    vec2 uv = pos\/R;\n    ivec2 p = ivec2(pos);\n        \n    vec4 data = T(pos); \n    vec2 X = DECODE(data.x) + pos;\n    vec2 V = DECODE(data.y);\n    float M = data.z;\n    \n    if(M != 0.) \/\/not vacuum\n    {\n        \/\/Compute the force\n        vec2 Fa = vec2(0.);\n        range(i, -2, 2) range(j, -2, 2)\n        {\n            vec2 tpos = pos + vec2(i,j);\n            vec4 data = T(tpos);\n\n            vec2 X0 = DECODE(data.x) + tpos;\n            vec2 V0 = DECODE(data.y);\n            float M0 = data.z;\n            vec2 dx = X0 - X;\n           \n            Fa += M0*MF(dx)*dx;\n        }\n        \n        vec2 F = vec2(0.);\n        if(iMouse.z > 0.)\n        {\n            vec2 dx= pos - iMouse.xy;\n             F -= 0.003*dx*GS(dx\/30.);\n        }\n        \n       \t\/\/gravity\n        F += 0.001*vec2(0,-1);\n        \n        \/\/integrate velocity\n        V += (F + Fa)*dt\/M;\n        \n        \/\/Wyatt thermostat\n        X += cooling*Fa*dt\/M;\n        \n        vec3 BORD = bN(X);\n        V += 0.5*smoothstep(0., 5., -BORD.z)*BORD.xy;\n        \n        \/\/velocity limit\n        float v = length(V);\n        V \/= (v > 1.)?1.*v:1.;\n    }\n    \n    \/\/save\n    X = X - pos;\n    U = vec4(ENCODE(X), ENCODE(V), M, 0.);\n}","name":"Buffer B","description":"","type":"buffer"}]}}