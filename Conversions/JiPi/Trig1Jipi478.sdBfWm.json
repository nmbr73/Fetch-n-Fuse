{
 "ver": "0.1",
 "info": {
  "id": "sdBfWm",
  "date": "0",
  "viewed": 0,
  "name": "Trig1 JiPi 478",
  "description": "Testing depth of field.",
  "likes": 0,
  "published": "Private",
  "usePreview": 0,
  "tags": [
   "raymarchingdof"
  ],
  "hasliked": 0,
  "parentid": "Xs23WV",
  "parentname": "Trig1"
 },
 "renderpass": [
  {
   "inputs": [
    {
     "id": "XsX3Rn",
     "filepath": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg",
     "type": "texture",
     "channel": 0,
     "sampler": {
      "filter": "mipmap",
      "wrap": "repeat",
      "vflip": "false",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    },
    {
     "id": "XsX3zn",
     "filepath": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png",
     "type": "cubemap",
     "channel": 1,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "false",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    }
   ],
   "outputs": [],
   "code": "float truc(vec3 p) {\n\tvec3 t;\n\tt.x = cos(p.x) + sin(p.y);\n\tt.y = cos(p.y) - sin(p.z);\n\tt.z = cos(p.z) + sin(p.x);\n\treturn length(t) - 0.8;\n}\n\nfloat displace(vec3 p) {\n\tp = texture(iChannel0, (p.xz) / 20.).rgb / 20.;\n\treturn p.x + p.y + p.z;\n}\n\nfloat map(vec3 p) {\n\tfloat d = 100.0;\n\td = truc(p);\n\td += displace(p);\n\treturn d;\n}\n\nfloat intersect(vec3 ro, vec3 rd) {\n\tfloat t = 0.0;\n\tfor (int i = 0; i < 50; i++) {\n\tfloat d = map(ro + rd * t);\n\tif (d <= 0.01) return t;\n\tt += d;\n\t}\n\treturn 0.0;\n}\n\nvec3 normal(vec3 p) {\n\tfloat eps = 0.1;\n\treturn normalize(vec3(\n\t\tmap(p + vec3(eps, 0, 0)) - map(p - vec3(eps, 0, 0)),\n\t\tmap(p + vec3(0, eps, 0)) - map(p - vec3(0, eps, 0)),\n\t\tmap(p + vec3(0, 0, eps)) - map(p - vec3(0, 0, eps))\n\t));\n}\n\nfloat occ(vec3 p) {\n\tfloat ao = 0.0;\n\tfloat eps = 0.5;\n\tao += map(p + vec3(eps, eps, eps));\n\tao += map(p + vec3(eps, eps, -eps));\n\tao += map(p + vec3(eps,-eps, eps));\n\tao += map(p + vec3(eps, -eps, -eps));\n\tao += map(p + vec3(-eps, eps, eps));\n\tao += map(p + vec3(-eps, eps, -eps));\n\tao += map(p + vec3(-eps, -eps, eps));\n\tao += map(p + vec3(-eps, -eps, -eps));\n\treturn ao / (8.0 * eps);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy - 0.5;\n\tuv.x = uv.x * iResolution.x / iResolution.y;\n\t\n\tfloat t = 10.0 + iTime * 0.2;\n\tfloat cr = 32.0;\n\t\n\tvec3 ro = vec3(cos(t) * cr, 0.0, sin(t) * cr);\n\tvec3 ta = vec3(cos(t - 0.1) * cr, 0.0, sin(t - 0.1) * cr);\n\tvec3 ww = normalize(vec3(ta - ro));\n\tvec3 vv = vec3(0,1,0);\n\tvec3 uu = normalize(cross(ww, vv));\n\tvec3 l1 = normalize(vec3(1, 1, 1));\n\tvec3 l2 = normalize(vec3(-1, -1, 1));\n\t\n\tvec3 fcolor = vec3(0.0);\n\tfor (int i = 0; i < 4; i++) {\n\t\n\t\t// Reinder dof ! thx\n\t\t\n\t\tconst float fov = 1.0;\n\t\tvec3 er = normalize(vec3(uv.xy, fov));\n\t\tvec3 rd = er.x * uu + er.y * vv + er.z * ww;\n\t\t\n\t\tfloat rnd = fract(sin(iTime * 20322.1232)) / 13211.123;\n\t\tvec3 go = 0.01 * vec3((rnd - vec2(0.3)) * 2., 0.0);\n\t\tvec3 gd = normalize( er*4.0 - go );\n\t\t\n\t\tro += go.x * uu + go.y * vv;\n\t\trd += gd.x * uu + gd.y * vv;\n\t\trd = normalize(rd);\n\t\t\n\t\tfloat d = intersect(ro, rd);\n\t\tvec3 color = vec3(0);\n\t\t\n\t\tif (d > 0.0) {\n\t\t\tvec3 pi = ro + rd * d;\n\t\t\tvec3 ni = normal(pi);\n\t\t\tfloat dif = (dot(ni, l1) + dot(ni, l2)) / 2.0;\n\t\t\tfloat spec1 = pow(max(0.5, dot(reflect(l1, ni), rd)), 20.0);\n\t\t\tfloat spec2 = pow(max(0.5, dot(reflect(l2, ni), rd)), 20.0);\n\t\t\tvec3 peps = ro + rd * (d - .3);\n\t\t\tvec3 rn = reflect(rd, ni);\n\t\t\tvec3 rf = texture(iChannel1, rn).xyz;\n\t\t\tfloat ao = occ(pi);\n\t\t\tcolor = vec3(1, 0, 0) * dif * ao + spec1 + spec2 + rf * 0.8;\n\t\t}\n\t\tcolor *= min(1.0, 9./d);\n\t\tfcolor += color - pow(length(uv.xy), 6.0) * 2.0;\n\t}\n\tfragColor = vec4(fcolor / 4.,1.0);\n}",
   "name": "Image",
   "description": "",
   "type": "image"
  }
 ]
}