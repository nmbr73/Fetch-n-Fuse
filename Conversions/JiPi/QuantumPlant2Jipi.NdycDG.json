{
 "ver": "0.1",
 "info": {
  "id": "NdycDG",
  "date": "0",
  "viewed": 0,
  "name": "Quantum Plant2 JiPi",
  "description": "toolbox",
  "likes": 0,
  "published": "Private",
  "usePreview": 0,
  "tags": [
   "personnaltoolbox"
  ],
  "hasliked": 0,
  "parentid": "NdKyRd",
  "parentname": "Quantum Plant 2"
 },
 "renderpass": [
  {
   "inputs": [
    {
     "id": "4sXGRn",
     "filepath": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg",
     "type": "texture",
     "channel": 1,
     "sampler": {
      "filter": "mipmap",
      "wrap": "repeat",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    },
    {
     "id": "4dX3zn",
     "filepath": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png",
     "type": "cubemap",
     "channel": 0,
     "sampler": {
      "filter": "mipmap",
      "wrap": "clamp",
      "vflip": "false",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    }
   ],
   "outputs": [
    {
     "id": "4dfGRr",
     "channel": 0
    }
   ],
   "code": "const float CELL_SIZE = 2.;\n\nfloat cubeHeight(vec3 cell) {\n    float t = iTime * 2.;\n    return (sin(cell.x + t*0.125)*0.125+sin(cell.z + t)*0.125) * 15.;\n}\n\nvec3 cellTransform(vec3 m) {\n\n   float cellSize = CELL_SIZE;\n\n   vec3 cell = round(m / cellSize);\n   cell.y = min(cell.y, -2.);\n\n   m.y -= cubeHeight(cell);\n   \n   return m - cell * cellSize;\n}\n\nfloat udBox(vec3 p) {\n    float a = CELL_SIZE*0.45;\n    float corner = a * 0.1;\n\n    return length(max(abs(p) - a, 0.)) - corner;\n}\n\nfloat map(vec3 m) {\n\n   vec3 cell = round(m / CELL_SIZE);\n   cell.y = -2.;\n\n   float dist = 9999.;\n\n   for(float i=-1.;i<2.;i+=1.) {\n      for(float j=-1.;j<2.;j+=1.) {\n\n            vec3 neighbour = cell;\n\n            neighbour.x += i;\n            neighbour.z += j;\n        \n            vec3 p = m - neighbour * CELL_SIZE;\n            p.y -= cubeHeight(neighbour);        \n        \n            dist = min(dist, udBox(p));\n        }\n    }\n\n    return dist;\n}\n\nbool rayMarch(in vec3 ro, in vec3 rd, out vec3 m, float max) {\n    \n    float md = 0.0;\n   \n    while(md < max) {       \n    \n        m = ro + rd * md;    \n        \n    \tfloat dist = map(m);\n        \n        if(dist < 0.01) {\n            return true;\n        }\n\n        md += min(CELL_SIZE, dist);\n    }\n    \n\treturn false;    \n}\n\nvec3 computeNormal(in vec3 pos) {\n\tvec3 eps = vec3( 0.005, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t     map(pos+eps.xyy) - map(pos-eps.xyy),\n\t     map(pos+eps.yxy) - map(pos-eps.yxy),\n\t     map(pos+eps.yyx) - map(pos-eps.yyx));\n\treturn normalize(nor);\n}\n\nconst vec3 light = normalize(vec3(1,-1,-1));\nconst float SHADOW_FADE = 10.;\n\nfloat computeShadow(vec3 p, vec3 light) {\n\n    vec3 m;\n    \n    if(rayMarch(p - light * 0.05, -light, m, SHADOW_FADE)) {\n        float distFactor = clamp(length(m-p)/SHADOW_FADE, 0., 1.);\n        return 0.5 + smoothstep(0., 1., distFactor) * 0.5;\n    }\n\n    return 1.;\n}\n\nvec4 text3d(vec3 p, vec3 n) {\n    p=p*.2;//IQ made it\n    vec3 a = n*n;\n\tvec4 x = texture(iChannel1, p.yz );\n\tvec4 y = texture(iChannel1, p.zx );\n\tvec4 z = texture(iChannel1, p.yx );\n\treturn (x*a.x + y*a.y + z*a.z) / (a.x + a.y + a.z);\n}\n\nvec4 render(vec3 ro, vec3 rd, vec3 m, vec3 normal, vec4 env) {\n\n    float shadow = computeShadow(m, light);\n    float diffuse = clamp(dot(normal, -light), 0.,1.);\n    float hilight = pow(clamp(dot(reflect(light, normal), rd), 0., 1.), 40.) * 0.;\n    \n    vec4 baseColor = text3d(cellTransform(m), normal);\n    \n    vec4 testMask = vec4(baseColor.g);\n//    return testMask;\n    \n    float fresnel = (1. - clamp(dot(-rd, normal), 0., 1.))*0.25;    \n    \n    return (vec4(0.25 + diffuse) * mix(baseColor, env, fresnel) + hilight) * shadow;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 m;\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n\n    float angleY = 3.1415*0.25*iTime * 0.1;\n    float cosa = cos(angleY);\n    float sina = sin(angleY);    \n\n    mat3 rotY = mat3(vec3(cosa, 0., sina), vec3(0., 1., 0.), vec3(-sina, 0., cosa));\n\n    float angleX = 0.7;//iTime * 0.;\n    cosa = cos(angleX);\n    sina = sin(angleX);    \n\n    mat3 rotX = mat3(vec3(1., 0., 0.), vec3(0., cosa, sina), vec3(0., -sina, cosa));\n\n    mat3 transfo = rotY * rotX;\n\n    float camAnim = iTime*0.;\n    vec3 camera = vec3(0, -2., -10. + 1.5*sin(camAnim));\n    \n    vec3 ro = camera;\n    vec3 rd\t= normalize(vec3(uv.xy, 1.));\n\n    ro = transfo * ro;\n    rd = transfo * rd;\n\n    if(rayMarch(ro, rd, m, 100.)) {\n        vec3 normal = computeNormal(m);\n        \n        vec3 refl = reflect(rd, normal);\n        vec3 m2;\n        \n        vec4 env; \n        \n        if(rayMarch(m + refl*0.015, refl, m2, 100.)) {\n            vec3 normal2 = computeNormal(m2);\n            vec3 localRefl = reflect(refl, normal2);\n            vec4 localEnv = texture(iChannel0, localRefl); \n            env = render(m, refl, m2, normal2, localEnv);\n        }\n        else {\n            env = texture(iChannel0, refl);\n        }\n        \n        fragColor = render(ro, rd, m, normal, env);\n    }\n    else {\n       fragColor = vec4(0); \n    }\n}\n    \n    \n",
   "name": "Image",
   "description": "",
   "type": "image"
  }
 ]
}