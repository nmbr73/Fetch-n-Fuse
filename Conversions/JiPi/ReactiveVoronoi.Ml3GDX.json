{"Shader":{"ver":"0.1","info":{"id":"Ml3GDX","date":"1476629748","viewed":1574,"name":"Reactive Voronoi","username":"glk7","description":"Ray-marched cubic section of an extruded voronoi tiled plane. The extrusion height of each cell reacts to a random frequency of the audio on iChannel0. The scene can be rotated with the mouse.","likes":33,"published":3,"flags":0,"usePreview":0,"tags":["3d","voronoi","raymarch","interactive","reactive","hardshadows"],"hasliked":0},"renderpass":[{"inputs":[{"id":19,"src":"\/media\/a\/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","ctype":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":37,"channel":0}],"code":"\/\/ Created by genis sole - 2016\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International.\n\n\/\/ A remastered version of this can be found here: https:\/\/www.shadertoy.com\/view\/MtyGWK \n\/\/ Adds a better traversal, stronger lighting, softer shadows and AO.\n\nconst float PI = 3.1416;\n\nvec2 hash2( vec2 p )\n{\n    \/\/ procedural white noise\t\n\treturn fract(sin(vec2(dot(p,vec2(127.1,311.7)),\n                          dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n\/\/ From http:\/\/www.iquilezles.org\/www\/articles\/voronoilines\/voronoilines.htm\nvec3 voronoi( in vec2 x )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    \/\/----------------------------------\n    \/\/ first pass: regular voronoi\n    \/\/----------------------------------\n\tvec2 mg, mr;\n\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\t#ifdef ANIMATE\n        o = 0.5 + 0.5*sin( iTime + 6.2831*o );\n        #endif\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }\n\n    \/\/----------------------------------\n    \/\/ second pass: distance to borders\n    \/\/----------------------------------\n    md = 8.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\t#ifdef ANIMATE\n        o = 0.5 + 0.5*sin( iTime + 6.2831*o );\n        #endif\t\n        vec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>0.00001 )\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n\n    return vec3( md, mr );\n}\n\n\n\/\/ Modified version of the above iq's voronoi borders. \n\/\/ Returns the distance to the border in a given direction.\nvec3 voronoi( in vec2 x, in vec2 dir)\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    \/\/----------------------------------\n    \/\/ first pass: regular voronoi\n    \/\/----------------------------------\n\tvec2 mg, mr;\n\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }\n\n    \/\/----------------------------------\n    \/\/ second pass: distance to borders\n    \/\/----------------------------------\n    md = 1e5;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\tvec2 r = g + o - f;\n\n    \n \t\tif( dot(r-mr,r-mr) > 1e-5 ) {\n            vec2 l = r-mr;\n            \n            if (dot(dir, l) > 1e-5) {\n            \tmd = min(md, dot(0.5*(mr+r), l)\/dot(dir, l));\n            }\n        }\n        \n    }\n    \n    return vec3( md, n+mg);\n}\n\nbool IRayAABox(in vec3 ro, in vec3 rd, in vec3 invrd, in vec3 bmin, in vec3 bmax, \n               out vec3 p0, out vec3 p1) \n{\n    vec3 t0 = (bmin - ro) * invrd;\n    vec3 t1 = (bmax - ro) * invrd;\n\n    vec3 tmin = min(t0, t1);\n    vec3 tmax = max(t0, t1);\n    \n    float fmin = max(max(tmin.x, tmin.y), tmin.z);\n    float fmax = min(min(tmax.x, tmax.y), tmax.z);\n    \n    p0 = ro + rd*fmin;\n    p1 = ro + rd*fmax;\n \n    return fmax >= fmin;   \n}\n\nvec3 AABoxNormal(vec3 bmin, vec3 bmax, vec3 p) \n{\n    vec3 n1 = -(1.0 - smoothstep(0.0, 0.03, p - bmin));\n    vec3 n2 = (1.0 -  smoothstep(0.0, 0.03, bmax - p));\n    \n    return normalize(n1 + n2);\n}\n\nconst vec3 background = vec3(0.04);\nconst vec3 scmin = -vec3(1.77, 1.0, 1.77);\nconst vec3 scmax = vec3(1.77, 1.5, 1.77);\n\n\/\/ From http:\/\/iquilezles.org\/www\/articles\/palettes\/palettes.htm\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 color(vec2 p) {\n    return pal(3.434+(hash2(p).x*0.02), \n               vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,0.7,0.4),vec3(0.0,0.15,0.20)  );\n}\n\nfloat disp(in vec2 p) {\n    return scmin.y + 0.1 + hash2(p).x * 0.5 + texture(iChannel0, vec2(hash2(p).x, 0.0)).r*2.0;\n}\n\nvec4 map(in vec2 p, in vec2 dir) {\n    vec3 v = voronoi(p*2.0, dir)*0.5;\n    return vec4(v, disp(v.yz));\n}\n\nfloat ShadowFactor(in vec3 ro, in vec3 rd) {\n\tvec3 p0 = vec3(0.0);\n    vec3 p1 = vec3(0.0);\n    \n    IRayAABox(ro, rd, 1.0\/rd, scmin, scmax, p0, p1);\n    p0 = ro + rd*0.02;\n    \n    vec2 dir = normalize(rd.xz);\n    float sf = rd.y \/ length(rd.xz);\n\n    float m = -1e5;\n    \n    const int max_steps = 32;\n    for (int i = max_steps; i > 0; --i) {\n        if (p0.y < m) break;\n        \n        if (dot((p1 - p0), rd) < 0.0) return 1.0;\n  \n        vec4 v = map(p0.xz, dir);\n        \n        m = v.w;\n        if (p0.y < m) return 0.0;\n        \n        p0 += rd*(length(vec2(v.x, v.x*sf)) + 0.02);\n    }\n    \n    p0 += rd * (m - p0.y)\/rd.y;\n    if (dot((p1 - p0), rd) < 0.0) return 1.0;   \n    \n    return 0.0;\n}\n\nvec3 Shade(in vec3 p, in vec3 n, in vec3 ld, in vec2 c) {\n    vec3 col = color(c);\n\treturn (col * 0.15 + col * max(0.0, dot(n,ld)) * ShadowFactor(p, ld) * 0.85) * 3.5;\n}\n\nvec3 Render(in vec3 ro, in vec3 rd, in vec3 ld) {\n    vec3 p0 = vec3(0.0);\n    vec3 p1 = vec3(0.0);\n    \n    if (!IRayAABox(ro, rd, 1.0\/rd, scmin, scmax, p0, p1)) return background;\n    \n    vec2 dir = normalize(rd.xz);\n    float sf = rd.y \/ length(rd.xz);\n    \n    vec2 lvp = vec2(0);\n    vec2 vp = p0.xz;\n    \n    float m = -1e5;\n    \n    vec3 n = vec3(0.0);\n    \n    const int max_steps = 32;\n    for (int i = max_steps; i > 0; --i) {\n        if (p0.y < m) {\n            n = vec3(0.0, 1.0, 0.0);\n            break;\n        }\n        \n        if (dot((p1 - p0), rd) < 0.0) return background;\n  \n        vec4 v = map(p0.xz, dir);\n\t\t\n        lvp = vp;\n        vp = v.yz;\n        \n        m = v.w;\n        if (p0.y < m) break;\n        \n        p0 += rd*(length(vec2(v.x, v.x*sf)) + 0.02);\n    }\n    \n    \n    \n    if (n.y != 0.0) {\n    \tp0 += rd * (-p0.y + m)\/rd.y;\n        if (dot((p1 - p0), rd) < 0.0) return background;\n    }\n    \n    n = normalize(mix(vec3(normalize(lvp - vp), 0.0).xzy, n, \n                  smoothstep(0.00, 0.03, voronoi(p0.xz*2.0).x*0.5)));\n    \n    if (all(equal(p0.xz, lvp))) {\n    \tn = AABoxNormal(scmin, scmax, p0); \n    }\n    \n    return Shade(p0, n, ld, vp);\n}\n\nvoid CameraOrbitRay(in vec2 fragCoord, in float n, in vec3 c, in float d, \n                    out vec3 ro, out vec3 rd, out mat3 t) \n{\n    float a = 1.0\/max(iResolution.x, iResolution.y);\n    rd = normalize(vec3((fragCoord - iResolution.xy*0.5)*a, n));\n \n    ro = vec3(0.0, 0.0, -d);\n    \n    float ff = min(1.0, step(0.001, iMouse.x) + step(0.001, iMouse.y));\n    vec2 m = PI*ff + vec2(((iMouse.xy + 0.1) \/ iResolution.xy) * (PI*2.0));\n    m.y = -m.y;\n    m.y = sin(m.y*0.5)*0.6 + 0.6;\n        \n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cos(m.y), sin(m.y), 0.0, -sin(m.y), cos(m.y));\n    mat3 rotY = mat3(cos(m.x), 0.0, -sin(m.x), 0.0, 1.0, 0.0, sin(m.x), 0.0, cos(m.x));\n    \n    t = rotY * rotX;\n    \n    ro = t * ro;\n    ro = c + ro;\n\n    rd = t * rd;\n    \n    rd = normalize(rd);\n}\n\nvec3 LightDir(in mat3 t) \n{\n    vec3 l = normalize(vec3(1.0, 1.0, -1.0));\n    return t * l;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 ro = vec3(0.0);\n    vec3 rd = vec3(0.0);\n    mat3 t = mat3(1.0);\n    \n    CameraOrbitRay(fragCoord, 1.0, vec3(0.0), 10.0, ro, rd, t);\n\tfragColor = vec4(pow(Render(ro, rd, LightDir(t)), vec3(0.5454)), 1.0);\n}","name":"Image","description":"","type":"image"}]}}