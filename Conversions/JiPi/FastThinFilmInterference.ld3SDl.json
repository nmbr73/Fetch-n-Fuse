{"Shader":{"ver":"0.1","info":{"id":"ld3SDl","date":"1462110373","viewed":8261,"name":"Fast Thin-Film Interference","username":"cornusammonis","description":"A fast and fairly realistic thin-film interference and chromatic dispersion simulation shader.","likes":162,"published":3,"flags":0,"usePreview":0,"tags":["interference","bubble","thinfilm"],"hasliked":0},"renderpass":[{"inputs":[{"id":22,"src":"\/media\/a\/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","ctype":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":45,"src":"\/media\/a\/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":37,"channel":0}],"code":"\/*\n\tFast Thin-Film Interference\n\n\tThis is a performance-optimized version of my previous \n\tthin-film interference shader here: https:\/\/www.shadertoy.com\/view\/XddXRj\n\tThis version also fixes a platform-specific bug and has\n\ta few other tweaks as well.\n\n\tThin-film interference and chromatic dispersion are simulated at\n\tsix different wavelengths and then downsampled to RGB.\n*\/\n\n\/\/ To see just the reflection (no refraction\/transmission) uncomment this next line:\n\/\/#define REFLECTANCE_ONLY\n\n\/\/ performance and raymarching options\n#define INTERSECTION_PRECISION 0.01  \/\/ raymarcher intersection precision\n#define ITERATIONS 20\t\t\t\t \/\/ max number of iterations\n#define AA_SAMPLES 1\t\t\t\t \/\/ anti aliasing samples\n#define BOUND 6.0\t\t\t\t\t \/\/ cube bounds check\n#define DIST_SCALE 0.9   \t\t\t \/\/ scaling factor for raymarching position update\n\n\/\/ optical properties\n#define DISPERSION 0.05\t\t\t\t \/\/ dispersion amount\n#define IOR 0.9     \t\t\t\t \/\/ base IOR value specified as a ratio\n#define THICKNESS_SCALE 32.0\t\t \/\/ film thickness scaling factor\n#define THICKNESS_CUBEMAP_SCALE 0.1  \/\/ film thickness cubemap scaling factor\n#define REFLECTANCE_SCALE 3.0        \/\/ reflectance scaling factor\n#define REFLECTANCE_GAMMA_SCALE 2.0  \/\/ reflectance gamma scaling factor\n#define FRESNEL_RATIO 0.7\t\t\t \/\/ fresnel weight for reflectance\n#define SIGMOID_CONTRAST 8.0         \/\/ contrast enhancement\n\n#define TWO_PI 6.28318530718\n#define WAVELENGTHS 6\t\t\t\t \/\/ number of wavelengths, not a free parameter\n\n\/\/ iq's cubemap function\nvec3 fancyCube( sampler2D sam, in vec3 d, in float s, in float b )\n{\n    vec3 colx = textureLod( sam, 0.5 + s*d.yz\/d.x, b ).xyz;\n    vec3 coly = textureLod( sam, 0.5 + s*d.zx\/d.y, b ).xyz;\n    vec3 colz = textureLod( sam, 0.5 + s*d.xy\/d.z, b ).xyz;\n    \n    vec3 n = d*d;\n    \n    return (colx*n.x + coly*n.y + colz*n.z)\/(n.x+n.y+n.z);\n}\n\n\/\/ iq's 3D noise function\nfloat hash( float n ){\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x ) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n\nvec3 noise3(vec3 x) {\n\treturn vec3( noise(x+vec3(123.456,.567,.37)),\n\t\t\t\t noise(x+vec3(.11,47.43,19.17)),\n\t\t\t\t noise(x) );\n}\n\n\/\/ a sphere with a little bit of warp\nfloat sdf( vec3 p ) {\n\tvec3 n = vec3(sin(iDate.w * 0.5), sin(iDate.w * 0.3), cos(iDate.w * 0.2));\n\tvec3 q = 0.1 * (noise3(p + n) - 0.5);\n  \n\treturn length(q + p) - 3.5;\n}\n\nvec3 fresnel( vec3 rd, vec3 norm, vec3 n2 ) {\n   vec3 r0 = pow((1.0-n2)\/(1.0+n2), vec3(2));\n   return r0 + (1. - r0)*pow(clamp(1. + dot(rd, norm), 0.0, 1.0), 5.);\n}\n\nvec3 calcNormal( in vec3 pos ) {\n    const float eps = INTERSECTION_PRECISION;\n\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n\treturn normalize( v1*sdf( pos + v1*eps ) + \n\t\t\t\t\t  v2*sdf( pos + v2*eps ) + \n\t\t\t\t\t  v3*sdf( pos + v3*eps ) + \n\t\t\t\t\t  v4*sdf( pos + v4*eps ) );\n}\n\n#define GAMMA_CURVE 50.0\n#define GAMMA_SCALE 4.5\nvec3 filmic_gamma(vec3 x) {\n\treturn log(GAMMA_CURVE * x + 1.0) \/ GAMMA_SCALE;    \n}\n\nvec3 filmic_gamma_inverse(vec3 y) {\n\treturn (1.0 \/ GAMMA_CURVE) * (exp(GAMMA_SCALE * y) - 1.0); \n}\n\n\/\/ sample weights for the cubemap given a wavelength i\n\/\/ room for improvement in this function\n#define GREEN_WEIGHT 2.8\nvec3 texCubeSampleWeights(float i) {\n\tvec3 w = vec3((1.0 - i) * (1.0 - i), GREEN_WEIGHT * i * (1.0 - i), i * i);\n    return w \/ dot(w, vec3(1.0));\n}\n\nvec3 sampleCubeMap(vec3 i, vec3 rd) {\n\tvec3 col = textureLod(iChannel0, rd * vec3(1.0,-1.0,1.0), 0.0).xyz; \n    return vec3(\n        dot(texCubeSampleWeights(i.x), col),\n        dot(texCubeSampleWeights(i.y), col),\n        dot(texCubeSampleWeights(i.z), col)\n    );\n}\n\nvec3 sampleCubeMap(vec3 i, vec3 rd0, vec3 rd1, vec3 rd2) {\n\tvec3 col0 = textureLod(iChannel0, rd0 * vec3(1.0,-1.0,1.0), 0.0).xyz;\n    vec3 col1 = textureLod(iChannel0, rd1 * vec3(1.0,-1.0,1.0), 0.0).xyz; \n    vec3 col2 = textureLod(iChannel0, rd2 * vec3(1.0,-1.0,1.0), 0.0).xyz; \n    return vec3(\n        dot(texCubeSampleWeights(i.x), col0),\n        dot(texCubeSampleWeights(i.y), col1),\n        dot(texCubeSampleWeights(i.z), col2)\n    );\n}\n\n\n\nvec3 sampleWeights(float i) {\n\treturn vec3((1.0 - i) * (1.0 - i), GREEN_WEIGHT * i * (1.0 - i), i * i);\n}\n\nvec3 resample(vec3 wl0, vec3 wl1, vec3 i0, vec3 i1) {\n\tvec3 w0 = sampleWeights(wl0.x);\n    vec3 w1 = sampleWeights(wl0.y);\n    vec3 w2 = sampleWeights(wl0.z);\n    vec3 w3 = sampleWeights(wl1.x);\n    vec3 w4 = sampleWeights(wl1.y);\n    vec3 w5 = sampleWeights(wl1.z);\n    \n    return i0.x * w0 + i0.y * w1 + i0.z * w2\n         + i1.x * w3 + i1.y * w4 + i1.z * w5;\n}\n\n\/\/ downsample to RGB\nvec3 resampleColor(vec3[WAVELENGTHS] rds, vec3 refl0, vec3 refl1, vec3 wl0, vec3 wl1) {\n\n    \n    #ifdef REFLECTANCE_ONLY\n    \tvec3 intensity0 = refl0;\n    \tvec3 intensity1 = refl1;\n    #else\n        vec3 cube0 = sampleCubeMap(wl0, rds[0], rds[1], rds[2]);\n    \tvec3 cube1 = sampleCubeMap(wl1, rds[3], rds[4], rds[5]);\n    \n        vec3 intensity0 = filmic_gamma_inverse(cube0) + refl0;\n    \tvec3 intensity1 = filmic_gamma_inverse(cube1) + refl1;\n    #endif\n    vec3 col = resample(wl0, wl1, intensity0, intensity1);\n\n    return 1.4 * filmic_gamma(col \/ float(WAVELENGTHS));\n}\n\nvec3 resampleColorSimple(vec3 rd, vec3 wl0, vec3 wl1) {\n    vec3 cube0 = sampleCubeMap(wl0, rd);\n    vec3 cube1 = sampleCubeMap(wl1, rd);\n    \n    vec3 intensity0 = filmic_gamma_inverse(cube0);\n    vec3 intensity1 = filmic_gamma_inverse(cube1);\n    vec3 col = resample(wl0, wl1, intensity0, intensity1);\n\n    return 1.4 * filmic_gamma(col \/ float(WAVELENGTHS));\n}\n\n\/\/ compute the wavelength\/IOR curve values.\nvec3 iorCurve(vec3 x) {\n\treturn x;\n}\n\nvec3 attenuation(float filmThickness, vec3 wavelengths, vec3 normal, vec3 rd) {\n\treturn 0.5 + 0.5 * cos(((THICKNESS_SCALE * filmThickness)\/(wavelengths + 1.0)) * dot(normal, rd));    \n}\n\nvec3 contrast(vec3 x) {\n\treturn 1.0 \/ (1.0 + exp(-SIGMOID_CONTRAST * (x - 0.5)));    \n}\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in vec4 m ) {\n    camTar = vec3(0.0,0.0,0.0); \n    if (max(m.z, m.w) <= 0.0) {\n    \tfloat an = 1.5 + sin(time * 0.05) * 4.0;\n\t\tcamPos = vec3(6.5*sin(an), 0.0 ,6.5*cos(an));   \n    } else {\n    \tfloat an = 10.0 * m.x - 5.0;\n\t\tcamPos = vec3(6.5*sin(an),10.0 * m.y - 5.0,6.5*cos(an)); \n    }\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)\/iResolution.y;\n    vec4 m = vec4(iMouse.xy\/iResolution.xy, iMouse.zw);\n\n    \/\/ camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m );\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );\n    \n    float dh = (0.666 \/ iResolution.y);\n    const float rads = TWO_PI \/ float(AA_SAMPLES);\n    \n    vec3 col = vec3(0.0);\n    \n    vec3 wavelengths0 = vec3(1.0, 0.8, 0.6);\n    vec3 wavelengths1 = vec3(0.4, 0.2, 0.0);\n    vec3 iors0 = IOR + iorCurve(wavelengths0) * DISPERSION;\n    vec3 iors1 = IOR + iorCurve(wavelengths1) * DISPERSION;\n    \n    vec3 rds[WAVELENGTHS];\n    \n    for (int samp = 0; samp < AA_SAMPLES; samp++) {\n        vec2 dxy = dh * vec2(cos(float(samp) * rads), sin(float(samp) * rads));\n        vec3 rd = normalize(camMat * vec3(p.xy + dxy, 1.5)); \/\/ 1.5 is the lens length\n\t\tvec3 pos = ro;\n        bool hit = false;\n        for (int j = 0; j < ITERATIONS; j++) {\n            float t = DIST_SCALE * sdf(pos);\n            pos += t * rd;\n            hit = t < INTERSECTION_PRECISION;\n            if ( clamp(pos, -BOUND, BOUND) != pos || hit ) {\n                break;    \n            }\n        }\n        \n        if (hit) {\n            vec3 normal = calcNormal(pos);\n\n            float filmThickness = fancyCube( iChannel1, normal, THICKNESS_CUBEMAP_SCALE, 0.0 ).x + 0.1;\n\n            vec3 att0 = attenuation(filmThickness, wavelengths0, normal, rd);\n            vec3 att1 = attenuation(filmThickness, wavelengths1, normal, rd);\n\n            vec3 f0 = (1.0 - FRESNEL_RATIO) + FRESNEL_RATIO * fresnel(rd, normal, 1.0 \/ iors0);\n            vec3 f1 = (1.0 - FRESNEL_RATIO) + FRESNEL_RATIO * fresnel(rd, normal, 1.0 \/ iors1);\n\n            vec3 rrd = reflect(rd, normal);\n\n            vec3 cube0 = REFLECTANCE_GAMMA_SCALE * att0 * sampleCubeMap(wavelengths0, rrd);\n            vec3 cube1 = REFLECTANCE_GAMMA_SCALE * att1 * sampleCubeMap(wavelengths1, rrd);\n\n            vec3 refl0 = REFLECTANCE_SCALE * filmic_gamma_inverse(mix(vec3(0), cube0, f0));\n            vec3 refl1 = REFLECTANCE_SCALE * filmic_gamma_inverse(mix(vec3(0), cube1, f1));\n\n            rds[0] = refract(rd, normal, iors0.x);\n            rds[1] = refract(rd, normal, iors0.y);\n            rds[2] = refract(rd, normal, iors0.z);\n            rds[3] = refract(rd, normal, iors1.x);\n            rds[4] = refract(rd, normal, iors1.y);\n            rds[5] = refract(rd, normal, iors1.z);\n\n            col += resampleColor(rds, refl0, refl1, wavelengths0, wavelengths1);\n        } else {\n        \tcol += resampleColorSimple(rd, wavelengths0, wavelengths1);    \n        }\n\n    }\n    \n    col \/= float(AA_SAMPLES);\n\t   \n    fragColor = vec4( contrast(col), 1.0 );\n}","name":"Image","description":"","type":"image"}]}}