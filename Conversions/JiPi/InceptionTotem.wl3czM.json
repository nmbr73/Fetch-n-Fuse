{"Shader":{"ver":"0.1","info":{"id":"wl3czM","date":"1608661232","viewed":5382,"name":"Inception Totem","username":"dean_the_coder","description":"Another quick and small demo, playing around with creating a better wood texture than I've made in the past.\n\nIf the totem falls over, let me know...","likes":18,"published":3,"flags":0,"usePreview":0,"tags":["3d","raymarching","movie","cineshader"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"id":37,"channel":0}],"code":"\/\/ Processed by 'GLSL Shader Shrinker' (Shrunk by 125 characters)\n\/\/ (https:\/\/github.com\/deanthecoder\/GLSLShaderShrinker)\n\n\/\/ 'Inception Totem' dean_the_coder (Twitter: @deanthecoder)\n\/\/ https:\/\/www.shadertoy.com\/view\/wl3czM\n\/\/\n\/\/ Another quick and small demo, playing around with creating\n\/\/ a better wood texture than I've made in the past.\n\/\/ Still not happy with it - I think it needs some specular in\n\/\/ the lighter areas, and probably worth of a new shader experiment.\n\/\/\n\/\/ If the totem falls over, let me know...\n\/\/\n\/\/ Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane\n\/\/ and a bunch of others for sharing their knowledge!\n\n\/\/ License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat time;\n\nstruct Hit {\n\tfloat d;\n\tint id;\n\tvec3 uv;\n};\n\n\/\/ Thanks Shane - https:\/\/www.shadertoy.com\/view\/lstGRB\nfloat n31(vec3 p) {\n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p);\n\tp = fract(p);\n\tp = p * p * (3. - 2. * p);\n\tvec4 h = vec4(0, s.yz, s.y + s.z) + dot(ip, s);\n\th = mix(fract(sin(h) * 43.5453), fract(sin(h + s.x) * 43.5453), p.x);\n\th.xy = mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\nfloat n21(vec2 p) {\n\tconst vec3 s = vec3(7, 157, 0);\n\tvec2 h,\n\t     ip = floor(p);\n\tp = fract(p);\n\tp = p * p * (3. - 2. * p);\n\th = s.zy + dot(ip, s.xy);\n\th = mix(fract(sin(h) * 43.5453), fract(sin(h + s.x) * 43.5453), p.x);\n\treturn mix(h.x, h.y, p.y);\n}\n\nfloat n11(float p) {\n\tfloat ip = floor(p);\n\tp = fract(p);\n\tvec2 h = fract(sin(vec2(ip, ip + 1.) * 12.3456) * 43.5453);\n\treturn mix(h.x, h.y, p * p * (3. - 2. * p));\n}\n\nfloat smin(float a, float b, float k) {\n\tfloat h = clamp(.5 + .5 * (b - a) \/ k, 0., 1.);\n\treturn mix(b, a, h) - k * h * (1. - h);\n}\n\nHit minH(Hit a, Hit b) {\n\tif (a.d < b.d) return a;\n\treturn b;\n}\n\nmat2 rot(float a) {\n\tfloat c = cos(a),\n\t      s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nfloat sdCyl(vec3 p, vec2 hr) {\n\tvec2 d = abs(vec2(length(p.xz), p.y)) - hr;\n\treturn min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nfloat sdCapsule(vec3 p, float h, float r) {\n\tp.y -= clamp(p.y, 0., h);\n\treturn length(p) - r;\n}\n\nvec3 getRayDir(vec3 ro, vec2 uv) {\n\tvec3 f = normalize(-ro),\n\t     r = normalize(cross(vec3(0, 1, 0), f));\n\treturn normalize(f + r * uv.x + cross(f, r) * uv.y);\n}\n\nfloat wood(vec2 p) {\n\tp.x *= 71.;\n\tp.y *= 1.9;\n\treturn n11(n21(p) * 30.);\n}\n\nHit map(vec3 p) {\n\tfloat t,\n\t      f = p.y;\n\tp.x += .2 + cos(time * 10.) * .05;\n\tp.z += 3.5 + sin(time * 10.) * .05;\n\tp.xz *= rot(time * 150.);\n\tp.xy *= rot(mix(.02, .04, sin(time * .001) * .5 - .5));\n\tp.y -= .4;\n\tt = 1. - abs(p.y \/ .4 + .07);\n\treturn minH(Hit(f, 1, p), Hit(smin(sdCyl(p, vec2(smoothstep(0., 1., t * t * t) * .35, .4)), sdCapsule(p + vec3(0, .35, 0), .8, .01), mix(.03, .3, t * .7)), 2, p));\n}\n\nvec3 calcN(vec3 p, float t) {\n\tfloat h = .004 * t;\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .5773 * (2. * vec3(((i + 3) >> 1) & 1, (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * map(p + e * h).d;\n\t}\n\n\treturn normalize(n);\n}\n\nfloat calcShadow(vec3 p, vec3 ld) {\n\t\/\/ Thanks iq.\n\tfloat s = 1.,\n\t      t = .1;\n\tfor (float i = 0.; i < 20.; i++) {\n\t\tfloat h = map(p + ld * t).d;\n\t\ts = min(s, 15. * h \/ t);\n\t\tt += h;\n\t\tif (s < .001 || t > 6.) break;\n\t}\n\n\treturn clamp(s, 0., 1.);\n}\n\n\/\/ Quick ambient occlusion.\nfloat ao(vec3 p, vec3 n, float h) { return map(p + h * n).d \/ h; }\n\nvec3 vignette(vec3 c, vec2 fc) {\n\tvec2 q = fc.xy \/ iResolution.xy;\n\tc *= .5 + .5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), .4);\n\treturn c;\n}\n\nvec3 lights(vec3 p, vec3 rd, float d, Hit h) {\n\tvec3 mat,\n\t     ld = normalize(vec3(6, 3, -10) - p),\n\t     ld2 = ld * vec3(-1, 1, 1),\n\t     n = calcN(p, d);\n\tif (h.id == 1) {\n\t\t\/\/ Table.\n\t\tmat = mix(mix(vec3(.17, .1, .05), vec3(.08, .05, .03), wood(p.xz)), vec3(.2, .16, .08), .3 * wood(p.xz * .2));\n\t\tn.x -= smoothstep(.98, 1., pow(abs(sin(p.x * 2.4)), 90.)) * .3;\n\t\tn = normalize(n);\n\t}\n\telse \/\/ Totem.\n        mat = .03 * mix(vec3(.4, .3, .2), mix(vec3(.6, .3, .2), 2. * vec3(.7, .6, .5), n31(h.uv * 1e2)), n31(h.uv * 36.5));\n\n\tfloat ao = dot(vec3(ao(p, n, .2), ao(p, n, .5), ao(p, n, 2.)), vec3(.3, .4, .3)),\n\t      l1 = max(0., .1 + .9 * dot(ld, n)),\n\t      spe = smoothstep(0., 1., pow(max(0., dot(rd, reflect(ld, n))), 20.)) * 10. + smoothstep(0., 1., pow(max(0., dot(rd, reflect(ld2, n))), 20.)) * 2.,\n\t      fre = smoothstep(.7, 1., 1. + dot(rd, n));\n\n\tl1 *= mix(.4, 1., mix(calcShadow(p, ld), calcShadow(p, ld2), .3));\n\treturn mix(mat * (l1 * ao + spe) * vec3(2, 1.6, 1.4), vec3(.005), fre);\n}\n\nvec3 march(vec3 ro, vec3 rd) {\n\t\/\/ Raymarch.\n\tvec3 p, c;\n\tfloat d = .01;\n\tHit h;\n\tfor (float i = 0.; i < 90.; i++) {\n\t\tp = ro + rd * d;\n\t\th = map(p);\n\t\tif (abs(h.d) < .0015) break;\n\t\tif (d > 48.) return vec3(0); \/\/ Distance limit reached - Stop.\n\t\td += h.d;\n\t}\n\n\tc = lights(p, rd, d, h) * exp(-d * .14);\n    float f = smoothstep(-2.2, -3., p.z) * (h.id == 1 ? .4 : 1.);\n\tif (f > 0.0) {\n\t\t\/\/ Show reflection on the totem.\n\t\tro = p;\n\t\trd = reflect(rd, calcN(p, d));\n\t\td = .1;\n\t\tfor (float i = 0.; i < 90.; i++) {\n\t\t\tp = ro + rd * d;\n\t\t\th = map(p);\n\t\t\tif (abs(h.d) < .002 || d > 1.) break;\n\t\t\td += h.d;\n\t\t}\n\n\t\tc = mix(c, d > 1. ? vec3(0) : lights(p, rd, d, h), .2 * f);\n\t}\n\n\treturn c;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fc) {\n\ttime = mod(iTime * .2, 30.);\n    \n\tvec3 ro = vec3(0, 0, -5),\n\t     col = vec3(0);\n\tro.yz *= rot(-.13 - sin(time * .3) * .02);\n\tro.xz *= rot(.07 + cos(time) * .02);\n    \n\tfor (float dx = 0.; dx <= 1.; dx++) {\n\t\tfor (float dy = 0.; dy <= 1.; dy++) {\n\t\t\tvec2 uv = (fc + vec2(dx, dy) * .5 - .5 * iResolution.xy) \/ iResolution.y;\n\t\t\tcol += march(ro, getRayDir(ro, uv));\n\t\t}\n\t}\n\n\tcol \/= 4.;\n\n\tfragColor = vec4(vignette(pow(col * 3., vec3(.45)), fc), 0);\n}","name":"Image","description":"","type":"image"}]}}