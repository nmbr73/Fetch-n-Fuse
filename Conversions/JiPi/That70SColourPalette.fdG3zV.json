{"Shader":{"ver":"0.1","info":{"id":"fdG3zV","date":"1631795284","viewed":216,"name":"That 70's Colour Palette","username":"xenn","description":"yeah\nmouse click influences general direction","likes":5,"published":3,"flags":32,"usePreview":0,"tags":["mouse","background","shadertoy","feedback","integration","library","web","webdevelopment","webdev","javascript"],"hasliked":0},"renderpass":[{"inputs":[{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":258,"src":"\/media\/previz\/buffer01.png","ctype":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":258,"src":"\/media\/previz\/buffer01.png","ctype":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":259,"src":"\/media\/previz\/buffer02.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":37,"channel":0}],"code":"\n\/\/ Tone mapping and post processing\nfloat hash(float c){return fract(sin(dot(c,12.9898))*43758.5453);}\n\n\/\/ linear white point\nconst float W = 1.2;\nconst float T2 = 7.5;\n\nfloat filmic_reinhard_curve (float x) {\n    float q = (T2*T2 + 1.0)*x*x;    \n\treturn q \/ (q + x + T2*T2);\n}\n\nvec3 filmic_reinhard(vec3 x) {\n    float w = filmic_reinhard_curve(W);\n    return vec3(\n        filmic_reinhard_curve(x.r),\n        filmic_reinhard_curve(x.g),\n        filmic_reinhard_curve(x.b)) \/ w;\n}\n\nconst int N = 8;\nvec3 ca(sampler2D t, vec2 UV, vec4 sampl){\n\tvec2 uv = 1.0 - 2.0 * UV;\n\tvec3 c = vec3(0);\n\tfloat rf = 1.0;\n\tfloat gf = 1.0;\n    float bf = 1.0;\n\tfloat f = 1.0\/float(N);\n\tfor(int i = 0; i < N; ++i){\n\t\tc.r += f*texture(t, 0.5-0.5*(uv*rf) ).r;\n\t\tc.g += f*texture(t, 0.5-0.5*(uv*gf) ).g;\n\t\tc.b += f*texture(t, 0.5-0.5*(uv*bf) ).b;\n\t\trf *= 0.9972;\n\t\tgf *= 0.998;\n        bf \/= 0.9988;\n\t\tc = clamp(c,0.0, 1.0);\n\t}\n\treturn c;\n}\n\nvoid mainImage(out vec4 fragColor,vec2 fragCoord){\n    const float brightness = 1.0;\n    vec2 pp = fragCoord.xy\/iResolution.xy;\n    vec2 r = iResolution.xy;\n    vec2 p = 1.-2.*fragCoord.xy\/r.xy;\n    p.y *= r.y\/r.x;\n   \n    \/\/ a little chromatic aberration\n    vec4 sampl = texture(iChannel0, pp);\n    vec3 color = ca(iChannel1, pp, sampl).rgb;\n    \n    \/\/ final output\n    float vignette = 1.25 \/ (1.1 + 1.1*dot(p, p));\n    vignette *= vignette;\n    vignette = mix(1.0, smoothstep(0.1, 1.1, vignette), 0.25);\n    float noise = .012*vec3(hash(length(p)*iTime)).x;\n    color = color*vignette+noise;\n    color = filmic_reinhard(brightness*color);\n    \n    color = smoothstep(-0.025, 1.0,color);\n    \n    color = pow(color, vec3(1.0\/2.2));\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":259,"src":"\/media\/previz\/buffer02.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":260,"src":"\/media\/previz\/buffer03.png","ctype":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":260,"src":"\/media\/previz\/buffer03.png","ctype":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":257,"channel":0}],"code":"\/\/ created by florian berger (flockaroo) - 2016\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ single pass CFD\n\/\/ ---------------\n\/\/ this is some \"computational flockarooid dynamics\" ;)\n\/\/ the self-advection is done purely rotational on all scales. \n\/\/ therefore i dont need any divergence-free velocity field. \n\/\/ with stochastic sampling i get the proper \"mean values\" of rotations \n\/\/ over time for higher order scales.\n\/\/\n\/\/ try changing \"RotNum\" for different accuracies of rotation calculation\n\/\/ for even RotNum uncomment the line #define SUPPORT_EVEN_ROTNUM\n\nfloat getVal(vec2 uv)\n{\n    return length(texture(iChannel0,uv).xyz);\n}\n    \nvec2 getGrad(vec2 uv,float delta)\n{\n    vec2 d=vec2(delta,0);\n    return vec2(\n        getVal(uv+d.xy)-getVal(uv-d.xy),\n        getVal(uv+d.yx)-getVal(uv-d.yx)\n    )\/delta;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n    vec3 n = vec3(getGrad(uv,1.0\/iResolution.y),-500.0* (1. * abs(cos(iTime \/ 3.25))) - 95.);\n    \/\/n *= n;\n    n=normalize(n);\n    fragColor=vec4(n,1);\n    vec3 light = normalize(vec3(1.0,1.0,2.0 ));\n    float diff=clamp(dot(n,light),0.5,1.0);\n    float spec=clamp(dot(reflect(light,n),vec3(0,0,-1)),0.0,1.0);\n    spec=pow(spec,36.0)*1.5;\n    \/\/spec=0.0;\n\tfragColor = mix(texture(iChannel0,uv)*vec4(diff)+vec4(spec),texture(iChannel1,uv)*vec4(diff)+vec4(spec),0.5);\n}\n\/\/ Fork of \"not a fluid simulation\" by pali6. https:\/\/shadertoy.com\/view\/sdd3zj\n\/\/ 2021-09-01 08:39:43\n\n\/*\n\tTransverse Chromatic Aberration\n\n\tBased on https:\/\/github.com\/FlexMonkey\/Filterpedia\/blob\/7a0d4a7070894eb77b9d1831f689f9d8765c12ca\/Filterpedia\/customFilters\/TransverseChromaticAberration.swift\n\n\tSimon Gladman | http:\/\/flexmonkey.blogspot.co.uk | September 2017\n\n\nint sampleCount = 50;\nfloat blur = 0.6; \nfloat falloff = 2.50; \n\n\/\/ use iChannel0 for video, iChannel1 for test grid\n#define INPUTA iChannel0\n#define INPUTB iChannel1\n#define INPUTC iChannel2\n#define INPUTD iChannel3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 destCoord = fragCoord.xy \/ iResolution.xy;\n\n    vec2 direction = normalize(destCoord - 0.5); \n    vec2 velocity = direction * blur * pow(length(destCoord - 0.5), falloff);\n\tfloat inverseSampleCount = 1.0 \/ float(sampleCount); \n    \n    mat3x2 increments = mat3x2(velocity * .250 * inverseSampleCount,\n                               velocity * .50 * inverseSampleCount,\n                               velocity * 1.0 * inverseSampleCount);\n\n    vec3 accumulator = vec3(0);\n    mat3x2 offsets = mat3x2(0); \n    \n    for (int i = 0; i < sampleCount; i++) {\n        accumulator.r += texture(INPUTA, destCoord + offsets[0]).r; \n        accumulator.g += texture(INPUTA, destCoord + offsets[1]).g; \n        accumulator.b += texture(INPUTA, destCoord + offsets[2]).b; \n        \n        accumulator.r += texture(INPUTB, destCoord + offsets[0]).r; \n        accumulator.g += texture(INPUTB, destCoord + offsets[1]).g; \n        accumulator.b += texture(INPUTB, destCoord + offsets[2]).b; \n        \n        accumulator.r *= texture(INPUTC, destCoord + offsets[0]).r; \n        accumulator.g *= texture(INPUTC, destCoord + offsets[1]).g; \n        accumulator.b *= texture(INPUTC, destCoord + offsets[2]).b; \n        \n         accumulator.r += texture(INPUTD, destCoord + offsets[0]).r; \n        accumulator.g += texture(INPUTD, destCoord + offsets[1]).g; \n        accumulator.b += texture(INPUTD, destCoord + offsets[2]).b; \n        \n        \n        offsets -= increments;\n        \n   \/\/     accumulator.rgb = clamp(accumulator.rgb, 0., 1.);\n \n\/\/ vec4 blendy = (blend + accumulator),1.0;\n    }\n    vec3 blend  = texture(INPUTA, destCoord + offsets[0]).rgb;\n    blend = clamp(blend.rgb, 0., 1.);\n    vec3 blendo = (accumulator \/ float(sampleCount));\n \/\/blend += blend + accumulator;\nfragColor = mix(vec4(blend.rgb,1.0),vec4(blendo.rgb,1.0),0.975);\n\/\/\tfragColor = vec4(accumulator \/ float(sampleCount), 1.0);\n}\n\n*\/","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define iFeedbackColorShiftZoom 0.0011\n\/\/#define iFeedbackColorShiftImpact 0.001\n#define iBlob1ColorPulseSpeed -0.03456\n#define iBlob2ColorPulseSpeed 0.04321\n#define Margins .0\n\n\n\n\n\n\n\n\n\n\n\n\/*\n * Conway Ticket\n * \n * Copyright (C) 2021  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and\/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http:\/\/www.gnu.org\/licenses\/>.\n *\/\n \nivec2 boardSize = ivec2(125),\n    ci = ivec2(1,0);\nvec2 blockSize,\n    xij;\nvec3 c = vec3(1,0,-1);\nfloat stepTimeDelta = .05,\n    pi = 3.14159,\n    fsaa = 144.,\n    bpm = 90.,\n    spb = 60.\/90.,\n    scale,\n    nbeats,\n    stepTime;\n\n\/\/ Creative Commons Attribution-ShareAlike 4.0 International Public License\n\/\/ Created by David Hoskins.\n\/\/ See https:\/\/www.shadertoy.com\/view\/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(p.xyx * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat lfnoise(float y)\n{\n    vec2 t = y*c.xx;\n    vec2 i = floor(t);\n    t = smoothstep(c.yy, c.xx, fract(t));\n    vec2 v1 = vec2(hash12(i), hash12(i+c.xy)),\n    v2 = vec2(hash12(i+c.yx), hash12(i+c.xx));\n    v1 = c.zz+2.*mix(v1, v2, t.y);\n    return mix(v1.x, v1.y, t.x);\n}\n\nfloat m(vec2 x)\n{\n    return max(x.x,x.y);\n}\n\nfloat d210(vec2 x)\n{\n    return min(max(max(max(max(min(max(max(m(abs(vec2(abs(abs(x.x)-.25)-.25, x.y))-vec2(.2)), -m(abs(vec2(x.x+.5, abs(abs(x.y)-.05)-.05))-vec2(.12,.02))), -m(abs(vec2(abs(x.x+.5)-.1, x.y-.05*sign(x.x+.5)))-vec2(.02,.07))), m(abs(vec2(x.x+.5,x.y+.1))-vec2(.08,.04))), -m(abs(vec2(x.x, x.y-.04))-vec2(.02, .08))), -m(abs(vec2(x.x, x.y+.1))-vec2(.02))), -m(abs(vec2(x.x-.5, x.y))-vec2(.08,.12))), -m(abs(vec2(x.x-.5, x.y-.05))-vec2(.12, .07))), m(abs(vec2(x.x-.5, x.y))-vec2(.02, .08)));\n}\n\nfloat dbox3(vec3 x, vec3 b)\n{\n  b = abs(x) - b;\n  return length(max(b,0.))\n         + min(max(b.x,max(b.y,b.z)),0.);\n}\n\nfloat setStateF(ivec2 index, ivec2 where, float oldState, float newState)\n{\n    return all(equal(index, where)) ? newState : oldState;\n}\n\n\/\/ Distance to star\nfloat dstar(vec2 x, float N, vec2 R)\n{\n    float d = pi\/N,\n        p0 = acos(x.x\/length(x)),\n        p = mod(p0, d);\n    vec2 a = mix(R,R.yx,mod(round((p-p0)\/d),2.)),\n    \tp1 = a.x*c.xy,\n        ff = a.y*vec2(cos(d),sin(d))-p1;\n    return dot(length(x)*vec2(cos(p),sin(p))-p1,ff.yx*c.zx)\/length(ff);\n}\n\nfloat dhexagonpattern(vec2 p) \n{\n    vec2 q = vec2(p.x*1.2, p.y + p.x*.6),\n        qi = floor(q),\n        pf = fract(q);\n    float v = mod(qi.x + qi.y, 3.);\n    \n    return dot(step(pf.xy,pf.yx), 1.-pf.yx + step(1.,v)*(pf.x+pf.y-1.) + step(2.,v)*(pf.yx-2.*pf.xy));\n}\n\n\/\/ x: material\n\/\/ y: distance\n\/\/ z: reflectivity\nvec3 add(vec3 a, vec3 b)\n{\n    if(a.y < b.y) return a;\n    return b;\n}\n\nvec3 hsv2rgb(vec3 cc)\n{\n    vec4 K = vec4(1., 2. \/ 3., 1. \/ 3., 3.);\n    vec3 p = abs(fract(cc.xxx + K.xyz) * 6. - K.www);\n    return cc.z * mix(K.xxx, clamp(p - K.xxx, 0., 1.), cc.y);\n}\n\nvec2 rgb2sv(vec3 cc)\n{\n    vec4 K = vec4(0., -1. \/ 3., 2. \/ 3., -1.),\n        p = mix(vec4(cc.bg, K.wz), vec4(cc.gb, K.xy), step(cc.b, cc.g)),\n        q = mix(vec4(p.xyw, cc.r), vec4(cc.r, p.yzx), step(p.x, cc.r));\n    return vec2((q.x - min(q.w, q.y)) \/ (q.x + 1.e-10), q.x);\n}\n\n\n\n#define pi acos(-1.)\n\n\n#define sint(a) (asin(sin(a))*2. - 1.)\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n\/\/#define pmod(p,d) mod(p - (d)*0.5, (d)) - 0.5*(d)\n\nfloat r11(float i){ return fract(sin(i*12.126)*12.6);}\n\n#define xor(a,b,c) min(max((a),-(b)), max((b),-(a) - c)) \n\nfloat ss( float c, float power, float bias){\n    c = clamp(c,-0.,1.);\n    \/\/c = smoothstep(0.,1.,c);\n    \n    c = pow(c,1. + bias);\n    \n    float a = pow( abs(c), power);\n    float b = 1.-pow( abs(c - 1.), power);\n    \n    return mix(a,b,c);\n}\nfloat valueNoise(float i, float p){ return mix(r11(floor(i)),r11(floor(i) + 1.), ss(fract(i), p,0.6));}\n\nfloat valueNoiseStepped(float i, float p, float steps){ return mix(  floor(r11(floor(i))*steps)\/steps, floor(r11(floor(i) + 1.)*steps)\/steps, ss(fract(i), p,0.6));}\n\n\n\/\/ See: https:\/\/www.shadertoy.com\/view\/ls2Bz1\n\/\/ Spectral Colour Schemes\n\/\/ By Alan Zucconi\n\/\/ Website: www.alanzucconi.com\n\/\/ Twitter: @AlanZucconi\n\n\/\/ Example of different spectral colour schemes\n\/\/ to convert visible wavelengths of light (400-700 nm) to RGB colours.\n\n\/\/ The function \"spectral_zucconi6\" provides the best approximation\n\/\/ without including any branching.\n\/\/ Its faster version, \"spectral_zucconi\", is advised for mobile applications.\n\n\n\/\/ Read \"Improving the Rainbow\" for more information\n\/\/ http:\/\/www.alanzucconi.com\/?p=6703\n\n\n\nfloat saturate (float x)\n{\n    return min(1.0, max(0.0,x));\n}\nvec3 saturate (vec3 x)\n{\n    return min(vec3(1.,1.,1.), max(vec3(0.,0.,0.),x));\n}\n\n\/\/ --- Spectral Zucconi --------------------------------------------\n\/\/ By Alan Zucconi\n\/\/ Based on GPU Gems: https:\/\/developer.nvidia.com\/sites\/all\/modules\/custom\/gpugems\/books\/GPUGems\/gpugems_ch08.html\n\/\/ But with values optimised to match as close as possible the visible spectrum\n\/\/ Fits this: https:\/\/commons.wikimedia.org\/wiki\/File:Linear_visible_spectrum.svg\n\/\/ With weighter MSE (RGB weights: 0.3, 0.59, 0.11)\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n\tvec3 y = vec3(1.,1.,1.) - x * x;\n\ty = saturate(y-yoffset);\n\treturn y;\n}\n\n\/\/ --- Spectral Zucconi 6 --------------------------------------------\n\n\/\/ Based on GPU Gems\n\/\/ Optimised by Alan Zucconi\nvec3 spectral_zucconi6 (float x)\n{\n\t\/\/ w: [400, 700]\n\t\/\/ x: [0,   1]\n\n\tconst vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n\tconst vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n\tconst vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n\n\tconst vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n\tconst vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n\tconst vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n\n\treturn\n\t\tbump3y(c1 * (x - x1), y1) +\n\t\tbump3y(c2 * (x - x2), y2) ;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":259,"src":"\/media\/previz\/buffer02.png","ctype":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":258,"channel":0}],"code":"\/** \n * Brightness Contrast Saturation Hue\n * Demo: https:\/\/www.shadertoy.com\/view\/MdjBRy\n * starea @ ShaderToy\n * \n * Forked and remixed from: \n * [1] https:\/\/shadertoy.com\/view\/llGSzK\n * [2] https:\/\/shadertoy.com\/view\/MsjXRt\n *\n * Created 7\/26\/2017\n * Updated 8\/11\/2017\n **\/\n\n\/*\nmat4 brightnessMatrix( float b ) {\n    return mat4( \n        1, 0, 0, 0,\n        0, 1, 0, 0,\n        0, 0, 1, 0,\n        b, b, b, 1 );\n}\n*\/\nvoid brightnessAdjust( inout vec4 color, in float b) {\n    color.rgb += b;\n}\n\n\/*\nmat4 contrastMatrix( float c ) {\n\tfloat t = 0.5 - c * 0.5;\n    return mat4( \n        c, 0, 0, 0,\n        0, c, 0, 0,\n        0, 0, c, 0,\n        t, t, t, 1 );\n\n}\n*\/\n\nvoid contrastAdjust( inout vec4 color, in float c) {\n    float t = 0.5 - c * 0.5; \n    color.rgb = color.rgb * c + t;\n}\n\nmat4 saturationMatrix( float saturation ) {\n    vec3 luminance = vec3( 0.3086, 0.6094, 0.0820 );\n    float oneMinusSat = 1.0 - saturation;\n    vec3 red = vec3( luminance.x * oneMinusSat );\n    red.r += saturation;\n    \n    vec3 green = vec3( luminance.y * oneMinusSat );\n    green.g += saturation;\n    \n    vec3 blue = vec3( luminance.z * oneMinusSat );\n    blue.b += saturation;\n    \n    return mat4( \n        red,     0,\n        green,   0,\n        blue,    0,\n        0, 0, 0, 1 );\n}\n\nint modi(int x, int y) {\n    return x - y * (x \/ y);\n}\n\nint and(int a, int b) {\n    int result = 0;\n    int n = 1;\n\tconst int BIT_COUNT = 32;\n\n    for(int i = 0; i < BIT_COUNT; i++) {\n        if ((modi(a, 2) == 1) && (modi(b, 2) == 1)) {\n            result += n;\n        }\n\n        a >>= 1;\n        b >>= 1;\n        n <<= 1;\n\n        if (!(a > 0 && b > 0))\n            break;\n    }\n    return result;\n}\n\n\/\/ forked from https:\/\/www.shadertoy.com\/view\/llGSzK\n\/\/ performance optimized by Ruofei\nvec4 vibrance(vec4 inCol, float vibrance) \/\/r,g,b 0.0 to 1.0,  vibrance 1.0 no change, 0.0 image B&W.\n{\n \tvec4 outCol;\n    if (vibrance <= 1.0)\n    {\n        float avg = dot(inCol.rgb, vec3(0.3, 0.6, 0.1));\n        outCol.rgb = mix(vec3(avg), inCol.rgb, vibrance); \n    }\n    else \/\/ vibrance > 1.0\n    {\n        float hue_a, a, f, p1, p2, p3, i, h, s, v, amt, _max, _min, dlt;\n        float br1, br2, br3, br4, br5, br2_or_br1, br3_or_br1, br4_or_br1, br5_or_br1;\n        int use;\n\n        _min = min(min(inCol.r, inCol.g), inCol.b);\n        _max = max(max(inCol.r, inCol.g), inCol.b);\n        dlt = _max - _min + 0.00001 \/*Hack to fix divide zero infinities*\/;\n        h = 0.0;\n        v = _max;\n\n\t\tbr1 = step(_max, 0.0);\n        s = (dlt \/ _max) * (1.0 - br1);\n        h = -1.0 * br1;\n\n\t\tbr2 = 1.0 - step(_max - inCol.r, 0.0); \n        br2_or_br1 = max(br2, br1);\n        h = ((inCol.g - inCol.b) \/ dlt) * (1.0 - br2_or_br1) + (h*br2_or_br1);\n\n\t\tbr3 = 1.0 - step(_max - inCol.g, 0.0); \n        \n        br3_or_br1 = max(br3, br1);\n        h = (2.0 + (inCol.b - inCol.r) \/ dlt) * (1.0 - br3_or_br1) + (h*br3_or_br1);\n\n        br4 = 1.0 - br2*br3;\n        br4_or_br1 = max(br4, br1);\n        h = (4.0 + (inCol.r - inCol.g) \/ dlt) * (1.0 - br4_or_br1) + (h*br4_or_br1);\n\n        h = h*(1.0 - br1);\n\n        hue_a = abs(h); \/\/ between h of -1 and 1 are skin tones\n        a = dlt;      \/\/ Reducing enhancements on small rgb differences\n\n        \/\/ Reduce the enhancements on skin tones.    \n        a = step(1.0, hue_a) * a * (hue_a * 0.67 + 0.33) + step(hue_a, 1.0) * a;                                    \n        a *= (vibrance - 1.0);\n        s = (1.0 - a) * s + a * pow(s, 0.25);\n\n        i = floor(h);\n        f = h - i;\n\n        p1 = v * (1.0 - s);\n        p2 = v * (1.0 - (s * f));\n        p3 = v * (1.0 - (s * (1.0 - f)));\n\n        inCol.rgb = vec3(0.0); \n        i += 6.0;\n        \/\/use = 1 << ((int)i % 6);\n        use = int(pow(2.0,mod(i,6.0)));\n        a = float(and(use , 1)); \/\/ i == 0;\n        use >>= 1;\n        inCol.rgb += a * vec3(v, p3, p1);\n \n        a = float(and(use , 1)); \/\/ i == 1;\n        use >>= 1;\n        inCol.rgb += a * vec3(p2, v, p1); \n\n        a = float( and(use,1)); \/\/ i == 2;\n        use >>= 1;\n        inCol.rgb += a * vec3(p1, v, p3);\n\n        a = float(and(use, 1)); \/\/ i == 3;\n        use >>= 1;\n        inCol.rgb += a * vec3(p1, p2, v);\n\n        a = float(and(use, 1)); \/\/ i == 4;\n        use >>= 1;\n        inCol.rgb += a * vec3(p3, p1, v);\n\n        a = float(and(use, 1)); \/\/ i == 5;\n        use >>= 1;\n        inCol.rgb += a * vec3(v, p1, p2);\n\n        outCol = inCol;\n    }\n    return outCol;\n}\n\n\/\/ remixed from mAlk's https:\/\/www.shadertoy.com\/view\/MsjXRt\nvec4 shiftHue(in vec3 col, in float Shift)\n{\n    vec3 P = vec3(0.55735) * dot(vec3(0.55735), col);\n    vec3 U = col - P;\n    vec3 V = cross(vec3(0.55735), U);    \n    col = U * cos(Shift * 6.2832) + V * sin(Shift * 6.2832) + P;\n    return vec4(col, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ uniforms\n\tfloat brightness = 0.15;\n\tfloat contrast = 1.2;\n    float saturation = 1.5;\n    float _vibrance = 4.0;\n    float _hue = abs(sin(iTime * 0.1)); \n    \n    vec4 color = texture( iChannel0, fragCoord\/iResolution.xy );\n    \n    fragColor = saturationMatrix(saturation) * color; \n    brightnessAdjust(color, brightness); \n    contrastAdjust(color, contrast); \n    fragColor = vibrance(fragColor, _vibrance);\n    fragColor = shiftHue(fragColor.rgb, _hue);\n    fragColor.a = 1.0;\n    if (iMouse.z > 0.5) fragColor = color; \n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":258,"src":"\/media\/previz\/buffer01.png","ctype":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":260,"src":"\/media\/previz\/buffer03.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":260,"src":"\/media\/previz\/buffer03.png","ctype":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":260,"src":"\/media\/previz\/buffer03.png","ctype":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":259,"channel":0}],"code":"                                                                                                                                                                                                                                                                                        \/\/ See Image tab for details, also visit:\n\/\/\n\/\/ https:\/\/xemantic.github.io\/shader-web-background\/\n\/\/\n\/\/ In the original shader-web-background these values are provided as uniforms\n\/\/ feel free to play with them and if you will find something prettier than\n\/\/ the equilibrium I established, please send it back to me :)\nconst vec2  iFeedbackZoomCenter       = vec2(0., 0.);\nconst float iFeedbackZoomRate         = .001;\nconst float iFeedbackFadeRate         = .998;\n\/\/const float iFeedbackColorShiftZoom   = .05;\nconst float iFeedbackColorShiftImpact = 0.0001;\nconst vec2  iDrawCenter               = vec2(0., 0.);\nconst float iDrawIntensity            = 2.5;\nconst float iBlobEdgeSmoothing        = .15;\nconst float iBlob1Radius              = .33;\nconst float iBlob1PowFactor           = 20.;\n\/\/const float iBlob1ColorPulseSpeed     = .04;\nconst float iBlob2Radius              = .55;\nconst float iBlob2PowFactor           = 20.;\n\/\/const float iBlob2ColorPulseSpeed     = .01234;\nconst float iBlob2ColorPulseShift     = -.0;\nconst float iColorShiftOfRadius       = .5;\nconst float iFeedbackMouseShiftFactor = .003;\n\n\/*\n  Normally it would be provided by texture parameters, but on Mac\/iOS the texture REPEAT\n  seems to work only for power-of-2 texture sizes.\n *\/\nvec4 repeatedTexture(in sampler2D channel, in vec2 uv) {\n    return texture(channel, mod(uv, 1.));\n}\n\nfloat drawBlob(\n    in vec2 st,\n    in vec2 center,\n    in float radius,\n    in float edgeSmoothing\n) {\n    float dist = length((st - center) \/ radius);\n    return dist * smoothstep(1., 1. - iBlobEdgeSmoothing, dist);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \/\/ in shader-web-background provided as uniforms: start\n    float iMinDimension = min(iResolution.x, iResolution.y);\n    vec2 iScreenRatioHalf =\n        (iResolution.x >= iResolution.y)\n            ? vec2(iResolution.y \/ iResolution.x * .5, .5)\n            : vec2(.5, iResolution.x \/ iResolution.y);\n    vec3 iBlob1Color = spectral_zucconi6(\n        mod(iTime * iBlob1ColorPulseSpeed, 1.)\n    );\n    \n    vec3 iBlob2Color = spectral_zucconi6(\n        mod(iTime * iBlob2ColorPulseSpeed + iBlob2ColorPulseShift, 1.)\n    );\n    vec2 iFeedbackShiftVector =\n        (iMouse.x > 0. && iMouse.y > 0.)\n            ? (iMouse.xy * 2. - iResolution.xy) \/ iMinDimension * iFeedbackMouseShiftFactor\n            : vec2(0);\n    \/\/ in shader-web-background provided as uniforms: end\n            \n    \n    vec2 uv = fragCoord \/ iResolution.xy;\n    vec2 st = (fragCoord * 2. - iResolution.xy) \/ iMinDimension;\n\n    vec2  drawDelta = st - iDrawCenter;\n    float drawAngle = atan(drawDelta.x, drawDelta.y);\n    float drawDist = length(drawDelta);\n\nvec3 feedbk = repeatedTexture(iChannel1, uv - st).rgb;\n    vec3 colorShift = repeatedTexture(\n        iChannel0,\n        uv - st * iFeedbackColorShiftZoom * iScreenRatioHalf\n    ).rgb;\n\n    vec2 stShift = vec2(0);\n    stShift += iFeedbackZoomRate * (st - iFeedbackZoomCenter);\n    stShift += (feedbk.bg\/colorShift.rb - .5) * iFeedbackColorShiftImpact;\n    stShift += iFeedbackShiftVector;\n    stShift *= iScreenRatioHalf;\n\n    vec3 prevColor = repeatedTexture(iChannel2, uv - stShift).rgb;\n    prevColor *= iFeedbackFadeRate;\n\n    vec3 drawColor = vec3(0);\n   \n\n    float radius =\n        1.\n        + (colorShift.r + colorShift.g + colorShift.b) * iColorShiftOfRadius;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob1Radius, iBlobEdgeSmoothing),\n          iBlob1PowFactor\n        ) * iBlob1Color;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob2Radius, iBlobEdgeSmoothing),\n          iBlob2PowFactor\n        ) * iBlob2Color;\n\n    vec3 color = vec3(0);\n    drawColor *= iDrawIntensity;\n    prevColor *= iFeedbackFadeRate;\n    color += prevColor;\n    color += drawColor;\n\n    color = clamp(color, 0., 1.);\n    vec4 blend = texture(iChannel3,uv);\nvec4 blendy = texture(iChannel2,uv);\nvec4    blendo = max(blend,blendy);\n    fragColor = mix(blendo,vec4(color, 1.),0.95);\n\/\/      fragColor = min(blendo,vec4(color, 1.));\n}\n","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":5,"src":"\/media\/a\/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","ctype":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":30,"src":"\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":259,"src":"\/media\/previz\/buffer02.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":259,"src":"\/media\/previz\/buffer02.png","ctype":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":260,"channel":0}],"code":"\/\/ created by florian berger (flockaroo) - 2016\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ single pass CFD\n\/\/ ---------------\n\/\/ this is some \"computational flockarooid dynamics\" ;)\n\/\/ the self-advection is done purely rotational on all scales. \n\/\/ therefore i dont need any divergence-free velocity field. \n\/\/ with stochastic sampling i get the proper \"mean values\" of rotations \n\/\/ over time for higher order scales.\n\/\/\n\/\/ try changing \"RotNum\" for different accuracies of rotation calculation\n\/\/ for even RotNum uncomment the line #define SUPPORT_EVEN_ROTNUM\n\n#define RotNum 5\n\/\/#define SUPPORT_EVEN_ROTNUM\n\n#define Res  iChannelResolution[0]\n#define Res1 iChannelResolution[1]\n\n\/\/#define keyTex iChannel3\n\/\/#define KEY_I texture(keyTex,vec2((105.5-32.0)\/256.0,(0.5+0.0)\/3.0)).x\n\nconst float ang = 2.0*3.1415926535\/float(RotNum);\nmat2 mu = mat2(cos(ang),sin(ang),-sin(ang),cos(ang));\nmat2 mh = mat2(cos(ang*0.5),sin(ang*0.5),-sin(ang*0.5),cos(ang*0.5));\n\nvec4 randS(vec2 uv)\n{\n    return texture(iChannel1,uv*Res.xy\/Res1.xy)-vec4(0.5);\n}\n\nfloat getRot(vec2 pos, vec2 b)\n{\n    vec2 p = b;\n    float rot=0.0;\n    for(int i=0;i<RotNum;i++)\n    {\n        rot+=dot(texture(iChannel0,fract((pos+p)\/Res.xy)).xy-vec2(0.5),p.yx*vec2(1,-1));\n        p = mu*p;\n    }\n    return rot\/float(RotNum)\/dot(b,b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord.xy;\n    float rnd = randS(vec2(float(iFrame)\/Res.x,0.5\/Res1.y)).x;\n    \n    vec2 b = vec2(cos(ang*rnd),sin(ang*rnd));\n    vec2 v=vec2(0);\n    float bbMax=0.7*Res.y; bbMax*=bbMax;\n    for(int l=0;l<20;l++)\n    {\n        if ( dot(b,b) > bbMax ) break;\n        vec2 p = b;\n        for(int i=0;i<RotNum;i++)\n        {\n#ifdef SUPPORT_EVEN_ROTNUM\n            v+=p.yx*getRot(pos+p,-mh*b);\n#else\n            \/\/ this is faster but works only for odd RotNum\n            v+=p.yx*getRot(pos+p,b);\n#endif\n            p = mu*p;\n        }\n        b*=2.0;\n    }\n    \n     vec2 uv = fragCoord\/iResolution.xy; \/\/ Normalized pixel coordinates (from 0 to 1)\n\n\/\/  vec4 col = texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)\/Res.xy));\n\/\/  vec4 col2 = texture(iChannel3,fract((pos+v*vec2(-1,1)*2.0)\/Res.xy));\n\/\/  vec4 blend = mix(col2,col,0.5);\n  \n\/\/  fragColor=blend;\n  \n   vec4 col = texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)\/Res.xy));\n  vec4 col2 = texture(iChannel3,fract((pos+v*vec2(-1,1)*2.0)\/Res.xy));\n  vec4 blend = max(col,col2);\n  \n  fragColor=blend,(fract((pos+v*vec2(-1,1)*2.0)\/Res.xy));\n  \/\/  fragColor=texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)\/Res.xy));\n    \n    \/\/ add a little \"motor\" in the center\n \/\/   vec2 scr=(fragCoord.xy\/Res.xy)*2.0-vec2(1.0);\n\/\/    fragColor.xy += (0.001*scr.xy \/ (dot(scr,scr)\/0.1+0.3));\n    \n \/\/   if(iFrame<=4 || KEY_I>0.5) fragColor=texture(iChannel2,fragCoord.xy\/Res.xy);\n}\n","name":"Buffer D","description":"","type":"buffer"}]}}