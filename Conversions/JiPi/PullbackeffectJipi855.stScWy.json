{
 "ver": "0.1",
 "info": {
  "id": "stScWy",
  "date": "0",
  "viewed": 0,
  "name": "PullbackEffect JiPi855",
  "description": "4k intro presented at Revision 2022 demoparty\nCode: Kali\nMusic: Uctumi",
  "likes": 0,
  "published": "Private",
  "usePreview": 0,
  "tags": [
   "intro",
   "4k",
   "demoscene"
  ],
  "hasliked": 0,
  "parentid": "7t2yDz",
  "parentname": "[4k] Pullback Effect"
 },
 "renderpass": [
  {
   "inputs": [
    {
     "id": "ltBSRz",
     "filepath": "https://soundcloud.com/pablo-andrioli/bolacircuitera-version-bien-1",
     "type": "musicstream",
     "channel": 0,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 0
    }
   ],
   "outputs": [
    {
     "id": "4dfGRr",
     "channel": 0
    }
   ],
   "code": "#define time (iChannelTime[0]+1.2)\n\n#define resolution iResolution\n\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define sm(a,b) smoothstep(a,b,time)\n#define hash(p) fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453)\n\nfloat st, det = .01, t, sc = 0., on = 0., tr = 1., mat = 0., y;\nvec3 col = vec3(0), carpos, cardir, pal, glcol;\nvec2 pf1, pf2, pf3, e = vec2(0, .001);\n\n\nmat3 lookat(vec3 dir) {\n    dir = normalize(dir);\n    vec3 rt = normalize(vec3(-dir.z, 0, dir));\n    return mat3(rt, cross(rt, dir), dir);\n}\n\n\nfloat is(float s) {\n    return step(abs(sc - s), .1);\n\n}\n\nvec3 path(float tt) {\n    vec3 p = vec3(sin(tt * .5 + cos(tt * .2)) + sin(tt * .1), 5., tt);\n    tt += 70. * step(time, 80.);\n    p.y -= smoothstep(290., 280., tt) * 10. + smoothstep(270., 265., tt) * 5. + smoothstep(240., 235., tt) * 5.;\n    p.x *= .5 + tr * .5;\n    p.x *= sm(57., 55.) + sm(89., 91.);\n    return p;\n}\n\nvec3 carpath(float t) {\n    vec3 p = path(t);\n    p.y += 1. - tr + sm(52., 55.) * 4. * sm(82., 80.);\n    p.x *= sm(55., 52.) + sm(105., 107.);\n    p.z -= 375.;\n    p.xz *= rot(-sm(75., 80.) * 3.1416);\n    p.z += 375.;\n    if (time > 89.) p = path(p.z);\n    return p;\n}\n\nvec3 fractal(vec2 p)\n{\n    p = abs(fract(p * .05) - .5);\n    float ot1 = 1000., ot2 = ot1;\n    for (float i = 0.; i < 6.; i++) {\n        p = abs(p) / clamp(abs(p.x * p.y), 0.15, 5.) - vec2(1.5, 1);\n        ot1 = min(ot1, abs(p.x) + step(fract(time * .7 + float(i) * .2), .5 * p.y));\n        ot2 = min(ot2, length(p));\n    }\n    ot1 = smoothstep(.1, .05, ot1);\n    return time < 75. ? vec3(p, 0) * ot2 * ot1 * .3 + ot1 * .3 : vec3(p.x, -1, p.y * .5) * ot2 * ot1 * .3 + ot1 * .3; \n}\n\n\nfloat map(vec2 p) {\n    if (y > 10.) return 0.;\n    vec2 ppp = p.yx; ppp.x -= 311.;\n    vec3 pa = path(p.y);\n    float h = 0.;\n    p.x -= pa.x * sm(24., 25.);\n    float d = floor(p.y * 3.) / 3. - carpos.z - sm(52., 57.) * 20.;\n    p.x *= 1. + smoothstep(0., 2., d) * 2. * is(1.);\n    pf1 = p;\n    if (time < 24.) {\n        p -= carpos.xz;\n        p *= rot(-.5 * time / max(.5, floor(length(p))));\n        pf2 = vec2((atan(p.x, p.y) / 3.1416), length(p));\n        return pa.y - .5 - floor(length(p)) * sm(18., 17.) * (sm(5., 8.) - .5) * .7;\n    }\n    float b = step(300. + step(75., time) * 46., p.y);\n    p = floor(p * 3.) / 3.;\n    pf3 = p;\n    h += hash(p) * 3. * sm(24., 26.) * (1. - b * .9) * sm(550., 500.);\n    if (sc > 1.) p = floor(p), h += (clamp(hash(p + .1), .75, 1.) - .75) * 20.;\n    if (time > 22. && b < .5) h *= smoothstep(0.5, 5. - d, abs(p.x) * 1.5) * (sc > 1. ? 2. : 1.); // barre\n    h += pa.y - .5;\n    return h;\n}\n\nfloat de(vec3 p) {\n    p -= carpos;\n    st = .1;\n    float bound = length(p * vec3(1, 2, 1)) - 3. + tr;\n    if (bound > 0.) return bound + 5.;\n    p = lookat(cardir * vec3(.5, 0, 1)) * p;\n    p.xy *= rot(sin(time * 1.5) * .2 + cardir.x);\n    p.yz *= rot(t * 1.5 * step(.2, tr));\n    p.xz *= rot(.5 * tr);\n    float mat1 = exp(-.8 * length(sin(p * 6.)));\n    float d1 = length(p) - .5;\n    float d = 100.;\n    p.xy *= rot(smoothstep(.3, .5, abs(p.x)) * sign(p.x) * .2);\n    p.y *= 1.2 + smoothstep(.3, .4, abs(p.x));\n    p.x *= 1. - min(.7, abs(p.z - .4));\n    p.z += smoothstep(0., .6, p.x * p.x);\n    p.z -= smoothstep(.1, .0, abs(p.x)) * .5 * min(p.z, 0.);\n    d = length(p) - .5;\n    d += abs(p.y) * smoothstep(.6, .3, abs(p.x));\n    p.y += 5.;\n    d = mix(d, d1, sqrt(tr));\n    mat = mix(exp(-.8 * length(sin(p * 6.3))), mat1, tr) + step(abs(p.x), .03) * .1;\n    mat *= min(1., on * 4.);\n    if (d < 2.) st = .05;\n    return d * .6;\n}\n\nvec4 hit(vec3 p) {\n    float h = map(p.xz), d = de(p);\n    return vec4(p.y < h, d < det * 2., h, d);\n}\n\nvec3 bsearch(vec3 p, vec3 dir) {\n    float ste = st*-.5;\n    for (float h2 = 1., i = h2; i++ < 21.;)\n    {\n        p += dir * ste;\n        vec4 hi = hit(p);\n        float h = max(hi.x, hi.y);\n        if (abs(h - h2) > .001) {\n            ste *= -.5;\n            h2 = h;\n        }\n    }\n    return p;\n}\n\nvec3 march(vec3 from, vec3 dir) {\n    vec3 p, cl = vec3(0.), pr = p;\n    float td = 2. + hash(dir.xy + time) * .1, g = 0., eg = 0., ref = 0.;\n    p = from + td * dir;\n    vec4 h;\n    for (int i = 0; i < 300; i++) {\n        p += dir * st;\n        y = p.y;\n        td += st;\n        h = hit(p);\n        if (h.y > .5 && ref == 0.) {\n            pr = p;\n            ref = 1.;\n            p -= .2 * dir;\n            for (int i = 0; i < 20; i++) {\n                float d = de(p) * .5;\n                p += d * dir;\n                if (d < det) break;\n            }\n            dir = reflect(dir, normalize(vec3(de(p + e.yxx), de(p + e.xyx), de(p + e.xxy)) - de(p)));\n            p += hash(dir.xy + time) * .1 * dir;\n        }\n        g = max(g, max(0., .2 - h.w) / .2) * mat;\n        eg += .01 / (.1 + h * h * 20.).w * mat;\n        if (h.x > .5 || td > 25. || (h.y > .5 && mat > .4)) break;\n    }\n    if (h.x > .9) {\n        p -= dir * det;\n        p = bsearch(p, dir);\n        vec3 ldir = normalize(p - (carpos + vec3(0., 2., 0.)));\n        vec3 n = normalize(vec3(map(p.xz + e.yx) - map(p.xz - e.yx), 2. * e.y, map(p.xz + e.xy) - map(p.xz - e.xy)));;\n        n.y *= -1.;\n        float cam = max(.2, dot(dir, n)) * step(on, .9 - is(3.)) * .8;\n        cl = (max(cam * .3, dot(ldir, n)) * on + cam) * .8 * pal;\n        float dl = length(p.xz - carpos.xz) * 1.3 * (1. - sm(52., 55.) * .5);\n        cl *= min(.8, exp(-.15 * dl * dl));\n        cl += (fractal(pf1) * sm(20., 22.) + fractal(pf2 * 5.) * sm(25., 23.) + fractal(pf3 * .2) * 2. * float(1. < sc) * -n.y + fractal(p.xy).g * n.z * 2. * is(2.) + .7 * step(abs(pf1.x), .3) * step(.7, fract(pf1.y * 4.)) * step(pf1.y, 292.)\n            * step(1.5, sc)) * exp(-.3 * dl) * .7;\n        mat = 0.;\n    }\n    else {\n        cl = pal * ref * .3 + smoothstep(7., 0., length(p.xz)) * .13;\n    }\n    if (td > 25.) cl = fractal(p.xz * .2) * max(0.,dir.y);\n    cl = mix(cl, vec3(ref), .2 * ref) + exp(-.3 * length(p + vec3(0, 17, -157))) * glcol * 5. * is(3.);\n    p -= carpos;\n    if (time > 80. && time < 89. && length(p) < 2.) cl += fractal(p.zx*2.);\n    return cl + (g + eg) * glcol;\n}\n\nvec4 main2()\n{\n    vec2 uv = gl_FragCoord.xy / resolution.xy - .5; uv.x *= 1.8;\n    tr = sm(50., 48.) + sm(86.4, 89.);\n    on = sm(14., 15.) * abs(sin(time * .7)) * .6 - fract(sin(time) * 10.) * step(20., time);\n    if (time > 21.) on = 1.;\n    if (time > 110.) on = step(time, 114.3) * abs(sin(time * 8.));\n    pal = mix(vec3(.6, 1, .5) * .75, vec3(1, .5, .5), sm(74., 75.));\n    glcol = mix(vec3(.5, 1, .5) * on * .8, vec3(1.5, .5, .5), sm(74., 75.));\n    t = (max(21.2, time) - (time - 114.5) * sm(90., 116.5))*5.;\n    vec3 from = carpath(t - 2.);\n    vec3 cam = vec3(-4., 4., 2.);\n    if (time < 28.) cam.xz *= rot(-max(8., time) * .7 + 2.5);\n    if (time > 28.) from = carpath(t - 2.), cam = vec3(-3, 4, -2), sc = 1.;\n    if (time > 35.) from = carpath(t + 4.), cam = vec3(0, 3, 0);\n    if (time > 41.5) from = carpath(t - 3.), cam = vec3(1, 4. - tr * 2., 0);\n    if (time > 52.) from = carpath(t + 5.), cam = vec3(sin(time) * 3., 4, 0);\n    if (time > 55.) from = carpath(t + 5.), cam = mix(cam, vec3(-5, 6, -8), sm(55., 58.)), sc = 2.;\n    if (abs(time - 67.) < 3.) from = path(68. * 5.), cam = vec3(4, 3, -0.5);\n    if (time > 85.) sc = 3.;\n    cam.z += sm(77., 78.) * 4.;\n    cam.y *= .5 + .5 * sm(87., 85.);\n    cam.x += sm(90., 92.) * 10.;\n    cam = mix(cam, vec3(3, 2, 10), sm(105., 110.));\n    from += cam;\n    carpos = carpath(t);\n    vec3 carpos2 = carpath(t + 1. * (1. - is(0.)));\n    from = mix(from, carpos2 + cam * .8, sm(93., 95.));\n    cardir = normalize(carpath(t + 1.) - carpos);\n    return march(from, lookat(normalize(carpos2 - from)) * normalize(vec3(uv, 1.2 + sm(85., 86.) - sm(90., 91.)))).rgbr * sm(1., 3.) * sm(117.5, 115.5);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = main2();\n}",
   "name": "Image",
   "description": "",
   "type": "image"
  }
 ]
}