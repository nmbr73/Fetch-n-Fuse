{"Shader":{"ver":"0.1","info":{"id":"ldXGzN","date":"1363777687","viewed":2173,"name":"Audio heightfield 1","username":"huttarl","description":"Based on video heightfield by @simesgreen, https:\/\/www.shadertoy.com\/view\/Xss3zr\n\"The hills are alive...\"","likes":20,"published":3,"flags":0,"usePreview":0,"tags":["heightfield","audio"],"hasliked":0},"renderpass":[{"inputs":[{"id":19,"src":"\/media\/a\/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","ctype":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":37,"channel":0}],"code":"\/\/ Based on video heightfield by @simesgreen, https:\/\/www.shadertoy.com\/view\/Xss3zr\n\n\/* To try:\n - adjust range and scale of sound frequencies.\n   x use x^2 or something so they're spread more evenly\n   - adjust upward - are we missing some at the bottom?\n     No, there are no lower frequencies to show, apparently.\n*\/\n\nconst int _Steps = 64;\nconst vec3 lightDir = vec3(0.577, 0.577, 0.577);\n\nconst float bands = 30.0;\n\n\/\/ transforms\nvec3 rotateX(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    vec3 r;\n    r.x = p.x;\n    r.y = ca*p.y - sa*p.z;\n    r.z = sa*p.y + ca*p.z;\n    return r;\n}\n\nvec3 rotateY(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    vec3 r;\n    r.x = ca*p.x + sa*p.z;\n    r.y = p.y;\n    r.z = -sa*p.x + ca*p.z;\n    return r;\n}\n\nbool\nintersectBox(vec3 ro, vec3 rd, vec3 boxmin, vec3 boxmax, out float tnear, out float tfar)\n{\n\t\/\/ compute intersection of ray with all six bbox planes\n\tvec3 invR = 1.0 \/ rd;\n\tvec3 tbot = invR * (boxmin - ro);\n\tvec3 ttop = invR * (boxmax - ro);\n\t\/\/ re-order intersections to find smallest and largest on each axis\n\tvec3 tmin = min (ttop, tbot);\n\tvec3 tmax = max (ttop, tbot);\n\t\/\/ find the largest tmin and the smallest tmax\n\tvec2 t0 = max (tmin.xx, tmin.yz);\n\ttnear = max (t0.x, t0.y);\n\tt0 = min (tmax.xx, tmax.yz);\n\ttfar = min (t0.x, t0.y);\n\t\/\/ check for hit\n\tbool hit;\n\tif ((tnear > tfar)) \n\t\thit = false;\n\telse\n\t\thit = true;\n\treturn hit;\n}\n\n\nfloat normalCurve(float x) {\n\tconst float pi = 3.141592653589;\n\t\/\/ const float e = 2.71828;\n\t\/\/ return pow(e, -x*x*0.5) \/ sqrt(2.0 * pi);\n\t\/\/ Cauchy:\n\treturn 1.0\/(pi * (1.0 + x*x));\n}\n\n\/\/ return texture coords from 0 to 1\nvec2 worldToTex(vec3 p)\n{\n\tvec2 uv = p.xz*0.5+0.5;\n\tuv.y = 1.0 - uv.y;\n\treturn uv;\n}\n\nfloat h1(vec2 uv) {\n\tfloat band = pow(uv.x, 2.); \/\/ floor(uv.x * bands) \/ bands;\n\tfloat amp = texture(iChannel0, vec2(band, 0.25)).x;\n\treturn amp * normalCurve((uv.y - 0.5) * 5.0) * 1.5; \/\/  * (1.0 - abs(p.z - 0.5));\n}\n\n\/\/ return a value from 0 to 1\nfloat heightField(vec3 p)\n{\n\tvec2 uv = worldToTex(p);\n\t\/\/ Get amplitude of the frequency that corresponds to p.x\n\treturn h1(uv);\n\n\t\/\/ return sin(p.x * 4.0) * sin(p.z * 4.0) * 0.5 + 0.5;\n}\n\nbool traceHeightField(vec3 ro, vec3 rayStep, out vec3 hitPos)\n{\n\tvec3 p = ro;\n\tbool hit = false;\n\tfloat pH = 0.0;\n\tvec3 pP = p;\n\tfor(int i=0; i<_Steps; i++) {\n\t\tfloat h = heightField(p);\n\t\tif ((p.y < h) && !hit) {\n\t\t\thit = true;\n\t\t\t\/\/hitPos = p;\n\t\t\t\/\/ interpolate based on height\n            hitPos = mix(pP, p, (pH - pP.y) \/ ((p.y - pP.y) - (h - pH)));\n\t\t}\n\t\tpH = h;\n\t\tpP = p;\n\t\tp += rayStep;\n\t}\n\treturn hit;\n}\n\nvec3 background(vec3 rd)\n{\n     return mix(vec3(1.0, 1.0, 1.0), vec3(0.0, 0.5, 1.0), abs(rd.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixel = (fragCoord.xy \/ iResolution.xy)*2.0-1.0;\n\n    \/\/ compute ray origin and direction\n    float asp = iResolution.x \/ iResolution.y;\n    vec3 rd = normalize(vec3(asp*pixel.x, pixel.y, -2.0));\n    vec3 ro = vec3(0.0, 0.0, 2.0);\n\t\t\n\tvec2 mouse = iMouse.xy \/ iResolution.xy;\n\n\t\/\/ rotate view\n    float a;\n\ta = (0.25 + mouse.y) * 2.0 - 1.0;\n\t\/\/= -1.0;\n    rd = rotateX(rd, a);\n    ro = rotateX(ro, a);\n\t\t\n    \/\/a = -(mouse.x)*3.0;\n\ta = sin(iTime*0.2);\n    rd = rotateY(rd, a);\n    ro = rotateY(ro, a);\n\t\n\t\/\/ intersect with bounding box\n    bool hit;\t\n\tconst vec3 boxMin = vec3(-1.0, -0.01, -1.0);\n\tconst vec3 boxMax = vec3(1.0, 0.5, 1.0);\n\tfloat tnear, tfar;\n\thit = intersectBox(ro, rd, boxMin, boxMax, tnear, tfar);\n\n\ttnear -= 0.0001;\n\tvec3 pnear = ro + rd*tnear;\n    vec3 pfar = ro + rd*tfar;\n\t\n    float stepSize = length(pfar - pnear) \/ float(_Steps);\n\t\n    vec3 rgb = background(rd);\n    if(hit)\n    {\n    \t\/\/ intersect with heightfield\n\t\tro = pnear;\n\t\tvec3 hitPos;\n\t\thit = traceHeightField(ro, rd*stepSize, hitPos);\n\t\tif (hit) {\n\t\t\t\/\/ rgb = hitPos*0.5+0.5;\n\t\t\t\n\t\t\tvec2 uv = worldToTex(hitPos);\n\t\t\t\/\/ rgb = texture(iChannel0, uv).xyz;\n\t\t\tfloat amp = h1(uv) * 2.0;\n\n\t\t\t\/\/ float amp = hitPos.y * 2.0;\n            \/\/ Compute hue\n\t\t\trgb = vec3(amp, 4.0 * amp * (1.0 - amp), 0.5 * (1.0 - amp));\n            \/\/ Add white waveform\n\t\t\tfloat wave = texture(iChannel0, vec2(uv.x, 0.75)).x;\n\t\t\trgb += 1.0 -  smoothstep( 0.0, 0.01, abs(wave - uv.y));\n\t\t\t\/\/ vec3(amp, amp * 0.7 + 0.2, amp * 0.5 + 0.2);\n\t\t\t\/\/vec2 g = gradient(iChannel0, uv, vec2(1.0) \/ iResolution.xy);\n\t\t\t\/\/vec3 n = normalize(vec3(g.x, 0.01, g.y));\n\t\t\t\/\/rgb = n*0.5+0.5;\n#if 0\n\t\t\t\/\/ shadows\n\t\t\thitPos += vec3(0.0, 0.01, 0.0);\n\t\t\tbool shadow = traceHeightField(hitPos, lightDir*0.01, hitPos);\n\t\t\tif (shadow) {\n\t\t\t\trgb *= 0.75;\n\t\t\t}\n#endif\t\t\t\n\t\t}\n     }\n\n    fragColor=vec4(rgb, 1.0);\n\t\/\/fragColor = vec4(vec3(tfar - tnear)*0.2, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}}