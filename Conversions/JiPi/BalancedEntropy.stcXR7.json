{"Shader":{"ver":"0.1","info":{"id":"stcXR7","date":"1638850552","viewed":374,"name":"Balanced Entropy","username":"scry","description":"https:\/\/youtu.be\/DJ-6s62WcMo","likes":17,"published":3,"flags":0,"usePreview":0,"tags":["3d","raymarched","psychedelic","trippy"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"id":37,"channel":0}],"code":"#define deg (3.14159\/180.)\nmat2 r2d(float a) {\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\n\/\/rgb2hsv2rgb from https:\/\/stackoverflow.com\/questions\/15095909\/from-rgb-to-hsv-in-opengl-glsl\n\/\/ All components are in the range [0\u20261], including hue.\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 \/ 3.0, 2.0 \/ 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) \/ (6.0 * d + e)), d \/ (q.x + e), q.x);\n}\n\n\/\/ All components are in the range [0\u20261], including hue.\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 \/ 3.0, 1.0 \/ 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\/\/ 2D Random\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\n\/\/ 2D Noise based on Morgan McGuire @morgan3d\n\/\/ https:\/\/www.shadertoy.com\/view\/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    \/\/ Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    \/\/ Smooth Interpolation\n\n    \/\/ Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    \/\/ u = smoothstep(0.,1.,f);\n\n    \/\/ Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n\/\/from https:\/\/www.shadertoy.com\/view\/ttBXRG\nfloat staircase( in float x, in float k )\n{\n    float i = floor(x);\n    float f = fract(x);\n    \n    float a = 0.5*pow(2.0*((f<0.5)?f:1.0-f), k);\n    f = (f<0.5)?a:1.0-a;\n    \n    return i+f;\n}\n\n\nfloat bitm(vec2 uv,int c) {\n    float h = 5.;\n    float w = 3.;\n    int p = int(pow(2.,(w)));\n    float line1 = 9591.;\n    uv = floor(vec2(uv.x*w,uv.y*h))\/vec2(w,w);\n    float c1 = 0.;\n    float cc = uv.x + uv.y*w;\n    c1 = mod( floor( float(c) \/ exp2(ceil(cc*w-0.6))) ,2.);\n    c1 *= step(0.,uv.x)*step(0.,uv.y);\n    c1 *= step(0.,(-uv.x+0.99))*step(0.,(-uv.y+1.6));\n    return (c1);\n}\n#define logo 1\nvec3 slogo(vec2 uv, float ar) {\n    if (logo == 0) {\n        return vec3(0.);\n    }\n    vec2 px = vec2(1.\/3.,1.\/5.);\n    float ls = 4.1;\n    uv.x = 0.993-uv.x;\n    uv *= 8.*ls;\n    ls += 2.;\n    float ul = length(uv);\n    uv -= px.yx*0.5*0.5*ls;\n    ul = length(vec2(uv.x*0.5,uv.y)-0.5);\n    uv.x *= ar*1.75;\n    int s = 29671;\n    int c = 29263;\n    int r = 31469;\n    int y = 23186;\n    uv.x= 5.-uv.x;\n    float b = bitm(uv,s);\n    uv.x -= 1.\/3.*4.;\n    b += bitm(uv,c);\n    uv.x -= 1.\/3.*4.;\n    b += bitm(uv,r);\n    uv.x -= 1.\/3.*4.;\n    b += bitm(uv,y);\n    float rr = step(0.,uv.x+px.x*13.)*step(0.,uv.y+px.y)*step(0.,(-uv.x+px.x*4.))*step(0.,(-uv.y+px.y*6.));\n    b = clamp(b,0.,1.);\n    \/\/b = rr*floor(b);\n    float ptime = iTime;\n    vec3 l = hsv2rgb(vec3(b+ptime,0,rr-b*1.9))*rr;\n    \/\/l -= length(uv)*0.5;\n    \/\/l -= ul*rr*0.6;\n    l -= 0.1-clamp(ul*0.1,rr*1.-b,0.1);\n    \/\/l -= 3.-ul*2;\n    \/\/l = clamp(l,-1.,1.);\n    return vec3(l);\n}\n\n\/\/iq sdbox and sdvertcalcapsule functions :)\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat abx(float a,float b) {\n    return abs(abs(a)-b)-b;\n}\n\nfloat dty(vec3 p, vec3 s) {\n    float ls = s.x;\n    float lr = s.y;\n    \/\/p.zy *= r2d((3.14159\/180.)*-sin(iTime+p.y*20));\n    \/\/p.xy *= r2d((3.14159\/180.)*iTime);\n    float d = sdBox(p+vec3(0.,0,0.),vec3(lr*1.));\n    \/\/float d = sdVerticalCapsule(p+vec3(0.,ls\/2,0.),ls,lr);\n    \/\/float d = length(p)-0.001;\n    \/\/d = length(p)-0.014;\n    return d;\n}\n\nvec4 fr(vec3 p) {\n    \/\/p.z = 0.;\n    \/\/float pfd = 0.95;\n    \/\/p = (fract((p*pfd))-0.5)\/pfd;\n    \/\/p.xz *= r2d((3.14159\/180.)*-90);\n    float st = iTime*0.2;\n    float sm = sin(st*10.)*0.5+0.5;\n    \/\/sm = 0.;\n    \/\/sm += sin(st*2.)*0.25;\n    \/\/sm *= 1.;\n    float lp = length(p);\n    \/\/sm += sin(st*1)*0.125;\n    \/\/float lr = -0.001-sin(lp*20.+iTime)*0.0015;\n    float lr = 0.13;\n    float ls = 0.5;\n    \/\/p *= 2.;\n    \/\/ls += spectrum1.y*16.;\n    lr += 0.001;\n    float d = 10000.;\n    float u = 1.;\n\n    float lsm = 0.495;\n    vec3 dp = p;\n\n    float rt = iTime*2.;\n\n    float pd = 0.185;\n    \/\/float pm = 1.-(sin(iTime)*0.5+0.5);\n    float pm = 1.;\n    \/\/p *=  2.;\n    float tm = iTime;\n    tm *= 0.1;\n    float ia = -1.;\n    float pdm = sin(iTime*1.1+lp*dp.z*29.)*0.5+0.5;\n    pdm *= 0.2;\n    pdm += 0.3;\n    pdm = 0.5;\n    \/\/p += sin(p*20.+iTime)\/24.;\n    float lss = 2.8;\n    st += sin(st*2.)*0.25+sin(st*3.)*0.25;\n    int sps = 7;\n    vec3 rp = p;\n    \/\/rp.xy *= r2d(deg*90*floor(iTime*8.));\n    \/\/rp.xz *= r2d(deg*90*floor(iTime*20.3));\n    \/\/sps += int(rp.x*15.);\n    \/\/sps += (sin(iTime)*0.5+0.5)*10.; \n    sps = clamp(sps,1,18);\n    \/\/lr = deg*15.;\n   lr = 0.2;\n   float ad = (sin(iTime*0.4+lp*29.)*0.5+0.5);\n    \n    for (int i=0;i<sps;i++) {\n    d = min(d,dty(p,vec3(ls,lr,0.)));\n    \/\/d -= sin(d*80.)*0.005;\n    \/\/p += sin(d*200.)*0.001;\n    \n    \/\/d = min(d,dty(p.yxz,vec3(ls,lr,0.)));\n    \/\/d = min(d,dty(p.xzy,vec3(ls,lr,0.)));\n    \/\/p.x += 0.1;\n    ia += 1.;\n    \/\/lr *= 2.9;\n    lr *= .5;\n    \/\/lr += 0.000002;\n    \/\/lr = sin(lr+iTime*0.1)*0.1+0.1;\n    \/\/lr += 0.01;\n    \/\/lr *= ia+0.0003;\n    pd *= u;\n    \n    p.yz *= r2d((3.14159\/180.)*-45.);\n    p.zy = abs(p.zy);\n    \/\/p.x = abs(p.x)-0.09;\n    \n    p.yz *= r2d((3.14159\/180.)*+45.);\n    \n    p.xy *= r2d((3.14159\/180.)*-45.);\n\n    p.xy = abs(p.xy)-pd;\n\n    pd *= pdm;\n    \/\/pd *= sin(iTime*0.1+dp.z*2.)*0.5+0.5;\n\n    p.xy *= r2d((3.14159\/180.)*+45.);\n    \n    \/\/p = abs(p)-0.02;\n    \n    ls *= lsm;\n    ls += 0.002;\n    \n    }\n    \/\/d += sin(p.z*200.)*0.001;\n    \/\/p += iTime*0.1;\n    \/\/dp.xy *= r2d((iTime*0.1));\n    \/\/dp.xz *= r2d((iTime*0.3));\n    \/\/p = fract(p*0.5)\/0.5;\n    d = min(d,dty(p,vec3(ls,lr,0.)));\n    \/\/p *= sin(p*10.)*0.5;\n    d += (sin(p.y*90.+iTime+dp.x*5.)*0.5+0.5)*0.1;\n    d += (sin(p.y*30.+iTime*0.2+dp.x*2.)*0.5+0.5)*0.1;\n    \/\/d -= (sin(dp.y*7.+iTime*0.2)*0.5+0.5)*0.05;\n    d *= 0.5;\n    \/\/d = min(d,dty(p.yxz,vec3(ls,lr,0.)));\n    \/\/d = min(d,dty(p.xzy,vec3(ls,lr,0.)));\n\n    return vec4(p,d*0.5);\n}\n\n\nvec4 map(vec3 p) {\n    \/\/p += 1.;\n    \/\/p.xy *= r2d(1.);\n    \/\/p.xz *= r2d(1.);\n    \n   \n    \/\/p.xy += 2.;\n    \/\/\n    vec3 c = p;\n    p.z -= 1.;\n    \n    \/\/vec3 c = p;\n    float cd = 12.*(sin(iTime*0.002+5.)*0.5+0.5);\n    \/\/c.z = (fract(c.z*cd))\/cd;\n    float rt = iTime*0.1;\n    \/\/p.xy *= r2d((3.14159\/180.)*-45*iTime*9.);\n    \/\/p = abs(p);\n    \/\/p = abs(p+0.5);\n    p.yz *= r2d(deg*35.264);\n    p.xz *= r2d(-deg*90.);\n    \/\/p.z += 0.5;\n    \/\/p = abs(p)-0.5;\n    float pfd = 0.9;\n    \/\/p = (fract((p-0.25)*pfd)-0.5)\/pfd;\n    \/\/p.xz *= r2d(.75);\n    \/\/p += 0.89;\n    p.xy *= r2d(sin(rt*0.5)*0.5);\n    p.yz *= r2d(rt);\n\n    \n    float d = length(p)-3.;\n    \/\/float env = d;\n    \/\/float env = mix(d,sdBox(p,vec3(1.966)),0.001+sin(p.x*13.)*0.001);\n    float env = mix(d,sdBox(p,vec3(1.966)),0.002);\n    \/\/p.xz *= r2d(-rt);\n    \/\/p.z += iTime;\n    \n    \/\/float pz = p.z;\n    vec4 frd = fr(p);\n    \/\/d = sdf(p);\n    \n    \/\/d = abs(d)-0.0008;\n    \n    \n    d = frd.w;\n    d = min(d,-env);\n    \/\/float dl = (sin(iTime)*0.5+0.5)*0.1;\n    \/\/d = abs(d+0.01)-0.01;\n    float dl = 0.001;\n    d = abs(d+dl)-dl;\n    \/\/d = mix(d,(length(p)-0.28)*0.7,0.9);\n   \/\/ d = min(d,sdBox(p,vec3(0.3)));\n    c.z *= 2.;\n    d = max(d, -(length(c)-0.5));\n    \/\/d = max(d, -(length(c)-01.2));\n    \n    return vec4(p,d);\n}\n\nvec3 calcNorm(vec3 p) {\n    \/\/float eps = 0.01*(sin(p.z*0.1)*0.5+0.5);\n    float eps = 0.0008;\n    vec2 h = vec2(eps,0.);\n    return normalize(vec3(map(p-h.xyy).w-map(p+h.xyy).w,\n                          map(p-h.yxy).w-map(p+h.yxy).w,\n                          map(p-h.yyx).w-map(p+h.yyx).w));\n}\n\nfloat edges(vec3 p) {\n    float eps = 0.001;\n    \/\/return calcNorm(p)\n    vec3 n1 = calcNorm(p*(1.-eps));\n    vec3 n2 = calcNorm(p*(1.));\n    return clamp(abs((n1.x+n1.y+n1.z)-(n2.x+n2.y+n2.z)),0.,1.);\n    \/\/return (map(p+(eps)).w-map(p-(eps)).w)*18.;\n}\n\n\n#define render 0\nvec2 RM(vec3 ro, vec3 rd) {\n    float dO = 0.;\n    float ii = 0.;\n    int steps = 130;\n    \/\/steps = int(steps*(sin(iTime)*0.5+0.5));\n    if (render == 1) {\n        steps = 150;\n    }\n    float d = 130.;\n    for (int i=0;i<steps;i++) {\n        vec3 p = ro+rd*dO;\n        \/\/ro += calcNormL(p)*0.02;\n        \/\/ro += lens(p).xyz*0.2;\n        float dS = map(p).w;\n        dO += dS*(d\/float(steps));\n        \/\/dO += dS*(100.\/float(steps))*(dO+2.)*0.15;\n        ii += 0.5*d\/float(steps);\n        if (dO > 1000. || dS < 0.00009) {\n            break;\n        }\n    }\n    return vec2(dO,ii);\n}\n\nvec3 color(vec3 p, vec2 d) {\n    return vec3(p);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy \/ iResolution.xy;\n    vec2 tv = fragCoord.xy \/ iResolution.xy;\n    \n    vec2 R = iResolution.xy;\n    float ar = R.x\/R.y;\n    \/\/uv.x *= ar;\n    \n    uv -= 0.5;\n    uv.x *= ar;\n    float c= length(uv);\n    vec3 col = vec3(0.);\n    vec3 ro = vec3(0.,0.,0);\n    \/\/ro.z = -2.;\n    vec3 rd = normalize(vec3(uv,1.));\n    \n        vec3 bak = texture(iChannel0, tv).rgb;\n    float rn = noise(vec2(noise(fract(rd.xy*220.+iTime*0.01)*90.)*100.));\n    \/\/if (rn > 0.2) {\n    \/\/if (1 == 1) {\n    if (rn < clamp(c*.7,0.,1.0)+0.3 && render != 0) {\n        col = bak;\n        fragColor = vec4(col,1.0);\n        return;\n    }\n    \n    vec2 d = RM(ro,rd);\n    vec3 p = ro+rd*d.x;\n    vec4 mp = map(p);\n    vec3 n = calcNorm(p);\n    float lp = length(p);\n    \n    vec3 na = n;\n    \/\/vec3\n\n    \n    vec2 dd = d;\n    float ga = 1.;\n    float time = iTime;\n    vec4 m = mp;\n    vec4 mr = mp;\n    vec3 b = vec3(0.);\n    float e = edges(p);\n    \/\/e = clamp(e,0.,0.1)*8;\n    \/\/col += d.x*ga*0.1;\n    \/\/col += n*ga*0.1+d.y*ga*0.05;\n    \/\/col += d.x*.1;\n    \n    for(int i=0;i<2;i++) {\n        if (d.x > 1000.) {\n            \/\/col *= 0.;\n            ga = 0.;\n        }\n        \/\/col += d.y*0.02*ga;\n        col += hsv2rgb(vec3(d.x+iTime*0.01,d.y*0.015,d.y*0.02*ga));\n        \/\/col += (abs(e)*30.-0.3)*ga;\n        \/\/col += n+d.y*0.1-2.;\n        \/\/col += (n+d.y*0.1-2.+d.x*0.1)*ga;\n        \/\/col += abs((n*1.8+d.y*0.05-2.+d.x*0.1))*ga;\n        \/\/col += n*d.y*ga*0.01;\n        \/\/col += n*ga;\n        \/\/col += n*ga*d.x;\n        \/\/col += vec3(d.x*0.1)*ga;\n        \/\/col += d.x*ga*0.1;\n        \/\/col += n*ga*0.1+d.y*ga*0.05;\n        ga *= .3;\n        \/\/ga -= 0.2;\n        \/\/ga *= 0.2;\n        ro = p-n*0.002;\n        rd = reflect(rd,n);\n        d = RM(ro,rd);\n        \/\/b += d.x*0.02*ga;\n        p = ro+rd*d.x;\n        n = calcNorm(p);\n        e = edges(p);\n        mr = map(p);\n        \/\/col += d.x*.1;\n        \n        \/\/col += n*ga*0.1+d.y*ga*0.25;\n    }\n    \/\/col += d.y*ga*0.01;\n    \/\/col += e;\n    col += hsv2rgb(vec3(d.x,d.y*0.015,d.y*0.02*ga));\n    \/\/col *= 0.6;\n    col = rgb2hsv(col);\n    col.x += 0.7;\n    \/\/col.x += iTime;\n    col.y *= 1.2;\n    col.z -= dd.x*0.15;\n    col = hsv2rgb(col);\n    vec2 ttv = tv;\n    ttv -= 0.5;\n    \/\/ttv *= 0.99;\n    ttv += 0.5;\n\n    col += slogo(ttv,ar)*.6;\n    vec2 ux = uv;\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}}