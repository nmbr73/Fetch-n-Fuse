{
 "ver": "0.1",
 "info": {
  "id": "sdsfzs",
  "date": "0",
  "viewed": 0,
  "name": "Fluther Of Orbs JiPi 940",
  "description": "School of electric audio orbs, kind of like jelly fish.  Use mouse to look around.",
  "likes": 0,
  "published": "Private",
  "usePreview": 0,
  "tags": [
   "raymarching",
   "distancefield",
   "fisheye",
   "polarmarching"
  ],
  "hasliked": 0,
  "parentid": "4sl3Dj",
  "parentname": "Fluther Of Orbs"
 },
 "renderpass": [
  {
   "inputs": [
    {
     "id": "XdfGzn",
     "filepath": "/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3",
     "type": "music",
     "channel": 0,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    }
   ],
   "outputs": [],
   "code": "// **************************************************************************\n// DEFINITIONS\n\n#define PI 3.14159\n#define TWO_PI 6.28318\n#define ONE_OVER_PI 0.3183099\n#define ONE_OVER_TWO_PI 0.159154\n#define PI_OVER_TWO 1.570796\n    \n#define EPSILON 0.0001\n#define BIG_FLOAT 1000000.0\n\n// **************************************************************************\n// OPTIMIZATION DEFS\n\n// Comment in the quality of your choice based on graphics card performance\n\n//#define HIGH_QUALITY\n#define MID_QUALITY\n//#define LOW_QUALITY\n\n#ifdef HIGH_QUALITY\n#define MAX_NUM_TRACE_ITERATIONS 64\n#define NUM_POLAR_MARCH_STEPS 128\n#define FOG_EXTENT 1400.\n#endif\n\n#ifdef MID_QUALITY\n#define MAX_NUM_TRACE_ITERATIONS 48\n#define NUM_POLAR_MARCH_STEPS 64\n#define FOG_EXTENT 1000.\n#endif \n\n#ifdef LOW_QUALITY\n#define MAX_NUM_TRACE_ITERATIONS 32\n#define NUM_POLAR_MARCH_STEPS 32\n#define FOG_EXTENT 800.\n#endif \n\n// always have audio samples as multiple of 3\n#define NUM_AUDIO_SAMPLE_TRIPLES 3\n\n// **************************************************************************\n// GLOBALS\n\n// the beat electronebulae is about 126 beats per minute, so we some timings\n// based events based on multiples of that beat rate.\n\n// - - - - - - - - - - - - -\n// Audio based signals\nfloat g_beatRate = 126./60.;\nfloat g_time = 0.;\nfloat g_audioResponse = 1.;\n\n// audio signals\nfloat g_bassBeat = 0.;\nfloat g_audioFreqs[ NUM_AUDIO_SAMPLE_TRIPLES ];\n\n// - - - - - - - - - - - - -\n// Cell walls properties\n\n#define CELL_BOX_HALF_SIZE_DEFAULT 75.\nfloat g_cellBoxHalfSize = CELL_BOX_HALF_SIZE_DEFAULT;\n\n// - - - - - - - - - - - - -\n// Fog properties\n\nvec3 g_fogColor = vec3(0.23, 0.12, 0.12);\n\n// - - - - - - - - - - - - -\n// Orb properties\n\n//   dimensions of the orb\n#define ORB_OUTER_RADIUS_DEFAULT 50.\nfloat g_orbOuterRadius = ORB_OUTER_RADIUS_DEFAULT; // defaults\n#define ORB_CENTER_RADIUS_DEFAULT 10.\nfloat g_orbCenterRadius = ORB_CENTER_RADIUS_DEFAULT; // defaults\n\n//   surface properties of the orb\nfloat g_orbSurfaceFacingKr = .1;\nfloat g_orbSurfaceEdgeOnKr = 1.8;\nfloat g_orbIOR = 1.33;\n\nvec2 g_numOrbCells = vec2(24., 128.); // defaults\nvec2 g_numOrbsChangeRate = vec2(0.);\n\n//   properties of the \"spark\" lines\nfloat g_sparkWidth = 1.2;\nfloat g_sparkColorIntensity = 1.;\nvec3 g_sparkCoreColor = vec3(1.1, 0.5, 0.5);\nvec3 g_sparkExtentColor = vec3(1.2, 1.2, 2.3);\n\nvec2 g_sparkRotationRate = vec2(0.);\n\n// - - - - - - - - - - - - -\n// Camera properties\n\nvec3 g_camOrigin = vec3(0., 0., -120.);\nvec3 g_camPointAt = vec3( 0.0, 0.0, 0.0 );\nvec3 g_camUpDir = vec3( 0.0, 1.0, 0.0 );\n\nvec2 g_camRotationRates = vec2(0.);\n\n// **************************************************************************\n// MATH UTILITIES\n// **************************************************************************\n\n// XXX: To get around a case where a number very close to zero can result in \n// erratic behavior with sign, we assume a positive sign when a value is \n// close to 0.\nfloat zeroTolerantSign(float value)\n{\n    // DEBRANCHED\n    // Equivalent to:\n    // if (abs(value) > EPSILON) { \n    //    s = sign(value); \n    // }\n    return mix(1., sign(value), step(EPSILON, abs(value)));\n}\n\n// convert a 3d point to two orb coordinates. First coordinate is latitudinal\n// angle (angle from the plane going through x+z) Second coordinate is azimuth\n// (rotation around the y axis)\n\n// Range of outputs := ([PI/2, -PI/2], [-PI, PI])\nvec2 cartesianToPolar( vec3 p ) \n{    \n    return vec2(PI/2. - acos(p.y / length(p)), atan(p.z, p.x));\n}\n\n// Convert a polar coordinate (x is latitudinal angle, y is azimuthal angle)\n// results in a 3-float vector with y being the up axis.\n\n// Range of outputs := ([-1.,-1.,-1.] -> [1.,1.,1.])\nvec3 polarToCartesian( vec2 angles )\n{\n    float cosLat = cos(angles.x);\n    float sinLat = sin(angles.x);\n    \n    float cosAzimuth = cos(angles.y);\n    float sinAzimuth = sin(angles.y);\n    \n    return vec3(cosAzimuth * cosLat,\n                sinLat,\n                sinAzimuth * cosLat);\n}\n\n// Rotate the input point around the y-axis by the angle given as a \n// cos(angle) and sin(angle) argument.  There are many times where \n// I want to reuse the same angle on different points, so why do the \n// heavy trig twice.\n// Range of outputs := ([-1.,-1.,-1.] -> [1.,1.,1.])\nvec3 rotateAroundYAxis( vec3 point, float cosangle, float sinangle )\n{\n    return vec3(point.x * cosangle  + point.z * sinangle,\n                point.y,\n                point.x * -sinangle + point.z * cosangle);\n}\n\n// Rotate the input point around the x-axis by the angle given as a \n// cos(angle) and sin(angle) argument.  There are many times where \n// I want to reuse the same angle on different points, so why do the \n// heavy trig twice.\n// Range of outputs := ([-1.,-1.,-1.] -> [1.,1.,1.])\nvec3 rotateAroundXAxis( vec3 point, float cosangle, float sinangle )\n{\n    return vec3(point.x,\n                point.y * cosangle - point.z * sinangle,\n                point.y * sinangle + point.z * cosangle);\n}\n\n// Returns the floor and ceiling of the given float\nvec2 floorAndCeil( float x ) \n{\n    return vec2(floor(x), ceil(x));\n}\n\n// Returns the floor and ceiling of each component in respective\n// order (floor(p.x), ceil(p.x), floor(p.y), ceil(p.y)) \nvec4 floorAndCeil2( vec2 p ) \n{\n    return vec4(floorAndCeil(p.x), \n                floorAndCeil(p.y));\n}\n\n// Returns 2 floats, the first is the rounded value of float.  The second\n// is the direction in which the rounding took place.  So if rounding \n// occurred towards a larger number 1 is returned, otherwise -1 is returned. \nvec2 round_and_dir( float x ) \n{\n    return vec2(floor(x+0.5), sign(fract(x)-0.5));\n}\n\n// Returns 4 floats, \n// the first is the rounded value of p.x\n// the second is the direction in which the rounding took place for p.x\n// So if rounding occurred towards a greater number 1 is returned, \n// otherwise -1 is returned\n// the third is the rounded value of p.y.  \n// the fourth is the direction in which the rounding took place for p.y\nvec4 round_and_dir2( vec2 p ) \n{\n    return vec4(round_and_dir(p.x), round_and_dir(p.y));\n}\n\n// **************************************************************************\n// NOISE/FRACTAL FUNCTIONS\n// **************************************************************************\n\n// Periodic saw tooth function that repeats with a period of \n// 4 and ranges from [-1, 1].  \n// The function starts out at 0 for x=0,\n//  raises to 1 for x=1,\n//  drops to 0 for x=2,\n//  continues to -1 for x=3,\n//  and then rises back to 0 for x=4\n// to complete the period\n\nfloat sawtooth( float x )\n{\n    float xmod = mod(x+3.0, 4.);\n    return abs(xmod-2.0) - 1.0;\n}\n\n// **************************************************************************\n// INTERSECT UTILITIES\n// **************************************************************************\n\n// intersection for a sphere with a ray. In the case where a ray hits, there \n// is gauranteed to be a tmin and tmax return value even if one of the hits\n// is \"behind\" the ray origin. If both hits are behind the origin, no hit\n// takes place.\n\n// Returns a vec3 where:\n//  result.x = 1. or 0. to indicate if a hit took place\n//  result.y = tmin\n//  result.z = tmax\n\nvec3 intersectSphere(vec3 rayOrigin,                 \n                     vec3 rayDir, \n                     float radius,\n                     vec3 sphereCenter)\n{\n\n    // Calculate the ray origin in object space of the sphere\n    vec3 ospaceRayOrigin = rayOrigin - sphereCenter;\n\n    // We don't consider an intersection if the ray is inside the sphere\n\n    // DEBRANCH\n    // Equivalent to:\n    // if (dot(ospaceRayOrigin, ospaceRayOrigin) < radius*radius) {\n    //     return vec3(0.);\n    // }\n    \n    float a = dot(rayDir, rayDir);\n    float b = 2.0*dot(ospaceRayOrigin, rayDir);\n    float c = dot(ospaceRayOrigin, ospaceRayOrigin) - radius*radius;\n    float discr = b*b - 4.0*a*c; // discriminant\n\n    float tmin = 0.0;\n    float tmax = 0.0;\n\n    // DEBRANCH\n    // Equivalent to:\n    // if (discr > 0.) {\n    //     ...\n    // }\n\n    float isdiscrgtZero = step(0., discr);\n\n    // Real root of disc, so intersection\n    // avoid taking square root of negative discriminant.\n    float sdisc = sqrt(abs(discr));\n    tmin = (-b - sdisc)/(2.0 * a);\n    tmax = (-b + sdisc)/(2.0 * a); \n\n    float hit = isdiscrgtZero * max( step(0., tmin), step(0., tmax) );\n\n    return vec3(hit, tmin, tmax);\n}\n\n// Reference: http://geomalgorithms.com/a05-_intersect-1.html. Does an\n// intersection test against a plane that is assumed to be double sided and\n// passes through the origin and has the specified normal.\n\n// Returns a vec2 where:\n//   result.x = 1. or 0. if there is a hit\n//   result.y = t such that origin + t*dir = hit point\nvec2 intersectDSPlane(vec3 origin,\n                      vec3 dir,\n                      vec3 planeNormal,\n                      vec3 planeOffset)\n{\n    float dirDotN = dot(dir, planeNormal);\n    // if the ray direction is parallel to the plane, let's just treat the \n    // ray as intersecting *really* far off, which will get culled as a\n    // possible intersection.\n\n    float denom = zeroTolerantSign(dirDotN) * max(abs(dirDotN), EPSILON);\n    float t = min(BIG_FLOAT, -dot(planeNormal, (origin - planeOffset)) / denom);    \n    return vec2(step(EPSILON, t), t);\n\n}\n\n// Reference: http://geomalgorithms.com/a05-_intersect-1.html Does an\n// intersection test against a plane that is assumed to  be single sided and\n// passes through a planeOffset and has the specified normal.\n\n// References: \n// http://www.geometrictools.com/Documentation/IntersectionLineCone.pdf\n// http://www.geometrictools.com/LibMathematics/Intersection/Intersection.html\n//\n// Does an intersection with an infinite cone centered at the origin and \n// oriented along the positive y-axis extending to infinite.  Returns the \n// minimum positive value of t if there is an intersection.  \n\n// This function works by taking in the latitudinal parameters from -PI/2 to\n// PI/2 which correspond to the latitudinal of the x-z plane.  The reference\n// provided assumes the angle of the cone is determined based on the cone angle\n// from the y-axis.  So instead of using a cosine of the angle as described in\n// the reference, we use a sine of the angle and also consider whether the\n// angle is positive or negative to determine which side of the pooled cone\n// we are selecting.\n//\n// If the angle of the z-x plane is near zero, this function just does a an\n// intersection against the x-y plane to handle the full range of possible\n// input.  This function clamps any angles between -PI/2 and PI/2.\n\n// Trying to DEBRANCH this code results in webgl behaving funny in MacOS\n// XXX: Any help fixing this is appreciated\n\n// Returns a vec2 where:\n//   result.x = 1. or 0. if there is a hit\n//   result.y = t such that origin + t*dir = hit point\n\nvec2 intersectSimpleCone(vec3 origin,\n                         vec3 dir,\n                         float coneAngle)\n{\n    \n    // for convenience, if coneAngle ~= 0., then intersect\n    // with the x-z plane.      \n    float axisDir = zeroTolerantSign(coneAngle);\n    float clampedConeAngle = clamp(abs(coneAngle), 0., PI/2.);    \n    \n    float t = 0.;\n\n    if (clampedConeAngle < EPSILON) {\n        t = -origin.y / dir.y;\n        return vec2(step(0., t), t);\n    }\n    \n    // If coneAngle is 0, assume the cone is infinitely thin and no\n    // intersection can take place\n    if (clampedConeAngle < EPSILON) {\n        return vec2(0.);\n    }\n    \n    float sinAngleSqr = sin(clampedConeAngle);\n    sinAngleSqr *= sinAngleSqr;\n\n    // Quadric to solve in order to find values of t such that \n    // origin + direction * t intersects with the pooled cone.\n    // \n    // c2 * t^2 + 2*c1*t + c0 = 0\n    //\n    // This is a little math trick to get rid of the constants in the \n    // classic equation t = ( -b +- sqrt(b^2 - 4ac) ) / 2a\n    // by making b = 2*c1, you can see how this helps divide out the constants\n    // t = ( -2 * c1 +- sqrt( 4 * c1^2 - 4 * c2c0) / 2 * c2\n    // see how the constants drop out so that\n    // t = ( -c1 +- sqrt( c1^2 - c2 * c0)) / c2\n\n    // Lots of short cuts in reference intersection code due to the fact that\n    // the cone is at the origin and oriented along positive y axis.\n    // \n    // A := cone aligned axis = vec3(0., 1., 0.)\n    // E := origin - coneOrigin = origin\n    // AdD := dot(A, dir) = dir.y\n    // AdE := dot(A, E) = origin.y\n    // DdE := dot(dir, E) = dot(dir, origin)\n    // EdE := dot(E, E) = dot(origin, origin)\n    \n    float DdO = dot(dir, origin);\n    float OdO = dot(origin, origin);\n    \n    float c2 = dir.y * dir.y - sinAngleSqr;\n    float c1 = dir.y * origin.y - sinAngleSqr * DdO;\n    float c0 = origin.y * origin.y - sinAngleSqr * OdO;\n\n    float discr = c1*c1 - c2*c0;\n    float hit = 0.;\n\n    // if c2 is near zero, then we know the line is tangent to the cone one one\n    // side of the pool.  Need to check if the cone is tangent to the negative\n    // side of the cone since that could still intersect with quadric in one\n    // place.\n    if (abs(c2) > EPSILON) {\n    \n        if (discr < 0.0) {\n            \n            return vec2(0.);\n            \n        } else {\n    \n            // Real root of disc, so intersection may have 2 solutions, fine the \n            // nearest one.\n            float sdisc = sqrt(discr);\n            float t0 = (-c1 - sdisc)/c2;\n            float t1 = (-c1 + sdisc)/c2;\n    \n            // a simplification we can make since we know the cone is aligned\n            // along the y-axis and therefore we only need to see how t affects\n            // the y component.\n            float intersectPt0y = origin.y + dir.y * t0;\n            float intersectPt1y = origin.y + dir.y * t1;    \n            \n            // If the intersectPts y value is greater than 0. we know we've\n            // intersected along the positive y-axis since the cone is aligned\n            // along the y-axis\n    \n            // If the closest intersection point is also a valid intersection\n            // have that be the winning value of t.\n            \n            if ((t0 >= 0.) &&\n                (axisDir * intersectPt0y > 0.)) {\n                t = t0;\n                hit = 1.;\n            }\n            \n            if ((t1 >= 0.) &&\n                ((t1 < t0) || (hit < .5)) &&\n                (axisDir * intersectPt1y > 0.)) {\n                t = t1;     \n                hit = 1.;\n            }\n    \n        } \n\n    } else if (abs(c1) > EPSILON) {\n        // This is the code to handle the case where there  is a ray that is on\n        // the pooled cone and intersects at the very tip of the cone at the\n        // origin.\n        float t0 = -0.5 * c0 / c1;\n        \n        float intersectPty = origin.y + dir.y * t0;\n        if (( t0 >= 0.) && (axisDir * intersectPty > 0.)) {\n            t = t0;\n            hit = 1.;\n        }       \n    }\n    \n    return vec2(hit, t);\n\n}\n\n// Returns the vector that is the shortest path from the bounded line segment\n// u1->u2 to the line represented by the line passing through v1 and v2.  \n//\n// result.x is the distance of the shortest path between the line segment and\n// the unbounded line\n//\n// result.y = is the value of t along the line segment of ba [0,1] that \n// represents the 3d point (p) of the shortest vector between the two line \n// segments that rests on the vector between u1 anb u2 such that \n//    p = u1 + (u2-u1) * t\n//\n// result.z = is the value of t along the line passing through v1 and v2 such\n// that q represents the closest point on the line to the line segment u2<-u1:\n//    q = v1 + (v2-v1) * t\n// t is unbounded in this case but is parameterized such that t=0 at v1 and t=1\n// at v2.\n\nvec3 segmentToLineDistance( vec3 u1, \n                            vec3 u2, \n                            vec3 v1, \n                            vec3 v2 )\n{\n    vec3 u = u2 - u1;\n    vec3 v = v2 - v1;\n    vec3 w = u1 - v1;\n    \n    // For the maths:\n    // http://geomalgorithms.com/a07-_distance.html#dist3D_Segment_to_Segment\n    float a = dot(  u, u );\n    float b = dot(  u, v ); \n    float c = dot(  v, v );   \n    float d = dot(  u, w );\n    float e = dot(  v, w ); \n    \n    // just a way of calculating two equations with one operation.\n    // th.x is the value of t along ba\n    // th.y is the value of t along wv \n\n    // when a*c - b*b is near 0 (the lines are parallel), we will just assume\n    // a close line is the distance between u1 and v1\n    float denom = (a * c - b * b);\n\n    // DEBRANCHED\n    // Equivalent to:\n    // vec2 th = (abs(denom) < EPSILON ? vec2(0.) : \n    //                                  vec2( b*e - c*d, a*e - b*d ) / denom);\n\n    float clampedDenom = sign(denom) * max(EPSILON, abs(denom));\n    vec2 th = mix( vec2( b*e - c*d, a*e - b*d ) / clampedDenom, \n                   vec2(0.),\n                   step(abs(denom), EPSILON));\n\n    // In the case where the line to line comparison has p be a point that lives\n    // off of the bounded segment u2<-u1, just fine the closest path between u1\n    // and u2 and pick the shortest\n\n    float ifthxltZero = step(th.x, 0.);\n    float ifthxgt1 = step(1., th.x);\n\n    // DEBRANCHED\n    // Equivalent to:\n    // if (th.x < 0.) {\n    //     th.x = 0.;\n    //     th.y = dot(v, u1-v1) / c; // v . (u1<-v1) / v . v\n    // } else if (th.x > 1.) {\n    //     th.x = 1.;\n    //     th.y = dot(v, u2-v1) / c; // v . (u2<-v1) / v . v\n    // }\n    \n    th.x = clamp(th.x, 0., 1.);\n    th.y = mix(th.y, dot(v, u1-v1) / c, ifthxltZero);\n    th.y = mix(th.y, dot(v, u2-v1) / c, ifthxgt1);\n    \n    // p is the nearest clamped point on the line segment u1->u2\n    vec3 p = u1     + u  * th.x;\n    // q is the nearest unbounded point on the line segment v1->v2\n    vec3 q = v1     + v  * th.y;\n    \n    return vec3(length(p-q), th.x, th.y);\n}\n\n\n// Returns the vector that is the shortest path from the 3D point to the line\n// segment as well as the parameter t that represents the length along the line\n// segment that p is closest to.\n\n// Returned result is:\n\n// result.xyz := vector of the path from p to q where q is defined as the point\n// on the line segment that is closest to p.\n// result.w   := the t parameter such that a + (b-a) * t = q \n\nvec4 segmentToPointDistance( vec3 a, \n                             vec3 b, \n                             vec3 p)\n{\n    \n    vec3 ba = b - a;    \n    float t = dot(ba, (p - a)) / max(EPSILON, dot(ba, ba));\n    t = clamp(t, 0., 1.);\n    vec4 result = vec4(ba * t + a - p, t);\n    return result;\n}\n\n// Returns the vector that is the shortest path from the 3D point to the  line\n// that passes through a and b as well as the parameter t that represents the\n// length along the line that p is closest to.\n\n// Returned result is:\n\n// result.xyz := vector of the path from p to q where q is defined as the point\n// on the line segment that is closest to p.\n// result.w   := the t parameter such that a + (b-a) * t = q \n\nvec4 lineToPointDistance( vec3 a, \n                          vec3 b, \n                          vec3 p)\n{\n    \n    vec3 ba = b - a;    \n    float t = dot(ba, (p - a)) / dot(ba, ba);\n    vec4 result = vec4(ba * t + a - p, t);\n    return result;\n}\n\n// **************************************************************************\n// SHADING UTILITIES\n// **************************************************************************\n\n// Approximating a dialectric fresnel effect by using the schlick approximation\n// http://en.wikipedia.org/wiki/Schlick's_approximation. Returns a vec3 in case\n// I want to approximate a different index of reflection for each channel to\n// get a chromatic effect.\nvec3 fresnel(vec3 I, vec3 N, float eta)\n{\n    // assume that the surrounding environment is air on both sides of the \n    // dialectric\n    float ro = (1. - eta) / (1. + eta);\n    ro *= ro;\n    \n    float fterm = pow(1. - max(dot(-I, N), 0.), 5.);  \n    return vec3(ro + ( 1. - ro ) * fterm); \n}\n\n// **************************************************************************\n// TRACE UTILITIES\n// **************************************************************************\n\n// This ray structure is used to march the scene and accumulate all final\n// results.\n\nstruct SceneRayStruct {\n    vec3 origin;        // origin of the ray - updates at refraction, \n                        // reflection boundaries\n    vec3 dir;           // direction of the ray - updates at refraction, \n                        // reflection boundaries\n\n    float marchDist;    // current march distance of the ray - updated during\n                        // tracing\n    float marchMaxDist; // max march distance of the ray - does not update\n\n    vec3 cellCoords; // current box being marched through - updated during\n                        // marching\n\n    vec4 orbHitPoint;   // xyz is the point on the orb that hit point took\n                        // place.  The w value is 0 or 1 depending on if there\n                        // was in fact a hit on an orb.\n\n    vec4 color;         // accumulated color and opaqueness of the ray - updated\n                        // during tracing\n\n    vec4 debugColor;    // an alternative color that is updated during\n                        // traversal if it has a non-zero opaqueness, then it\n                        // will be returned to the frame buffer as the current\n                        // frag color. Alpha is ignored when displaying to the \n                        // frag color.\n};\n\n// This ray structure is used to march through a space that represents the\n// interior of the orbs and is chopped up into cells whose boundaries are\n// aligned with the azimuthal and latitudinal angles of the sphere.\n\n// Looking at a cross section of the orb from the azimuthal direction (from\n// top down). You can see how in this case of a sphere divided into 8\n// subdomains, the cell coordinates wrap at the back of the sphere.\n\n//\n//        . * ' * .\n//      *   8 | 1   *\n//    *  \\    |    /  *\n//   /  7  \\  |  /  2  \\\n//  *________\\|/________*\n//  *        /|\\        *\n//   \\  6  /  |  \\  3  /\n//    *  /    |    \\  *\n//      *   5 | 4   *\n//        ' * . * ' \n//\n//        V Front V\n\n\n// Looking at a cross section of the orb from the side split down the center.\n// You can see in this example of the latitudinal cells having 4 subdomains\n// (or cells), the latitudinal cells are divided by cones originating from the\n// sphere center.\n\n//\n//        . * ' * .\n//      * \\   4   / *\n//    *    \\     /    *\n//   /  3   \\   /   3  \\\n//  *________\\ /________*\n//  *        / \\        *\n//   \\  2   /   \\   2  /\n//    *    /     \\    *\n//      * /   1   \\ *\n//        ' * . * '\n//\n//        V Bottom V\n\nstruct OrbRayStruct {\n    vec3 origin;                  // origin of the ray to march through the\n                                  // orb space - does not update\n    \n    vec3 dir;                     // direction of the ray to march through the\n                                  // orb space - does not update\n\n    float marchDist;              // current march distance of the ray through\n                                  // the sphere - updated during tracing\n\n    float marchNextDist;          // represents the next extent of the current\n                                  // cell so we can create a line segment on\n                                  // the ray that represents the part of the\n                                  // line that is clipped by the orb cell\n                                  // boundaries.  We then use this line\n                                  // segment to perform a distance test  of\n                                  // the spark\n\n    float marchMaxDist;           // max march distance of the ray - does not \n                                  // update represents the other side the sphere\n \n    int azimuthalOrbCellMarchDir; // when marching through the orb cells, we\n                                  // keep track of which way the ray is going\n                                  // in the azimuthal direction, so we only\n                                  // need to test against one side of the\n                                  // orb cell - a plane that lies on the\n                                  // y-axis and is rotated  based on the\n                                  // current cell.  This avoids precision\n                                  // issues calculated at beginning of\n                                  // traversal and used through out the\n                                  // iterations.\n\n    vec2 orbCellCoords;           // Keep track of the current orb cell\n                                  // we're in: x is the latitudinal cell number\n                                  // y is the azimuthal cell number\n\n    float orbHash;                // Hash to this particular orb so we can use\n                                  // it as the unique identifier to key into \n                                  // variation based signals.\n\n    vec4 color;                   // accumulated color and opaqueness of the ray\n                                  // marching the orbs.\n\n    vec4 debugColor;              // an alternative color that is updated during\n                                  // traversal if it has a non-zero opaqueness,\n                                  // then it will be returned to the frame\n                                  // buffer as the current frag color\n\n};\n\n// Returns the distance field to the cell center corresponding to the \n// cell coordinate plus the neighbor offset, which should only have \n// integer values in the range ([-1,-1,-1], [1,1,1])\n//\n// result.xyz = p relative to the neighbor orb center\n// result.w   = distance to orb exterior \nvec4 currCellOrbDF( vec3 modp, \n                    vec3 cellCoords, \n                    vec3 neighborOffset)\n{\n\n    float maxOffset = g_cellBoxHalfSize - ORB_OUTER_RADIUS_DEFAULT;\n    vec3 currCellCoords = cellCoords + neighborOffset;  \n\n    // Add a subtle sinuisoidal wave to sorb center.\n    vec3 noiseSeed = vec3(dot(vec3(5.3, 5.0, 6.5), currCellCoords),\n                          dot(vec3(6.5, 5.3, 5.0), currCellCoords),\n                          dot(vec3(5.0, 6.5, 5.3), currCellCoords));\n    \n    noiseSeed += 0.5 * vec3(0.5, 0.9, 1.2) * g_time;\n                          \n    vec3 currOffset = vec3(maxOffset) * cos(noiseSeed);     \n\n    vec3 currSphCenter = 2. * g_cellBoxHalfSize * neighborOffset + currOffset;\n    vec3 sphereRelativeP = modp - currSphCenter;\n\n    float dist = length(sphereRelativeP) - g_orbOuterRadius;    \n\n    return vec4(sphereRelativeP, dist);   \n}\n\n// Returns the distance field to the nearest orb shell plus the position of\n// p relative to the center of the orb.\n//\n// result.xyz = p relative to orb center\n// result.w   = distance to orb exterior \nvec4 orbDF( vec3 p, vec3 rayDir, vec3 cellCoords )\n{\n\n    // Look into this cell to check distance to that sphere and then check the\n    // distance to the spheres for the next cells to see if they are closer,\n    // we can guess the \"next\" cells by just looking at the sign of the ray\n    // dir (so we don't check all 27 possible cells - 9x9x9 grid).  This\n    // limits it down just to checking 8 possible cells.\n    vec3 modp = mod(p, 2. * g_cellBoxHalfSize) - g_cellBoxHalfSize;\n\n    vec4 nextCellOffset = vec4(sign(rayDir), 0.);\n\n    // 1. current cell\n    vec4 result = currCellOrbDF(modp, cellCoords, vec3(0.));\n        \n    // 2. neighbor in the x direction of the ray\n    vec4 neighborResult = currCellOrbDF(modp, cellCoords, nextCellOffset.xww);    \n    if (neighborResult.w < result.w) { result = neighborResult; }\n\n    // 3. neighbor in the y direction of the ray\n    neighborResult = currCellOrbDF(modp, cellCoords, nextCellOffset.wyw);\n    if (neighborResult.w < result.w) { result = neighborResult; }\n\n    // 4. neighbor in the z direction of the ray\n    neighborResult = currCellOrbDF(modp, cellCoords, nextCellOffset.wwz);\n    if (neighborResult.w < result.w) { result = neighborResult; }\n    \n    // 5. neighbor in the x-y direction of the ray\n    neighborResult = currCellOrbDF(modp, cellCoords, nextCellOffset.xyw);\n    if (neighborResult.w < result.w) { result = neighborResult; }\n\n    // 6. neighbor in the y-z direction of the ray\n    neighborResult = currCellOrbDF(modp, cellCoords, nextCellOffset.wyz);\n    if (neighborResult.w < result.w) { result = neighborResult; }\n\n    // 7. neighbor in the x-z direction of the ray\n    neighborResult = currCellOrbDF(modp, cellCoords, nextCellOffset.xwz);\n    if (neighborResult.w < result.w) { result = neighborResult; }\n        \n    // 8. neighbor in the x-y-z direction of the ray\n    neighborResult = currCellOrbDF(modp, cellCoords, nextCellOffset.xyz);\n    if (neighborResult.w < result.w) { result = neighborResult; }\n\n    return result;\n}\n\n// Given a scene ray generated from a camera, trace the scene by first\n// distance field marching.\n\nfloat traceScene(inout SceneRayStruct sceneRay)\n{\n\n    // --------------------------------------------------------------------\n    // How deep into the \"infinite\" cooridor of orbs do we want to go.  Each\n    // iteration does distance field marching which will converge on the \n    // nearest orb or continue to the next.\n\n    vec3 marchPoint = sceneRay.origin;\n    float dist = BIG_FLOAT;\n    \n    for (int iterations = 0; \n         iterations < MAX_NUM_TRACE_ITERATIONS; \n         iterations += 1) {\n        \n        if ((sceneRay.marchMaxDist < sceneRay.marchDist) ||\n            (dist < .01)) {\n            continue;\n        }  \n                \n        // used as a way to hash the current cell\n        sceneRay.cellCoords = floor(marchPoint /(2. * g_cellBoxHalfSize));\n\n        // scene map\n        vec4 orbDFresult = orbDF( marchPoint, \n                                  sceneRay.dir,\n                                  sceneRay.cellCoords );\n        dist = orbDFresult.w;\n\n        if (dist < .01) {\n\n            sceneRay.orbHitPoint.xyz = orbDFresult.xyz;\n            sceneRay.orbHitPoint.w = 1.;\n        }\n        \n        sceneRay.marchDist += dist;\n        marchPoint += dist * sceneRay.dir; \n        \n    }            \n\n    return sceneRay.orbHitPoint.w;\n}\n\n\n// Function used for ray marching the interior of the orb.  The sceneRay is \n// also passed in since it may have some information we want to key off of\n// like the current orb cell coordinate.\n//\n// Returns the OrbRayStruct that was passed in with certain parameters\n// updated.\nvoid shadeOrbInterior(inout OrbRayStruct orbRay, \n                      in SceneRayStruct sceneRay)\n{    \n    \n    // Before marching into the orb coordinates, first determine if the orbRay\n    // is casting in the direction of the sphere where the \"angle\" is increasing\n    // along the azimuthal direction, in which case we assume we are marching\n    // along the azimuthal cells in a positive direction.\n\n    vec3 orbRayEnd = orbRay.origin + orbRay.dir * orbRay.marchMaxDist;\n    vec4 ltpresult = lineToPointDistance(orbRay.origin, orbRayEnd, vec3(0.));\n    vec3 ltp = ltpresult.xyz;\n    vec3 rdircrossltp = normalize(cross(orbRay.dir, ltp));\n        \n    orbRay.azimuthalOrbCellMarchDir = (dot(rdircrossltp, \n                                      vec3(0., 1., 0.)) > 0.) ? 1 : -1;  \n\n\n    // ------------------------------------------------------------\n    // Convert the cartesian point to orb space within the range\n    // Latitudinal    := [-PI/2, PI/2]\n    // Azimuth        := [-PI, PI]\n    vec2 orbRayOriginPt = cartesianToPolar(orbRay.origin);                \n    \n    //\n    // convert orb coordinates into number of spark domains       \n    // Latitudinal    := [-PI/2, PI/2]\n    // Azimuth        := [-PI, PI]\n    // LatdDomains    := [-numLatdDomains/2., numLatdDomains/2.] \n    // AzimuthDomains := [-numAzimDomains/2., numAzimDomains/2.]\n    // In order to avoid confusion        \n\n    orbRayOriginPt -= g_sparkRotationRate * g_time;\n    orbRayOriginPt *= g_numOrbCells * vec2(1./PI, 1./TWO_PI);\n\n    vec4 rOrbRayOriginPtResults = round_and_dir2(orbRayOriginPt);\n    vec2 cellCoords = vec2(rOrbRayOriginPtResults.xz);                        \n    cellCoords -= vec2(.5,.5) * rOrbRayOriginPtResults.yw;\n\n    orbRay.orbCellCoords = cellCoords;\n\n    // ------------------------------------------------------------\n    // March through the orb cells a fixed number of steps.\n\n    for ( int i = 0; i < NUM_POLAR_MARCH_STEPS; i++)\n    {\n        // If orbRay color has near opaque opacity or we've reached the extent of \n        // the orb, no need to continue marching.  Use continue instead of break\n        // since that appears to be more optimal.\n        if (max(step(orbRay.marchMaxDist, orbRay.marchDist),\n                step(0.95, orbRay.color.a)) > .5) {\n            continue;\n        }\n        \n        vec3 marchPoint = orbRay.origin + orbRay.dir * orbRay.marchDist;\n        \n        // Convert the cartesian point to orb space within the range\n        // Latitudinal    := [-PI/2, PI/2]\n        // Azimuth        := [-PI, PI]\n        vec2 orbMarchPt = cartesianToPolar(marchPoint);                \n        \n        // convert orb coordinates into number of cell domains       \n        // From:\n        // Latitudinal    := [-PI/2, PI/2]\n        // Azimuth        := [-PI, PI]\n        // To:\n        // LatdDomains    := [-numLatdDomains/2., numLatdDomains/2.]        \n        // AzimuthDomains := [-numAzimDomains/2., numAzimDomains/2.]\n\n        orbMarchPt -= g_sparkRotationRate * g_time;\n        orbMarchPt *= g_numOrbCells * vec2(ONE_OVER_PI, ONE_OVER_TWO_PI);\n\n        vec2 orbSparkStart = orbRay.orbCellCoords;     \n        \n        // convert back into orb coordinate range \n        // Latitudinal      := [-PI/2, PI/2]\n        // Azimuth        := [-PI, PI] \n        vec2 remapOrbSparkStart = orbSparkStart * vec2(PI, TWO_PI) / \n                                            g_numOrbCells;\n                \n        remapOrbSparkStart += g_sparkRotationRate * g_time;     \n                \n        // ------------------------------------------------------------------\n        // Spark color contribution\n\n        // create the properties of this spark\n        vec3 sparkDir = polarToCartesian(remapOrbSparkStart);\n        vec3 sparkOrigin = g_orbCenterRadius * sparkDir;\n        vec3 sparkEnd = g_orbOuterRadius * sparkDir;\n                \n        // test this marches closeness to the spark and use that to\n        // drive spark presence.\n        vec3 sparkResult = segmentToLineDistance(sparkOrigin,\n                                                 sparkEnd,\n                                                 orbRay.origin,\n                                                 orbRayEnd);\n\n        vec3 sparkColor = vec3(0.);\n        float sparkOpacity = 0.;        \n        \n        // As the orbs are traced farther into the distance, increase the glow extent\n        // and alpha extent to account for filtering.\n\n        float distanceLerp = smoothstep(100., 600., sceneRay.marchDist);\n        float sparkGlowExtent = max(g_sparkWidth, mix(.5, 3.0, distanceLerp));\n        float sparkAlphaExtent = 1.2 * sparkGlowExtent;\n        float sparkAttenuate = abs(sparkResult.x);\n\n        // Use triples to compress the expensive operations by using their vec3\n        // versions.\n        vec3 audioAttenuateTriples = vec3(0.);\n        \n        // Determine how the audio signals drive this spark.  Each audio sample is\n        // \"traveling\" through the spark of the orbs from top down with different offsets.\n        for (int i = 0; i < NUM_AUDIO_SAMPLE_TRIPLES; i += 1) {\n            vec3 indexes = 3. * vec3(float(i) + 0., \n                                     float(i) + 1.,\n                                     float(i) + 2.);\n\n            vec3 sparkPopTravelSeed = 10. * indexes + orbRay.orbHash + orbRay.orbCellCoords.x + g_beatRate * 3. * g_time;                                  \n            sparkPopTravelSeed = smoothstep(vec3(15.), \n                                            vec3(0.), \n                                            mod(sparkPopTravelSeed, \n                                                5. * 3. * float(NUM_AUDIO_SAMPLE_TRIPLES)));\n\n            sparkPopTravelSeed = smoothstep(0., \n                                            0.75,  \n                                            pow(sparkPopTravelSeed, vec3(1.5)) );\n\n            audioAttenuateTriples += g_audioFreqs[i] * sparkPopTravelSeed;\n        }\n        \n        // Take the sum of all of the audio attnuate triples for this\n        // spark.\n        float audioAttenuate = dot(audioAttenuateTriples, vec3(1.));\n\n        audioAttenuate = mix(1., min(1., audioAttenuate), g_audioResponse);\n    \n        sparkAttenuate = mix(1.2 * sparkAlphaExtent, sparkAttenuate, audioAttenuate);\n\n        // The core presence has a longer throw then the spark itself, which helps it\n        // pop against sparks in the bg.\n        float sparkCorePresence = smoothstep(sparkGlowExtent, 0., sparkAttenuate);\n        float sparkAmt = smoothstep(sparkAlphaExtent, 0., sparkAttenuate);        \n\n        sparkColor = g_sparkColorIntensity * mix(g_sparkCoreColor, \n                                                 g_sparkExtentColor, \n                                                 sparkResult.y);\n\n        // Pump this spark based on the amount of audio passing through \n        // the spark.\n        sparkColor = mix(sparkColor, \n                         1.25 * sparkColor, \n                         g_audioResponse * audioAttenuate);\n\n        sparkColor = (1. - orbRay.color.a) * sparkColor * sparkCorePresence;\n        sparkOpacity = (1. - orbRay.color.a) * sparkAmt;        \n\n        // ------------------------------------------------------------------\n        // Compute the cell bound marching\n        \n        // Test the boundary walls of a polar cell represented by the floor or\n        // ceil of the polarized march pt.  The boundary walls to test are\n        // determined based on how we're marching through the orb cells.\n\n        // Remember that x is the latitudinal angle so to find it's boundary,\n        // we intersect with a cone.  y is the azimuth angle so we can more\n        // simply intersect the plane that is perpendicular with the x-z plane\n        // and rotated around the y-axis by the value of the angle.\n\n        // Remember to remap the floors and ceils to   \n        // Latitudinal      := [-PI/2, PI/2]\n        // Azimuth          := [-PI, PI]\n        vec4 orbCellBounds = floorAndCeil2(orbRay.orbCellCoords) *\n            vec2(PI, TWO_PI).xxyy / g_numOrbCells.xxyy;\n        \n        orbCellBounds += g_sparkRotationRate.xxyy * g_time;\n        \n        float nextRelativeDist = orbRay.marchMaxDist - orbRay.marchDist;\n        float t = BIG_FLOAT;        \n        vec2 cellCoordIncr = vec2(0.);\n\n        // Intersect with the planes passing through the origin and aligned\n        // with the y-axis.  The plane is a rotation around the y-axis based\n        // on the  azimuthal boundaries.  Remember we know which direction the\n        // ray is traveling so we only need to test one side of the cell.        \n        float orbNextCellAzimAngle = (orbRay.azimuthalOrbCellMarchDir < 0 ? \n                                        orbCellBounds.z : orbCellBounds.w);\n\n        vec3 orbNextCellAzimBound = vec3(-sin(orbNextCellAzimAngle), \n                                          0., \n                                          cos(orbNextCellAzimAngle));\n\n        vec2 intersectResult = intersectDSPlane(marchPoint, orbRay.dir, \n                                                orbNextCellAzimBound, vec3(0.) );\n\n        // DEBRANCHED\n        // Equivalent to:\n        //\n        // if ((intersectResult.x > 0.5) && (nextRelativeDist > intersectResult.y)) {\n        //    nextRelativeDist = intersectResult.y;\n        //    cellCoordIncr = vec2(0., orbRay.azimuthalOrbCellMarchDir);            \n        // }\n\n        float isAzimPlaneHit = intersectResult.x * step(intersectResult.y, nextRelativeDist);\n        nextRelativeDist = mix(nextRelativeDist, intersectResult.y, isAzimPlaneHit);\n        cellCoordIncr = mix(cellCoordIncr, vec2(0., orbRay.azimuthalOrbCellMarchDir), isAzimPlaneHit);\n        \n        // XXX Future work: It would be nice if we only test one side of the\n        // cell wall in the latitudinal direction based on the direction of the\n        // orb ray as it marches through the cells, like what I'm doing with the\n        // azimuthal direction. But due to some shader issues and the extra\n        // complexity this adds to the  code, this seems like a more stable\n        // approach.  If we do go down this road, you could determine which\n        // direction the ray is travelling but you'll need to test if that ray\n        // crosses the \"dividing plane\" since the \"negative\" direction will\n        // become the \"positive\" direction at  that point.  Perhaps this\n        // indicates I need to rethink how the orb cell coordinates are\n        // defined.  I think solving this problem will get to the bottom of the\n        // black speckling that happens.\n\n        // Test the top of the current orb cell\n        intersectResult = intersectSimpleCone(marchPoint, orbRay.dir, orbCellBounds.x);\n\n        // DEBRANCHED\n        // Equivalent to:\n        //\n        // if ((intersectResult.x > 0.5) && (nextRelativeDist > intersectResult.y)) {\n        //    nextRelativeDist = intersectResult.y;\n        //    cellCoordIncr = vec2(-1., 0.);            \n        // }\n        \n        float isTopConeHit = intersectResult.x * step(intersectResult.y, nextRelativeDist);\n        nextRelativeDist = mix(nextRelativeDist, intersectResult.y, isTopConeHit);\n        cellCoordIncr = mix(cellCoordIncr, vec2(-1, 0.), isTopConeHit);\n    \n\n        // Test the bottom of the current orb cell\n        intersectResult = intersectSimpleCone(marchPoint, orbRay.dir, orbCellBounds.y);\n\n        // DEBRANCHED\n        // Equivalent to:\n        //\n        // if ((intersectResult.x > 0.5) && (nextRelativeDist > intersectResult.y)) {\n        //    nextRelativeDist = intersectResult.y;\n        //    cellCoordIncr = vec2(-1., 0.);            \n        // }\n\n        float isBottomConeHit = intersectResult.x * step(intersectResult.y, nextRelativeDist);\n        nextRelativeDist = mix(nextRelativeDist, intersectResult.y, isBottomConeHit);\n        cellCoordIncr = mix(cellCoordIncr, vec2(1, 0.), isBottomConeHit);\n        \n\n        // ------------------------------------------------------------------\n        // Update orbRay for next march step\n\n        // We now know what cell we're going to march into next\n        // XXX: There is a fudge factor on the EPSILON here to get around some\n        // precision issues we're seeing with intersecting the simple cones. \n        // This probably indicates there is something flawed in the cell logic\n        // traversal.\n        orbRay.marchNextDist = min(orbRay.marchMaxDist, orbRay.marchDist + nextRelativeDist + .01);\n        orbRay.orbCellCoords += cellCoordIncr;\n\n        // Make sure that y wraps (the azimuthal dimension) when you've reached\n        // the extent of the number of orb cells\n        orbRay.orbCellCoords.y = mod(orbRay.orbCellCoords.y + g_numOrbCells.y/2., \n                                     g_numOrbCells.y) - g_numOrbCells.y/2.;\n        \n        orbRay.marchDist = orbRay.marchNextDist;        \n        \n        // ------------------------------------------------------------------\n        // Shade the center of the orb interior itself (only if this cell's\n        // march has intersected with that center interior).  Avoid an if \n        // statement here by having the signal that drives the presence of \n        // this color come on only when the ray is intersecting that orb\n        // interior.\n\n        vec3 marchExit = orbRay.origin + orbRay.dir * orbRay.marchNextDist;  \n\n        vec4 segToPtResult = segmentToPointDistance(marchPoint,\n                                                    marchExit,\n                                                    vec3(0.));\n        \n        float distToCenter = length(segToPtResult.xyz);\n\n        float centerOrbProximityMask = smoothstep(g_orbCenterRadius + 1., \n                                                  g_orbCenterRadius, \n                                                  distToCenter);\n\n        float sparkOriginGlowMaxDist = mix(3.0, 0.5, \n                                           smoothstep(8., \n                                                      128., \n                                                      min(g_numOrbCells.x, \n                                                          g_numOrbCells.y)));\n        \n        float sparkOriginGlow = min(sparkOriginGlowMaxDist, abs(sparkOriginGlowMaxDist - \n                                      distance(segToPtResult.xyz, sparkOrigin)));\n        \n        sparkOriginGlow = audioAttenuate * pow(sparkOriginGlow, 3.5);\n\n        // Spark origin contribution, color a signal based on this particular marches\n        // closest point to the orb origin and that distance to the actual spark \n        // origin.\n        sparkColor += .06 * centerOrbProximityMask * sparkOriginGlow * g_sparkCoreColor;\n        sparkOpacity += .06 * centerOrbProximityMask * sparkOriginGlow;\n\n        float isMarchIntersectingCenterOrb = smoothstep(g_orbCenterRadius + .1, \n                                                        g_orbCenterRadius, distToCenter);\n\n        float centerOrbGlow = .4 * g_sparkColorIntensity * max(0., \n                    1. - dot(-normalize(segToPtResult.xyz), orbRay.dir));\n\n        centerOrbGlow = pow(centerOrbGlow, .6);\n\n        // Center orb glow (diffuse falloff) - independent of sparks\n        sparkColor += max(0., (1. - sparkOpacity)) * g_sparkCoreColor * centerOrbGlow * isMarchIntersectingCenterOrb;\n                \n        orbRay.color.rgb += (1. - orbRay.color.a) * sparkColor;\n        orbRay.color.a += (1. - orbRay.color.a) * sparkOpacity;\n                                \n        // If we want to terminate march (because we intersected the center orb), \n        // then make sure to make the alpha for this orb ray 1. \n        orbRay.color.a += (1. - orbRay.color.a) * isMarchIntersectingCenterOrb;        \n\n    }\n    \n}\n\nvec3 sampleEnvironment(vec3 normalizedDir)\n{\n\n    vec3 skyColor     = vec3(0.55, 0.45, 0.58);\n    vec3 horizonColor = vec3(0.50, 0.35, 0.55);\n\n    float envAmp = 1.0 * (1. + .1 * g_bassBeat);\n    return envAmp * mix(horizonColor, skyColor, smoothstep(-.5, 1.0, normalizedDir.y)); \n}\n\nvoid simpleShadeOrb(inout SceneRayStruct sceneRay)\n{\n\n    vec3 hitPoint = sceneRay.orbHitPoint.xyz;\n    vec3 rayDir   = sceneRay.dir;\n\n    // We march the interior assuming the sphere is at the origin.        \n    vec3 hitNormal = normalize(hitPoint);\n\n    float falloff = dot(hitNormal, -sceneRay.dir);\n    sceneRay.color.rgb = vec3(1. - falloff);\n    sceneRay.color.a = 1.;\n    \n}\n\nvoid shadeOrb(inout SceneRayStruct sceneRay)\n{\n\n    // Create a unique hash for this particular cell. We're assuming\n    // that the number of visible cells won't exceed 100x100x100.\n    float orbHash = (sceneRay.cellCoords.x + \n                     100. * sceneRay.cellCoords.y + \n                     10000. * sceneRay.cellCoords.z);\n\n    // --------------------------------------------------------------------\n    // by rotating the hitPoint and the ray direction around the \n    // origin of the orb, we can add rotational variety from orb\n    // to orb. \n    vec3 hitPoint = sceneRay.orbHitPoint.xyz;\n    vec3 rayDir   = sceneRay.dir;\n\n    float rotateXAngle = 0.125 * g_time + orbHash;\n    float cosRotateXAxis = cos(rotateXAngle);\n    float sinRotateXAxis = sin(rotateXAngle);    \n    \n    hitPoint = rotateAroundXAxis(hitPoint, cosRotateXAxis, sinRotateXAxis);\n    rayDir   = rotateAroundXAxis(rayDir, cosRotateXAxis, sinRotateXAxis);\n\n    float rotateYAngle = 0.125 * g_time + orbHash;\n    float cosRotateYAxis = cos(rotateYAngle);\n    float sinRotateYAxis = sin(rotateYAngle);\n\n    hitPoint = rotateAroundYAxis(hitPoint, cosRotateYAxis, sinRotateYAxis);\n    rayDir   = rotateAroundYAxis(rayDir, cosRotateYAxis, sinRotateYAxis);\n    \n    // We march the interior assuming the sphere is at the origin.        \n    vec3 hitNormal = normalize(hitPoint);\n    \n    // --------------------------------------------------------------------\n    // Environment map reflection on orb surface\n\n    vec3 reflectDir = reflect(rayDir, hitNormal);\n    vec3 reflColor = sampleEnvironment(reflectDir);\n    \n    float reflectRatio = fresnel(rayDir, hitNormal, 1. / g_orbIOR).x;\n    float kr = mix(g_orbSurfaceFacingKr, g_orbSurfaceEdgeOnKr, reflectRatio);\n    sceneRay.color.rgb += kr * reflColor;\n    \n    sceneRay.color.a += (1. - sceneRay.color.a) * min(1., kr);//reflectRatio;\n\n    // --------------------------------------------------------------------\n    // Calculate the interior distance to march\n     \n    vec3 refractDir = refract(rayDir, hitNormal, 1. / g_orbIOR);    \n        \n    // Consider the interior sphere (the emitter) when ray marching\n    vec3 innerIntersectResult = intersectSphere(hitPoint, \n                                                refractDir, \n                                                g_orbCenterRadius,\n                                                vec3(0.));\n\n    float interiorSphereHitDist = mix(BIG_FLOAT, \n                                      innerIntersectResult.y, \n                                      innerIntersectResult.x);\n\n    // --------------------------------------------------------------------\n    // Orb Interior Shading     \n\n    vec3 orbIntersectResult = intersectSphere(hitPoint, \n                                              refractDir,\n                                              g_orbOuterRadius,\n                                              vec3(0.));\n    \n    float sphereDepth = abs(orbIntersectResult.z - orbIntersectResult.y);    \n    float rayExtent = min(interiorSphereHitDist, sphereDepth);        \n\n    OrbRayStruct orbRay = OrbRayStruct(hitPoint, // origin\n                                       refractDir, // dir\n                                       0., // ray parameterized start\n                                       0., // the next ray march step\n                                       rayExtent, // ray parameterized end\n                                       0, //  azimuthalOrbCellMarchDir\n                                       vec2(0.), // orbCellCoords\n                                       orbHash, // unique float for this orb\n                                       vec4(0.), // color\n                                       vec4(0.));  // debugColor \n\n    shadeOrbInterior(orbRay, sceneRay); \n\n    // --------------------------------------------------------------------\n    // Transfer the orb ray march results to the scene ray trace.\n\n    sceneRay.color.rgb += (1. - sceneRay.color.a) * orbRay.color.rgb;\n    sceneRay.color.a += (1. - sceneRay.color.a) * orbRay.color.a;\n\n    sceneRay.debugColor += orbRay.debugColor;\n\n}\n\nvoid animateGlobals()\n{\n\tg_time = iChannelTime[0];\n\tg_numOrbsChangeRate = vec2(g_beatRate * 0.05, g_beatRate * 0.0625);\n\tg_sparkRotationRate = vec2(.0, g_beatRate * .25);\n\tg_camRotationRates = vec2(0.125 * g_beatRate, -0.0625 * g_beatRate);\n    \n    // Change the number of polar cells along the azimuthal and latitudinal axis\n    // over time using a sawtooth signal. \n    //g_numOrbCells.x = 16. + 4. * (2. * (sawtooth( g_numOrbsChangeRate.x * g_time + 1.)) +\n    //                                2.);\n    \n    g_numOrbCells.y = 8. + 8. * pow(2., floor(2. * sawtooth( g_numOrbsChangeRate.y * g_time + 4.) + \n                                       2.));\n    \n    // inflate and deflate the cell box size over time using a sine function. \n    g_cellBoxHalfSize = CELL_BOX_HALF_SIZE_DEFAULT * (1. + 0.5 * (0.5 * sin(.25 * (g_beatRate * g_time / TWO_PI)) + .5)); \n\n    \n    // Ramp into the audio driving the spark signals.\n    g_audioResponse = mix(0.4, 0.9, smoothstep(0., 5., g_time));\n    \n    // Would be nice if I could find a way to ramp off of the beat better, but that\n    // would require some history knowledge.\n    g_bassBeat = g_audioResponse * smoothstep(.9, .95, texture( iChannel0, vec2( 0.0, 0.0 ) ).r);\n\n    // For each audio sample, sample the audio channel along the x-axis (increasing frequency\n    // with each sample).  \n    for (int i = 0; i < NUM_AUDIO_SAMPLE_TRIPLES; i += 1) {\n\n        float audioOffset = float(i) * (0.95/float(NUM_AUDIO_SAMPLE_TRIPLES*3));\n        g_audioFreqs[i] = smoothstep(0., 1., texture( iChannel0, vec2(0.0 + audioOffset, 0.0)).r);\n    }\n    \n    // In thumbnail mode, show at least some of the audio sparks\n    if (iResolution.y < 250.) \n        g_audioFreqs[0] = 1.;\n    \n    // Thump the color intensity, and fog color based on the bass beat.\n    g_sparkColorIntensity = mix(1., 1.3, g_bassBeat);\n    g_fogColor *= mix(1., 1.4, g_bassBeat);\n\n    // remap the mouse click ([-1, 1], [-1/ar, 1/ar])\n    vec2 click = iMouse.xy / iResolution.xx;    \n    click = 2.0 * click - 1.0;   \n    \n    // camera position\n    vec3 lookAtOffset = vec3(0., 0., -20.);\n    \n    float rotateXAngle    = .2 * g_time - PI * click.y;\n    float cosRotateXAngle = cos(rotateXAngle);\n    float sinRotateXAngle = sin(rotateXAngle);\n    \n    float rotateYAngle    = .2 * g_time + TWO_PI * click.x;\n    float cosRotateYAngle = cos(rotateYAngle);\n    float sinRotateYAngle = sin(rotateYAngle);\n\n    // Rotate the lookAt position around the origin\n    lookAtOffset = rotateAroundXAxis(lookAtOffset, cosRotateXAngle, sinRotateXAngle);\n    lookAtOffset = rotateAroundYAxis(lookAtOffset, cosRotateYAngle, sinRotateYAngle);\n\n    // Then add an offset on top of the lookAtOffset so that we \"crane\"\n    // the camera 200 units away from the origin.  We can then slowly\n    // rotate the crane around it's azimuth to explore the scene.\n    g_camOrigin = vec3(0., 0.0 , -200.);\n    g_camPointAt = g_camOrigin + lookAtOffset;\n\n    // re-use variables\n    rotateYAngle    = 1. * g_camRotationRates.y * g_time;\n    cosRotateYAngle = cos(rotateYAngle);\n    sinRotateYAngle = sin(rotateYAngle);\n\n    g_camOrigin    = rotateAroundYAxis(g_camOrigin,  cosRotateYAngle, sinRotateYAngle );\n    g_camPointAt   = rotateAroundYAxis(g_camPointAt, cosRotateYAngle, sinRotateYAngle );\n\n}\n\n// **************************************************************************\n// MAIN\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // ----------------------------------\n    // Animate globals\n\n    animateGlobals();\n\n    // ----------------------------------\n    // Setup Camera\n\n    // Shift p so it's in the range -1 to 1 in the x-axis and 1./aspectRatio\n    // to 1./aspectRatio in the y-axis (a reminder aspectRatio := width /\n    // height of screen)\n\n    // I could simplify this to:\n    // vec2 p = fragCoord.xy / iResolution.xx; <- but that's a bit obtuse\n    // to read.\n    \n    vec2 p = fragCoord.xy / iResolution.xy;      \n    float aspectRatio = iResolution.x / iResolution.y;\n    p = 2.0 * p - 1.0;\n    p.y *= 1./aspectRatio;\n    \n    // calculate the rayDirection that represents mapping the  image plane\n    // towards the scene\n    vec3 cameraZDir = normalize( g_camPointAt - g_camOrigin );\n    vec3 cameraXDir = normalize( cross(cameraZDir, g_camUpDir) );\n\n    // no need to normalize since we know cameraXDir and cameraZDir are orthogonal\n    vec3 cameraYDir = cross(cameraXDir, cameraZDir);\n    \n    // Make the constant in front of cameraZDir (camFocalLengthScalar) bigger\n    // to tighten focus, smaller to widen focus.\n\n    vec2 uv = p*0.5+0.5;\n    float vignet = pow(10.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y),0.4);\n        \n    // Add a bit of fisheye distortion based on vignet signal\n    float camFocalLengthScalar = mix(.4, 1.0, vignet);\n    vec3 rayDir = normalize( p.x*cameraXDir + p.y*cameraYDir + camFocalLengthScalar * cameraZDir );    \n        \n    // Add a clipping plane bias so orbs don't get too close to camera\n    g_camOrigin += 5. * rayDir;\n    SceneRayStruct ray = SceneRayStruct(g_camOrigin, // origin\n                                        rayDir, // direction\n                                        0., // current march depth\n                                        FOG_EXTENT, // max march depth\n                                        vec3(0.), // cellCoords\n                                        vec4(0.), // orbHitPoint\n                                        vec4(0.), // color\n                                        vec4(0.)); // debug color\n    \n    // ----------------------------------\n    // Trace Scene\n\n    traceScene(ray);\n\n    // ----------------------------------\n    // Shade Scene\n\n    if ((ray.marchDist < FOG_EXTENT) && (ray.orbHitPoint.w > .5)) {\n        //simpleShadeOrb(sceneRay);\n        shadeOrb(ray);        \n    }\n\n    // ----------------------------------\n    // Harvest final color results\n\n    vec4 tracedColor = ray.color;\n    \n    // multiply the alpha onto the color.  If you want info on why I do this,\n    // consult the source paper:\n    // http://graphics.pixar.com/library/Compositing/paper.pdf\n    tracedColor.rgb *= tracedColor.a;\n\n    // ----------------------------------\n    // Fog\n\n    tracedColor.rgb = mix(tracedColor.rgb, g_fogColor, \n                          smoothstep(50., FOG_EXTENT, ray.marchDist));\n\n    // ----------------------------------\n    // Color grading\n\n    // Increase contrast\n    tracedColor.rgb = pow(tracedColor.rgb, vec3(1.7));\n    \n    // vigneting\n    tracedColor *= mix(0.3, 1., vignet);\n\n    fragColor = tracedColor;\n    \n    // Debug color's alpha is not multiplied during final output.  If it is \n    // non-zero, then the debugcolor is respected fully \n    fragColor.rgb = mix(fragColor.rgb, ray.debugColor.rgb, \n                           step(EPSILON, ray.debugColor.a));\n}",
   "name": "Image",
   "description": "",
   "type": "image"
  }
 ]
}