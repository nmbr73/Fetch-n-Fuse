{"Shader":{"ver":"0.1","info":{"id":"WltXRj","date":"1581666305","viewed":729,"name":"7.5 kilobytes for Nathalie","username":"BrunoLevy","description":" A special valentine shader for my wife Nathalie, rendered using 'cupidon arrows tracing'.\n","likes":21,"published":3,"flags":0,"usePreview":0,"tags":["raytracing","aabb","mesh","valentine"],"hasliked":0},"renderpass":[{"inputs":[{"id":26,"src":"\/media\/a\/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","ctype":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":37,"channel":0}],"code":"\/\/ Settings\n\/\/ (smoothness, extinction and scale are changed in function of heart beats)\n      float smoothness;           \/\/ 1.0: smooth shading  0.0: faceted shading \n      float refract_index;        \/\/ 1.0: no refraction   1.3: water   2.4: diamond\n      float extinction;           \/\/ the higher, the darker (in function of thicness) \nconst float reflect_coeff = 0.75; \/\/ 0.0: no reflection   1.0: shiny reflections\nconst vec3  core_color = vec3(1.0,0.0,0.0); \n      float scale;\n      bool  dispersion = true;    \/\/ set to true to decompose light like a prism\nbool  fixed_cam = false;          \/\/ Set to true for fixed cam and rotating lighting env.\n\n\/\/ Mesh data borrowed from https:\/\/www.thingiverse.com\/thing:4041510\n\nconst vec3 bbox_min = vec3(-0.429853,-0.406522,-0.147051);\nconst vec3 bbox_max = vec3(0.429853,0.406522,0.147051);\n\n\/\/ Yes, I could have compressed that in a single int per triangle, on the other hand there are\n\/\/ only 64 of them, so I think it will not make a big difference...\nconst ivec3 triangles[64] = ivec3[](\nivec3(0x00000004,0x00000015,0x00000003),ivec3(0x00000015,0x00000017,0x00000003),ivec3(0x00000004,0x00000016,0x00000015),ivec3(0x00000003,0x00000005,0x00000004),ivec3(0x00000016,0x00000017,0x00000015),ivec3(0x00000001,0x00000016,0x00000004),ivec3(0x00000003,0x00000006,0x00000005),ivec3(0x00000005,0x00000019,0x00000004),ivec3(0x00000002,0x00000016,0x00000001),ivec3(0x00000004,0x0000001a,0x00000001),ivec3(0x00000000,0x00000017,0x00000016),ivec3(0x00000017,0x00000020,0x00000003),ivec3(0x00000019,0x0000001a,0x00000004),ivec3(0x00000000,0x00000016,0x00000002),ivec3(0x00000001,0x0000001a,0x00000002),\nivec3(0x00000003,0x00000020,0x00000006),ivec3(0x00000006,0x00000007,0x00000005),ivec3(0x00000008,0x00000019,0x00000005),ivec3(0x00000007,0x00000008,0x00000005),ivec3(0x00000019,0x0000001b,0x0000001a),ivec3(0x00000002,0x0000001a,0x00000013),ivec3(0x00000000,0x00000018,0x00000017),ivec3(0x00000018,0x00000021,0x00000017),ivec3(0x00000017,0x00000021,0x00000020),ivec3(0x00000002,0x00000013,0x00000000),ivec3(0x00000006,0x00000020,0x00000007),ivec3(0x00000008,0x0000001b,0x00000019),ivec3(0x0000001a,0x0000001b,0x00000013),ivec3(0x00000013,0x00000018,0x00000000),ivec3(0x00000007,0x0000001d,0x00000008),ivec3(0x00000009,0x00000021,0x00000018),\nivec3(0x00000007,0x00000020,0x0000001d),ivec3(0x00000020,0x00000021,0x00000009),ivec3(0x0000000a,0x00000018,0x00000013),ivec3(0x00000013,0x0000001b,0x00000012),ivec3(0x00000008,0x0000001c,0x0000001b),ivec3(0x0000001d,0x00000020,0x0000001f),ivec3(0x0000000a,0x00000013,0x0000000b),ivec3(0x00000009,0x00000018,0x0000000d),ivec3(0x0000000d,0x00000020,0x00000009),ivec3(0x0000001d,0x0000001e,0x00000008),ivec3(0x0000000b,0x00000013,0x00000012),ivec3(0x0000001b,0x0000001c,0x00000012),ivec3(0x0000000d,0x00000018,0x0000000a),ivec3(0x0000001f,0x00000020,0x0000000d),ivec3(0x00000008,0x0000001e,0x0000001c),ivec3(0x0000001d,0x0000001f,0x00000014),\nivec3(0x0000000b,0x00000012,0x0000000f),ivec3(0x00000014,0x0000001e,0x0000001d),ivec3(0x0000000b,0x00000010,0x0000000a),ivec3(0x00000012,0x0000001c,0x00000011),ivec3(0x0000000a,0x00000010,0x0000000d),ivec3(0x0000001c,0x0000001e,0x00000014),ivec3(0x0000000f,0x00000012,0x00000011),ivec3(0x00000011,0x0000001c,0x00000014),ivec3(0x0000000f,0x00000010,0x0000000b),ivec3(0x00000014,0x0000001f,0x0000000e),ivec3(0x0000000e,0x0000001f,0x0000000d),ivec3(0x0000000f,0x00000011,0x00000010),ivec3(0x00000011,0x00000014,0x0000000e),ivec3(0x0000000d,0x00000010,0x0000000c),ivec3(0x00000010,0x00000011,0x0000000c),ivec3(0x0000000c,0x0000000e,0x0000000d),\nivec3(0x0000000c,0x00000011,0x0000000e));\n\nconst int points[34] = int[](\n0x017d7191,0x2c5eb8dd,0x21cffd13,0x21aab001,0x354c7486,0x353860b1,0x21530152,0x35235591,0x3a4545f4,0x01c6fe52,0x017d726d,0x21cffeeb,0x21cd03ff,0x020aeb32,0x21aab3fd,0x2e3ebb21, 0x223ebba2,0x351c7f79,0x351eb2aa,0x21fe21ff,0x3598b72a,0x21cd0000,0x223eb85c,0x020ae8dd,0x000a7606,0x3e3cd911,0x351eb154,0x382b6dff,0x3ffca6ee,0x3523566d,0x3588b32b,0x2182e29b, 0x21700206,0x01d6f9ac\n);\n\nconst int normals[34] = int[](\n0x053c5a11,0x380ca561,0x184fba2a,0x13745467,0x3b99790f,0x3b95f121,0x2bd36c88,0x3b44b15d,0x3fd755fd,0x01b5ce56,0x053c59ed,0x186fb9d5,0x153aa7c2,0x0396d6de,0x1de42bbf,0x380ca69c, 0x0f0d76ff,0x3ba936f2,0x390cb9a1,0x1dcff5ff,0x36e53b34,0x13ea9c44,0x0ead60ff,0x03a6c91e,0x0038edff,0x3fe831e5,0x38fcc657,0x3f29c1f7,0x3fe83219,0x3b94f6a7,0x3f16da59,0x19535390, 0x07132da4,0x01c5cda4\n);\n\n\n\n\/\/ Gets x,y,z, coordinates packed in a single 32 bits int (10 bits per coordinate)\nint get_compressed_point(in int v) {\n    return  points[v];\n}\n\n\/\/ Converts a single-int 10 bits per components packed point into a standard vec3.\nvec3 uncompress_point(in int xyz) {\n   ivec3 XYZ = (ivec3(xyz) >> ivec3(0,10,20)) & ivec3(1023); \n   return scale * (bbox_min + (bbox_max - bbox_min) * vec3(XYZ) \/ 1023.0);\n}\n\n\/\/ Gets a point from a vertex index\nvec3 get_point(int v) {\n   return uncompress_point(get_compressed_point(v));\n}\n\n\/\/ Gets a normal from a vertex index\nvec3 get_normal(int v) {\n   int xyz = normals[v];\n   ivec3 XYZ = (ivec3(xyz) >> ivec3(0,10,20)) & ivec3(1023); \n   return vec3(-1) + vec3(XYZ) \/ 512.0;    \n}\n\nconst float FARAWAY=1e30;\n\nstruct Camera {\n    vec3 Obs;\n    vec3 View;\n    vec3 Up;\n    vec3 Horiz;\n    float H;\n    float W;\n    float z;\n};\n\nstruct Ray {\n    vec3 Origin;\n    vec3 Dir;\n};\n\nCamera camera(in vec3 Obs, in vec3 LookAt, in float aperture) {\n   Camera C;\n   C.Obs = Obs;\n   C.View = normalize(LookAt - Obs);\n   C.Horiz = normalize(cross(vec3(0.0, 1.0, 0.0), C.View));\n   C.Up = cross(C.View, C.Horiz);\n   C.W = float(iResolution.x);\n   C.H = float(iResolution.y);\n   C.z = (C.H\/2.0) \/ tan((aperture * 3.1415 \/ 180.0) \/ 2.0);\n   return C;\n}\n\nRay launch(in Camera C, in vec2 XY) {\n   return Ray(\n      C.Obs,\n      C.Obs+C.z*C.View+(XY.x-C.W\/2.0)*C.Horiz+(XY.y-C.H\/2.0)*C.Up \n   );\n}\n\nstruct Intersection {\n   float t;\n   vec3 P;\n   vec3 N;\n   vec3 Nsmooth;\n   int id; \/\/ index of latest intersected triangle, used to avoid finding the point\n           \/\/  where you started from when computing multiple bounces.\n};\n \nIntersection intersection() {\n   Intersection I;\n   I.t = FARAWAY;\n   I.id = -1; \n   return I;\n}\n\nRay reflect_ray(in Ray R, in Intersection I) {\n    return Ray(I.P, reflect(R.Dir, I.N));\n}\n\nRay refract_ray(in Ray R, in Intersection I, in float n1, in float n2) {\n    return Ray(I.P, refract(normalize(R.Dir), I.N, n1\/n2));\n}\n\n\/\/ Branchless ray-triangle intersection that gives, for free, as by-products:\n\/\/   Normal N\n\/\/   Barycentric coordinates (1-u-v, u, v)\n\/\/ (slightly modified Moller-Trumbore algorithm)\n\/\/ References and explanations here:\n\/\/ https:\/\/stackoverflow.com\/questions\/42740765\/intersection-between-line-and-triangle-in-3d\/42752998#42752998\nbool intersect_triangle(\n    in Ray R, in vec3 A, in vec3 B, in vec3 C, out float t, \n    out float u, out float v, out vec3 N\n) { \n   vec3 E1 = B-A;\n   vec3 E2 = C-A;\n         N = cross(E1,E2);\n   float det = -dot(R.Dir, N);\n   float invdet = 1.0\/det;\n   vec3 AO  = R.Origin - A;\n   vec3 DAO = cross(AO, R.Dir);\n   u =  dot(E2,DAO) * invdet;\n   v = -dot(E1,DAO) * invdet;\n   t =  dot(AO,N)   * invdet;\n   return (abs(det) >= 1e-6 && t >= 0.0 && u >= 0.0 && v >= 0.0 && (u+v) <= 1.0);\n}\n\n\/\/ Computes ray-triangle intersection from node index (i)\n\/\/ Returns true if there was an intersection.\n\/\/ Note: normal is not normalized\nbool triangle(in Ray R, in int i, inout Intersection I) {\n   ivec3 T = triangles[i];\n   vec3 A = get_point(T.x);\n   vec3 B = get_point(T.y);\n   vec3 C = get_point(T.z);    \n   float t,u,v;\n   vec3 N;\n   if(intersect_triangle(R, A,B,C, t, u, v, N) && t < I.t) {\n      I.t = t;\n      I.P = R.Origin + t*R.Dir;\n      I.id = i;\n      vec3 N1 = get_normal(T.x);\n      vec3 N2 = get_normal(T.y);\n      vec3 N3 = get_normal(T.z);       \n      I.Nsmooth = (1.0-u-v)*N1 + u*N2 + v*N3;\n      I.N = N;\n      return true;\n   }\n   return false;\n}\n \n\/\/ Good explanations here:\n\/\/ https:\/\/tavianator.com\/fast-branchless-raybounding-box-intersections\/\nbool segment_box_intersection(\n  in vec3 q1,\n  in vec3 dirinv,\n  in vec3 boxmin,\n  in vec3 boxmax,\n  in float t \n) {  \n   vec3 T1 = dirinv*(boxmin - q1);\n   vec3 T2 = dirinv*(boxmax - q1);\n   vec3 Tmin = min(T1,T2);\n   vec3 Tmax = max(T1,T2);\n   float tmin = max(max(Tmin.x, Tmin.y),Tmin.z);\n   float tmax = min(min(Tmax.x, Tmax.y),Tmax.z);    \n   return (tmax >= 0.0) && (tmin <= tmax) && (tmin <= t);\n}\n\n\/\/ No AABB-tree here (not worth it, we only got 64 triangles !)\n\/\/ Mesh ray-tracing with AABB-tree is here: https:\/\/www.shadertoy.com\/view\/WlcXRS\nbool raytrace_mesh(in Ray R, inout Intersection I) {\n    int prev_id = I.id; \/\/ index of latest intersected triangle\n    bool result = false;  \n    \/\/ ... But I still keep a single AABB around the whole mesh.\n    \/\/ We could do without it, but it gains a couple of FPS.\n    vec3 invDir = vec3(1.0\/R.Dir.x, 1.0\/R.Dir.y, 1.0\/R.Dir.z);\n    if(!segment_box_intersection(R.Origin, invDir, scale*bbox_min, scale*bbox_max, I.t)) {\n        return false;\n    }\n    for(int i=0; i<triangles.length(); ++i) {\n       if(i == prev_id) { continue; } \/\/ skip latest triangle\n       bool t_isect = triangle(R, i, I);\n       result = result || t_isect;\n    }\n    if(result) { \/\/ Interpolating between facetted and smooth shading, just for fun.\n        I.N = mix(normalize(I.N), normalize(I.Nsmooth), smoothness);\n        I.N = normalize(I.N); \n    }\n    return result;\n}  \n\n\/\/ Modifies ray and intersection, returns total length of traversed matter.\nfloat multi_refract(inout Ray R, inout Intersection I) {\n    float result = 0.0;\n    for(int i=0; i<10; ++i) {\n        if(dot(R.Dir,I.N) > 0.0) { \/\/ Exiting matter\n            result += I.t;\n            vec3 old_dir = R.Dir;\n            I.N = -I.N;\n            R = refract_ray(R, I, refract_index, 1.0);\n            if(R.Dir == vec3(0)) { \n               R.Dir = reflect(old_dir, I.N); \/\/ total reflection  \n            }\n        } else { \/\/ Entering matter\n            R = refract_ray(R, I, 1.0, refract_index);\n            R.Dir = normalize(R.Dir); \/\/ Needs to be unit, so that on exit, I.t is distance\n        }\n        I.t = FARAWAY;\n        if(!raytrace_mesh(R, I)) { break; }  \n    }\n    return result;\n}\n\nvec3 sky(in Ray R) {\n    if(fixed_cam) {\n        float alpha = iTime\/2.0;\n        float s = sin(alpha);\n        float c = cos(alpha);\n        vec3 V = vec3(\n            R.Dir.x * c + R.Dir.z * s,\n            R.Dir.y,\n            R.Dir.x * s - R.Dir.z * c\n        );\n        return vec3(textureLod(iChannel0, V, 0.0));\n    }\n    return vec3(textureLod(iChannel0, R.Dir, 0.0));\n}\n\n\n\/\/ Borrowed from https:\/\/www.shadertoy.com\/view\/XsKBWD\nfloat beat() {\n  return .7 + abs(-abs(sin(iTime * 3.)) + .5);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n   bool animate = (sin(iTime\/2.0) < 0.0); \n   if(animate) {\n      refract_index = 1.2;\n      scale      = 5.0+5.0*beat();\n      extinction = 0.5*(1.0 + sin(iTime*6.0));\n      smoothness = beat(); \/\/ 0.5*(1.0 + sin(iTime*3.0));        \n   } else {\n      refract_index = 2.4;\n      scale = 10.0;  \n      extinction = 0.0;  \n      smoothness = 0.0;          \n   }\n    \n   float alpha = fixed_cam ? 0.0 : iTime;  \n   float c = cos(alpha);\n   float s = sin(alpha);\n   Camera C = camera(\n       vec3(20.0*s, 1.5, 20.0*c),\n       vec3(0.0, 0.0, 0.0),\n       30.0       \n   );\n   Ray R = launch(C, fragCoord);\n   Intersection I = intersection();\n   raytrace_mesh(R, I);\n \n   if(I.t == FARAWAY) {\n      fragColor.xyz = sky(R); \n    } else {        \n      float fresnel = 1.0 + dot(R.Dir,I.N) \/ length(R.Dir);\n      fresnel = clamp(fresnel, 0.0, 1.0); \n      fragColor.xyz = reflect_coeff * fresnel * sky(reflect_ray(R,I)); \n       \n      if(dispersion) {\n         \/\/ Trace three rays (red, green, blue), change refraction index\n         \/\/ for each of them.\n         float base_refract_index = refract_index;\n         Ray R0 = R;\n         Intersection I0 = I;\n         refract_index = base_refract_index;\n         float l = multi_refract(R,I);\n         float d = exp(-l * extinction);\n         float r = sky(R).r;\n         I = I0; R = R0; refract_index = base_refract_index + 0.03;\n         multi_refract(R,I); \n         float g = sky(R).g; \n         I = I0; R = R0; refract_index = base_refract_index + 0.06;\n         multi_refract(R,I); \n         float b = sky(R).b;  \n         \/\/ Assemble final color using the contributions from the\n         \/\/ red, green and blue rays.\n         fragColor.xyz += mix(core_color, vec3(r,g,b), d);\n      } else {\n         float l = multi_refract(R,I);\n         float d = exp(-l * extinction);\n         fragColor.xyz += mix(core_color, sky(R), d);\n      }       \n    }\n}\n","name":"Image","description":"","type":"image"}]}}