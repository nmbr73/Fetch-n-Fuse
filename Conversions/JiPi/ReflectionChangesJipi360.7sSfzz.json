{
 "ver": "0.1",
 "info": {
  "id": "7sSfzz",
  "date": "0",
  "viewed": 0,
  "name": "reflection changes JiPi 360",
  "description": "reflection changes",
  "likes": 0,
  "published": "Private",
  "usePreview": 0,
  "tags": [
   "reflectionchanges"
  ],
  "hasliked": 0,
  "parentid": "fslfDf",
  "parentname": "reflection changes"
 },
 "renderpass": [
  {
   "inputs": [],
   "outputs": [
    {
     "id": "4dfGRr",
     "channel": 0
    }
   ],
   "code": "//cambios por jorge flores p.---->jorge2017a2\n//21-feb-2022\n///referencia y fork\n//https://www.shadertoy.com/view/MtlfRs.....by zackpudil in 2017-12-11\n\nfloat hash(vec2 n) {\n\treturn fract(dot(vec2(sin(n.x*2343.34), cos(n.y*30934.0)), vec2(sin(n.y*309392.34), cos(n.x*3991.0))));\n}\n\n// Minkowski operators, can be seen at http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.90.803&rep=rep1&type=pdf\n// It's a paper on generalized distance functions, but it intros on minkowski operators (generalizing them).\nfloat len(vec3 p, float l) {\n\tp = pow(abs(p), vec3(l));\n\treturn pow(p.x + p.y + p.z, 1.0/l);\n}\n\nvec2 GetDist(vec3 p  )\n{\n\tvec3 q = p;\n\tvec2 c = floor((p.xz + 3.0)/6.0);\n\t\n\tq.xz = mod(q.xz + 3.0, 6.0) - 3.0;\n\tq.y -= 0.5;\n    // use random value to produce different shape.\n    //return vec2(min(len(q, 1.5 + 9.0*hash(c)) - 1.5, p.y + 1.0),1.0);\n    float d1=len(q, 1.5 + 9.0*hash(c)) - 1.5;\n    float d2=p.y + 1.0;\n\t\n    return vec2(min(d1, d2),1.0);\n}\n\n// basic trace, with some LOD\nfloat RayMarch(vec3 o, vec3 d, float m) {\n\tfloat t = 0.0;\n\tfor(int i = 0; i < 200; i++) {\n\t\tfloat d = GetDist(o + d*t).x;\n\t\tif(d < (0.001 + 0.0001*t) || t >= m) break;\n        t += d*0.67;\n\t}\n\treturn t;\n}\n\n// basic normal.\nvec3 normal(vec3 p) {\n\tvec2 h = vec2(0.001, 0.0);\n\tvec3 n = vec3(\n\t\tGetDist(p + h.xyy).x - GetDist(p - h.xyy).x,\n\t\tGetDist(p + h.yxy).x - GetDist(p - h.yxy).x,\n\t\tGetDist(p + h.yyx).x - GetDist(p - h.yyx).x\n\t);\n\treturn normalize(n);\n}\n\nfloat getSoftShadow(vec3 p, vec3 lightPos)\n{   float res = 1.0;\n    float dist = 0.01;\n    float lightSize = 0.03;\n    for (int i = 0; i < 15; i++) {\n        float hit = GetDist(p + lightPos * dist).x;\n        res = min(res, hit / (dist * lightSize));\n        dist += hit;\n        if (hit < 0.0001 || dist > 60.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat ambOcclusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {\n        float hr = 0.01 + float(i) * 0.5 / 4.0;\n        float dd = GetDist(nor * hr + pos).x;\n        occ += (hr - dd)*sca;\n        sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );\n}\n\n//euclidean cameras.\nmat3 camera(vec3 o, vec3 l) \n{\tvec3 w = normalize(l - o);\n\tvec3 u = normalize(cross(vec3(0, 1, 0), w));\n\tvec3 v = normalize(cross(w, u));\t\n\treturn mat3(u, v, w);\n}\n\nvec3 iluminacion(vec3 pos,vec3 rd,vec3 nor, vec3 ref, vec3 lig)\n{\n    vec3 rcol =vec3(0.0);    \n    // occlusion and shadows\n    float occ = ambOcclusion(pos, nor);\n\t//float sha = step(5.0, trace(pos + nor*0.001, lig, 5.0));\n    float sha = getSoftShadow(pos, normalize(lig));\n\t\t\t\n    // lighting ambient + diffuse + fresnel + specular\n\trcol += 0.2*occ;\n\trcol += clamp(dot(lig, nor), 0.0, 1.0)*occ*sha;\n\trcol += pow(clamp(1.0 + dot(rd, nor), 0.0, 1.0), 2.0)*occ;\n\trcol += 2.0*pow(clamp(dot(ref, lig), 0.0, 1.0), 30.0)*occ;\n\t\t\t\n    // simple material.\n\tif(pos.y > -0.99)\n        rcol *= vec3(1.2, 0.7, 0.7);\n        //rcol *= vec3(0.92, 0.27, 0.57);\n\telse\n    {\n        rcol *= 0.2 + 0.5*mod(floor(pos.x) + floor(pos.z), 2.0);\n        //rcol*=vec3(0.5);\n     }\n        \n\treturn rcol;\t\t\n}        \n\nvec3 render(vec3 ro, vec3 rd) \n{\n    vec3 col = vec3(0.45, 0.8, 1.0);\n\tvec3 lig = normalize(vec3(0.8, 0.7, -0.6));\n    float t;\n    \n    \tfor(int i = 0; i < 3; i++) {\n\t\t t = RayMarch(ro, rd, 50.0);\n\t\tif(t < 50.0) \n        {\n\t\t\tvec3 rcol = vec3(0);\n            // geometry, hit position, normal, reflect\n\t\t\tvec3 pos = ro + rd*t;\n\t\t\tvec3 nor = normal(pos);\n\t\t\tvec3 ref = reflect(rd, nor);\n            rcol=iluminacion(pos,rd, nor, ref, lig);\n            // set up the ray orgin and direction for reflection.\n\t\t\tro = pos + nor*0.001;\n\t\t\trd = ref;\n            // sky fog.\n\t\t\trcol = mix(rcol, vec3(0.45, 0.8, 1.0), 1.0 - exp(-0.00715*t));\n            // lighten intensity on each successive reflect.\n\t\t\tif(i == 0)\n               col = rcol;\n\t\t\telse\n                col *= mix(rcol, vec3(1), 1.0 - exp(-0.8*float(i)));\n\t\t}\n\t}\n    return col;\n}\n\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43; \n    d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\t\n\tvec3 ro = vec3(2.7 + cos(iTime*0.3), 0, iTime);\n\tvec3 rd = camera(ro, vec3(2.5 + 0.9*cos(iTime*0.3 + 0.3), 0, iTime + 0.2))*normalize(vec3(p, 1.97));\n\t\n    vec3 col= render(ro, rd);\n        \n    // tone mapping and gamma correction.\n\t//col = 1.0 - exp(-0.5*col);\n\t//col = pow(abs(col), vec3(1.0/2.2));\n\tcol= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;\n\tfragColor = vec4(col, 1);\n}",
   "name": "Image",
   "description": "",
   "type": "image"
  }
 ]
}