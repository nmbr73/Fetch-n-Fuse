{
 "ver": "0.1",
 "info": {
  "id": "7d3yzj",
  "date": "0",
  "viewed": 0,
  "name": "Visceral Infection JiPi",
  "description": "Itchy throat? :D\nBased on shane's Desert Canyon https://www.shadertoy.com/view/Xs33Df",
  "likes": 0,
  "published": "Private",
  "usePreview": 0,
  "tags": [
   "raymarching",
   "tunnel",
   "organic",
   "bio",
   "pebbles"
  ],
  "hasliked": 0,
  "parentid": "7ddcW7",
  "parentname": "Visceral Infection"
 },
 "renderpass": [
  {
   "inputs": [
    {
     "id": "XsfGRn",
     "filepath": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg",
     "type": "texture",
     "channel": 1,
     "sampler": {
      "filter": "mipmap",
      "wrap": "repeat",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    },
    {
     "id": "4sf3Rr",
     "filepath": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png",
     "type": "texture",
     "channel": 0,
     "sampler": {
      "filter": "mipmap",
      "wrap": "repeat",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    }
   ],
   "outputs": [
    {
     "id": "4dfGRr",
     "channel": 0
    }
   ],
   "code": "/*\n    Based on:\n\tDesert Canyon by shane\n\thttps://www.shadertoy.com/view/Xs33Df\n    \n    I removed shane's comments to avoid passing them as my own. (I have no idea what I'm doing). \n    Please refer to shane's shader for extensive comments.\n*/\n\n\n#define FAR 125.\n\n#define RM_STEPS 128\n\nconst float freqA = .15/3.75;\nconst float freqB = .25/2.75;\nconst float ampA = 20.;\nconst float ampB = 2.;\n\nmat2 rot2( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\nfloat hash(float n){ return fract(cos(n)*45758.5453); }\nfloat hash(vec3 p){ return fract(sin(dot(p, vec3(7, 157, 113)))*45758.5453); }\n\nfloat getGrey(vec3 p){ return dot(p, vec3(0.299, 0.587, 0.114)); }\n\nfloat sminP(float a, float b , float s){\n    \n    float h = clamp(.5 + .5*(b - a)/s, 0., 1.);\n    return mix(b, a, h) - h*(1.0-h)*s;\n}\n\nfloat smaxP(float a, float b, float s){\n    \n    float h = clamp(.5 + .5*(a - b)/s, 0., 1.);\n    return mix(b, a, h) + h*(1. - h)*s;\n}\n\nvec2 path(in float z){ \n\n    return vec2(ampA*sin(z * freqA), ampB*cos(z * freqB) + 5.*(sin(z*0.025)  - 5.)); \n}\n\nfloat map(in vec3 p){\n    \n    float tx = (-texture(iChannel0, p.xz/22. + p.xy/80.).x-0.4) * 0.95;\n    \n    vec3 q = sin(p.zyx*.2 - (0.5+tx)*0.5 + iTime*0.13)*sminP(5.0, pow((0.5-tx)*5.5, 0.22), 3.);\n    \n    float h = q.x*q.y*q.z;\n  \n    p.xy -= path(p.z);\n    \n    float tnl = 2.0 - length(p.xy*vec2(.33, .66))*0.5 + h * 0.4 + (1. - tx)*.25;\n    \n    return tnl - tx*.5 + tnl*0.3; \n}\n\nfloat getprot(in vec3 p){\n    \n    float tx = (-texture(iChannel0, p.xz/22. + p.xy/80.).x-0.4) * 0.95;\n    \n    vec3 q = sin(p.zyx*.2 - (0.5+tx)*0.5 + iTime*0.13)*sminP(5.0, pow((0.5-tx)*5.5, 0.22), 3.);\n    \n    return q.x*q.y*q.z;// + (1. - tx)*.25- tx*.5; \n}\n\n// Log-Bisection Tracing\n// https://www.shadertoy.com/view/4sSXzD\n//\n// Log-Bisection Tracing by nimitz (twitter: @stormoid)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Contact: nmz@Stormoid.com\n\nfloat logBisectTrace(in vec3 ro, in vec3 rd){\n\n    float t = 0., told = 0., mid, dn;\n    float d = map(rd*t + ro);\n    float sgn = sign(d);\n\n    for (int i=0; i<RM_STEPS; i++){\n\n        if (sign(d) != sgn || d < 0.001 || t > FAR) break;\n \n        told = t;\n           \n        t += step(d, 1.)*(log(abs(d) + 1.1) - d) + d;\n        \n        d = map(rd*t + ro);\n    }\n    \n    if (sign(d) != sgn){\n\n        dn = sign(map(rd*told + ro));\n        \n        vec2 iv = vec2(told, t); \n\n        for (int ii=0; ii<8; ii++){ \n            mid = dot(iv, vec2(.5));\n            float d = map(rd*mid + ro);\n            if (abs(d) < 0.001)break;\n\n            iv = mix(vec2(iv.x, mid), vec2(mid, iv.y), step(0.0, d*dn));\n        }\n\n        t = mid; \n    }\n    \n    return min(t, FAR);\n}\n\nvec3 normal(in vec3 p)\n{  \n    vec2 e = vec2(-1, 1)*.001;   \n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n   \n    n = max(n*n, .001);\n    n /= (n.x + n.y + n.z );  \n    \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n\nvec3 doBumpMap( sampler2D tex, in vec3 p, in vec3 nor, float bumpfactor){\n   \n    const float eps = .001;\n    vec3 grad = vec3( getGrey(tex3D(tex, vec3(p.x - eps, p.y, p.z), nor)),\n                      getGrey(tex3D(tex, vec3(p.x, p.y - eps, p.z), nor)),\n                      getGrey(tex3D(tex, vec3(p.x, p.y, p.z - eps), nor)));\n    \n    grad = (grad - getGrey(tex3D(tex, p, nor)))/eps; \n            \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize(nor + grad*bumpfactor);\n}\n\nfloat calculateAO( in vec3 p, in vec3 n, float maxDist )\n{\n\tfloat ao = 0., l;\n\tconst float nbIte = 6.;\n\n    for(float i=1.; i< nbIte+.5; i++){\n    \n        l = (i + hash(i))*.5/nbIte*maxDist;\n        \n        ao += (l - map( p + n*l))/(1. + l);\n    }\n\t\n    return clamp(1. - ao/nbIte, 0., 1.);\n}\n\nfloat curve(in vec3 p){\n\n    const float eps = .05, amp = 4., ampInit = .5;\n\n    vec2 e = vec2(-1, 1)*eps; \n    \n    float t1 = map(p + e.yxx), t2 = map(p + e.xxy);\n    float t3 = map(p + e.xyx), t4 = map(p + e.yyy);\n    \n    return clamp((t1 + t2 + t3 + t4 - 4.*map(p))*amp + ampInit, 0., 1.);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n\tvec2 u = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\tvec3 lookAt = vec3(0, 0, 18.+iTime*1.9);\n\tvec3 ro = lookAt + vec3(0, .0, -.25);\n\n\tlookAt.xy += path(lookAt.z);\n\tro.xy += path(ro.z);\n\n    float FOV = 3.14159/1.5; \n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(vec3(forward.z, 0, -forward.x )); \n    vec3 up = cross(forward, right);\n\n    vec3 rd = normalize(forward + FOV*u.x*right + FOV*u.y*up);\n    \n\trd.xy = rot2( path(lookAt.z).x/64. )*rd.xy;\n    \n    vec3 lp = vec3(FAR*.5, FAR, FAR) + vec3(0, 0, ro.z);\n\n\tfloat t = logBisectTrace(ro, rd);\n    \n    vec3 fog = vec3(1, .9, .7);\n    //vec3 fog = vec3(1, .3, .3);\n\n    vec3 col = fog;\n    \n    if (t < FAR){\n    \n        vec3 sp = ro+t*rd;\n        vec3 sn = normal(sp);\n\n        vec3 ld = lp-sp;\n        ld /= max(length(ld), 0.001); \n    \n        const float tSize1 = 1./6.;\n\n        sn = doBumpMap(iChannel1, sp*tSize1, sn, .007/(1. + t/FAR));\n        \n        float shd = 0.9;\n        float curv = curve(sp)*.7 +.1;\n        float ao = calculateAO(sp, sn, 10.);\n        \n        float dif = max( dot( ld, sn ), 0.); \n        float spe = pow(max( dot( reflect(-ld, sn), -rd ), 0. ), 5.)*2.0; \n        float fre = clamp(1.0 + dot(rd, sn), 0., 1.);\n\n\t\tfloat Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 1.5);\n\t\tfloat fre2 = mix(.2, 1., Schlick);\n       \n        float amb = fre*fre2 + .76*ao;\n        \n        col = clamp(mix(vec3(.5, .4, .3), vec3(.25, .45, .125),(sp.y+1.)*.15), vec3(.25, .45, .125), vec3(1));\n        \n        curv = smoothstep(0., .7, curv);\n        col *= vec3(curv*0.9, curv*.45, curv*.25)*1.0;\n        \n        float prot = smoothstep(-0.0, -3.0, getprot(sp));\n        \n        col = mix(col, vec3(0.9, 0.6, 0.4), prot);\n        \n        col = (col*(dif + .1) + fre2*spe)*shd*ao + amb*col; \n        \n    }\n    \n    col = mix(col, fog, sqrt(smoothstep(FAR - 85., FAR, t)));\n    \n    col = pow(max(col, 0.), vec3(.85));\n\n    u = fragCoord/iResolution.xy;\n    col *= pow(16.*u.x*u.y*(1. - u.x)*(1. - u.y) , .0625);\n\n\tfragColor = vec4(clamp(col, 0., 1.), 1);\n}",
   "name": "Image",
   "description": "",
   "type": "image"
  }
 ]
}