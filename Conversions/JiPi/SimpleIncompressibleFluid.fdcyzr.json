{"Shader":{"ver":"0.1","info":{"id":"fdcyzr","date":"1652938699","viewed":34,"name":"Simple Incompressible Fluid","username":"davidar","description":"Yet another fluid simulation, just advection with a \"Poisson filter\" based pressure solver to zero out divergence. Click and drag the mouse the interact","likes":3,"published":3,"flags":32,"usePreview":0,"tags":["simulation","filter","fluid","poisson","advection","gaussian","ca","separable","incompressible","divergence","svd"],"hasliked":0},"renderpass":[{"inputs":[{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":259,"src":"\/media\/previz\/buffer02.png","ctype":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":37,"channel":0}],"code":"vec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    \/\/ https:\/\/iquilezles.org\/articles\/palettes\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord\/iResolution.xy;\n\n    \/\/ Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    float d = texture(iChannel0, uv).z;\n    \/\/d = mix(-1., 1., d);\n    \n    col = pal( d, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20) );\n\n    \/\/ Output to screen\n    fragColor = vec4(col, 1.);\n    \/\/fragColor = texture(iChannel2, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\/*\nBuffers B and C calculate fluid pressure using the two-pass Poisson solver described in\n    \"Fast Eulerian Fluid Simulation In Games Using Poisson Filters\"\n    https:\/\/www.shahinrabbani.ca\/torch2pd.html\n\nSolutions are initialised with a Gaussian blur of the previous solution\n*\/\n\n\/\/ https:\/\/youtu.be\/_3eyPUyqluc?t=355\nconst float poisson_filter[7] = float[](\n    .57843719174,\n    .36519596949,\n    .23187988879,\n    .14529589353,\n    .08816487385,\n    .05184872885,\n    .02906462467\n);\n\nfloat gaussian(float w, float s) {\n    return exp(-(w*w) \/ (2.*s*s)) \/ (s * sqrt(radians(360.)));\n}\n\n\n\n\/\/ Hash without Sine\n\/\/ MIT License...\n\/* Copyright (c)2014 David Hoskins.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and\/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.*\/\n\n\/\/----------------------------------------------------------------------------------------\n\/\/  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/\/  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/\/  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n\/\/----------------------------------------------------------------------------------------\n\/\/\/  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/\/  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/ 4 out, 1 in...\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/ 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/ 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/ 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n\n\n\/* https:\/\/www.shadertoy.com\/view\/XsX3zB\n *\n * The MIT License\n * Copyright \u00a9 2013 Nikita Miropolskiy\n * \n * ( license has been changed from CCA-NC-SA 3.0 to MIT\n *\n *   but thanks for attributing your source code when deriving from this sample \n *   with a following link: https:\/\/www.shadertoy.com\/view\/XsX3zB )\n *\n * ~\n * ~ if you're looking for procedural noise implementation examples you might \n * ~ also want to look at the following shaders:\n * ~ \n * ~ Noise Lab shader by candycat: https:\/\/www.shadertoy.com\/view\/4sc3z2\n * ~\n * ~ Noise shaders by iq:\n * ~     Value    Noise 2D, Derivatives: https:\/\/www.shadertoy.com\/view\/4dXBRH\n * ~     Gradient Noise 2D, Derivatives: https:\/\/www.shadertoy.com\/view\/XdXBRH\n * ~     Value    Noise 3D, Derivatives: https:\/\/www.shadertoy.com\/view\/XsXfRH\n * ~     Gradient Noise 3D, Derivatives: https:\/\/www.shadertoy.com\/view\/4dffRH\n * ~     Value    Noise 2D             : https:\/\/www.shadertoy.com\/view\/lsf3WH\n * ~     Value    Noise 3D             : https:\/\/www.shadertoy.com\/view\/4sfGzS\n * ~     Gradient Noise 2D             : https:\/\/www.shadertoy.com\/view\/XdXGW8\n * ~     Gradient Noise 3D             : https:\/\/www.shadertoy.com\/view\/Xsl3Dl\n * ~     Simplex  Noise 2D             : https:\/\/www.shadertoy.com\/view\/Msf3WH\n * ~     Voronoise: https:\/\/www.shadertoy.com\/view\/Xd23Dh\n * ~ \n *\n *\/\n\n\/* skew constants for 3d simplex functions *\/\nconst float F3 = 1.\/3.;\nconst float G3 = 1.\/6.;\n\n\/* 3d simplex noise *\/\nfloat simplex3d(vec3 p) {\n\t \/* 1. find current tetrahedron T and it's four vertices *\/\n\t \/* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices *\/\n\t \/* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*\/\n\t \n\t \/* calculate s and x *\/\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t \/* calculate i1 and i2 *\/\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t \/* x1, x2, x3 *\/\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t \/* 2. find four surflets and store them in d *\/\n\t vec4 w, d;\n\t \n\t \/* calculate surflet weights *\/\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t \/* w fades from 0.6 at the center of the surflet to 0.0 at the margin *\/\n\t w = max(0.6 - w, 0.0);\n\t \n\t \/* calculate surflet components *\/\n\t d.x = dot(hash33(s) - 0.5, x);\n\t d.y = dot(hash33(s + i1) - 0.5, x1);\n\t d.z = dot(hash33(s + i2) - 0.5, x2);\n\t d.w = dot(hash33(s + 1.0) - 0.5, x3);\n\t \n\t \/* multiply d by w^4 *\/\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t \/* 3. return the sum of the four surflets *\/\n\t return dot(d, vec4(52.0));\n}\n\n\n\n\/\/ https:\/\/iquilezles.org\/articles\/fbm\n\nfloat fbm( in vec3 x, in float G, in int numOctaves )\n{    \n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    for( int i=0; i<numOctaves; i++ )\n    {\n        t += a*simplex3d(f*x);\n        f *= 2.0;\n        a *= G;\n    }\n    return t;\n}\n\n\n\n\/* Texture Stencil Library https:\/\/www.shadertoy.com\/view\/ssBczm\n\nThe MIT License\n\nCopyright (c) 2022 David A Roberts <https:\/\/davidar.io\/>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and\/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*\/\n\nvec4 texStencil(sampler2D ch, vec2 uv, float coeff[9]) {\n    vec2 texel = 1. \/ vec2(textureSize(ch, 0));\n    const vec2 stencilOffset[9] = vec2[](\n        vec2(-1, 1), vec2( 0, 1), vec2( 1, 1),\n        vec2(-1, 0), vec2( 0, 0), vec2( 1, 0),\n        vec2(-1,-1), vec2( 0,-1), vec2( 1,-1)\n    );\n    vec4 r = vec4(0);\n    for (int i = 0; i < 9; i++)\n        r += coeff[i] * texture(ch, uv + texel * stencilOffset[i]);\n    return r;\n}\n\n\/\/ Gaussian\/binomial blur\n\/\/ https:\/\/bartwronski.com\/2021\/10\/31\/practical-gaussian-filter-binomial-filter-and-small-sigma-gaussians\/\nvec4 texBlur(sampler2D ch, vec2 uv) {\n    return texStencil(ch, uv, float[](\n        .0625, .125, .0625,\n        .125,  .25,  .125,\n        .0625, .125, .0625\n    ));\n}\n\n\/\/ Laplacian, optimal 9-point stencil\n\/\/ https:\/\/docs.lib.purdue.edu\/cgi\/viewcontent.cgi?article=1928&context=cstech\nvec4 texLapl(sampler2D ch, vec2 uv) {\n    return texStencil(ch, uv, float[](\n        1.,   4., 1.,\n        4., -20., 4.,\n        1.,   4., 1.\n    )) \/ 6.;\n}\n\n\/\/ horizontal gradient (Sobel filter)\nvec4 texGradX(sampler2D ch, vec2 uv) {\n    return texStencil(ch, uv, float[](\n        -1., 0., 1.,\n        -2., 0., 2.,\n        -1., 0., 1.\n    )) \/ 8.;\n}\n\n\/\/ vertical gradient (Sobel filter)\nvec4 texGradY(sampler2D ch, vec2 uv) {\n    return texStencil(ch, uv, float[](\n         1.,  2.,  1.,\n         0.,  0.,  0.,\n        -1., -2., -1.\n    )) \/ 8.;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":259,"src":"\/media\/previz\/buffer02.png","ctype":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":260,"src":"\/media\/previz\/buffer03.png","ctype":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":257,"channel":0}],"code":"void interaction(in vec2 uv, inout vec2 velocity, inout float ink) {\n    \/\/ this function describes any external forces on the fluid, for example:\n\n    vec3 seed = vec3(uv, iTime \/ 10.);\n    velocity += .05 * fbm(20. * seed, .5, 8);\n    velocity *= .99;\n    ink += (fbm(seed, .5, 8) + 1.) * 7e-3;\n    ink = clamp(.99 * ink, 0., 1.);\n\n    if (iMouse.z > 0.) {\n        vec2 p = iMouse.xy \/ iResolution.xy;\n        vec4 iMousePrev = texelFetch(iChannel3, ivec2(0,0), 0);\n        vec2 v = iMouse.xy - iMousePrev.xy;\n        if (length(v) > 1.) v = normalize(v);\n        velocity += v * exp(-1000. * dot(uv-p, uv-p));\n    }\n}\n\nvec3 fetch(vec2 uv) {\n    \/\/ subtract pressure gradient from velocity\n    return vec3(\n        texture(iChannel0, uv).x - texGradX(iChannel2, uv).x,\n        texture(iChannel0, uv).y - texGradY(iChannel2, uv).x,\n        texture(iChannel0, uv).z);\n}\n\nvec3 advect(vec2 uv) {\n    return fetch(uv - fetch(uv).xy \/ iResolution.xy);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord \/ iResolution.xy;\n    vec3 r = advect(uv);\n    interaction(uv, r.xy, r.z);\n    fragColor = vec4(r, 1.);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":259,"src":"\/media\/previz\/buffer02.png","ctype":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":258,"channel":0}],"code":"\/\/ Poisson solver - horizontal pass\n\nfloat rhs(vec2 pos) { \/\/ rhs of the poisson equation\n    vec2 uv = pos \/ iResolution.xy;\n    float divergence = texGradX(iChannel0, uv).x + texGradY(iChannel0, uv).y;\n    return -divergence;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float p = 0., g = 0.;\n    for (int i = -6; i <= 6; i++) {\n        vec2 pos = fragCoord + vec2(i,0);\n        p += poisson_filter[abs(i)] * rhs(pos);\n        g += gaussian(float(i), 3.) * texelFetch(iChannel2, ivec2(pos), 0).x;\n    }\n\tfragColor = vec4(p, g, 0, 0);\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":258,"src":"\/media\/previz\/buffer01.png","ctype":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":259,"channel":0}],"code":"\/\/ Poisson solver - vertical pass\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float p = 0., g = 0.;\n    for (int j = -6; j <= 6; j++) {\n        vec4 pass1 = texelFetch(iChannel1, ivec2(fragCoord) + ivec2(0,j), 0);\n        p += poisson_filter[abs(j)] * pass1.x;\n        g += gaussian(float(j), 3.) * pass1.y;\n    }\n    fragColor = vec4(g + p);\n}\n","name":"Buffer C","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":260,"channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = iMouse;\n}","name":"Buffer D","description":"","type":"buffer"}]}}