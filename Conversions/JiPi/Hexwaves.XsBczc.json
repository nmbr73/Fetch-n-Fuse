{"Shader":{"ver":"0.1","info":{"id":"XsBczc","date":"1494299996","viewed":1687,"name":"hexwaves","username":"mattz","description":"No distance marching -- just raytracing a hexagonal grid as first developed in https:\/\/www.shadertoy.com\/view\/XdSyzK","likes":69,"published":3,"flags":0,"usePreview":0,"tags":["voxel","raytrace","hex","seasick"],"hasliked":0},"renderpass":[{"inputs":[{"id":25,"src":"\/media\/a\/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","ctype":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":37,"channel":0}],"code":"\/* hexwaves, by mattz\n   License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n   Uses the hex grid traversal code I developed in https:\/\/www.shadertoy.com\/view\/XdSyzK\n\n*\/\n\n\n\/\/ square root of 3 over 2\nconst float hex_factor = 0.8660254037844386;\n\nconst vec3 fog_color = vec3(0.9, 0.95, 1.0);\n\n#define HEX_FROM_CART(p) vec2(p.x \/ hex_factor, p.y)\n#define CART_FROM_HEX(g) vec2(g.x * hex_factor, g.y)\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Used to draw top borders\n\nfloat hexDist(vec2 p) {\n    p = abs(p);\n    return max(dot(p, vec2(hex_factor, 0.5)), p.y) - 1.0;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Given a 2D position, find integer coordinates of center of nearest\n\/\/ hexagon in plane.\n\nvec2 nearestHexCell(in vec2 pos) {\n    \n    \/\/ integer coords in hex center grid -- will need to be adjusted\n    vec2 gpos = HEX_FROM_CART(pos);\n    vec2 hex_int = floor(gpos);\n\n    \/\/ adjust integer coords\n    float sy = step(2.0, mod(hex_int.x+1.0, 4.0));\n    hex_int += mod(vec2(hex_int.x, hex_int.y + sy), 2.0);\n\n    \/\/ difference vector\n    vec2 gdiff = gpos - hex_int;\n\n    \/\/ figure out which side of line we are on and modify\n    \/\/ hex center if necessary\n    if (dot(abs(gdiff), vec2(hex_factor*hex_factor, 0.5)) > 1.0) {\n        vec2 delta = sign(gdiff) * vec2(2.0, 1.0);\n        hex_int += delta;\n    }\n\n    return hex_int;\n    \n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Flip normal if necessary to have positive dot product with d\n\nvec2 alignNormal(vec2 h, vec2 d) {\n    return h*sign(dot(h, CART_FROM_HEX(d)));\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Intersect a ray with a hexagon wall with normal n\n\nvec3 rayHexIntersect(vec2 ro, vec2 rd, vec2 h) {\n\n    vec2 n = CART_FROM_HEX(h);\n\n    \/\/ solve for u such that dot(n, ro+u*rd) = 1.0\n    float u = (1.0 - dot(n, ro)) \/ dot(n, rd);\n\n    \/\/ return the \n    return vec3(h, u);\n\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Choose the vector whose z coordinate is minimal\n\nvec3 rayMin(vec3 a, vec3 b) {\n    return a.z < b.z ? a : b;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ From Dave Hoskins' https:\/\/www.shadertoy.com\/view\/4djSRW\n\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n\nvec3 hash32(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Return the cell height for the given cell center\n\nfloat height_for_pos(vec2 pos) {\n    \n    \/\/ shift origin a bit randomly\n    pos += vec2(2.0*sin(iTime*0.3+0.2), 2.0*cos(iTime*0.1+0.5));\n    \n    \/\/ cosine of distance from origin, modulated by Gaussian\n    float x2 = dot(pos, pos);\n    float x = sqrt(x2);\n    \n    return 6.0 * cos(x*0.2 + iTime) * exp(-x2\/128.0);\n    \n}\n\nvec4 surface(vec3 rd, vec2 cell, vec4 hit_nt, float bdist) {\n\n    \/\/ fog coefficient is 1 near origin, 0 far way\n    float fogc = exp(-length(hit_nt.w*rd)*0.02);\n\n    \/\/ get the normal\n    vec3 n = hit_nt.xyz;\n\n    \/\/ add some noise so we don't just purely reflect boring flat cubemap\n    \/\/ makes a nice \"disco ball\" look in background\n    vec3 noise = (hash32(cell)-0.5)*0.15;\n    n = normalize(n + noise);\n\n    \/\/ gotta deal with borders\n\n    \/\/ need to antialias more far away\n    float border_scale = 2.0\/iResolution.y;\n\n    const float border_size = 0.04;\n\n    float border = smoothstep(0.0, border_scale*hit_nt.w, abs(bdist)-border_size);\n\n    \/\/ don't even try to draw borders too far away\n    border = mix(border, 0.75, smoothstep(18.0, 45.0, hit_nt.w));\n\n    \/\/ light direction\n    vec3 L = normalize(vec3(3, 1, 4));\n\n    \/\/ diffuse + ambient term\n    float diffamb = (clamp(dot(n, L), 0.0, 1.0) * 0.8 + 0.2);\n\n    \/\/ start out white\n    vec3 color = vec3( 1.0 );\n\n    \/\/ add in border color\n    color = mix(vec3(0.1, 0, 0.08), color, border);\n\n    \/\/ multiply by diffuse\/ambient\n    color *= diffamb;\n\n    \/\/ cubemap fake reflection\n    color = mix(color, texture(iChannel0, reflect(rd, n)).yzx, 0.4*border);\n\n    \/\/ fog\n    color = mix(fog_color, color, fogc);\n    \n    return vec4(color, border);\n\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Return the color for a ray with origin ro and direction rd\n\nvec3 shade(in vec3 ro, in vec3 rd) {\n    \t\n    \/\/ the color we will return\n    vec3 color = fog_color;\n\n    \/\/ find nearest hex center to ray origin\n    vec2 cur_cell = nearestHexCell(ro.xy);\n\n    \/\/ get the three candidate wall normals for this ray (i.e. the\n    \/\/ three hex side normals with positive dot product to the ray\n    \/\/ direction)\n\n    vec2 h0 = alignNormal(vec2(0.0, 1.0), rd.xy);\n    vec2 h1 = alignNormal(vec2(1.0, 0.5), rd.xy);\n    vec2 h2 = alignNormal(vec2(1.0, -0.5), rd.xy);\n\n    \/\/ initial cell height at ray origin\n    float cell_height = height_for_pos(CART_FROM_HEX(cur_cell));\n    \n    \/\/ reflection coefficient\n    float alpha = 1.0;\n\n    \/\/ march along ray, one iteration per cell\n    for (int i=0; i<80; ++i) {\n        \n        \/\/ we will set these when the ray intersects\n        bool hit = false;\n        vec4 hit_nt;\n        float bdist = 1e5;\n\n        \/\/ after three tests, ht.xy holds the hex grid direction,\n        \/\/ ht.z holds the ray distance parameter\n        vec2 cur_center = CART_FROM_HEX(cur_cell);\n        vec2 rdelta = ro.xy-cur_center;\n        \n        vec3 ht = rayHexIntersect(rdelta, rd.xy, h0);\n        ht = rayMin(ht, rayHexIntersect(rdelta, rd.xy, h1));\n        ht = rayMin(ht, rayHexIntersect(rdelta, rd.xy, h2));\n\n        \/\/ try to intersect with top of cell\n        float tz = (cell_height - ro.z) \/ rd.z;\n\n        \/\/ if ray sloped down and ray intersects top of cell before escaping cell\n        if (ro.z > cell_height && rd.z < 0.0 && tz < ht.z) {\n\n            \/\/ set up intersection info\n            hit = true;\n            hit_nt = vec4(0, 0, 1.0, tz);   \n            vec2 pinter = ro.xy + rd.xy * tz;\n\n            \/\/ distance to hex border\n            bdist = hexDist(pinter - cur_center);\n\n        } else { \/\/ we hit a cell wall before hitting top.\n\n            \/\/ update the cell center by twice the grid direction\n            cur_cell += 2.0 * ht.xy;\n            \n            vec2 n = CART_FROM_HEX(ht.xy);\n            cur_center = CART_FROM_HEX(cur_cell);\n\n            float prev_cell_height = cell_height;\n            cell_height = height_for_pos(cur_center);\n\n            \/\/ get the ray intersection point with cell wall\n            vec3 p_intersect = ro + rd*ht.z;\n\n            \/\/ if we intersected below the height, it's a hit\n            if (p_intersect.z < cell_height) {\n\n                \/\/ set up intersection info\n                hit_nt = vec4(n, 0.0, ht.z);\n                hit = true;\n\n                \/\/ distance to wall top\n                bdist = cell_height - p_intersect.z;\n\n                \/\/ distance to wall bottom\n                bdist = min(bdist, p_intersect.z - prev_cell_height);\n\n                \/\/ distance to wall outer side corner\n                vec2 p = p_intersect.xy - cur_center;\n                p -= n * dot(p, n);\n                bdist = min(bdist, abs(length(p) - 0.5\/hex_factor));\n\n            }\n\n        }                      \n        \n        if (hit) {\n            \n            \/\/ shade surface\n            vec4 hit_color = surface(rd, cur_cell, hit_nt, bdist);\n            \n            \/\/ mix in reflection\n            color = mix(color, hit_color.xyz, alpha);\n            \n            \/\/ decrease blending coefficient for next bounce\n            alpha *= 0.17 * hit_color.w;\n            \n            \/\/ re-iniitialize ray position & direction for reflection ray\n            ro = ro + rd*hit_nt.w;\n            rd = reflect(rd, hit_nt.xyz);\n            ro += 1e-3*hit_nt.xyz;\n                        \n            \/\/ re-initialize candidate ray directions\n            h0 = alignNormal(vec2(0.0, 1.0), rd.xy);\n            h1 = alignNormal(vec2(1.0, 0.5), rd.xy);\n            h2 = alignNormal(vec2(1.0, -0.5), rd.xy);\n\n        }\n\n    }\n    \n    \/\/ use leftover ray energy to show sky\n    color = mix(color, fog_color, alpha);\n    \n    return color;\n\t\n}\t\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Pretty much my boilerplate rendering code, just a couple of \n\/\/ fancy twists like radial distortion and vingetting.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t\n\tconst float yscl = 720.0;\n\tconst float f = 500.0;\n\t\n    vec2 uvn = (fragCoord.xy - 0.5*iResolution.xy) \/ iResolution.y;\n\tvec2 uv = uvn * yscl;\n\t\n\tvec3 pos = vec3(-12.0, 0.0, 10.0);\n\tvec3 tgt = vec3(0.);\n\tvec3 up = vec3(0.0, 0.0, 1.0);\n\t\n\tvec3 rz = normalize(tgt - pos);\n\tvec3 rx = normalize(cross(rz,up));\n\tvec3 ry = cross(rx,rz);\n    \n    \/\/ compute radial distortion\n    float s = 1.0 + dot(uvn, uvn)*1.5;\n\t \n\tvec3 rd = mat3(rx,ry,rz)*normalize(vec3(uv*s, f));\n\tvec3 ro = pos;\n\n\tfloat thetax = -0.35 - 0.2*cos(0.031513*iTime);\n\tfloat thetay = -0.02*iTime;\n\t\n\tif (iMouse.y > 10.0 || iMouse.x > 10.0) { \n\t\tthetax = (iMouse.y - 0.5*iResolution.y) * -1.25\/iResolution.y;\n\t\tthetay = (iMouse.x - 0.5*iResolution.x) * 6.28\/iResolution.x; \n\t}\n\n\tfloat cx = cos(thetax);\n\tfloat sx = sin(thetax);\n\tfloat cy = cos(thetay);\n\tfloat sy = sin(thetay);\n\t\n\tmat3 Rx = mat3(1.0, 0.0, 0.0, \n\t\t\t\t   0.0, cx, sx,\n\t\t\t\t   0.0, -sx, cx);\n\t\n\tmat3 Ry = mat3(cy, 0.0, -sy,\n\t\t\t\t   0.0, 1.0, 0.0,\n\t\t\t\t   sy, 0.0, cy);\n    \n    mat3 R = mat3(0.0, 0.0, 1.0,\n                  -1.0, 0.0, 0.0,\n                  0.0, 1.0, 0.0);\n\t\n\trd = transpose(R)*Ry*Rx*R*rd;\n\tro = transpose(R)*Ry*Rx*R*(pos-tgt) + tgt;\n\n\tvec3 color = shade(ro, rd);\n    color = sqrt(color);\n    \n    vec2 q = fragCoord.xy \/ iResolution.xy;\n    \n    \/\/ stole iq's vingette code\n    color *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );       \n\n    fragColor = vec4(color, 1.0);\n    \n}","name":"Image","description":"","type":"image"}]}}