{"Shader":{"ver":"0.1","info":{"id":"MsVXWW","date":"1464534583","viewed":12738,"name":"Dusty nebula 4","username":"Duke","description":"Visualization technique is basically the same as in the [url=https:\/\/www.shadertoy.com\/view\/lsVSRW]Dusty nebula 3[\/url], but this time, I tried to imitate the filaments, which can be seen on most of the photos of nebulae.","likes":215,"published":3,"flags":16,"usePreview":0,"tags":["cloud","star","space","nebula","dust","filament"],"hasliked":0},"renderpass":[{"inputs":[{"id":30,"src":"\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","ctype":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":33,"src":"\/presets\/tex00.jpg","ctype":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":37,"channel":0}],"code":"\/\/ \"Dusty nebula 4\" by Duke\n\/\/ https:\/\/www.shadertoy.com\/view\/MsVXWW\n\/\/-------------------------------------------------------------------------------------\n\/\/ Based on \"Dusty nebula 3\" (https:\/\/www.shadertoy.com\/view\/lsVSRW) \n\/\/ and \"Protoplanetary disk\" (https:\/\/www.shadertoy.com\/view\/MdtGRl) \n\/\/ otaviogood's \"Alien Beacon\" (https:\/\/www.shadertoy.com\/view\/ld2SzK)\n\/\/ and Shane's \"Cheap Cloud Flythrough\" (https:\/\/www.shadertoy.com\/view\/Xsc3R4) shaders\n\/\/ Some ideas came from other shaders from this wonderful site\n\/\/ Press 1-2-3 to zoom in and zoom out.\n\/\/ License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\/\/-------------------------------------------------------------------------------------\n\n#define ROTATION\n\/\/#define MOUSE_CAMERA_CONTROL\n\n#define DITHERING\n#define BACKGROUND\n\n\/\/#define TONEMAPPING\n\n\/\/-------------------\n#define pi 3.14159265\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n\n\/\/ iq's noise\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)\/256.0, 0.0 ).yx;\n\treturn 1. - 0.82*mix( rg.x, rg.y, f.z );\n}\n\nfloat rand(vec2 co)\n{\n\treturn fract(sin(dot(co*0.123,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\/\/=====================================\n\/\/ otaviogood's noise from https:\/\/www.shadertoy.com\/view\/ld2SzK\n\/\/--------------------------------------------------------------\n\/\/ This spiral noise works by successively adding and rotating sin waves while increasing frequency.\n\/\/ It should work the same on all computers since it's not based on a hash function like some other noises.\n\/\/ It can be much faster than other noise functions if you're ok with some repetition.\nconst float nudge = 0.739513;\t\/\/ size of perpendicular vector\nfloat normalizer = 1.0 \/ sqrt(1.0 + nudge*nudge);\t\/\/ pythagorean theorem on that perpendicular to maintain scale\nfloat SpiralNoiseC(vec3 p)\n{\n    float n = 0.0;\t\/\/ noise amount\n    float iter = 1.0;\n    for (int i = 0; i < 8; i++)\n    {\n        \/\/ add sin and cos scaled inverse with the frequency\n        n += -abs(sin(p.y*iter) + cos(p.x*iter)) \/ iter;\t\/\/ abs for a ridged look\n        \/\/ rotate by adding perpendicular and scaling down\n        p.xy += vec2(p.y, -p.x) * nudge;\n        p.xy *= normalizer;\n        \/\/ rotate on other axis\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        \/\/ increase the frequency\n        iter *= 1.733733;\n    }\n    return n;\n}\n\nfloat SpiralNoise3D(vec3 p)\n{\n    float n = 0.0;\n    float iter = 1.0;\n    for (int i = 0; i < 5; i++)\n    {\n        n += (sin(p.y*iter) + cos(p.x*iter)) \/ iter;\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        iter *= 1.33733;\n    }\n    return n;\n}\n\nfloat NebulaNoise(vec3 p)\n{\n   float final = p.y + 4.5;\n    final -= SpiralNoiseC(p.xyz);   \/\/ mid-range noise\n    final += SpiralNoiseC(p.zxy*0.5123+100.0)*4.0;   \/\/ large scale features\n    final -= SpiralNoise3D(p);   \/\/ more large scale features, but 3d\n\n    return final;\n}\n\nfloat map(vec3 p) \n{\n\t#ifdef ROTATION\n\tR(p.xz, iMouse.x*0.008*pi+iTime*0.1);\n\t#endif\n    \n\tfloat NebNoise = abs(NebulaNoise(p\/0.5)*0.5);\n    \n\treturn NebNoise+0.03;\n}\n\/\/--------------------------------------------------------------\n\n\/\/ assign color to the media\nvec3 computeColor( float density, float radius )\n{\n\t\/\/ color based on density alone, gives impression of occlusion within\n\t\/\/ the media\n\tvec3 result = mix( vec3(1.0,0.9,0.8), vec3(0.4,0.15,0.1), density );\n\t\n\t\/\/ color added to the media\n\tvec3 colCenter = 7.*vec3(0.8,1.0,1.0);\n\tvec3 colEdge = 1.5*vec3(0.48,0.53,0.5);\n\tresult *= mix( colCenter, colEdge, min( (radius+.05)\/.9, 1.15 ) );\n\t\n\treturn result;\n}\n\nbool RaySphereIntersect(vec3 org, vec3 dir, out float near, out float far)\n{\n\tfloat b = dot(dir, org);\n\tfloat c = dot(org, org) - 8.;\n\tfloat delta = b*b - c;\n\tif( delta < 0.0) \n\t\treturn false;\n\tfloat deltasqrt = sqrt(delta);\n\tnear = -b - deltasqrt;\n\tfar = -b + deltasqrt;\n\treturn far > 0.0;\n}\n\n\/\/ Applies the filmic curve from John Hable's presentation\n\/\/ More details at : http:\/\/filmicgames.com\/archives\/75\nvec3 ToneMapFilmicALU(vec3 _color)\n{\n\t_color = max(vec3(0), _color - vec3(0.004));\n\t_color = (_color * (6.2*_color + vec3(0.5))) \/ (_color * (6.2 * _color + vec3(1.7)) + vec3(0.06));\n\treturn _color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    const float KEY_1 = 49.5\/256.0;\n\tconst float KEY_2 = 50.5\/256.0;\n\tconst float KEY_3 = 51.5\/256.0;\n    float key = 0.0;\n    key += 0.7*texture(iChannel1, vec2(KEY_1,0.25)).x;\n    key += 0.7*texture(iChannel1, vec2(KEY_2,0.25)).x;\n    key += 0.7*texture(iChannel1, vec2(KEY_3,0.25)).x;\n\n\t\/\/ ro: ray origin\n\t\/\/ rd: direction of the ray\n\tvec3 rd = normalize(vec3((gl_FragCoord.xy-0.5*iResolution.xy)\/iResolution.y, 1.));\n\tvec3 ro = vec3(0., 0., -6.+key*1.6);\n\n    #ifdef MOUSE_CAMERA_CONTROL\n    R(rd.yz, -iMouse.y*0.01*pi*2.);\n    R(rd.xz, iMouse.x*0.01*pi*2.);\n    R(ro.yz, -iMouse.y*0.01*pi*2.);\n    R(ro.xz, iMouse.x*0.01*pi*2.);\n    #else\n    R(rd.yz, -pi*3.93);\n    R(rd.xz, pi*3.2);\n    R(ro.yz, -pi*3.93);\n   \tR(ro.xz, pi*3.2);    \n    #endif \n    \n    #ifdef DITHERING\n\tvec2 dpos = ( fragCoord.xy \/ iResolution.xy );\n\tvec2 seed = dpos + fract(iTime);\n\t#endif \n    \n\t\/\/ ld, td: local, total density \n\t\/\/ w: weighting factor\n\tfloat ld=0., td=0., w=0.;\n\n\t\/\/ t: length of the ray\n\t\/\/ d: distance function\n\tfloat d=1., t=0.;\n    \n    const float h = 0.1;\n   \n\tvec4 sum = vec4(0.0);\n   \n    float min_dist=0.0, max_dist=0.0;\n\n    if(RaySphereIntersect(ro, rd, min_dist, max_dist))\n    {\n       \n\tt = min_dist*step(t,min_dist);\n   \n\t\/\/ raymarch loop\n\tfor (int i=0; i<56; i++) \n\t{\n\t \n\t\tvec3 pos = ro + t*rd;\n  \n\t\t\/\/ Loop break conditions.\n        if(td>0.9 || d<0.1*t || t>10. || sum.a > 0.99 || t>max_dist) break;\n\t    \n        \/\/ evaluate distance function\n        float d = map(pos);\n\t\t       \n\t\t\/\/ change this string to control density \n\t\td = max(d,0.08);\n        \n        \/\/ point light calculations\n        vec3 ldst = vec3(0.0)-pos;\n        float lDist = max(length(ldst), 0.001);\n\n        \/\/ star in center\n        vec3 lightColor=vec3(1.0,0.5,0.25);\n        sum.rgb+=(lightColor\/(lDist*lDist)\/30.); \/\/ star itself and bloom around the light\n      \n\t\tif (d<h) \n\t\t{\n\t\t\t\/\/ compute local density \n\t\t\tld = h - d;\n            \n            \/\/ compute weighting factor \n\t\t\tw = (1. - td) * ld;\n     \n\t\t\t\/\/ accumulate density\n\t\t\ttd += w + 1.\/200.;\n\t\t\n\t\t\tvec4 col = vec4( computeColor(td,lDist), td );\n\t\t\n\t\t\t\/\/ uniform scale density\n\t\t\tcol.a *= 0.185;\n\t\t\t\/\/ colour by alpha\n\t\t\tcol.rgb *= col.a;\n\t\t\t\/\/ alpha blend in contribution\n\t\t\tsum = sum + col*(1.0 - sum.a);  \n       \n\t\t}\n      \n\t\ttd += 1.\/70.;\n       \n        \/\/ enforce minimum stepsize\n        d = max(d, 0.04); \n      \n        #ifdef DITHERING\n        \/\/ add in noise to reduce banding and create fuzz\n        d=abs(d)*(.8+0.2*rand(seed*vec2(i)));\n        #endif \n\t\t\n        \/\/ trying to optimize step size near the camera and near the light source\n        t += max(d * 0.1 * max(min(length(ldst),length(ro)),1.0), 0.02);\n      \n\t}\n    \n    \/\/ simple scattering\n\tsum *= 1. \/ exp( ld * 0.2 ) * 0.6;\n        \n   \tsum = clamp( sum, 0.0, 1.0 );\n   \n    sum.xyz = sum.xyz*sum.xyz*(3.0-2.0*sum.xyz);\n    \n\t}\n\n    #ifdef BACKGROUND\n    \/\/ stars background\n    if (td<.8)\n    {\n        vec3 stars = vec3(noise(rd*500.0)*0.5+0.5);\n        vec3 starbg = vec3(0.0);\n        starbg = mix(starbg, vec3(0.8,0.9,1.0), smoothstep(0.99, 1.0, stars)*clamp(dot(vec3(0.0),rd)+0.75,0.0,1.0));\n        starbg = clamp(starbg, 0.0, 1.0);\n        sum.xyz += starbg; \n    }\n\t#endif\n   \n    #ifdef TONEMAPPING\n    fragColor = vec4(ToneMapFilmicALU(sum.xyz*2.2),1.0);\n\t#else\n    fragColor = vec4(sum.xyz,1.0);\n\t#endif\n}","name":"Image","description":"","type":"image"}]}}