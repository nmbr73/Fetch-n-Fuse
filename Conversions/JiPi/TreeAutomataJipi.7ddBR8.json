{
 "ver": "0.1",
 "info": {
  "id": "7ddBR8",
  "date": "0",
  "viewed": 0,
  "name": "Tree automata JiPi",
  "description": "Random automata which expands in a way similar to how I draw pixel art.  \nThere should be invisible regions which it can't grow in, could definitely be improved.\n\npress r to reset ",
  "likes": 0,
  "published": "Private",
  "usePreview": 0,
  "tags": [
   "cellularautomata"
  ],
  "hasliked": 0,
  "parentid": "Ns2XRh",
  "parentname": "Tree automata"
 },
 "renderpass": [
  {
   "inputs": [
    {
     "id": "4dXGR8",
     "filepath": "/media/previz/buffer00.png",
     "type": "buffer",
     "channel": 0,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    }
   ],
   "outputs": [
    {
     "id": "4dfGRr",
     "channel": 0
    }
   ],
   "code": "// Code forked from Inigo Quilez's game of life shader\n// https://www.shadertoy.com/view/XstGRf\n// Reset code stolen from somewhere else - sorry!\n// (Press R to reset shader)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n//fragColor = vec4( 1. - step(3. * texelFetch( iChannel0, ivec2(fragCoord), 0 ).x ,0.5));\n//fragColor = vec4(3. * texelFetch( iChannel0, ivec2(fragCoord), 0 ).x );\nfragColor = vec4(3. * texture( iChannel0, (vec2(ivec2(fragCoord))+0.5)/iResolution.xy ).x );\n\n\n\n}",
   "name": "Image",
   "description": "",
   "type": "image"
  },
  {
   "inputs": [
    {
     "id": "4dXGRr",
     "filepath": "/presets/tex00.jpg",
     "type": "keyboard",
     "channel": 1,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    },
    {
     "id": "4dXGR8",
     "filepath": "/media/previz/buffer00.png",
     "type": "buffer",
     "channel": 0,
     "sampler": {
      "filter": "nearest",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    }
   ],
   "outputs": [
    {
     "id": "4dXGR8",
     "channel": 0
    }
   ],
   "code": "#define KEYBOARD iChannel1\n#define KEY_RESET 82\n\n\nfloat Cell( in ivec2 p )\n{\n    // do wrapping\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    \n    // fetch texel\n   // return (texelFetch(iChannel0, p, 0 ).x > 0.5 ) ? 1 : 0;\n   //return texelFetch(iChannel0, p, 0 ).x;\n   return texture(iChannel0, (vec2(p)+0.5)/iResolution.xy ).x;\n}\n\nfloat hash1( float n )\n{\n    return fract(sin(n)*138.5453123);\n}\n\nbool key_down(int key) {\n    return int(texelFetch(KEYBOARD, ivec2(key, 0), 0).x) == 1;\n}\n\nfloat S(float x)\n{\nreturn step(0.5,x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 px = ivec2( fragCoord );\n    \n   if (key_down(KEY_RESET) || iFrame == 0 )\n   {\n   vec2 U = fragCoord/iResolution.y ; \n   U.x -= 0.375;\n   U = step( fract(3. * abs(U-0.5)),vec2(3. / iResolution.y) );\n   float f = max(U.x,U.y) * hash1(fragCoord.x*13.0 + 10.131 * iTime + hash1(fragCoord.y*73.1));\n   fragColor = vec4( step(0.5,f), 0,0,0 );\n   return;\n   }\n    \n  // center cell\n  float e = Cell(px); \n\n  // neighbour cells\n  float t = Cell(px + ivec2(0,-1));\n  float b = Cell(px + ivec2(0,1));\n  float l = Cell(px + ivec2(-1,0));\n  float r = Cell(px + ivec2(1,0));   \n\n  float tl = Cell(px + ivec2(-1,-1));\n  float tr = Cell(px + ivec2(1,-1));\n  float bl = Cell(px + ivec2(-1,1));\n  float br = Cell(px + ivec2(1,1));\n\n  float t2 = Cell(px + ivec2(0,-2));\n  float b2 = Cell(px + ivec2(0,2));\n  float l2 = Cell(px + ivec2(-2,0));\n  float r2 = Cell(px + ivec2(2,0));   \n\n\nfloat q = hash1(fragCoord.x*13.0+ 10.131 * iTime + hash1(fragCoord.y*73.1));\n\nvec2 uv = fragCoord/iResolution.xy;\nvec2 uv2 = floor(1000. * uv) / 1000.;\nfloat q2 = hash1(uv2.x*13.0 + hash1(uv2.y*73.1));\n\nif (q2 > 0.55)\n{\nfloat sumNeighbours = S(t) + S(b) + S(l) + S(r) + S(tl) + S(tr) + S(bl) + S(br);\n\nif ( sumNeighbours == 1. && e < 1.)\ne =  step(0.5, 0.6 * q);\n\nelse if (e > 0. && e < 2.)\n{\nif (tl * tr > 0. || tl * bl > 0. || bl * br >0. || tr * br > 0.)\ne = 0.;\nelse if (t * l > 0. || t * r > 0. || b * l > 0. || b * r > 0.)\ne = 0.;\n//else if (t2 * b2 > 0. || l2 * r2 > 0.)\nelse if ((t2 > 0. && t <1.) || (b2 > 0. && b < 1.) || (r2 >0. && r < 1.) || (l2 >0. && l <1.))\ne = 0.;\nelse if (sumNeighbours == 2.)\ne = 2.;\n}\n}\nelse\ne = 0.;\n    \nfragColor = vec4( e, 0.0, 0.0, 0.0 );\n}",
   "name": "Buffer A",
   "description": "",
   "type": "buffer"
  }
 ]
}