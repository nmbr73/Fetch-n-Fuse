{
 "ver": "0.1",
 "info": {
  "id": "NtcfDr",
  "date": "0",
  "viewed": 0,
  "name": "ContinuousGradient JiPi",
  "description": "Bottom : stylized use of the gradient with value for magnitude and hue for direction (correct only on B&W input, in RGB there is 3 directions and magnitudes).\nTop left : original continuous gradient.\nTop right : original input.",
  "likes": 0,
  "published": "Private",
  "usePreview": 0,
  "tags": [
   "sobel",
   "gradient",
   "derivative",
   "norm",
   "direction"
  ],
  "hasliked": 0,
  "parentid": "XtK3Dd",
  "parentname": "Continuous Gradient w. Direction"
 },
 "renderpass": [
  {
   "inputs": [
    {
     "id": "4sX3Rn",
     "filepath": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv",
     "type": "video",
     "channel": 0,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    }
   ],
   "outputs": [
    {
     "id": "4dfGRr",
     "channel": 0
    }
   ],
   "code": "#define DX (iMouse.x/iResolution.x)\n#define DY (iMouse.y/iResolution.y)\n#define BORDERRADIUS (6)\n#define GAMMA       (2.2)\n#define PI           (3.14159265359)\n#define LUMWEIGHT    (vec3(0.2126,0.7152,0.0722))\n#define pow3(x,y)      (pow( max(x,0.) , vec3(y) ))\n\n#define BORDERRADIUSf float(BORDERRADIUS)\n#define BORDERRADIUS22f float(BORDERRADIUS*BORDERRADIUS)\n\n// https://www.shadertoy.com/view/MsS3Wc\n// HSV to RGB conversion \nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec2 viewport(vec2 p)\n{   \n    return p/(iResolution.xy);\n}\n\nvec3 sampleImage(vec2 coord){\n   return pow3(texture(iChannel0,viewport(coord)).rgb,GAMMA);\n}\n\nfloat kernel(int a,int b){\n    return float(a)*exp(-float(a*a + b*b)/BORDERRADIUS22f)/BORDERRADIUSf;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor.rgb = sampleImage(fragCoord.xy);\n    \n    vec3 col;\n    vec3 colX = vec3(0.);\n    vec3 colY = vec3(0.);\n    float coeffX,coeffY;\n    \n    for( int i = -BORDERRADIUS ; i <= BORDERRADIUS ; i++ ){\n    \tfor( int j = -BORDERRADIUS ; j <= BORDERRADIUS ; j++ ){\n            coeffX = kernel(i,j);\n        \tcoeffY = kernel(j,i);\n            \n            col = sampleImage(fragCoord.xy+vec2(i,j));\n            colX += coeffX*col;\n            colY += coeffY*col;\n        }\n        \n    }\n    \n    vec3 derivative = sqrt( (colX*colX + colY*colY) )/(BORDERRADIUSf*BORDERRADIUSf);\n    float angle = atan(dot(colY,LUMWEIGHT),dot(colX,LUMWEIGHT))/(2.*PI) + iTime*(1. - DX)/2.;\n    vec3 derivativeWithAngle = hsv2rgb_smooth(vec3(angle,1.,pow(dot(derivative,LUMWEIGHT)*3.,3.)*5.));\n    \n    fragColor.rgb = mix(derivative,fragColor.rgb,DX);\n    fragColor.rgb = mix(derivativeWithAngle,fragColor.rgb,DY);\n    fragColor.rgb = pow3(fragColor.rgb,1./GAMMA);\n}",
   "name": "Image",
   "description": "",
   "type": "image"
  }
 ]
}