{
 "ver": "0.1",
 "info": {
  "id": "ftBfRy",
  "date": "0",
  "viewed": 0,
  "name": "Voronoi broke the scene JiPi",
  "description": "The goal of this Shader was to show that we can create a very simple voronoi cutting operator applicable to any scene with a simple function call (opCutVoronoi ). Unfortunately it's a bit slow.",
  "likes": 0,
  "published": "Private",
  "usePreview": 0,
  "tags": [
   "text",
   "effect",
   "font",
   "slice",
   "cut",
   "operator"
  ],
  "hasliked": 0,
  "parentid": "7tBBDw",
  "parentname": "Voronoi broke the scene"
 },
 "renderpass": [
  {
   "inputs": [
    {
     "id": "XsXGRn",
     "filepath": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg",
     "type": "texture",
     "channel": 1,
     "sampler": {
      "filter": "mipmap",
      "wrap": "repeat",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    },
    {
     "id": "4dX3Rn",
     "filepath": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg",
     "type": "texture",
     "channel": 2,
     "sampler": {
      "filter": "mipmap",
      "wrap": "repeat",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    },
    {
     "id": "4dXGzr",
     "filepath": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png",
     "type": "texture",
     "channel": 0,
     "sampler": {
      "filter": "mipmap",
      "wrap": "repeat",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    }
   ],
   "outputs": [
    {
     "id": "4dfGRr",
     "channel": 0
    }
   ],
   "code": "// Created by Sebastien Durand - 2022\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// -----------------------------------------------\n// The goal of this Shader was to show that we can create a very simple voronoi cutting operator\n// applicable to any scene with a simple function call (opCutVoronoi ).\n// -----------------------------------------------\n// Other cutting space : [CrashTest] https://www.shadertoy.com/view/wsSGDD\n// -----------------------------------------------\n\n\n#define WITH_EDGE\n\n\nfloat tOpen;\n\n// SPACE txt\n//int[] gtxt = int[] (83,80,65,67,69);\n// SCENE\nint[] gtxt = int[] (74,73,80,73,32);\n\n// [iq] https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;\nvec3 hash33(vec3 p ) {\n    uvec3 x = uvec3(p.x+10.,p.y+10.,p.z+10.);\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    vec3 o= vec3(x)*(1.0/float(0xffffffffU));\n    return .3*cos(.2*(3.+o)*6.2 + 2.2+ o*6.2831853);\n}\n\nfloat hash13(const in vec3 p ) {\n\tfloat h = dot(p,vec3(127.1,311.7,758.5453123));\t\n    return fract(sin(h)*43758.5453123);\n}\n\n//---------------------------------------------------------------\n// Here is the distance to voronoi3D cell (not exact: over estimate distance on edges)\n//---------------------------------------------------------------\nfloat sdVoronoi( in vec3 x, in vec3 cellId) {\n    float md = 64.0;    \n    vec3 mr = hash33(cellId);\n    for( int k=-1; k<=1; k++ )\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ ) {\n        if (i==0&&j==0&&k==0) continue;  // skip main cell \n        vec3 g = vec3(i,j,k),            // relative cell Id\n             r = g + hash33(cellId + g); // pos of other point\n        md = min(md, dot(.5*(mr+r)-x, normalize(r-mr))); // distance\n    }\n    return -1.2*md;\n}\n\n// --------------------------------------\n// Space Operators\n// --------------------------------------\n\n// [iq] https://www.shadertoy.com/view/4lyfzw\nfloat opExtrussion( in vec3 p, in float sdf, in float h) {\n    vec2 w = vec2(sdf, abs(p.z) - h);\n  \treturn min(max(w.x,w.y),0.) + length(max(w,0.));\n}\n\n// [iapafoto] https://www.shadertoy.com/view/7tBBDw\nfloat opCutVoronoi(inout vec3 p, float k) {\n    k += 1.;\n    float d = 999.; //-dout;\n    float dm;\n    vec3 posTxt = p;\n\n    for( int z=-1; z<=1; z++)\n    for( int j=-1; j<=1; j++)\n    for( int i=-1; i<=1; i++) {\n         vec3 g = vec3(i,j,z)+ /*vec3(1.); // +*/ floor(p/k);\n         if (length(k*g-p)<1.5) { // do it only on neighbourhood\n             float v = sdVoronoi(p-k*g, g);\n             if (d>v) {\n                 posTxt = p-k*g+g;\n             }\n             d  = min(d,v);\n         }\n    }\n    p = posTxt;\n\n    return d;\n}\n\nfloat opSuperCut(inout vec3 p) {\n    if (tOpen > 0.005) { // && p.y < 2. && p.y > -2. && p.z < 2.) {\n        p *= 2.;\n        float d = -.5*opCutVoronoi(p, tOpen);\n        p/=2.;\n        return d;\n    } \n    return 999.;\n}\n\n// --------------------------------------\n// Distance Functions\n// --------------------------------------\n\n// Adapted from [FabriceNeyret2] https://www.shadertoy.com/view/llyXRW\nfloat sdFont(in vec2 p, in int c) {\n    vec2 uv = (p + vec2(float(c%16), float(15-c/16)) + .5)/16.;\n    return max(max(abs(p.x) - .25, max(p.y - .35, -.38 - p.y)), textureLod(iChannel0, uv, 0.).w - 127./255.);\n}\n\nfloat sdMessage2D(in vec2 p, in int[5] txt, in float scale) { \n    p.y += .1;\n    p /= scale;\n \tfloat d = 999., w = .45; // letter width  \n    p.x += w*float(txt.length()-1)*.5; // center text arround 0\n    for (int id = 0; id<5; id++){\n    \td = min(d, sdFont(p, txt[id]));   \n    \tp.x -= w; \n    }\n    return scale*d;\n}\n\nfloat sdMessage3D(in vec3 p, in int[5] txt, in float scale, in float h) { \n    return opExtrussion(p, sdMessage2D(p.xy, txt, scale), h);\n}\n\n// --------------------------------------\n// Distance to scene\n// --------------------------------------\nfloat map(in vec3 p) {\n    float dcut = opSuperCut(p),\n          dScene = sdMessage3D(p, gtxt,2.,.5);\n    return max(dScene, -dcut);\n}\n\n// --------------------------------------\n// Shading Tools\n// --------------------------------------\n// Find initial space position\nvec4 MCol(in vec3 p) {\n    float dcut = opSuperCut(p),\n          dScene = sdMessage3D(p, gtxt,2.,.5);\n    return vec4(p, dScene >= -dcut ? 1. : 2.);\n}\n\n// Shane - normal + edge\nvec3 calcNormal(vec3 p, vec3 rd,  inout float edge, inout float crv, float t) { \n    float eps = 4.5/mix(450., min(850., iResolution.y), .35);\n    float d = map(p);\n#ifdef WITH_EDGE\n    vec3 e = vec3(eps, 0, 0),\n         da = vec3(-2.*d);\n    for(int i = min(iFrame,0); i<3; i++) {\n        for( int j=min(iFrame,0); j<2; j++ )\n            da[i] += map(p + e*float(1-2*j));\n        e = e.zxy;\n    }\n    da = abs(da);\n    edge = da.x + da.y + da.z;\n    edge = smoothstep(0., 1., sqrt(edge/e.x*2.));\n#endif\n    vec3 n = vec3(0.0);\n    for( int i=min(iFrame, 0); i<4; i++) {\n        vec3 e = .57735*(2.*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1)) - 1.);\n        n += e*map(p + .001*e);\n    }\n    return normalize(n - max(.0, dot(n,rd))*rd);\n}\n\n// Box:  https://www.shadertoy.com/view/ld23DV\nbool iBox( in vec3 ro, in vec3 rd, in vec3 sz, inout float tN, inout float tF) {\n    vec3 m = sign(rd)/max(abs(rd), 1e-8),\n         n = m*ro,\n         k = abs(m)*sz,\n         t1 = -n - k,\n         t2 = -n + k;\n\ttN = max( max( t1.x, t1.y ), t1.z );\n\ttF = min( min( t2.x, t2.y ), t2.z );\n    return !(tN > tF || tF <= 0.0);\n}\n\n//----------------------------------\n// Texture 3D (Shane)\n//----------------------------------\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){  \n    n = max(n*n, .001);\n    n /= n.x + n.y + n.z;  \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){   \n    const vec2 e = vec2(.001, 0);\n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    vec3 g = vec3(.299, .587, .114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(.299, .587, .114)) )/e.x; \n    g -= n*dot(n, g);\n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n}\n\n\n//----------------------------------\n// Shading\n//----------------------------------\nvec3 render(in vec3 ro, in vec3 rd, in float res, in vec3 pos, in vec3 n, in vec3 cobj, in vec3 light, vec3 cback, float spec) {\n    float \n         amb = clamp(.5+.5*n.y, .0, 1.),\n         dif = clamp(dot( n, light ), 0., 1.),\n         pp = clamp(dot(reflect(-light,n), -rd),0.,1.),\n         fre = (.7+.3*dif)*pow( clamp(1.+dot(n,rd),0.,1.), 2.);\n    vec3 brdf = .5*(amb)+ 1.*dif*vec3(1.,.9,.7),\n         sp = 3.*pow(pp,spec)*vec3(1., .6, .2),\n\t     col = cobj*(brdf + sp) + fre*(.5*cobj+.5);\n    return mix(col, vec3(.02,.2,.2),smoothstep(3.,10.,res));\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr ) {\n\tvec3 cw = normalize(ta-ro),\n         cp = vec3(sin(cr), cos(cr),.0),\n         cu = normalize( cross(cw,cp) ),\n         cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\n// --------------------------------------\n// Main\n// --------------------------------------\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 r = iResolution.xy, \n         m = iMouse.xy / r,\n\t     q = fragCoord.xy/r.xy;\n \n    tOpen = .5*smoothstep(.6,0.,cos(.3*iTime));\n\n    float a = mix(.3,3.*cos(.4*3.*iTime),.5+.5*cos(.2*iTime))+3.14*m.x;\n    \n    // camera\t\n    vec3 ta = vec3(0),\n         ro = ta + 1.2*vec3(4.5*cos(a), 3.*cos(.4*iTime) + 4.*m.y, 4.5*sin(a));\n    mat3 ca = setCamera( ro, ta, .1*cos(.123*iTime) );\n \n    vec2 p = (2.*fragCoord-r.xy)/r.y;        \n    // ray direction\n    vec3 rd = ca * normalize( vec3(p,2.5) );\n\n    float h = .1, t, tN = 0., tF = 10.;\n    // Background color\n\tvec3 c = vec3(.11);\n\n    if (iBox(ro, rd, vec3(2.3,.7,.6)*(1.+tOpen), tN, tF)) {\t\t\n        t = tN + .05*hash13(q.xyx);;\n\t// Ray marching\n        for(int i=min(0,iFrame);i<100;i++) { \n            if (h<1e-3 || t>tF) break;\n            t += h = map(ro + rd*t);\n        }\n    }\n\t\n    vec3 lp =  ro + 3.*vec3(.25, 2, -.1);\n            \n    // Calculate color on point\n\tif (h < 1e-2) {\n\t\tvec3 pos = ro + t * rd;\n        float edge = 0., crv = 1.;\n        vec4 txt = MCol(pos); \t\n        vec3 n = calcNormal(pos, rd, edge, crv, t),     \n             cobj = txt.w<1.5 ? vec3(.7) : 1.5*vec3(.8,.4,.0);\n        if (txt.w<1.5) {\n            n = doBumpMap(iChannel1, txt.xyz*2., n, .01);\n        } else {\n            n = doBumpMap(iChannel2, txt.xyz*2., n, .02);\n        }\n        // keep in visible side\n        n = normalize(n - max(.0,dot(n,rd))*rd);\n        // Shading\n        c = render(ro, rd, t, pos, n, cobj, normalize(lp-pos), c, txt.w<1.5 ? 99. : 16.);\n#ifdef WITH_EDGE\n        c *= 1. - edge*.8;\n#endif\n\t} else {\n        c *= .5+.5*hash13(q.xyx);   \n    }\n    \n    // post prod\n    c = pow(c, vec3(.75));\n    c = vec3(c* pow(16.*q.x*q.y*(1.-q.x)*(1.-q.y),.7f));\n\tfragColor = vec4(clamp(c, vec3(0), vec3(1)), t);\t\n}",
   "name": "Image",
   "description": "",
   "type": "image"
  }
 ]
}