{"Shader":{"ver":"0.1","info":{"id":"wlj3RR","date":"1558385160","viewed":511,"name":"Ball pit","username":"ShnitzelKiller","description":"Hash-based collision avoidance to enable arbitrary number of particles without performance loss. Use the mouse to add more balls, or erase by holding E. Uncomment #define gooey to change the physics mode.","likes":12,"published":3,"flags":48,"usePreview":0,"tags":["collision","interactive","physics","particle"],"hasliked":0},"renderpass":[{"inputs":[{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":37,"channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord\/diameter;\n    ivec2 id = ivec2(floor(uv));\n    \/\/ivec2 stripes = id % 2;\n    \/\/fragColor = vec4(vec3(0.1*float(abs(stripes.x-stripes.y))), 1.);\n    fragColor = vec4(0.,0.,0.,1.);\n    vec3 bgcol = vec3(0.);\n    float totalW = 0.01;\n    for (int i=-2; i<=2; i++) {\n        for (int j=-2; j<=2; j++) {\n            ivec2 disp = ivec2(i, j);\n            ivec2 otherid = id+disp;\n            if (otherid.x < 0 || otherid.y < 0 || otherid.x >= particleEdge.x || otherid.y >= particleEdge.y) continue;\n            for (int k=0; k<hashEdge; k++) {\n                for (int l=0; l<hashEdge; l++) {\n                    ivec2 offset = ivec2(k, l);\n                    vec4 state = texelFetch(iChannel0, otherid*hashEdge+offset,0);\n                    if (state.xy == vec2(-1.)) continue;\n                    float dist = length(state.xy-fragCoord);\n                    float W = smoothstep(diameter*2.,0.,dist);\n                    totalW += W;\n                    \/\/fragColor.xyz -= vec3(0.5, state.zw+.5)*smoothstep(diameter+1., diameter, dist);\n                    \/\/fragColor.xyz = abs(fragColor.xyz);\n                    fragColor.xyz += W*vec3(0.5, state.zw+.5);\n                }\n            }\n        }\n    }\n    fragColor.xyz \/= totalW;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\/\/to turn on blob physics instead of hard collisions:\n\/\/#define gooey\n\n\/\/number of bins per cell is hashEdge * hashEdge\n\/\/cannot be greater than diameter\n#define hashEdge 2\n\n\/\/real world scale of the cells (and particles)\n#define diameter 2.\n\n\/\/maximum number of times to try binning a particle\n#define numHashes 2\n\n\/\/number of particles is particleEdge.x * particleEdge.y\n#define particleEdge ivec2(floor(iResolution.xy\/diameter))\n\n\/\/starting speed\n#define speed 1.\n\/\/maxspeed must be smaller than diameter\n#define maxspeed 1.9\n#define restitution 0.75\n\n#ifdef gooey\n#define gravity 0.01\n#define drawRadius 42\n#else\n#define gravity 0.0\n#define drawRadius 2\n#endif\n\n\nvec2 noise2D(vec2 uv) {\n    return fract(3e4*sin((uv)*mat2(1,13.51,73.37,-57.17)));\n}\n\nivec2 hash2D(vec2 uv) {\n    return ivec2(floor(clamp(mod(3e4*sin((uv)*mat2(1,13.51,73.37,-57.17)), float(hashEdge)), 0., float(hashEdge))));\n}\n\n\nfloat noise1D(float t) {\n    return fract(14950.5*sin(1905.1*t));\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":33,"src":"\/presets\/tex00.jpg","ctype":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":258,"src":"\/media\/previz\/buffer01.png","ctype":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":257,"channel":0}],"code":"\/\/grid hashing\n\nvoid mainImage( out vec4 state, in vec2 fragCoord )\n{\n    ivec2 maxIndex = particleEdge * hashEdge;\n    ivec2 ind = ivec2(floor(fragCoord.xy));\n    \n    if (ind.x >= maxIndex.x || ind.y >= maxIndex.y) discard;\n    state = texelFetch(iChannel0, ind, 0);\n    ivec2 id = ind\/hashEdge; \/\/cell id\n    if (iMouse.z > 0.) {\n        float mousedist = length(iMouse.xy*float(hashEdge)\/diameter-fragCoord);\n        float keystate = texelFetch(iChannel3, ivec2(69.,0),0).x;\n        if (keystate > 0.5 && mousedist < float(hashEdge*16)) {\n            state = vec4(-1.,-1.,0.,0.);\n        } else if (ind % hashEdge == ivec2(0) && mousedist < float(hashEdge*drawRadius)) {\n        \tstate = vec4(vec2(id)*diameter+diameter*.5, (noise2D(fragCoord)*2.-1.)*speed);\n        }\n    }\n    if (iFrame == 0) {\n        \/\/initialization\n        if (ind % (hashEdge) == ivec2(0)) {\n            state = vec4(vec2(id)*diameter+diameter*.5, (noise2D(fragCoord)*2.-1.)*speed);\n        } else {\n\t\t\tstate = vec4(-1., -1., 0., 0.);\n        }\n    } else {\n        \/\/update\n        \n        \/\/particle leaving the cell\n        if (ivec2(floor(state.xy\/diameter)) != id) state = vec4(-1., -1., 0., 0.);\n        \n        \/\/particle entering the cell\n        for (int i=-1; i<=1; i++) {\n            for (int j=-1; j<=1; j++) {\n                ivec2 disp = ivec2(i, j);\n                if (disp == ivec2(0)) continue;\n                ivec2 otherid = id + disp;\n                if (otherid.x < 0 || otherid.y < 0 || otherid.x >= particleEdge.x || otherid.y >= particleEdge.y) continue;\n                \/\/check every bin inside the other cell for particles entering this cell\n                for (int k=0; k<hashEdge; k++) {\n                    for (int l=0; l<hashEdge; l++) {\n                        ivec2 offset = ivec2(k, l);\n                        vec4 otherstate = texelFetch(iChannel0, otherid*hashEdge + offset, 0);\n                        ivec2 id2 = ivec2(floor(otherstate.xy\/diameter));\n                        if (id2 == id) {\n                            for (int h=0; h<numHashes; h++) {\n                                \/\/receive the particle if this is the right bin\n                                ivec2 hashOffset = hash2D(otherstate.xy+float(h)*12345.);\n                                ivec2 hashInd = id*hashEdge+hashOffset;\n                                vec2 state0 = texelFetch(iChannel0, hashInd, 0).xy;\n                                if (state0 == vec2(-1.)) {\n                                    if (hashInd == ind) {\n                                        state = otherstate;\n                                        return;\n                                    }\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":258,"channel":0}],"code":"\/\/state update\n\n\/\/x,y = position\n\/\/z,w = velocity\n\/\/x,y are negative if unoccupied\n#define hardstep(h) (step(0., h)*2.-1.)\n\nvoid mainImage( out vec4 state, in vec2 fragCoord )\n{\n    ivec2 maxIndex = particleEdge * hashEdge;\n    ivec2 ind = ivec2(floor(fragCoord.xy));\n    ivec2 id = ind\/hashEdge; \/\/cell id\n\n    if (ind.x >= maxIndex.x || ind.y >= maxIndex.y) discard;\n    \n    state = texelFetch(iChannel0, ind, 0);\n    \n    if (state.xy != vec2(-1.)) {\n\n        \/\/collision detection\n        vec2 impulse = vec2(0.);\n        \/\/vec2 push = vec2(0.);\n        \/\/int collisions = 0;\n        for (int i=-2; i<=2; i++) {\n            for (int j=-2; j<=2; j++) {\n                ivec2 disp = ivec2(i, j);\n                if (disp == ivec2(0)) continue;\n                ivec2 otherid = id + disp;\n                if (otherid.x < 0 || otherid.y < 0 || otherid.x >= particleEdge.x || otherid.y >= particleEdge.y) continue;\n                \/\/check every bin inside the other cell for particles entering this cell\n                for (int k=0; k<hashEdge; k++) {\n                    for (int l=0; l<hashEdge; l++) {\n                        ivec2 offset = ivec2(k, l);\n                        vec4 otherstate = texelFetch(iChannel0, otherid*hashEdge + offset, 0);\n                        if (otherstate.xy == vec2(-1.)) continue;\n                        vec2 r = state.xy-otherstate.xy;\n                        \/\/center of mass frame\n                        vec2 v_cm = (state.zw+otherstate.zw)\/2.;\n                        vec2 v0 = state.zw-v_cm;\n                        #ifdef gooey\n                        float rn = length(r);\n                        float vproj = dot(v0, r)\/rn;\n                        float r2 = 2.*diameter-rn;\n                        float force = mix(0.3*r2-0.1*vproj, -2.\/(rn*rn), step(0.,-r2));\n                        impulse += r\/rn*force;\n                        #else\n                        float vproj = dot(v0, r)\/dot(r, r);\n                        if (length(r) < diameter*2.) {\n                            \/\/collisions++;\n                            \/\/move the particles apart\n                            \/\/push += r\/20.;\n                            \n                            \/\/compute collision impulse\n                            impulse -= (1.+restitution)*min(0.,vproj)*r;\n                        }\n                        #endif\n                    }\n                }\n            }\n        }\n        state.zw += impulse;\n        \/\/state.xy += push;\n        \/\/if (collisions < 1)\n            state.w -= gravity;\n\n        state.xy += state.zw;\n        \/\/bounce off walls\n        vec2 bounds = diameter*vec2(particleEdge)-1.;\n        if (state.xy != vec2(-1.)) {\n            vec2 sgn = hardstep(state.xy)*hardstep(bounds-state.xy);\n            state.zw *= sgn;\n            state.zw *= mix(restitution, 1., step(0., sgn.x*sgn.y));\n            state.xy = min(state.xy, bounds);\n            state.xy = max(state.xy, 0.);\n        }\n        float currspeed = length(state.zw);\n        state.zw = state.zw\/currspeed*min(currspeed,maxspeed);\n    }\n}","name":"Buffer B","description":"","type":"buffer"}]}}