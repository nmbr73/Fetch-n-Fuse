{
 "ver": "0.1",
 "info": {
  "id": "ssXfW7",
  "date": "0",
  "viewed": 0,
  "name": "Colorful Music JiPi 214",
  "description": "A 2D music visualizer with an audio reactive starfield.\nYou can change the music, along with some other settings, if you'd like.\nThis visualizer is inspired by the one used by Trap Nation.",
  "likes": 0,
  "published": "Private",
  "usePreview": 0,
  "tags": [
   "reactive",
   "music",
   "particles",
   "visualizer",
   "soundcloud"
  ],
  "hasliked": 0,
  "parentid": "llycWD",
  "parentname": "Colorful Music Visualizer"
 },
 "renderpass": [
  {
   "inputs": [
    {
     "id": "4sXGR8",
     "filepath": "/media/previz/buffer02.png",
     "type": "buffer",
     "channel": 0,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    }
   ],
   "outputs": [
    {
     "id": "4dfGRr",
     "channel": 0
    }
   ],
   "code": "/*\n  Free Public License 1.0.0\n\n  Copyright (C) 2018 by tikveel <steven@tikveel.nl>\n\n  Permission to use, copy, modify, and/or distribute this software for any purpose with or without fee is hereby granted.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING\n  ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL,\n  DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,\n  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE\n  USE OR PERFORMANCE OF THIS SOFTWARE.\n*/\n\n// An audio visualizer inspired by the one used by Trap Nation (https://www.youtube.com/user/AllTrapNation)\n// If you have a fast GPU, I recommend changing the amount of particles in the common pass\n// This song is Bossfight - Elevatia (https://soundcloud.com/bossfightswe/elevatia)\n// Other songs you should try (change in buffer A):\n//  Yeah Yeah Yeahs - Heads Will Roll (Jaydon Lewis Remix) (https://soundcloud.com/itsjaydonlewis/headswillroll)\n//  Pendulum - Tarantula (https://soundcloud.com/elijahpaul/tarantula-pendulum)\n//  Dr. Dre - The Next Episode (San Holo Remix) (https://soundcloud.com/electricspark/dr-dre-the-next-episode-san-holo-remix)\n//  Imagine Dragons - Believer (Kid Comet Nebula Remix) (https://soundcloud.com/kidcometmusic/imagine-dragons-believer-kid-comet-nebula-remix)\n//  Axel Thesleff - Bad Karma (https://soundcloud.com/axelthesleff/bad-karma)\n//  Flowrian - Banani Code (https://soundcloud.com/quantumsaturnus/flowrian-banani-code)\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}",
   "name": "Image",
   "description": "",
   "type": "image"
  },
  {
   "inputs": [],
   "outputs": [],
   "code": "/*\n  Free Public License 1.0.0\n\n  Copyright (C) 2018 by tikveel <steven@tikveel.nl>\n\n  Permission to use, copy, modify, and/or distribute this software for any purpose with or without fee is hereby granted.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING\n  ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL,\n  DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,\n  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE\n  USE OR PERFORMANCE OF THIS SOFTWARE.\n*/\n\n// Don't show the full spectrum, since we only care about the bass\n#define SPECTRUM_SCALE 0.08\n\n// The part that is used to detect loud bass, making the circle bigger\n#define BASS_MAX 0.008\n#define BASS_STEPS 8.0\n\n// How loud a frequency has to be in order to be shown\n#define MIN_VOLUME 0.8\n\n// How loud the bass has to be in order to be shown\n#define MIN_VOLUME_BASS 0.75\n\n// How much to smooth out the spectrum\n#define SMOOTH_RANGE 0.02\n#define SMOOTH_STEPS 10.0\n\n// The amount of particles\n// There are actually 4 times as many, since it is mirrored twice\n// This value has a huge impact on performance, so I recommend keeping it low\n#define PARTICLES 50\n\n// How far away to spawn particles\n#define PARTICLE_SPAWN_Z 4.0\n\n// Radius of the circle\n#define CIRCLE_RADIUS 0.12\n\n// How much impact the bass has on the particles\n#define BASS_IMPACT_ON_PARTICLES 1.0\n\n// The size of the white line of the circle\n#define CIRCLE_BORDER_SIZE 0.008\n\n// Colors\n#define SPECTRUM_COLOR_1 vec4(1.0, 1.0, 1.0, 1.0)\n#define SPECTRUM_COLOR_2 vec4(1.0, 1.0, 0.0, 0.95)\n#define SPECTRUM_COLOR_3 vec4(1.0, 0.5, 0.0, 0.9)\n#define SPECTRUM_COLOR_4 vec4(1.0, 0.0, 0.0, 0.85)\n#define SPECTRUM_COLOR_5 vec4(1.0, 0.2, 0.3, 0.8)\n#define SPECTRUM_COLOR_6 vec4(1.0, 0.0, 1.0, 0.75)\n#define SPECTRUM_COLOR_7 vec4(0.0, 0.0, 1.0, 0.7)\n#define SPECTRUM_COLOR_8 vec4(0.0, 0.8, 1.0, 0.65)\n#define SPECTRUM_COLOR_9 vec4(0.0, 1.0, 0.0, 0.6)\n\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\n// Famous HSV to RGB conversion function\n// (I don't know who made this)\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// Famous noise function, but without the '*2.0-1.0' part\n// (I don't know who made the original)\nfloat noise3D01(vec3 p) {\n    return fract(sin(dot(p ,vec3(12.9898,78.233,128.852))) * 43758.5453);\n}\n\n// Convert uv coordinates to polar coordinates\nvec2 uv_to_polar(vec2 uv, vec2 p) {\n    vec2 translated_uv = uv - p;\n    \n    // Get polar coordinates\n    vec2 polar = vec2(atan(translated_uv.x, translated_uv.y), length(translated_uv));\n    \n    // Scale to a range of 0 to 1\n    polar.s /= TWO_PI;\n    polar.s += 0.5;\n    \n    return polar;\n}\n\n// Circle, using polar coordinates\n#define circle_polar(len, r) smooth_circle_polar(len, r, 0.004)\nfloat smooth_circle_polar(float len, float r, float smoothness) {\n    float dist = len - r;\n    float s = smoothness / 2.0;\n    return 1.0 - smoothstep(r - s, r + s, dist);\n}\n\n// Circle, using cartesian coordinates\n#define circle(uv, p, radius) smooth_circle(uv-p, radius, 0.003)\nfloat smooth_circle(vec2 p, float r, float smoothness) {\n    float dist = length(p) - r;\n    float s = smoothness / 2.0;\n    return 1.0 - smoothstep(r - s, r + s, dist);\n}\n\n// Scale to values higher than another value\nfloat cut_lower(float v, float low) {\n    return clamp((v - low) * 1.0 / (1.0 - low), 0.0, 1.0);\n}",
   "name": "Common",
   "description": "",
   "type": "common"
  },
  {
   "inputs": [
    {
     "id": "4dXGR8",
     "filepath": "/media/previz/buffer00.png",
     "type": "buffer",
     "channel": 1,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    },
    {
     "id": "ldSSWd",
     "filepath": "https://soundcloud.com/bossfightswe/elevatia",
     "type": "musicstream",
     "channel": 0,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 0
    }
   ],
   "outputs": [
    {
     "id": "4dXGR8",
     "channel": 0
    }
   ],
   "code": "/*\n  Free Public License 1.0.0\n\n  Copyright (C) 2018 by tikveel <steven@tikveel.nl>\n\n  Permission to use, copy, modify, and/or distribute this software for any purpose with or without fee is hereby granted.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING\n  ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL,\n  DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,\n  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE\n  USE OR PERFORMANCE OF THIS SOFTWARE.\n*/\n\n// This buffer contains audio data\n// First col of first row: bass value\n// Second col of first row: value used for camera shake and background color cycle\n// Second row: scaled and smoothed out spectrum\n// All other rows: spectrums of previous frames\n\n#define get_fft(x) texture(iChannel0, vec2(x, 0.0)).r\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 fc = ivec2(floor(fragCoord));\n    \n    // Bass\n    if (fc == ivec2(0, 0)) {\n        float step_size = BASS_MAX / BASS_STEPS;\n        \n        float med = 0.0;\n        \n        for (float x = 0.0; x < BASS_MAX; x += step_size) {\n            med += get_fft(x);\n        }\n        \n        // Get medium value\n        med /= BASS_STEPS;\n        \n        // Cut off low values \n        med = cut_lower(med, MIN_VOLUME_BASS);\n        \n        fragColor = vec4(med, 0.0, 0.0, 1.0);\n        return;\n    }\n    \n    // Value used for circle shake and background color cycle\n    if (fc == ivec2(1, 0)) {\n        float bass = texelFetch(iChannel1, ivec2(0, 0), 0).r;\n        float old_value = texelFetch(iChannel1, fc, 0).r;\n        \n        // This value will get very high but buffers are Float32, so it doesn't really matter.\n        fragColor = vec4(old_value + bass, 0.0, 0.0, 1.0);\n        return;\n    }\n    \n    // Scaled and smoothed out spectrum\n    if (fc.y == 1) {\n        vec2 uv = fragCoord / iResolution.xy;\n        \n        float step_size = SMOOTH_RANGE / SMOOTH_STEPS;\n        \n        float med = 0.0;\n        \n        for (float x = 0.0; x < SMOOTH_RANGE; x += step_size) {\n            // Mirror if out of bounds\n            float left = (uv.x - x > 0.0) ? uv.x - x : 0.0 - (uv.x - x);\n            float right = (uv.x + x < 1.0) ? uv.x + x : 2.0 - (uv.x + x);\n            \n            med += cut_lower(get_fft(left * SPECTRUM_SCALE), MIN_VOLUME);\n            med += cut_lower(get_fft(right * SPECTRUM_SCALE), MIN_VOLUME);\n        }\n        \n        // Get medium value\n        med /= SMOOTH_STEPS;\n        med /= 2.0;\n        \n        fragColor = vec4(med, 0.0, 0.0, 1.0);\n        return;\n    }\n    \n    // Slide previous values one row down\n    fragColor = texelFetch(iChannel1, fc + ivec2(0, -1), 0);\n}",
   "name": "Buffer A",
   "description": "",
   "type": "buffer"
  },
  {
   "inputs": [
    {
     "id": "4dXGR8",
     "filepath": "/media/previz/buffer00.png",
     "type": "buffer",
     "channel": 1,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    },
    {
     "id": "XsXGR8",
     "filepath": "/media/previz/buffer01.png",
     "type": "buffer",
     "channel": 0,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    }
   ],
   "outputs": [
    {
     "id": "XsXGR8",
     "channel": 0
    }
   ],
   "code": "/*\n  Free Public License 1.0.0\n\n  Copyright (C) 2018 by tikveel <steven@tikveel.nl>\n\n  Permission to use, copy, modify, and/or distribute this software for any purpose with or without fee is hereby granted.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING\n  ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL,\n  DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,\n  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE\n  USE OR PERFORMANCE OF THIS SOFTWARE.\n*/\n\n// A simple starfield\n\n// This buffer contains particle data, spread over multiple rows\n// Color layout:\n//  x = x coordinate\n//  y = y coordinate\n//  z = z coordinate\n//  w = speed\n\n#if PARTICLES == 0\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0);\n}\n\n#else\n\n// Move a particle\n// uv is also passed, used as a parameter for noise3D\nvec4 get_next_particle(vec4 old, vec2 uv) {\n    float x = old.x;\n    float y = old.y;\n    float z = old.z;\n    float speed = old.w;\n    \n    // Get bass value\n    float bass = texelFetch(iChannel1, ivec2(0, 0), 0).r;\n    \n    z -= 0.02 * (speed + bass*BASS_IMPACT_ON_PARTICLES);\n    \n    // Out of screen, load new particle\n    if (z <= 0.0) {\n        // Generate random particle\n        x = noise3D01(vec3(uv.x, uv.y, iTime)) * 2.0 + 0.1;\n        y = noise3D01(vec3(uv.x, uv.y, iTime + 1.0)) * 1.5 + 0.1;\n        z = PARTICLE_SPAWN_Z;\n        speed = noise3D01(vec3(uv.x, uv.y, iTime + 2.0)) + 0.2;\n    }\n    \n    return vec4(x, y, z, speed);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 fc = ivec2(floor(fragCoord));\n    ivec2 rs = ivec2(iResolution.xy);\n    \n    // Particles can be stored in multiple rows\n    int num = int(rs.x * fc.y + fc.x);\n    if (num > PARTICLES) {\n        return;\n    }\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec4 old = texelFetch(iChannel0, fc, 0);\n    \n    // Output new particle\n    fragColor = get_next_particle(old, uv);\n}\n\n#endif",
   "name": "Buffer B",
   "description": "",
   "type": "buffer"
  },
  {
   "inputs": [
    {
     "id": "4dXGR8",
     "filepath": "/media/previz/buffer00.png",
     "type": "buffer",
     "channel": 0,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    },
    {
     "id": "XsXGR8",
     "filepath": "/media/previz/buffer01.png",
     "type": "buffer",
     "channel": 1,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    },
    {
     "id": "4sXGR8",
     "filepath": "/media/previz/buffer02.png",
     "type": "buffer",
     "channel": 2,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    }
   ],
   "outputs": [
    {
     "id": "4sXGR8",
     "channel": 0
    }
   ],
   "code": "/*\n  Free Public License 1.0.0\n\n  Copyright (C) 2018 by tikveel <steven@tikveel.nl>\n\n  Permission to use, copy, modify, and/or distribute this software for any purpose with or without fee is hereby granted.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING\n  ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL,\n  DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,\n  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE\n  USE OR PERFORMANCE OF THIS SOFTWARE.\n*/\n\n// To debug a buffer, set the value to 1\n#define DEBUG_BUFFER_A 0\n#define DEBUG_BUFFER_B 0\n\n// Draw the background\nvec3 background(vec2 uv, float extra) {\n    const float saturation = 0.6, value = 0.7;\n    \n    // Cycle faster when there is a lot of bass\n    float scaled = extra * 0.02;\n    \n    // Gradient of cycling hsv colors\n    vec3 color = mix(hsv2rgb(vec3((iTime*0.25 + scaled) * 0.02, saturation, value)), hsv2rgb(vec3((iTime*0.15 - scaled) * 0.1, saturation, value)), uv.y + 0.1);\n    \n    return color;\n}\n\n// Rotate a coordinate\nvec2 rotate(vec2 uv, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    vec2 new = uv * mat2(c, s, -s, c);\n    return new;\n}\n\n// Draw the inner circle\nvec3 inner_circle(vec2 uvmtp) {\n    // Rotate\n    vec2 rotated = rotate(uvmtp, PI * 2.0 * (1.0 - smoothstep(0.0, 1.0, cut_lower(fract(iTime * 0.06), 0.8))));\n    \n    // Gradient\n    vec3 color = mix(vec3(0.0), vec3(0.15), rotated.y * 0.5 + 0.5) + 0.1;\n    \n    // Lines\n    color = mix(color, vec3(0.0), (sin(length(rotated) * 80.0))*0.05);\n    \n    // From: https://thndl.com/square-shaped-shaders.html\n    // Draw the triangle\n    float a = atan(rotated.x, rotated.y) + PI * 0.5;\n    float b = TWO_PI / 3.0;\n    color = mix(color, vec3(rotated.y * 0.5 + 0.8)*0.5 + ((sin(iTime * 2.0) + 1.0) * 0.5)*0.2, 1.0 - smoothstep(0.5, 0.52, cos(floor(0.5 + a/b) * b - a) * length(rotated)));\n    \n    return color;\n}\n\n// Get a particle\nvec4 get_particle(int i) {\n    int x = i;\n    int y = 0;\n    \n    ivec2 rs = ivec2(iResolution.xy);\n    \n    // Get coordinate by particle id\n    while (x > rs.x) {\n        x -= rs.x;\n        y++;\n        if (y > rs.y) {\n            break;\n        }\n    }\n    \n    return texelFetch(iChannel1, ivec2(x, y), 0);\n}\n\n// Draw particles\nvoid particles(vec2 uvmtp, inout vec3 color) {\n    for (int i = 0; i < PARTICLES; i++) {\n        // Get particle\n        vec4 particle = get_particle(i);\n        \n        vec2 projected;\n        float size;\n        \n        for (int i = 0; i < 4; i++) {\n            switch (i) {\n            // Normal x, normal y\n            case 0: projected = vec2(particle.x, particle.y) / particle.z; break;\n            // Mirrored x, normal y\n            case 1: projected = vec2(0.0 - particle.x, particle.y) / particle.z; break;\n            // Normal x, mirrored y\n            case 2: projected = vec2(particle.x, 0.0 - particle.y) / particle.z; break;\n            // Mirrored x, mirrored y\n            case 3: projected = vec2(0.0 - particle.x, 0.0 - particle.y) / particle.z; break;\n            }\n            \n            size = (PARTICLE_SPAWN_Z - particle.z) / PARTICLE_SPAWN_Z;\n            color = mix(color, color + vec3(size * 0.6), smooth_circle(uvmtp - projected, size * 0.007, 0.005 + 0.008 * (particle.z / PARTICLE_SPAWN_Z)));\n        }\n    }\n}\n\n// Calculate radius\nfloat get_draw_radius(float x, float r, int fft_y) {\n    // Get FFT value\n    float fft = texelFetch(iChannel0, ivec2(x * iResolution.x, fft_y), 0).r;\n    \n    // Calculate radius\n    float radius = CIRCLE_RADIUS + r + fft * 0.07;\n    \n    // Clamp to the circle radius\n    radius = clamp(radius, CIRCLE_RADIUS + r, 1.0);\n    \n    return radius;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 fc = ivec2(floor(fragCoord));\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 uvmtp = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // Debug buffer A\n#if DEBUG_BUFFER_A\n    if (uv.y < 0.8) {\n        // Everything on the left side of the white line is considered bass\n        if (uv.x > BASS_MAX/SPECTRUM_SCALE - 0.002 && uv.x < BASS_MAX/SPECTRUM_SCALE + 0.002) {\n            fragColor = vec4(1.0);\n            return;\n        }\n        \n        float fft = texelFetch(iChannel0, ivec2(uv.x * iResolution.x, uv.y * iResolution.y), 0).r;\n        \n        fragColor = vec4(fft, 0.0, 0.0, 1.0);\n        return;\n    }\n    \n    // Bass value\n    fragColor = texelFetch(iChannel0, ivec2(0, 0), 0);\n    return;\n#endif\n    \n    // Debug buffer B\n#if DEBUG_BUFFER_B\n    // It might be hard to see, but if you look in the bottom left corner, you'll see some colors\n    fragColor = texelFetch(iChannel1, fc, 0);\n    return;\n#endif\n    \n    // Get bass value\n    float bass = texelFetch(iChannel0, ivec2(0, 0), 0).r;\n    \n    // Shake the bubble\n    vec2 shake = vec2(sin(iTime*9.0), cos(iTime*5.0)) * 0.002;\n    uvmtp += shake;\n    uv    += shake;\n    \n    // Get this value\n    float extra = texelFetch(iChannel0, ivec2(1, 0), 0).r;\n    \n    // Draw the background\n    vec3 color = background(uv, extra);\n    \n    // Draw particles\n#if PARTICLES != 0\n    particles(uvmtp, color);\n#endif\n    \n    // Rotate the circle a bit\n    uvmtp = rotate(uvmtp, sin(iTime * 1.5 + extra) * 0.005);\n    \n    // Shake the circle a bit\n    vec2 circle_shake = vec2(cos(iTime*9.0 + extra*0.3), sin(iTime*9.0 + extra*0.3))*0.003;\n    uvmtp += circle_shake;\n    \n    // Get polar coordinates for circle, shaking it a bit as well\n    vec2 polar = uv_to_polar(uvmtp, vec2(0.0, 0.0));\n    \n    // Mirror\n    float fft_x = polar.s;\n    fft_x *= 2.0;\n    if (fft_x > 1.0) {\n        fft_x = 2.0 - fft_x;\n    }\n    \n    // Invert (low frequencies on top)\n    fft_x = 1.0 - fft_x;\n    \n    // How much the circle should grow\n    float r = bass*0.03;\n    \n    // Draw spectrum\n    float radius;\n    color = mix(color, SPECTRUM_COLOR_9.rgb, smooth_circle_polar(polar.t, get_draw_radius(fft_x, r, 9), 0.006) * SPECTRUM_COLOR_8.a);\n    color = mix(color, SPECTRUM_COLOR_8.rgb, smooth_circle_polar(polar.t, get_draw_radius(fft_x, r, 8), 0.00575) * SPECTRUM_COLOR_7.a);\n    color = mix(color, SPECTRUM_COLOR_7.rgb, smooth_circle_polar(polar.t, get_draw_radius(fft_x, r, 7), 0.0055) * SPECTRUM_COLOR_6.a);\n    color = mix(color, SPECTRUM_COLOR_6.rgb, smooth_circle_polar(polar.t, get_draw_radius(fft_x, r, 6), 0.00525) * SPECTRUM_COLOR_5.a);\n    color = mix(color, SPECTRUM_COLOR_5.rgb, smooth_circle_polar(polar.t, get_draw_radius(fft_x, r, 5), 0.005) * SPECTRUM_COLOR_4.a);\n    color = mix(color, SPECTRUM_COLOR_4.rgb, smooth_circle_polar(polar.t, get_draw_radius(fft_x, r, 4), 0.00475) * SPECTRUM_COLOR_3.a);\n    color = mix(color, SPECTRUM_COLOR_3.rgb, smooth_circle_polar(polar.t, get_draw_radius(fft_x, r, 3), 0.0045) * SPECTRUM_COLOR_2.a);\n    color = mix(color, SPECTRUM_COLOR_2.rgb, smooth_circle_polar(polar.t, get_draw_radius(fft_x, r, 2), 0.00425) * SPECTRUM_COLOR_2.a);\n    color = mix(color, SPECTRUM_COLOR_1.rgb, smooth_circle_polar(polar.t, get_draw_radius(fft_x, r, 1), 0.004) * SPECTRUM_COLOR_1.a);\n    \n    // Draw inner circle\n    color = mix(color, inner_circle(uvmtp / (CIRCLE_RADIUS + r - CIRCLE_BORDER_SIZE)), circle_polar(polar.t, CIRCLE_RADIUS + r - CIRCLE_BORDER_SIZE));\n    \n    // Lighten the screen when there is a lot of bass\n    color += bass * 0.05;\n    \n    // Vignette\n    color *= smoothstep(0.0, 1.0, 1.7 - length(uvmtp));\n    \n    // Output the final color, mixed with the previous color to create some sort of motion blur\n    // (to make the movement look a little better)\n    vec3 previous_color = texture(iChannel2, uv).rgb;\n    fragColor = vec4(mix(previous_color, color, 0.8), 1.0);\n}",
   "name": "Buffer C",
   "description": "",
   "type": "buffer"
  }
 ]
}