{"Shader":{"ver":"0.1","info":{"id":"fljBWK","date":"1652760369","viewed":97,"name":"Taste of Noise 17","username":"leon","description":"Another colorful noise hell","likes":7,"published":3,"flags":32,"usePreview":0,"tags":["abstract"],"hasliked":0},"renderpass":[{"inputs":[{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":37,"channel":0}],"code":"\n\/\/ Taste of Noise 17 by Leon Denise 2022-05-17\n\n\/\/ A very distorted volume\n\/\/ Playing with a 3D FBM noise\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ Render result of Buffer A\n    vec2 uv = fragCoord.xy \/ iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":40,"src":"\/media\/a\/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","ctype":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":14854,"src":"\/media\/a\/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":257,"channel":0}],"code":"\n\/\/ Taste of Noise 17 by Leon Denise 2022-05-17\n\n\/\/ A very distorted volume\n\/\/ Playing with a 3D FBM noise\n\nfloat details;\n\n\/\/ rotation matrix\nmat2 rot (float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }\n\n\/\/ shortcut for lighting\n#define dt(rn,v,p) pow(dot(rn,normalize(v))*.5+.5,p)\n\n\/\/ https:\/\/iquilezles.org\/articles\/distfunctions\/\nfloat smin(float d1, float d2, float k) { float h = clamp( 0.5 + 0.5*(d2-d1)\/k, 0.0, 1.0 ); return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n\/\/ transform linear value into cyclic absolute value\nvec3 bend(vec3 v)\n{\n    return abs(sin(v*6.28*2.-iTime*.5));\n}\n\n\/\/ fractal brownian motion (layers of multi scale noise)\nvec3 fbm(vec3 p)\n{\n    vec3 result = vec3(0);\n    float falloff = 0.5;\n    for (float index = 0.; index < 3.; ++index)\n    {\n        result += bend(texture(iChannel0, p\/falloff).xyz) * falloff;\n        falloff \/= 2.;\n    }\n    return result;\n}\n\n\/\/ signed distance function\nfloat map(vec3 p)\n{\n    float d = 0.;\n    \n    \/\/ FBM animated noise\n    vec3 ps = p * .05;\n    ps.z += iTime*.001;\n    vec3 spicy = fbm(ps);\n    details = spicy.x;\n    spicy = spicy * 2. - 1.;\n    \n    \/\/ displace volume\n    d += spicy.x * .2;\n    \n    \/\/ volume to surface\n    d = abs(d)-.1;\n\n    \/\/ substract volume from origin\n    float carve = -1.25+.25*sin(iTime*.1+length(p));\n    d = smin(d, -(length(p)-0.), carve);\n    \n    return d * .25;\n}\n\n\/\/ Antoine Zanuttini\n\/\/ https:\/\/www.shadertoy.com\/view\/3sBGzV\nvec3 getNormal (vec3 pos)\n{\n    vec2 noff = vec2(0.005,0);\n    return normalize(map(pos)-vec3(map(pos-noff.xyy), map(pos-noff.yxy), map(pos-noff.yyx)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ coordinates\n    vec2 uv = (fragCoord.xy - iResolution.xy \/ 2.)\/iResolution.y;\n    vec3 noise = texture(iChannel1, fragCoord.xy\/1024.+iTime).rgb;\n    vec3 ray = normalize(vec3(uv, .5));\n    vec3 pos = vec3(0,0,0);\n    \n    \/\/ init variables\n    vec3 color, normal, tint, dir, refl;\n    float index, shade, light;\n    const float count = 50.;\n\n    \/\/ ray marching\n    for (index = count; index > 0.; --index)\n    {\n        float dist = map(pos);\n        if (dist < .001) break;\n        dist *= .9+.1*noise.z;\n        pos += ray*dist;\n    }\n    \n    \/\/ lighting\n    shade = index\/count;\n    normal = getNormal(pos);\n    tint = .5+.5*cos(vec3(1,2,3)+details*20.);\n    refl = reflect(ray, normal);\n    color += tint;\n    color += vec3(1.000,0.502,0.792)*dt(refl, vec3(0,0,-1), .5);\n    color = clamp(color * shade, 0., 1.);\n    \n    \/\/ temporal buffer\n    uv = fragCoord.xy \/ iResolution.xy;\n    vec3 frame = texture(iChannel2, uv).rgb;\n    color = mix(color, frame, .9);\n    \n    fragColor = vec4(color, 1.);\n}","name":"Buffer A","description":"","type":"buffer"}]}}