{
 "ver": "0.1",
 "info": {
  "id": "7llyRB",
  "date": "0",
  "viewed": 0,
  "name": "Puffy JiPi 467",
  "description": "Hi shadertoyers! I haven't done much DF modelling in the past, so I thought it was a good idea to try something. I wanted to make it look cartoonish, but it ended near the uncanny valley between a cartoon and something a bit more real xD",
  "likes": 0,
  "published": "Private",
  "usePreview": 0,
  "tags": [
   "puffy"
  ],
  "hasliked": 0,
  "parentid": "ltdyDl",
  "parentname": "Puffy"
 },
 "renderpass": [
  {
   "inputs": [],
   "outputs": [
    {
     "id": "4dfGRr",
     "channel": 0
    }
   ],
   "code": "\n// GLOBALS\n\n// position & direction\nvec3 pos_finn, pos_eyes;\nvec3 dir_eye;\nmat3 dir_mouth;\nvec3 dir_light;\n\n// coloring and animation\nfloat heye, weye, beye;\nfloat hmouth, cmouth;\nfloat hfinns, htail;\nfloat puff;\nfloat time;\nfloat tim_tail;\nfloat ani_tail, ani_mouth;\n\n// colors\nvec3 col_water = vec3(.3, .7, 1.);\nvec3 col_fish_1 = vec3(1., 0.4, 0.2);\nvec3 col_fish_2 = vec3(1., 0.8, 0.5);\nvec3 col_eyes = vec3(0.7, 0.75, 1.);\nfloat t = 20.;\n\n// marching\nfloat maxdist = 5.;\nfloat det = .001;\n\n\n\n// USEFUL LITTLE FUNCTIONS\n\n// 2D rotation\nmat2 rot2D(float a) {\n  a = radians(a);\n  float s = sin(a);\n  float c = cos(a);\n  return mat2(c, s, -s, c);\n}\n\n// Align vector\nmat3 lookat(vec3 fw, vec3 up) {\n  fw = normalize(fw);\n  vec3 rt = normalize(cross(fw, normalize(up)));\n  return mat3(rt, cross(rt, fw), fw);\n}\n\n\n// Tile fold \nfloat fmod(float p, float c) { return abs(c - mod(p, c * 2.)) / c; }\n\n// Smooth min\nfloat smin(float a, float b, float k) {\n  float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n  return mix(b, a, h) - k * h * (1.0 - h);\n}\n\n// Smooth max\nfloat smax(float a, float b, float k) {\n  float h = clamp(0.5 + 0.5 * (a - b) / k, 0.0, 1.0);\n  return mix(b, a, h) - k * h * (1.0 - h);\n}\n\n// Torus\nfloat sdTorus(vec3 p, vec2 t, vec3 s) {\n  p = p.yxz * s;\n  vec2 q = vec2(length(p.xz) - t.x, p.y);\n  return length(q) - t.y;\n}\n\n\n// PUFFY'S SURFACE DISPLACEMENT FUNCTIONS\n\nfloat thorns(vec3 p) {\n  p.xz*=rot2D(-25.);\n  float s1 = smoothstep(.0, .7, -p.x + p.z + .6);\n  float s2 = smoothstep(.15, .3, length(p.xy)) * smoothstep(.0, .3, length(p.yz));\n  float s3 = smoothstep(.0, .25, abs(p.y));\n  p.x = fmod(atan(p.x, p.y), .31459 / 2.);\n  p.y = fmod(atan(p.y, p.z), .31459 / 2.);\n  p.xz*=rot2D(25.);\n  return min(1., exp((-3. - puff*3.) * length(p.xy))) * s1 * s2 * s3;\n}\n\nfloat spiral(vec3 p, vec3 c) {\n  p.y = abs(p.y);\n  vec3 pos = p;\n  p = lookat(c, vec3(0., 1., 0.)) * p;\n  float a = length(p.xy) * 35.;\n  p.yx *= mat2(sin(a), cos(a), -cos(a), sin(a));\n  float s=pow(abs(p.x), 2.) * smoothstep(0.7, 1., max(0., 1. - length(p.xy)));\n  return s*smoothstep(0.,.05,pos.z+.1);\n}\n\nfloat skin(vec3 pos) {\n  pos *= 2.;\n  vec3 p = pos;\n  float m = 1000.;\n  for (int i = 0; i < 7; i++) {\n    p = abs(p) / dot(p, p) - .5;\n    m = min(m, length(p));\n  }\n  return max(0., 1. - m) * (.1 + smoothstep(-pos.x + 1., 0., .4)) * .003;\n}\n\n// PUFFY'S DE FUNCTIONS\n\n// Body parts\n\nfloat finn(vec3 p) {\n  p.z += .27;\n  p.x += .1;\n  p.x *= 1.-pow(smoothstep(0., .2, -p.z),1.5)*.3;\n  mat2 ro = rot2D(cos(tim_tail*4.+(p.x+p.z)*5.) *(3.-p.x*20.));   \n  p.xy *= ro;\n  p.zy *= ro;\n  float e = atan(p.x, p.z);\n  float o = sin(e * 20.) * .003;\n  float a = .19 - p.z * .15;\n  float d = max(abs(p.y + o) - .005, length(p.xz) - a + cos(o * 500.) * .02);\n  d = max(p.x - p.z*.6, d);\n  d = max(p.z-p.x*.3, d);\n  return d * .75;\n}\n\n\nfloat tail(vec3 p) {\n  p.z += .18;\n  p.x += puff * .1;\n  p.x += .45 + pow(smoothstep(0., .4, abs(p.z)), 5.) * .1;\n  p.xy *= rot2D(cos(tim_tail + p.x * 5. + p.z * 3.) * 25.);\n  float e = atan(p.x, p.z);\n  float o = sin(e * 20.) * .003;\n  float a = .27 - p.z * .15;\n  float d = max(abs(p.y + o) - .003, length(p.xz) - a + cos(o * 500.) * .02);\n  float d1 = smax(p.x - p.z * .2, d, .02);\n  d1 = smax(-p.x * .4 + p.z, d1, .02);\n  float d2 = smax(p.x + p.z * .3, d, .02);\n  d2 = smax(-p.x * .3 - p.z, d2, .02);\n  d = smin(d1, d2, .03);\n  return d * .7;\n}\n\nfloat finns(vec3 p) {\n  float amp = (1. - puff * .3) * .15;\n  float t = time*5. + sign(p.y) * .2;\n  float l = length(p) * 2.;\n  p.y = abs(p.y);\n  p += normalize(pos_finn) * (.28 + puff * .05);\n  p*=1.3;\n  p = lookat(normalize(vec3(-1., -.0, -5.)), vec3(0., 1., 0.)) * p;\n  amp *= (1. + length(p) * 5.);\n  float a = .2 + cos(t + atan(p.y, p.z) * 2.) * amp * .5;\n  float b = 1.2 + puff *1.5 + sin(t - amp) * amp;\n  p.zx *= mat2(sin(a), cos(a), -cos(a), sin(a));\n  p.yx *= mat2(sin(b), cos(b), -cos(b), sin(b));\n  float e = atan(p.y, p.z);\n  float o = sin(e * 20.) * .003;\n  float r = .45 - smoothstep(1., 3., abs(e)) * .25;\n  float d =\n      max(abs(p.x + o) - .005, length(p.yz) - r + cos(p.z * 100.) * .01) * .9;\n  d = max(-p.y - p.z * .5, d);\n  d = max(p.z + p.y * .2, d);\n  d = smin(d, length(p) - .04, .04);\n  return d * .8;\n}\n\nfloat mouth(vec3 p) {\n  p *= dir_mouth;\n  float mo = length(p.yz * vec2(.35 + ani_mouth * .1-p.z*2., 1.)) - .02 * (1. + ani_mouth * .4);\n  return max(-p.x, mo);\n}\n\nfloat body(vec3 p) {\n  float m = smoothstep(0., 1.5, -p.x + 1.3) * .2;\n  float s = smoothstep(0., 1.7, -p.x);\n  p.z -= puff * .1;\n  p.z -= smoothstep(0., p.z*.3 + p.x - .6 + ani_mouth * .1,-.1)*.05;\n  p.y *= 1. + pow(abs(p.z - .2), 2.) * 1.5;\n  p.z *= 1. - (p.x + .1) * .1;\n  p.zy *= 1.+smoothstep(0.,.5,-p.x)*.3;\n  float d = length(p*vec3(1.+smoothstep(0.,.5,-p.x+p.z)*.5,1.,1.4)) - .47 - s-puff*.12;\n  p += vec3(.14 + puff * .0, .0, .2);\n  p.x -= p.z*.5;\n  p.z += puff * .1;\n  d = smin(d, length(p * vec3(0.6, 1.2, 1.7)) - .55 + m, .2) + .1;\n  d+=smoothstep(0.,.7,-p.x)*.05;\n  return (d+.05) * .7;\n}\n\nfloat eye(vec3 p) {\n\tfloat d = length(p) - .13;\n    return d;\n}\n\n// Main DE function\nfloat de(vec3 p) {\n  beye = 0.;\n  heye = 0.;\n  weye = step(0., p.y);\n  hmouth = 0.;\n  hfinns = 0.;\n  htail = 0.;\n  p.y *= 1.15;\n  vec3 rp = p;\n  p.y = abs(p.y);\n  mat2 rotbod=rot2D(smoothstep(0., 1.3, -p.x + .2) * ani_tail * 25.);\n  rp.xy *= rotbod;\n  rp.zy *= rotbod;\n  float t = time * 10.;\n  p += sin(p * 20. + t) * .002;\n  float fi = finn(rp);\n  float fis = finns(rp);\n  float ta = tail(rp);\n  float mo = mouth(p);\n  float sk = skin(rp);\n  float res = (body(rp) - thorns(rp) * (.01 + puff * .1)) * .8 - sk;\n  res += spiral(rp, -pos_eyes + vec3(0.1, 1., -0.3))*.4;\n  rp.y = abs(rp.y);\n  float eyeh = eye(rp + pos_eyes * .9);\n  float eyes = eye(rp + pos_eyes);\n  res = smax(res, -mo, .013);\n  res = smin(res, eyes, .02);\n  res = smin(res, eyeh, .035);\n  res = smin(res, fis, .02);\n  res = smin(res, fi, .02);\n  res = smin(res, ta, .03);\n  beye = abs(res - eyes);\n  heye = 1.-step(.005, beye);\n  hfinns = 1.-step(.005,abs(res-fi));\n  hfinns = max(hfinns,1.-step(.005,abs(res-fis)));\n  htail = 1.-step(.02, abs(res-ta));\n  hmouth = 1.-step(.01, abs(res-mo));\n  return res;\n}\n\n// PUFFY'S COLORING FUNCTIONS\n\nvec3 color_eyes(vec3 p, vec3 n) {\n  vec3 p1 = p + pos_eyes;\n  vec3 p2 = p + vec3(pos_eyes.x, -pos_eyes.y, pos_eyes.z);\n  vec3 l = p1;\n  vec3 c = vec3(1.);\n  p1 = lookat(dir_eye, vec3(0., 1., .5)) * p1;\n  p2 = lookat(dir_eye, vec3(0., 1., -.5)) * p2;\n  p1.y -= .01;\n  p2.y += .01;\n  c -= smoothstep(.07, .085, length(p1.xy) + 1. - weye) * (.4 + col_eyes * 1.5);\n  c -= smoothstep(.07, .085, length(p2.xy) + weye) * (.4 + col_eyes * 1.5);\n  c *= smoothstep(.03 + sin(atan(p1.x, p1.y) * 25.) * .02, .07, length(p1.xy) + 1. - weye);\n  c *= smoothstep(.03 + sin(atan(p2.x, p2.y) * 25.) * .02, .07, length(p2.xy) + weye);\n  return mix(c, -col_fish_1 - .2, smoothstep(.0, .0055, beye));\n}\n\nvec3 color(vec3 p, vec3 n) {\n  float c=.1+max(0.,p.x*3.);\n  float th=pow(max(0.,.2-abs(thorns(p)))/.2,3.);\n  vec3 col = mix(col_fish_1, col_fish_2, c);\n  col=mix(col_fish_1, col, .3+th*.7);\n  if (heye > 0.)\n    col = color_eyes(p, n);\n  if (hmouth > 0.)\n    col = col_fish_2 - .03;\n  if (hfinns > 0.)\n    col = mix(col_fish_1, col_fish_2 + .15,\n              smoothstep(.37, .5, length(p+vec3(0.,0.,.05)) - puff * .05));\n  if (htail > 0.)\n    col = mix(col_fish_1, col_fish_2 + .2,\n              smoothstep(.6, .75, length(p) - puff * .1));\n  return abs(col);\n}\n\n// BACKGROUND AND FOREGROUND FRACTAL\n\nfloat fractal(vec3 p) {\n  p += cos(p.z * 3. + time * 4.) * .02;\n  float depth = smoothstep(0., 6., -p.z + 5.);\n  p *= .3;\n  p = abs(2. - mod(p + vec3(0.4, 0.7, time * .07), 4.));\n  float ls = 0.;\n  float c = 0.;\n  for (int i = 0; i < 6; i++) {\n    p = abs(p) / min(dot(p, p), 1.) - .9;\n    float l = length(p);\n    c += abs(l - ls);\n    ls = l;\n  }\n  return .15 + smoothstep(0., 50., c) * depth * 4.;\n}\n\n// NORMALS AND LIGHTING\n\nvec3 normal(vec3 p) {\n  vec3 e = vec3(0.0, det * 2., 0.0);\n\n  return normalize(vec3(de(p + e.yxx) - de(p - e.yxx),\n                        de(p + e.xyx) - de(p - e.xyx),\n                        de(p + e.xxy) - de(p - e.xxy)));\n}\n\nfloat shadow(vec3 pos) {\n  float sh = 1.0;\n  float totdist = det * 30.;\n  float d = 10.;\n  for (int i = 0; i < 8; i++) {\n    if (d > det) {\n      vec3 p = pos - totdist * dir_light;\n      d = de(p);\n      sh = min(sh, 20. * d / totdist);\n      totdist += d;\n    }\n  }\n  return clamp(sh, 0.0, 1.0);\n}\n\nfloat light(vec3 p, vec3 dir, vec3 n, float shw) {\n  float dif = pow(max(0., dot(dir_light, -n)), 3.);\n  float amb = pow(max(0., dot(dir, -n)), 3.);\n  return dif * .7 * shw + amb * .2 + .15;\n}\n\n// RAY MARCHING AND SHADING\n\nvec3 march(vec3 from, vec3 dir) {\n  vec3 odir = dir;\n  vec3 p = from + dir * 2.;\n  float fg = fractal(p + dir) * .55;\n  vec3 col = vec3(0.);\n  float totdist = 0.;\n  float d;\n  float v = 0.;\n  cmouth = 1.;\n  for (int i = 0; i < 80; i++) {\n    p = from + totdist * dir;\n    d = de(p);\n    if (d < det || totdist > maxdist)\n      break;\n    totdist += d;\n    v += max(0., .1 - d) / .1;\n  }\n  float fade = smoothstep(maxdist * .2, maxdist * .9, maxdist - totdist);\n  float ref = 1.;\n  float eyes_ref = heye;\n  float shw = 1.;\n  if (d < det * 2.) {\n    p -= (det - d) * dir;\n    vec3 n = normal(p);\n    col = color(p, n) * (.1 + .9 * cmouth);\n    shw = shadow(p);\n    col *= light(p, dir, n, shw);\n    from = p - det * dir * 3.;\n    dir = reflect(dir, n);\n    ref = fade * (.3 * cmouth + eyes_ref * .2);\n    col = mix(col_water * .15, col, fade);\n  }\n  col *= normalize(col_water + 1.5) * 1.7;\n  p = maxdist * dir;\n  vec3 bk = fractal(p) * ref * col_water;\n  float glow = pow(max(0., dot(dir, -dir_light)), 1.5+eyes_ref*1.5);\n  vec3 glow_water = normalize(col_water+1.);\n  bk += glow_water*(glow*(1.-eyes_ref*.7) + pow(glow, 8.) * 1.5) * shw * cmouth * ref;\n  col += v * .06 * glow * ref * glow_water;\n  col += bk + fg * col_water;\n  return col;\n}\n\n// MAIN\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n  // Set globals\n  time = mod(iTime, 600.);\n  ani_mouth = sin(time * 6.);\n  puff = -.03+.5*smoothstep(.945, .95, abs(sin(time * .1)))+ani_mouth*.04;\n  pos_finn = normalize(vec3(0.35, -1, 0.));\n  pos_eyes = vec3(-1., -1.1, 1.) * .12;\n  //pos_eyes*=1.+vec3(-1.,1.,0.)*puff*.05;\n  dir_light = normalize(vec3(-.3, 0.2, 1.));\n  dir_mouth = lookat(normalize(vec3(-.4-puff*.1+ani_mouth*.03, 0., -1.)), vec3(0., 1., 0.));\n  tim_tail = time * 2.;\n  ani_tail = cos(tim_tail);\n\n  // Pixel coordinates\n  vec2 uv = fragCoord / iResolution.xy - .5;\n  vec2 uv2 = uv;\n  float ar = iResolution.x / iResolution.y; \n  uv.x *= ar;\n\n  // Camera\n  vec2 mouse = (iMouse.xy / iResolution.xy - .5) * 4.;\n  float tcam = (time+67.)*.05;\n  float zcam = smoothstep(.7, 1., cos(tcam)) * 1.8 - .3;\n  zcam -= smoothstep(.7, 1., -cos(tcam)) * 1.6;\n  if (iMouse.z < .1) mouse = vec2(sin(time * .15)*ar, zcam);\n  vec3 dir = normalize(vec3(uv, .9));\n  vec3 from = vec3(1., 0., -0.5 + mouse.y) * 1.25;\n  from.xy *= rot2D(-mouse.x * 40.);\n  dir = lookat(normalize(-from+vec3(sin(time*.5)*.3,cos(time*.25)*.1,0.)), vec3(0., 0., -1.)) * dir;\n\n  // Eyes direction\n  dir_eye = normalize(from);\n  //dir_eye.x = max(dir_eye.x, pos_eyes.x - .5);\n  dir_eye.y = min(abs(dir_eye.y), pos_eyes.y*sign(dir_eye.y)+.5*sign(dir_eye.y));\n  dir_eye.z = min(dir_eye.z, pos_eyes.z - .5);\n\n  // March and color\n  vec3 col = march(from, dir);\n  col *= vec3(1.1, .9, .8);\n  col += dot(uv2, uv2) * vec3(0., 0.6, 1.) * .8;\n\n  // Output to screen\n  fragColor = vec4(col, 1.);\n}\n",
   "name": "Image",
   "description": "",
   "type": "image"
  }
 ]
}