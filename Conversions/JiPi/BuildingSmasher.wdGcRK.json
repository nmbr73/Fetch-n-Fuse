{"Shader":{"ver":"0.1","info":{"id":"wdGcRK","date":"1603383460","viewed":1271,"name":"Building smasher","username":"michael0884","description":"Tracking the deformation gradient to model solid bodies. Yeah, no actual particles here.  Only particle distributions.\nSPACE - zoom in\nUse plugin to accelerate simulation\n","likes":45,"published":3,"flags":48,"usePreview":0,"tags":["particles","ca"],"hasliked":0},"renderpass":[{"inputs":[{"id":2,"src":"\/media\/a\/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","ctype":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":33,"src":"\/presets\/tex00.jpg","ctype":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":258,"src":"\/media\/previz\/buffer01.png","ctype":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":37,"channel":0}],"code":"\/\/ Fork of \"Neo-Hookean Field\" by michael0884. https:\/\/shadertoy.com\/view\/3dVyDD\n\/\/ 2020-10-20 18:45:49\n\n\/\/ Fork of \"Neo-Hookean 2: Electric Boogaloo\" by michael0884. https:\/\/shadertoy.com\/view\/tsVyWR\n\/\/ 2020-10-16 17:16:16\n\n\/\/ Fork of \"CA Neo-Hookean\" by michael0884. https:\/\/shadertoy.com\/view\/WdGyWR\n\/\/ 2020-10-13 18:17:06\n\n\/\/used sources \n\/\/https:\/\/github.com\/nialltl\/incremental_mpm\/blob\/master\/Assets\/2.%20MLS_MPM_NeoHookean_Multithreaded\/MLS_MPM_NeoHookean_Multithreaded.cs\n\/\/https:\/\/www.seas.upenn.edu\/~cffjiang\/research\/mpmcourse\/mpmcourse.pdf\n\n\/\/ Fork of \"CA Paste\" by michael0884. https:\/\/shadertoy.com\/view\/tsGczh\n\/\/ 2020-10-12 21:02:54\n\n\/\/ Fork of \"CA Molecular dynamics\" by michael0884. https:\/\/shadertoy.com\/view\/3s3cWr\n\/\/ 2020-10-08 22:00:15\n\n\/\/ Fork of \"Landau Ginzburg fluid\" by michael0884. https:\/\/shadertoy.com\/view\/WlXBDf\n\/\/ 2020-09-21 21:03:05\n\n\/\/ Fork of \"Everflow\" by michael0884. https:\/\/shadertoy.com\/view\/ttBcWm\n\/\/ 2020-07-19 18:18:22\n\n\/\/ Fork of \"Paint streams\" by michael0884. https:\/\/shadertoy.com\/view\/WtfyDj\n\/\/ 2020-07-11 22:38:47\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); \/\/ cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nconst int KEY_SPACE = 32;\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,2), 0 ).x > 0.5;\n}\n\n\n#define radius 0.25\n#define zoom 0.2\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{    \n    \/\/zoom in\n    if(isKeyPressed(KEY_SPACE))\n    {\n    \tpos = iMouse.xy + pos*zoom - R*zoom*0.5;\n    }\n    float rho = 0.001;\n    vec2 c = vec2(0.);\n    float De = 0.;\n    vec2 vel = vec2(0., 0.);\n    vec2 grad = vec2(0.);\n\n    float rho2 = 0.;\n    \/\/compute the smoothed density and velocity\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = floor(pos) + vec2(i,j);\n        vec4 data = T(tpos);\n\n        vec2 X0 = DECODE(data.x) + tpos;\n        vec2 V0 = DECODE(data.y);\n        float M0 = data.z;\n        vec2 dx = X0 - pos;\n        vec2 dx0 = X0 - tpos;\n\t    mat2 D0 = mat2(T1(tpos));\n        \n        float K = GS(dx\/radius)\/(radius*radius);\n        rho += M0*K;\n        grad += normalize(dx)*K;\n        c += M0*K*DECODE(data.w);\n        De += M0*K*abs(deformation_energy(D0));\n        vel += M0*K*V0;\n        vec2 dsize = destimator(dx0,  data.z);\n        float bsdf = sdBox(pos - X0,0.5*dsize);\n        \/\/float bsdf = length(pos - X0) - 0.5*length(destimator(dx0));\n        rho2 += M0*smoothstep(0.1, -0.1, bsdf)\/(dsize.x*dsize.y);\n    }\n\n   grad \/= rho; \n   c \/= rho;\n   vel \/= rho;\n   De \/= rho;\n    \n   \/\/vec3 vc = hsv2rgb(vec3(6.*atan(vel.x, vel.y)\/(2.*PI), 1.0, rho*length(vel.xy)));\n   float d = smoothstep(0.3,0.7,mix(rho, rho2,1.0));\n   col.xyz = mix(vec3(0.),5.*vec3(0,0.5,1.0)*De*De + 0.04*rho2 + 0.02*texture(iChannel2, 3.*c).xyz, d);\n   col.xyz = sqrt(col.xyz);\n    \/\/col.xyz = vec3(rho2)*0.2;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define T(p) texelFetch(iChannel0, ivec2(mod(p,R)), 0)\n#define T1(p) texelFetch(iChannel1, ivec2(mod(p,R)), 0)\n#define P(p) texture(iChannel0, mod(p,R)\/R)\n#define C(p) texture(iChannel1, mod(p,R)\/R)\n\n#define PI 3.14159265\n#define dt 0.5\n#define R iResolution.xy\n\n\/\/useful functions\n#define GS(x) exp(-dot(x,x))\n#define GS0(x) exp(-length(x))\n#define CI(x) smoothstep(1.0, 0.9, length(x))\n#define Dir(ang) vec2(cos(ang), sin(ang))\n#define Rot(ang) mat2(cos(ang), sin(ang), -sin(ang), cos(ang))\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n#define velocity_averaging 0.\n\n\/\/squishy solid\n#define relax 0.000\n#define distribution_size 1.0\n\/\/estimation str\n#define difd 2.0\n\/\/target density\n#define trho 0.\n\/\/density target strenght\n#define rhoe 0.0\n\n\/\/estimating the in-cell distribution size\nvec2 destimator(vec2 dx, float M)\n{\n    \/\/size estimate by in-cell location\n    vec2 ds = distribution_size*clamp(1.0 - difd*abs(dx), 0.001, 1.0);\n    return ds + 0.3*max(M\/(ds.x*ds.y) - 1.1, 0.)*dt;\n}\n\nfloat deformation_energy(mat2 D)\n{\n    D = transpose(D)*D;\n    return 2.*(D[0][0]*D[0][0] + D[1][1]*D[1][1] - 2.0);\n}\n\n\n\/\/ Lam\u00e9 parameters for stress-strain relationship\n#define elastic_lambda 3.2\n#define elastic_mu 4.2\n#define incompressible_viscosity 1.0\n\n\n\/\/viscous fluid\n\/*\n#define relax 0.05\n#define distribution_size 0.98\n\/\/ Lam\u00e9 parameters for stress-strain relationship\n#define elastic_lambda 0.2\n#define elastic_mu 0.1\n#define incompressible_viscousity 0.05\n*\/ \n\n\/\/MD force\nfloat MF(vec2 dx, vec2 dv)\n{\n    return incompressible_viscosity*dot(dx,dv)*GS(0.8*dx);\n}\n\n\nfloat Ha(vec2 x)\n{\n    return ((x.x >= 0.)?1.:0.)*((x.y >= 0.)?1.:0.);\n}\n\nfloat Hb(vec2 x)\n{\n    return ((x.x > 0.)?1.:0.)*((x.y > 0.)?1.:0.);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nvec2 opRepLim(in vec2 p, in vec2 c, in vec2 l)\n{\n    return p-c*clamp(round(p\/c),-l,l);\n}\n\/\/data packing\n#define PACK(X) ( uint(round(65534.0*clamp(0.5*X.x+0.5, 0., 1.))) + \\\n           65535u*uint(round(65534.0*clamp(0.5*X.y+0.5, 0., 1.))) )   \n               \n#define UNPACK(X) (clamp(vec2(X%65535u, X\/65535u)\/65534.0, 0.,1.)*2.0 - 1.0)              \n\n#define DECODE(X) UNPACK(floatBitsToUint(X))\n#define ENCODE(X) uintBitsToFloat(PACK(X))","name":"Common","description":"","type":"common"},{"inputs":[{"id":5,"src":"\/media\/a\/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","ctype":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":14,"src":"\/media\/a\/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","ctype":"texture","channel":2,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":259,"src":"\/media\/previz\/buffer02.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":260,"src":"\/media\/previz\/buffer03.png","ctype":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":257,"channel":0}],"code":"\/\/Reintegration tracking\n\nfloat particleBox(vec2 x, vec2 s)\n{\n    return float(sdBox(x, s) < 0.);\n}\n\nfloat particleArch(vec2 x, vec2 s)\n{\n    return float(opSubtraction(sdBox(x + vec2(0, s.y*0.4), s*vec2(0.5, 0.9)), sdBox(x, s)) < 0.);\n}\n\nfloat Building(vec2 x, vec2 s)\n{\n    vec2 room_s = s.y*vec2(0.12);\n    vec2 rep_s = vec2(0.15)*s.x;\n    float rooms = sdBox(opRepLim(x + vec2(0., -0.1*room_s.y), rep_s, vec2(30.0)), room_s);\n    float sd = opSubtraction(rooms, sdBox(x, s));\n    return float(sd < 0.);\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    \n    vec2 X = vec2(0);\n    vec2 V = vec2(0);\n    float M = 0.;\n    vec2 C = vec2(0.);\n    \/\/basically integral over all updated neighbor distributions\n    \/\/that fall inside of this pixel\n    \/\/this makes the tracking conservative\n    range(i, -1, 1) range(j, -1, 1)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = T(tpos);\n       \n        vec2 X0 = DECODE(data.x) + tpos;\n    \tvec2 V0 = DECODE(data.y);\n        \n        \n        \/\/particle distribution size\n        vec2 K = destimator(X0 - tpos , data.z);\n       \n        X0 += V0*dt; \/\/integrate position\n\n        \n        vec4 aabbX = vec4(max(pos - 0.5, X0 - K*0.5), min(pos + 0.5, X0 + K*0.5)); \/\/overlap aabb\n        vec2 center = 0.5*(aabbX.xy + aabbX.zw); \/\/center of mass\n        vec2 size = max(aabbX.zw - aabbX.xy, 0.); \/\/only positive\n        \n        \/\/the deposited mass into this cell\n        vec3 m = data.z*vec3(center, 1.0)*size.x*size.y\/(K.x*K.y);\n        \n        \/\/add weighted by mass\n        X += m.xy;\n        V += V0*m.z;\n      \tC += m.z*DECODE(data.w);\n        \/\/add mass\n        M += m.z;\n    }\n    \n    \/\/normalization\n    if(M != 0.)\n    {\n        X \/= M;\n        V \/= M;\n        C \/= M;\n    }\n    \n    \/\/initial condition\n    if(iFrame < 1)\n    {\n        X = pos;\n        V = vec2(0.);\n        vec4 nya = texture(iChannel2, clamp(1.8*X*vec2(0.166,1.)\/R, vec2(0.),vec2(0.1666, 1.0)));\n        M = max(max(Building(X - R*vec2(0.5,0.32), R*vec2(0.4,0.3)),\n            particleBox(X - R*vec2(0.1,0.9), R*vec2(0.0))), \n                particleBox(X - R*vec2(0.5,0.12), R*vec2(0.47, 0.1)));\n        \n        C = mod(3.*pos\/R, 1.);\n    }\n    \n    X = X - pos;\n    U = vec4(ENCODE(X), ENCODE(V), M, ENCODE(C));\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":259,"src":"\/media\/previz\/buffer02.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":260,"src":"\/media\/previz\/buffer03.png","ctype":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":258,"channel":0}],"code":"\/\/deformation gradient advection and update\n\n\n\/\/particle distribution\nvec3 PD(vec2 x, vec2 pos)\n{\n    return vec3(x, 1.0)*Ha(x - (pos - 0.5))*Hb((pos + 0.5) - x);\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    \n    \/\/deformation gradient\n   \tmat2 D = mat2(0);\n    float M = 0.;\n    \n    \/\/basically integral over all updated neighbor distributions\n    \/\/that fall inside of this pixel\n    \/\/this makes the tracking conservative\n    range(i, -1, 1) range(j, -1, 1)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = T(tpos);\n       \n        vec2 X0 = DECODE(data.x) + tpos;\n    \tvec2 V0 = DECODE(data.y);\n       \tmat2 D0 = mat2(T1(tpos));\n          \n        \/\/particle distribution size\n        vec2 K = destimator(X0 - tpos,  data.z);\n        \n        X0 += V0*dt; \/\/integrate position\n\n        vec4 aabbX = vec4(max(pos - 0.5, X0 - K*0.5), min(pos + 0.5, X0 + K*0.5)); \/\/overlap aabb\n        vec2 center = 0.5*(aabbX.xy + aabbX.zw); \/\/center of mass\n        vec2 size = max(aabbX.zw - aabbX.xy, 0.); \/\/only positive\n        \n        \/\/the deposited mass into this cell\n        vec3 m = data.z*vec3(center, 1.0)*size.x*size.y\/(K.x*K.y);\n        \n        \/\/add deformation grad weighted by mass\n        D += D0*m.z;\n      \t\n        \/\/add mass\n        M += m.z;\n    }\n    \n    \/\/normalization\n    if(M != 0.)\n    {\n       D \/= M;\n    }\n\telse D = mat2(1.0);\n    \n    \/\/initial condition\n    if(iFrame < 1)\n    {\n        D = mat2(1.0);\n    }\n\n    U = vec4(D);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":258,"src":"\/media\/previz\/buffer01.png","ctype":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":259,"channel":0}],"code":"\/\/velocity update\n\nfloat border(vec2 p)\n{\n    float bound = -sdBox(p - R*0.5, R*vec2(0.48, 0.48)); \n    float box = sdBox((p - R*vec2(0.5, 0.6)) , R*vec2(0.05, 0.01));\n    float drain = -sdBox(p - R*vec2(0.5, 0.7), R*vec2(0.0, 0.0));\n    return bound;\n}\n\n#define h 1.\nvec3 bN(vec2 p)\n{\n    vec3 dx = vec3(-h,0,h);\n    vec4 idx = vec4(-1.\/h, 0., 1.\/h, 0.25);\n    vec3 r = idx.zyw*border(p + dx.zy)\n           + idx.xyw*border(p + dx.xy)\n           + idx.yzw*border(p + dx.yz)\n           + idx.yxw*border(p + dx.yx);\n    return vec3(normalize(r.xy), r.z + 1e-4);\n}\n\nvec2 normalize2(vec2 a)\n{\n    return all(equal(a, vec2(0.)))?vec2(0.):normalize(a);\n}\n\n\nmat2 strain(mat2 D)\n{\n    float J = abs(determinant(D)) + 0.001;\n\n    \/\/ MPM course, page 46\n    float volume = J;\n\n    \/\/ useful matrices for Neo-Hookean model\n    mat2 F_T = transpose(D);\n    mat2 F_inv_T = inverse(F_T);\n    mat2 F_minus_F_inv_T = D - F_inv_T;\n\n    \/\/ MPM course equation 48\n    mat2 P_term_0 = elastic_mu * (F_minus_F_inv_T);\n    mat2 P_term_1 = elastic_lambda * log(J) * F_inv_T;\n    mat2 P = P_term_0 + P_term_1;\n\n    \/\/ equation 38, MPM course\n    mat2 stress = P*F_T;\n\n    return volume * stress;\n}\n\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    vec2 uv = pos\/R;\n    ivec2 p = ivec2(pos);\n        \n    vec4 data = T(pos); \n    mat2 D = mat2(T1(pos));\n    vec2 X = DECODE(data.x) + pos;\n    vec2 V = DECODE(data.y);\n    float M = clamp(data.z, 0., 2.0);\n    vec2 C = DECODE(data.w);\n    if(M>0.0) \/\/not vacuum\n    {\n        \/\/Compute the force\n      \n        vec2 F = vec2(0.);\n        float b = 0.;\n   \n        mat2 local_strain = strain(D);\n        if(M > 0.0)\n        {\n            range(i, -2,2) range(j, -2, 2)\n            {\n                if(!(i == 0 && j == 0))\n                {\n                    vec2 tpos = pos + vec2(i,j);\n                    vec4 data = T(tpos);\n\n                    vec2 X0 = 0.*DECODE(data.x) + tpos;\n                    vec2 V0 = DECODE(data.y);\n                    float M0 = data.z;\n                    vec2 dx = X0 - X;\n                    vec2 dv = V0 - V;\n                    mat2 D0 = mat2(T1(tpos));\n                    float weight = GS(0.8*dx);\n                   \n                    \/\/F += M0*strain((D0*M + D*M0)\/(M+M0))*dx*weight;\n                    mat2 strain0 = (M0*strain(D0) + M*local_strain)\/(M0+M) + mat2(2.4*dot(dx,dv));\n                    F += M0*strain0*dx*weight;\n                   \n                    b += weight;\n                }\n            }\n       \n            F \/= b;\n \t\t\tF = clamp(F, -0.4,0.4);\n        }\n        if(iMouse.z > 0.)\n        {\n            vec2 dx= pos - iMouse.xy;\n            F += 0.02*normalize2(dx)*GS(dx\/80.);\n        }\n        \n       \t\/\/gravity\n        F += 0.001*vec2(0,-1);\n        \n        \/\/integrate velocity\n        V += F*dt;\n        \/\/X +=  0.*F*dt;\n        \n        vec3 BORD = bN(X);\n        V += 0.1*smoothstep(0., 5., -BORD.z)*BORD.xy;\n        V *= 1. - 0.5*smoothstep(-30., 0., -pos.y);\n        \n        \/\/velocity limit\n        float v = length(V);\n        V \/= (v > 1.)?1.*v:1.;\n    }\n    \n    \/\/save\n    X = X - pos;\n    U = vec4(ENCODE(X), ENCODE(V), data.z, ENCODE(C));\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":258,"src":"\/media\/previz\/buffer01.png","ctype":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":260,"channel":0}],"code":"vec2 normalize2(vec2 a)\n{\n    return all(equal(a, vec2(0.)))?vec2(0.):normalize(a);\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    vec2 uv = pos\/R;\n    ivec2 p = ivec2(pos);\n        \n    vec4 data = T(pos); \n    vec2 X = DECODE(data.x) + pos;\n    vec2 V = DECODE(data.y);\n    float M = data.z;\n    float C = data.w;\n    mat2 D = mat2(T1(pos));\n    \n    if(M > 0.01) \/\/not vacuum\n    {\n        \/\/Compute the velocity gradient matrix\n        mat2 B = mat2(0.);\n        float a = 0.01;\n        float rho = 0.;\n        range(i, -2, 2) range(j, -2, 2)\n        {\n            vec2 tpos = pos + vec2(i,j);\n            vec4 data = T(tpos);\n\n            vec2 X0 = DECODE(data.x) + tpos;\n            vec2 V0 = DECODE(data.y);\n            float M0 = data.z;\n            vec2 dx = X0 - X;\n            vec2 dv = V0 - V;\n\t\t\tvec2 dsize = clamp(destimator(X0 - tpos, data.z), 0.3, 1.0);\n            float weight = clamp(M0, 0.0, 1.0)*GS(0.8*dx);\n            rho += M0*weight;\n            B += mat2(dv*dx.x,dv*dx.y)*weight;\n            a += weight;\n        }\n        B \/= a;\n        rho \/= a;\n      \n        float drho = rho - 1.0;\n        B -= 0.007*mat2(drho)*abs(drho);\n       \n        \/\/integrate deformation gradient\n       \tD += 1.*dt*B*D;\n       \n        \/\/smoothing\n        \n        float r = relax + 0.05*smoothstep(-30., 0., -pos.y);\n        D = D*(1. - r) + mat2(1.)*r;\n        \n        \/\/clamp the gradient to not go insane\n        D = mat2(clamp(vec4(D - mat2(1.)), -5.0, 5.0)) + mat2(1.);\n    }\n    \n    \/\/save\n    U = vec4(D);\n}","name":"Buffer D","description":"","type":"buffer"}]}}