{
 "ver": "0.1",
 "info": {
  "id": "ssKyR3",
  "date": "0",
  "viewed": 0,
  "name": "Particles SDF JiPi",
  "description": "particles",
  "likes": 0,
  "published": "Private",
  "usePreview": 0,
  "tags": [
   "particles"
  ],
  "hasliked": 0,
  "parentid": "NsyyR3",
  "parentname": "Particles SDF"
 },
 "renderpass": [
  {
   "inputs": [
    {
     "id": "Xsf3zn",
     "filepath": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
     "type": "texture",
     "channel": 2,
     "sampler": {
      "filter": "mipmap",
      "wrap": "repeat",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    },
    {
     "id": "4dXGR8",
     "filepath": "/media/previz/buffer00.png",
     "type": "buffer",
     "channel": 0,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    },
    {
     "id": "XsXGR8",
     "filepath": "/media/previz/buffer01.png",
     "type": "buffer",
     "channel": 1,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    }
   ],
   "outputs": [
    {
     "id": "4dfGRr",
     "channel": 0
    }
   ],
   "code": "vec3 rand3( vec2 p ) { return textureLod( iChannel2, (p*8.0+0.5)/256.0, 0.0 ).xyw; }\n\nfloat rand2(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nuint mod_i32( int i32_bas , int i32_div ){\n\n    float   flt_res =  mod( float(i32_bas), float(i32_div));\n    uint    i32_res = uint( flt_res );\n    return( i32_res );\n}\n\nvec4 randomColor(int i) {\n    float r = rand2(vec2(i, mod_i32(i, 7))) * 0.7;\n    float g = rand2(vec2(mod_i32(i, 19), i));\n    float b = rand2(vec2(mod_i32(i, 6), mod_i32(i, 13)));\n    return vec4(r, g, b, 1.0f);\n}\n\nvec3 currentColor = vec3(0.0f);\n\nfloat scene(vec3 pos, mat3 m) {\n    currentColor = vec3(0.0f);\n    float k = 10000.0f;\n    vec2 scale = 9. * iResolution.xy / max ( iResolution.x, iResolution.y ) ;\n    vec3 q = m * pos;\n    for (int i = 0; i < 800; ++i) {\n        float radius = 0.3;\n        vec4 particleData = texelFetch(iChannel0, ivec2(i, 0), 0);\n        if (particleData.w == 0.0)\n            continue;\n        vec2 pos = decode_vec2(particleData.x);\n        pos = scale * ( pos - vec2 ( 0.5 ) );\n        vec4 color = randomColor(i);\n        float dist = sphere(q, vec3(pos.x, -0.00, pos.y), radius); \n        k = smin(k, dist, 5.0f);\n        currentColor += 2.0f / (20.0f *dist + 1.0f) * color.xyz;\n    }\n    //currentColor = clamp(vec3(0.0f), vec3(1.0f), currentColor);\n    \n    return k;\n}\n\nvec3 trace ( in vec3 from, in vec3 dir, out bool hit, mat3 m)\n{\n\tvec3\tp         = from;\n\tfloat\ttotalDist = 0.0;\n\t\n\thit = false;\n\t\n    int stepNum = 70;\n\tfor ( int steps = 0; steps < stepNum; steps++ )\n\t{\n        float dist = scene(p, m);\n\n        p += dist * dir;\n        \n\t\tif ( dist < 0.01 )\n\t\t{\n\t\t\thit = true;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\ttotalDist += dist;\n\t\t\n\t\tif ( totalDist > 10.0 )\n\t\t\tbreak;\t\n\t}\n\t\n\treturn p;\n}\n\nvec3 generateNormal ( vec3 z, float d, mat3 m)\n{\n    float eps = 0.01;\n    float e   = max (d * 0.5, eps );\n    float dx1 = scene(z + vec3(e, 0, 0), m);\n    float dx2 = scene(z - vec3(e, 0, 0), m);\n    float dy1 = scene(z + vec3(0, e, 0), m);\n    float dy2 = scene(z - vec3(0, e, 0), m);\n    float dz1 = scene(z + vec3(0, 0, e), m);\n    float dz2 = scene(z - vec3(0, 0, e), m);\n    \n    return normalize ( vec3 ( dx1 - dx2, dy1 - dy2, dz1 - dz2 ) );\n}\n\n\nvec3 lightPos = vec3(0, -6., 0.);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float minDist = 1000.0f;\n    int minDistParticle = -1;\n    \n    float border = 0.15;\n    bool doVoronoi = uv.x > border && uv.x < 1.0f - border && uv.y > border && uv.y < 1.0f - border;\n    \n    for (int i = 0; i < 800; ++i) {\n        float radius = 0.01;\n        vec4 particleData = texelFetch(iChannel0, ivec2(i, 0), 0);\n        if (particleData.w == 0.0) {\n            continue;\n        }\n        vec2 pos = decode_vec2(particleData.x);\n        float dist = length(pos - uv);\n        if (dist < minDist) {\n            minDist = dist;\n            minDistParticle = i;\n        }\n        if (dist < radius)\n            fragColor = randomColor(i);\n    }\n    if (doVoronoi) {\n        fragColor = randomColor(minDistParticle);\n    }\n    \n    /////////////////////////////////////////////////////\n   \n    //fragColor = vec4(1.0f - clamp( 0.01, 1.0, minDist));\n    \n        // Normalized pixel coordinates (from 0 to 1)\n    \n    mat3 m;\n    \n    m = mat3(\n        vec3(1, 0, 0),\n        vec3(0, 1, 0),\n        vec3(0, 0, 1)\n    );\n    \n    vec3 cameraPos = vec3(0.,-5., 0.);\n    vec3 cameraForward = vec3(0., 1, 0.);\n    vec3 cameraUp = vec3 (0., 0., 1.);\n    float cameraFocus = 5.;\n    \n    vec2 scale = 9. * iResolution.xy / max ( iResolution.x, iResolution.y ) ;\n    uv    = scale * ( fragCoord/iResolution.xy - vec2 ( 0.5 ) );\n\n    \n    vec3 from = vec3(uv.x, (cameraPos + cameraForward * cameraFocus).z, uv.y);\n    vec3 dir = normalize(from - cameraPos);\n    \n    bool hit;\n    vec3 p1 = trace(cameraPos, dir, hit, m);\n    float d1 = length(cameraPos - p1);\n     float c1 = length(p1);\n    \n    vec3 backgroundColor = vec3(0., 0., 0.);\n    vec3 surfaceColor = vec3(1., 1., 1.);\n    \n    vec4 col;\n    \n    if (hit) {\n\n       vec3 l = normalize(lightPos - p1);\n       vec3 n = generateNormal(p1, 0.001, m);\n       vec3 v = normalize(cameraPos - p1);\n       float diffuse = max(0., dot(n, l));\n\n       vec3  h  = normalize ( l + v );\n       float hn = max ( 0.0, dot ( h, n ) );\n       float specular = pow ( hn, 150.0 );\n\n       col = 0.5*vec4 ( diffuse ) * vec4(currentColor, 1.0) + 0.5 * specular * vec4 ( 1, 1, 1, 1 );\n    }\n    else {\n       col = vec4(0.0f);\n    }\n   \n\n    // Output to screen\n    fragColor = col;\n}\n",
   "name": "Image",
   "description": "",
   "type": "image"
  },
  {
   "inputs": [
    {
     "id": "4dXGR8",
     "filepath": "/media/previz/buffer00.png",
     "type": "buffer",
     "channel": 1,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    },
    {
     "id": "XsXGR8",
     "filepath": "/media/previz/buffer01.png",
     "type": "buffer",
     "channel": 0,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    }
   ],
   "outputs": [
    {
     "id": "4dXGR8",
     "channel": 0
    }
   ],
   "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 particleData = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    vec2 pos = decode_vec2(particleData.x);\n    vec2 vel = decode_vec2(particleData.y);\n    if (pos.y < 0.0 || pos.y > 1.0) {\n        vel.y = -vel.y;\n    }\n    if (pos.x < 0.0 || pos.x > 1.0) {\n        vel.x = -vel.x;\n    }\n    \n    pos += vel * iTimeDelta * 0.2;\n    // vel.y -= iTimeDelta * 2.0;\n    particleData.x = encode_vec2(pos);\n    particleData.y = encode_vec2(vel);\n    uint bufferBegin = uint(texelFetch(iChannel0, ivec2(0, 0), 0));\n    uint bufferEnd = uint(texelFetch(iChannel0, ivec2(1, 0), 0));\n    uint idx = uint(fragCoord.x);\n    bool commonFill = idx >= bufferBegin && idx < bufferEnd;\n    bool overflowFill = bufferBegin > bufferEnd && (idx >= bufferBegin || idx < bufferEnd);\n    if (idx >= bufferBegin && idx <= bufferEnd) {\n        particleData = vec4(0, 0, 0, 1);\n        particleData.x = encode_vec2(iMouse.xy / iResolution.xy);\n        particleData.y = encode_vec2(vec2(random(vec2(fragCoord.x, 5.0)), random(fragCoord)) * 2.0 - 1.0);\n        //particleData = vec4(1.0f);\n    }\n    fragColor = particleData;\n    // fragColor = vec4(sin(iTime * 2.0 + fragCoord.x) * 0.1 + 0.5, cos(iTime * 2.0 + fragCoord.x) * 0.1 + 0.5, 1.0, 1.0);\n}",
   "name": "Buffer A",
   "description": "",
   "type": "buffer"
  },
  {
   "inputs": [
    {
     "id": "XsXGR8",
     "filepath": "/media/previz/buffer01.png",
     "type": "buffer",
     "channel": 0,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    }
   ],
   "outputs": [
    {
     "id": "XsXGR8",
     "channel": 0
    }
   ],
   "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uvec2 coords = uvec2(fragCoord);\n    if (coords.y == 0u && coords.x < 2u) {\n        if (iMouse.z > 0.0) {\n            float spawnCount = 5.0;\n            fragColor.x = float(int(texelFetch(iChannel0, ivec2(0, 0), 0).x + spawnCount) % 800);\n        } else {\n            fragColor.x = texelFetch(iChannel0, ivec2(1, 0), 0).x;\n        }\n    }\n}",
   "name": "Buffer B",
   "description": "",
   "type": "buffer"
  },
  {
   "inputs": [],
   "outputs": [],
   "code": "const float QUANT_COUNT = 65536.0 - 1.0;\n\nfloat encode_vec2(vec2 v) {\n    v = clamp(v, vec2(-3.0), vec2(3.0));\n    v /= 3.0;\n    v *= 0.5;\n    v += 0.5;\n    v *= QUANT_COUNT;\n    return uintBitsToFloat(uint(v.x) << 16 | uint(v.y));\n}\n\nvec2 decode_vec2(float vi) {\n    vec2 v = vec2(floatBitsToUint(vi) >> 16u, floatBitsToUint(vi) & 0xFFFFu);\n    v /= QUANT_COUNT;\n    v -= 0.5;\n    v *= 2.0;\n    v *= 3.0;\n    return v;\n}\n\nfloat random(vec2 uv)\n{\n    return fract(sin(dot(uv,vec2(12.9898,78.233)))*43758.5453123);\n}\n\nconst float PI = 3.14;\n\nfloat smin ( float a, float b, float k )\n{\n\tfloat res = exp ( -k*a ) + exp ( -k*b );\n\treturn -log ( res ) / k;\n}\n\nvec4 smin ( vec4 a, vec4 b, float k )\n{\n\tvec4 res = exp ( -k*a ) + exp ( -k*b );\n\treturn -log ( res ) / k;\n}\n\n\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n\nfloat sphere(vec3 pos, vec3 spherePos, float sphereRadius) {\n    return length(pos - spherePos) - sphereRadius;\n}\n\n\n\n\nmat2 rotate(float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n\n    return mat2(c, -s, s, c);\n}\n",
   "name": "Common",
   "description": "",
   "type": "common"
  }
 ]
}