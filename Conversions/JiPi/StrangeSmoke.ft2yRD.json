{"Shader":{"ver":"0.1","info":{"id":"ft2yRD","date":"1649282833","viewed":57,"name":"strange smoke","username":"xenn","description":"kinda interesting","likes":4,"published":3,"flags":32,"usePreview":0,"tags":["mouse","background","shadertoy","feedback","integration","library","web","webdevelopment","webdev","javascript"],"hasliked":0},"renderpass":[{"inputs":[{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":260,"src":"\/media\/previz\/buffer03.png","ctype":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":37,"channel":0}],"code":"\/\/ Fork of a fork of a fork of a fork of a fork of a fork of a fork of a fork of a \n\n\/\/Chromatic aberration, film grain and tone mapping\n\nfloat NoiseSeed;\n\nfloat randomFloat(){\n  NoiseSeed = sin(NoiseSeed) * 84522.13219145687;\n  return fract(NoiseSeed);\n}\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))\/(x*(c*x+d)+e);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    if(fragCoord.y \/ iResolution.y < Margins || fragCoord.y \/ iResolution.y > 1.0-Margins){\n        fragColor = vec4(ACESFilm(vec3(0)), 1.0);\n        return;\n    }\n    \n    NoiseSeed = float(iFrame)* .003186154 + fragCoord.y * 17.2986546543 + fragCoord.x;\n    \n    vec2 uv = fragCoord.xy\/iResolution.xy;\n    \n    vec2 d = (uv-vec2(.5)) * .0075;\n    vec3 color = vec3(texture(iChannel0, uv - 0.0 * d).r,\n                      texture(iChannel0, uv - 1.0 * d).g,\n                      texture(iChannel0, uv - 2.0 * d).b);\n                                  \n    vec3 col = vec3(texture(iChannel1, uv - 0.0 * d).r,\n                      texture(iChannel1, uv - 1.0 * d).g,\n                      texture(iChannel1, uv - 2.0 * d).b);\n                      \n        vec3 col2 = vec3(texture(iChannel2, uv - 0.0 * d).r,\n                      texture(iChannel2, uv - 1.0 * d).g,\n                      texture(iChannel2, uv - 2.0 * d).b);\n                      \n                \/\/      col = min(col,color);\n                      color = min(col2,col);\n               \/\/       col2 = mix(col,color,0.5);\n             \/\/        col2 = min(col,color);\n                      \n                       \n \/\/     color = mix(col,color,col2);\n    float noise = .9 + randomFloat()*.15;\n  \tfragColor = vec4(ACESFilm(((color * 0.5)+ (mix(col,color,col2)))*noise), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":258,"src":"\/media\/previz\/buffer01.png","ctype":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":258,"src":"\/media\/previz\/buffer01.png","ctype":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":257,"channel":0}],"code":"                                                                                                                                                                                                                                                                                        \/\/ See Image tab for details, also visit:\n\/\/\n\/\/ https:\/\/xemantic.github.io\/shader-web-background\/\n\/\/\n\/\/ In the original shader-web-background these values are provided as uniforms\n\/\/ feel free to play with them and if you will find something prettier than\n\/\/ the equilibrium I established, please send it back to me :)\nconst vec2  iFeedbackZoomCenter       = vec2(0., 0.);\nconst float iFeedbackZoomRate         = -.001;\nconst float iFeedbackFadeRate         = .998;\nconst float iFeedbackColorShiftZoom   = .005;\nconst float iFeedbackColorShiftImpact = -0.0001;\nconst vec2  iDrawCenter               = vec2(0., 0.);\nconst float iDrawIntensity            = .025;\nconst float iBlobEdgeSmoothing        = .01;\nconst float iBlob1Radius              = .75;\nconst float iBlob1PowFactor           = 20.;\nconst float iBlob1ColorPulseSpeed     = .024;\nconst float iBlob2Radius              = .65;\nconst float iBlob2PowFactor           = 20.;\nconst float iBlob2ColorPulseSpeed     = .01234;\nconst float iBlob2ColorPulseShift     = 0.0;\nconst float iColorShiftOfRadius       = 0.5;\nconst float iFeedbackMouseShiftFactor = .003;\n\n\/*\n  Normally it would be provided by texture parameters, but on Mac\/iOS the texture REPEAT\n  seems to work only for power-of-2 texture sizes.\n *\/\nvec4 repeatedTexture(in sampler2D channel, in vec2 uv) {\n    return texture(channel, mod(uv, 1.));\n}\n\nfloat drawBlob(\n    in vec2 st,\n    in vec2 center,\n    in float radius,\n    in float edgeSmoothing\n) {\n    float dist = length((st - center) \/ radius);\n    return dist * smoothstep(1., 1. - iBlobEdgeSmoothing, dist);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \/\/ in shader-web-background provided as uniforms: start\n    float iMinDimension = min(iResolution.x, iResolution.y);\n    vec2 iScreenRatioHalf =\n        (iResolution.x >= iResolution.y)\n            ? vec2(iResolution.y \/ iResolution.x * .5, .5)\n            : vec2(.5, iResolution.x \/ iResolution.y);\n    vec3 iBlob1Color = spectral_zucconi6(\n        mod(iTime * iBlob1ColorPulseSpeed, 1.)\n    );\n    \n    vec3 iBlob2Color = spectral_zucconi6(\n        mod(iTime * iBlob2ColorPulseSpeed + iBlob2ColorPulseShift, 1.)\n    );\n    vec2 iFeedbackShiftVector =\n        (iMouse.x > 0. && iMouse.y > 0.)\n            ? (iMouse.xy * 2. - iResolution.xy) \/ iMinDimension * iFeedbackMouseShiftFactor\n            : vec2(0);\n    \/\/ in shader-web-background provided as uniforms: end\n            \n    \n    vec2 uv = fragCoord \/ iResolution.xy;\n    vec2 st = (fragCoord * 2. - iResolution.xy) \/ iMinDimension;\n\n    vec2  drawDelta = st - iDrawCenter;\n    float drawAngle = atan(drawDelta.x, drawDelta.y);\n    float drawDist = length(drawDelta);\n\nvec3 feedbk = repeatedTexture(iChannel1, uv - st).rgb;\n    vec3 colorShift = repeatedTexture(\n        iChannel0,\n        uv - st * iFeedbackColorShiftZoom * iScreenRatioHalf\n    ).rgb;\n\n    vec2 stShift = vec2(0);\n    stShift += iFeedbackZoomRate * (st - iFeedbackZoomCenter);\n    stShift += (feedbk.br\/colorShift.gr - .5) * iFeedbackColorShiftImpact;\n    stShift += iFeedbackShiftVector;\n    stShift *= iScreenRatioHalf;\n\n    vec3 prevColor = mix(repeatedTexture(iChannel2, uv - stShift).rgb,repeatedTexture(iChannel3, uv - stShift).rgb,repeatedTexture(iChannel1, uv - stShift).rgb);\n     vec3 prevColor2 = repeatedTexture(iChannel2, uv - stShift).rgb+repeatedTexture(iChannel3, uv - stShift).rgb * repeatedTexture(iChannel1, uv - stShift).rgb\/512.;\n    prevColor +=prevColor2\/512.;\n    prevColor *= iFeedbackFadeRate;\n\n    vec3 drawColor = vec3(0);\n   \n\n    float radius =\n        1.\n        + (colorShift.r + colorShift.g + colorShift.b) * iColorShiftOfRadius;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob1Radius, iBlobEdgeSmoothing),\n          iBlob1PowFactor\n        ) * iBlob1Color;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob2Radius, iBlobEdgeSmoothing),\n          iBlob2PowFactor\n        ) * iBlob2Color;\n\n    vec3 color = vec3(0);\n    drawColor *= iDrawIntensity;\n    prevColor *= iFeedbackFadeRate;\n    color += prevColor;\n    color += drawColor;\n\n    color = clamp(color, 0., 1.);\n    fragColor = vec4(color, 1.);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\/\/#define iFeedbackColorShiftZoom 0.2\n\/\/#define iFeedbackColorShiftImpact 0.001\n\/\/#define iBlob1ColorPulseSpeed 0.03456\n\/\/#define iBlob2ColorPulseSpeed 0.02345\n#define Margins .0\n#define iTime iTime \/ 1.0\n\n#define PI 3.14159265359\n\nvec2 getFontSymbolSampleUV(int x, int y, vec2 uv) {\n\treturn uv * vec2(1.\/16.) + vec2(float(x) \/ 16., float(y) \/ 16.);\n}\n\nfloat getHeight(vec2 uv, sampler2D bumpMap, float maxHeight) {\n    return texture(bumpMap, uv).r*maxHeight;\n}\n\nvec3 getSlope(vec2 uv, float height, vec2 axis, sampler2D bumpMap, float maxHeight, vec2 texelSize) {\n    float h1 = getHeight(uv+texelSize*axis, bumpMap, maxHeight);\n    float h2 = getHeight(uv-texelSize*axis, bumpMap, maxHeight);\n    return vec3(1,((height-h2) + (h1-height)) \/ 2.,0);\n}\n\nvec3 bump2Normal(vec2 uv, sampler2D bumpMap, float maxHeight, vec2 texelSize) {\n    \n    float height = getHeight(uv, bumpMap, maxHeight);\n        \n    vec3 slopeX = getSlope(uv, height, vec2(1., 0.), bumpMap, maxHeight, texelSize).zyx;\n    vec3 slopeY = getSlope(uv, height, vec2(0., 1.), bumpMap, maxHeight, texelSize).xyz;\n    return cross(slopeX, slopeY).zyx;\n}\n\nvec3 normal2rgb(vec3 normal) {\n    return normalize(normal.rbg * vec3(0.5, 0.5, 0.5) + vec3(0.5, 0.5, 0.5));\n}\n\nfloat radius = 20.;\nfloat intensity = 5.;\nfloat fade = .99;\n\nfloat pi = 3.14159265359;\n\nfloat blurRadius = 3.;\n\nfloat sinWave(float v, float m){return (sin(v*m*pi*2.)+1.)\/2.;}\n\n\/\/from https:\/\/github.com\/hughsk\/glsl-hsv2rgb\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 \/ 3.0, 1.0 \/ 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec4 xy2hue(vec2 v){\n    float h = (atan(v.y, v.x)\/(pi) + 1.)\/2.;\n    float b = length(v);\n    return vec4(hsv2rgb(vec3(h, 1., b)), 1.);\n}\n\n\n\n\n\n\n\n\/*\n * Conway Ticket\n * \n * Copyright (C) 2021  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and\/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http:\/\/www.gnu.org\/licenses\/>.\n *\/\n \nivec2 boardSize = ivec2(125),\n    ci = ivec2(1,0);\nvec2 blockSize,\n    xij;\nvec3 c = vec3(1,0,-1);\nfloat stepTimeDelta = .05,\n\/\/    pi = 3.14159,\n    fsaa = 144.,\n    bpm = 90.,\n    spb = 60.\/90.,\n    scale,\n    nbeats,\n    stepTime;\n\n\/\/ Creative Commons Attribution-ShareAlike 4.0 International Public License\n\/\/ Created by David Hoskins.\n\/\/ See https:\/\/www.shadertoy.com\/view\/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(p.xyx * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat lfnoise(float y)\n{\n    vec2 t = y*c.xx;\n    vec2 i = floor(t);\n    t = smoothstep(c.yy, c.xx, fract(t));\n    vec2 v1 = vec2(hash12(i), hash12(i+c.xy)),\n    v2 = vec2(hash12(i+c.yx), hash12(i+c.xx));\n    v1 = c.zz+2.*mix(v1, v2, t.y);\n    return mix(v1.x, v1.y, t.x);\n}\n\nfloat m(vec2 x)\n{\n    return max(x.x,x.y);\n}\n\nfloat d210(vec2 x)\n{\n    return min(max(max(max(max(min(max(max(m(abs(vec2(abs(abs(x.x)-.25)-.25, x.y))-vec2(.2)), -m(abs(vec2(x.x+.5, abs(abs(x.y)-.05)-.05))-vec2(.12,.02))), -m(abs(vec2(abs(x.x+.5)-.1, x.y-.05*sign(x.x+.5)))-vec2(.02,.07))), m(abs(vec2(x.x+.5,x.y+.1))-vec2(.08,.04))), -m(abs(vec2(x.x, x.y-.04))-vec2(.02, .08))), -m(abs(vec2(x.x, x.y+.1))-vec2(.02))), -m(abs(vec2(x.x-.5, x.y))-vec2(.08,.12))), -m(abs(vec2(x.x-.5, x.y-.05))-vec2(.12, .07))), m(abs(vec2(x.x-.5, x.y))-vec2(.02, .08)));\n}\n\nfloat dbox3(vec3 x, vec3 b)\n{\n  b = abs(x) - b;\n  return length(max(b,0.))\n         + min(max(b.x,max(b.y,b.z)),0.);\n}\n\nfloat setStateF(ivec2 index, ivec2 where, float oldState, float newState)\n{\n    return all(equal(index, where)) ? newState : oldState;\n}\n\n\/\/ Distance to star\nfloat dstar(vec2 x, float N, vec2 R)\n{\n    float d = pi\/N,\n        p0 = acos(x.x\/length(x)),\n        p = mod(p0, d);\n    vec2 a = mix(R,R.yx,mod(round((p-p0)\/d),2.)),\n    \tp1 = a.x*c.xy,\n        ff = a.y*vec2(cos(d),sin(d))-p1;\n    return dot(length(x)*vec2(cos(p),sin(p))-p1,ff.yx*c.zx)\/length(ff);\n}\n\nfloat dhexagonpattern(vec2 p) \n{\n    vec2 q = vec2(p.x*1.2, p.y + p.x*.6),\n        qi = floor(q),\n        pf = fract(q);\n    float v = mod(qi.x + qi.y, 3.);\n    \n    return dot(step(pf.xy,pf.yx), 1.-pf.yx + step(1.,v)*(pf.x+pf.y-1.) + step(2.,v)*(pf.yx-2.*pf.xy));\n}\n\n\/\/ x: material\n\/\/ y: distance\n\/\/ z: reflectivity\nvec3 add(vec3 a, vec3 b)\n{\n    if(a.y < b.y) return a;\n    return b;\n}\n\n\/\/vec3 hsv2rgb(vec3 cc)\n\/\/{\n\/\/    vec4 K = vec4(1., 2. \/ 3., 1. \/ 3., 3.);\n\/\/    vec3 p = abs(fract(cc.xxx + K.xyz) * 6. - K.www);\n\/\/    return cc.z * mix(K.xxx, clamp(p - K.xxx, 0., 1.), cc.y);\n\/\/}\n\nvec2 rgb2sv(vec3 cc)\n{\n    vec4 K = vec4(0., -1. \/ 3., 2. \/ 3., -1.),\n        p = mix(vec4(cc.bg, K.wz), vec4(cc.gb, K.xy), step(cc.b, cc.g)),\n        q = mix(vec4(p.xyw, cc.r), vec4(cc.r, p.yzx), step(p.x, cc.r));\n    return vec2((q.x - min(q.w, q.y)) \/ (q.x + 1.e-10), q.x);\n}\n\n\n\n#define pi acos(-1.)\n\n\n#define sint(a) (asin(sin(a))*2. - 1.)\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n\/\/#define pmod(p,d) mod(p - (d)*0.5, (d)) - 0.5*(d)\n\nfloat r11(float i){ return fract(sin(i*12.126)*12.6);}\n\n#define xor(a,b,c) min(max((a),-(b)), max((b),-(a) - c)) \n\nfloat ss( float c, float power, float bias){\n    c = clamp(c,-0.,1.);\n    \/\/c = smoothstep(0.,1.,c);\n    \n    c = pow(c,1. + bias);\n    \n    float a = pow( abs(c), power);\n    float b = 1.-pow( abs(c - 1.), power);\n    \n    return mix(a,b,c);\n}\nfloat valueNoise(float i, float p){ return mix(r11(floor(i)),r11(floor(i) + 1.), ss(fract(i), p,0.6));}\n\nfloat valueNoiseStepped(float i, float p, float steps){ return mix(  floor(r11(floor(i))*steps)\/steps, floor(r11(floor(i) + 1.)*steps)\/steps, ss(fract(i), p,0.6));}\n\n\n\/\/ See: https:\/\/www.shadertoy.com\/view\/ls2Bz1\n\/\/ Spectral Colour Schemes\n\/\/ By Alan Zucconi\n\/\/ Website: www.alanzucconi.com\n\/\/ Twitter: @AlanZucconi\n\n\/\/ Example of different spectral colour schemes\n\/\/ to convert visible wavelengths of light (400-700 nm) to RGB colours.\n\n\/\/ The function \"spectral_zucconi6\" provides the best approximation\n\/\/ without including any branching.\n\/\/ Its faster version, \"spectral_zucconi\", is advised for mobile applications.\n\n\n\/\/ Read \"Improving the Rainbow\" for more information\n\/\/ http:\/\/www.alanzucconi.com\/?p=6703\n\n\n\nfloat saturate (float x)\n{\n    return min(1.0, max(0.0,x));\n}\nvec3 saturate (vec3 x)\n{\n    return min(vec3(1.,1.,1.), max(vec3(0.,0.,0.),x));\n}\n\n\/\/ --- Spectral Zucconi --------------------------------------------\n\/\/ By Alan Zucconi\n\/\/ Based on GPU Gems: https:\/\/developer.nvidia.com\/sites\/all\/modules\/custom\/gpugems\/books\/GPUGems\/gpugems_ch08.html\n\/\/ But with values optimised to match as close as possible the visible spectrum\n\/\/ Fits this: https:\/\/commons.wikimedia.org\/wiki\/File:Linear_visible_spectrum.svg\n\/\/ With weighter MSE (RGB weights: 0.3, 0.59, 0.11)\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n\tvec3 y = vec3(1.,1.,1.) - x * x;\n\ty = saturate(y-yoffset);\n\treturn y;\n}\n\n\/\/ --- Spectral Zucconi 6 --------------------------------------------\n\n\/\/ Based on GPU Gems\n\/\/ Optimised by Alan Zucconi\nvec3 spectral_zucconi6 (float x)\n{\n\t\/\/ w: [400, 700]\n\t\/\/ x: [0,   1]\n\n\tconst vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n\tconst vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n\tconst vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n\n\tconst vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n\tconst vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n\tconst vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n\n\treturn\n\t\tbump3y(c1 * (x - x1), y1) +\n\t\tbump3y(c2 * (x - x2), y2) ;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":258,"channel":0}],"code":"\/\/ created by florian berger (flockaroo) - 2016\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ single pass CFD\n\/\/ ---------------\n\/\/ this is some \"computational flockarooid dynamics\" ;)\n\/\/ the self-advection is done purely rotational on all scales. \n\/\/ therefore i dont need any divergence-free velocity field. \n\/\/ with stochastic sampling i get the proper \"mean values\" of rotations \n\/\/ over time for higher order scales.\n\/\/\n\/\/ try changing \"RotNum\" for different accuracies of rotation calculation\n\/\/ for even RotNum uncomment the line #define SUPPORT_EVEN_ROTNUM\n\n#define RotNum 7\n#define SUPPORT_EVEN_ROTNUM\n\n#define Res  iChannelResolution[0]\n#define Res1 iChannelResolution[1]\n\n\/\/#define keyTex iChannel3\n\/\/#define KEY_I texture(keyTex,vec2((105.5-32.0)\/256.0,(0.5+0.0)\/3.0)).x\n\nconst float ang = 2.0*3.1415926535\/float(RotNum);\nmat2 mu = mat2(cos(ang),sin(ang),-sin(ang),cos(ang));\nmat2 mh = mat2(cos(ang*0.5),sin(ang*0.5),-sin(ang*0.5),cos(ang*0.5));\n\nvec4 randS(vec2 uv)\n{\n    return texture(iChannel1,uv*Res.xy\/Res1.xy)-vec4(0.5);\n}\n\nfloat getRot(vec2 pos, vec2 b)\n{\n    vec2 p = b;\n    float rot=0.0;\n    for(int i=0;i<RotNum;i++)\n    {\n        rot+=dot(texture(iChannel0,fract((pos+p)\/Res.xy)).xy-vec2(0.5),p.yx*vec2(1,-1));\n        p = mu*p;\n    }\n    return rot\/float(RotNum)\/dot(b,b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord.xy;\n    float rnd = randS(vec2(float(iFrame)\/Res.x,0.5\/Res1.y)).x;\n    \n    vec2 b = vec2(cos(ang*rnd),sin(ang*rnd));\n    vec2 v=vec2(0);\n    float bbMax=0.7*Res.y; bbMax*=bbMax;\n    for(int l=0;l<20;l++)\n    {\n        if ( dot(b,b) > bbMax ) break;\n        vec2 p = b;\n        for(int i=0;i<RotNum;i++)\n        {\n#ifdef SUPPORT_EVEN_ROTNUM\n            v+=p.yx*getRot(pos+p,-mh*b);\n#else\n            \/\/ this is faster but works only for odd RotNum\n            v+=p.yx*getRot(pos+p,b);\n#endif\n            p = mu*p;\n        }\n        b*=2.0;\n    }\n    \n     vec2 uv = fragCoord\/iResolution.xy; \/\/ Normalized pixel coordinates (from 0 to 1)\n\n\/\/  vec4 col = texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)\/Res.xy));\n\/\/  vec4 col2 = texture(iChannel3,fract((pos+v*vec2(-1,1)*2.0)\/Res.xy));\n\/\/  vec4 blend = mix(col2,col,0.5);\n  \n\/\/  fragColor=blend;\n  \n   vec4 col = texture(iChannel0,fract((pos-v*vec2(-1,1)*2.0)\/Res.xy));\n  vec4 col2 = texture(iChannel2,fract((pos-v*vec2(-1,1)*2.0)\/Res.xy));\n  vec4 col3 = texture(iChannel3,fract((pos+v*vec2(-1,1)*2.0)\/Res.xy));\n\/\/  col = max(col,col2);\n\/\/  col2= min(col,col2);\n  vec4 blend = mix(col,col2,col3);\n \/\/ blend = (blend*0.5)* ((max(col,blend))*0.5)+ ((min(col,blend))*0.5);\n  blend = clamp(blend, 0., 1.);\n  fragColor=blend,(fract((pos-v*vec2(-1,1)*2.0)\/Res.xy));\n  \/\/  fragColor=texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)\/Res.xy));\n    \n    \/\/ add a little \"motor\" in the center\n \/\/   vec2 scr=(fragCoord.xy\/Res.xy)*2.0-vec2(1.0);\n\/\/    fragColor.xy += (0.001*scr.xy \/ (dot(scr,scr)\/0.1+0.3));\n    \n \/\/   if(iFrame<=4 || KEY_I>0.5) fragColor=texture(iChannel2,fragCoord.xy\/Res.xy);\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":258,"src":"\/media\/previz\/buffer01.png","ctype":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":260,"src":"\/media\/previz\/buffer03.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":260,"src":"\/media\/previz\/buffer03.png","ctype":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":260,"src":"\/media\/previz\/buffer03.png","ctype":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":259,"channel":0}],"code":"                                                                                                                                                                                                                                                                                        \/\/ See Image tab for details, also visit:\n\/\/\n\/\/ https:\/\/xemantic.github.io\/shader-web-background\/\n\/\/\n\/\/ In the original shader-web-background these values are provided as uniforms\n\/\/ feel free to play with them and if you will find something prettier than\n\/\/ the equilibrium I established, please send it back to me :)\nconst vec2  iFeedbackZoomCenter       = vec2(0., 0.);\nconst float iFeedbackZoomRate         = .001;\nconst float iFeedbackFadeRate         = .996;\nconst float iFeedbackColorShiftZoom   = .005;\nconst float iFeedbackColorShiftImpact = 0.0001;\nconst vec2  iDrawCenter               = vec2(0., 0.);\nconst float iDrawIntensity            = .1;\nconst float iBlobEdgeSmoothing        = .1;\nconst float iBlob1Radius              = .85;\nconst float iBlob1PowFactor           = 20.;\nconst float iBlob1ColorPulseSpeed     = -.04;\nconst float iBlob2Radius              = .78;\nconst float iBlob2PowFactor           = 20.;\nconst float iBlob2ColorPulseSpeed     = .1234;\nconst float iBlob2ColorPulseShift     = 0.0;\nconst float iColorShiftOfRadius       = 0.5;\nconst float iFeedbackMouseShiftFactor = .003;\n\n\/*\n  Normally it would be provided by texture parameters, but on Mac\/iOS the texture REPEAT\n  seems to work only for power-of-2 texture sizes.\n *\/\nvec4 repeatedTexture(in sampler2D channel, in vec2 uv) {\n    return texture(channel, mod(uv, 1.));\n}\n\nfloat drawBlob(\n    in vec2 st,\n    in vec2 center,\n    in float radius,\n    in float edgeSmoothing\n) {\n    float dist = length((st - center) \/ radius);\n    return dist * smoothstep(1., 1. - iBlobEdgeSmoothing, dist);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \/\/ in shader-web-background provided as uniforms: start\n    float iMinDimension = min(iResolution.x, iResolution.y);\n    vec2 iScreenRatioHalf =\n        (iResolution.x >= iResolution.y)\n            ? vec2(iResolution.y \/ iResolution.x * .5, .5)\n            : vec2(.5, iResolution.x \/ iResolution.y);\n    vec3 iBlob1Color = spectral_zucconi6(\n        mod(iTime * iBlob1ColorPulseSpeed, 1.)\n    );\n    \n    vec3 iBlob2Color = spectral_zucconi6(\n        mod(iTime * iBlob2ColorPulseSpeed + iBlob2ColorPulseShift, 1.)\n    );\n    vec2 iFeedbackShiftVector =\n        (iMouse.x > 0. && iMouse.y > 0.)\n            ? (iMouse.xy * 2. - iResolution.xy) \/ iMinDimension * iFeedbackMouseShiftFactor\n            : vec2(0);\n    \/\/ in shader-web-background provided as uniforms: end\n            \n    \n    vec2 uv = fragCoord \/ iResolution.xy;\n    vec2 st = (fragCoord * 2. - iResolution.xy) \/ iMinDimension;\n\n    vec2  drawDelta = st - iDrawCenter;\n    float drawAngle = atan(drawDelta.x, drawDelta.y);\n    float drawDist = length(drawDelta);\n\nvec3 feedbk = repeatedTexture(iChannel1, uv - st).rgb;\n    vec3 colorShift = repeatedTexture(\n        iChannel0,\n        uv - st * iFeedbackColorShiftZoom * iScreenRatioHalf\n    ).rgb;\n\n    vec2 stShift = vec2(0);\n    stShift += iFeedbackZoomRate * (st - iFeedbackZoomCenter);\n    stShift += (feedbk.br\/colorShift.gr - .5) * iFeedbackColorShiftImpact;\n    stShift += iFeedbackShiftVector;\n    stShift *= iScreenRatioHalf;\n\n    vec3 prevColor = mix(repeatedTexture(iChannel2, uv - stShift).rgb,repeatedTexture(iChannel3, uv - stShift).rgb,repeatedTexture(iChannel1, uv - stShift).rgb);\n     vec3 prevColor2 = repeatedTexture(iChannel2, uv - stShift).rgb+repeatedTexture(iChannel3, uv - stShift).rgb * repeatedTexture(iChannel1, uv - stShift).rgb\/512.;\n    prevColor +=prevColor2\/512.;\n    prevColor *= iFeedbackFadeRate;\n\n    vec3 drawColor = vec3(0);\n   \n\n    float radius =\n        1.\n        + (colorShift.r + colorShift.g + colorShift.b) * iColorShiftOfRadius;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob1Radius, iBlobEdgeSmoothing),\n          iBlob1PowFactor\n        ) * iBlob1Color;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob2Radius, iBlobEdgeSmoothing),\n          iBlob2PowFactor\n        ) * iBlob2Color;\n\n    vec3 color = vec3(0);\n    drawColor *= iDrawIntensity;\n    prevColor *= iFeedbackFadeRate;\n    color += prevColor;\n    color += drawColor;\n\n    color = clamp(color, 0., 1.);\n    fragColor = vec4(color, 1.);\n}\n","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":258,"src":"\/media\/previz\/buffer01.png","ctype":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":260,"src":"\/media\/previz\/buffer03.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":260,"channel":0}],"code":"\/\/ created by florian berger (flockaroo) - 2016\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ single pass CFD\n\/\/ ---------------\n\/\/ this is some \"computational flockarooid dynamics\" ;)\n\/\/ the self-advection is done purely rotational on all scales. \n\/\/ therefore i dont need any divergence-free velocity field. \n\/\/ with stochastic sampling i get the proper \"mean values\" of rotations \n\/\/ over time for higher order scales.\n\/\/\n\/\/ try changing \"RotNum\" for different accuracies of rotation calculation\n\/\/ for even RotNum uncomment the line #define SUPPORT_EVEN_ROTNUM\n\n#define RotNum 7\n\/\/#define SUPPORT_EVEN_ROTNUM\n\n#define Res  iChannelResolution[0]\n#define Res1 iChannelResolution[1]\n\n\/\/#define keyTex iChannel3\n\/\/#define KEY_I texture(keyTex,vec2((105.5-32.0)\/256.0,(0.5+0.0)\/3.0)).x\n\nconst float ang = 2.0*3.1415926535\/float(RotNum);\nmat2 mu = mat2(cos(ang),sin(ang),-sin(ang),cos(ang));\nmat2 mh = mat2(cos(ang*0.5),sin(ang*0.5),-sin(ang*0.5),cos(ang*0.5));\n\nvec4 randS(vec2 uv)\n{\n    return texture(iChannel1,uv*Res.xy\/Res1.xy)-vec4(0.5);\n}\n\nfloat getRot(vec2 pos, vec2 b)\n{\n    vec2 p = b;\n    float rot=0.0;\n    for(int i=0;i<RotNum;i++)\n    {\n        rot+=dot(texture(iChannel0,fract((pos+p)\/Res.xy)).xy-vec2(0.5),p.yx*vec2(1,-1));\n        p = mu*p;\n    }\n    return rot\/float(RotNum)\/dot(b,b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord.xy;\n    float rnd = randS(vec2(float(iFrame)\/Res.x,0.5\/Res1.y)).x;\n    \n    vec2 b = vec2(cos(ang*rnd),sin(ang*rnd));\n    vec2 v=vec2(0);\n    float bbMax=0.7*Res.y; bbMax*=bbMax;\n    for(int l=0;l<20;l++)\n    {\n        if ( dot(b,b) > bbMax ) break;\n        vec2 p = b;\n        for(int i=0;i<RotNum;i++)\n        {\n#ifdef SUPPORT_EVEN_ROTNUM\n            v+=p.yx*getRot(pos+p,-mh*b);\n#else\n            \/\/ this is faster but works only for odd RotNum\n            v+=p.yx*getRot(pos+p,b);\n#endif\n            p = mu*p;\n        }\n        b*=2.0;\n    }\n    \n     vec2 uv = fragCoord\/iResolution.xy; \/\/ Normalized pixel coordinates (from 0 to 1)\n\n\/\/  vec4 col = texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)\/Res.xy));\n\/\/  vec4 col2 = texture(iChannel3,fract((pos+v*vec2(-1,1)*2.0)\/Res.xy));\n\/\/  vec4 blend = mix(col2,col,0.5);\n  \n\/\/  fragColor=blend;\n  \n   vec4 col = texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)\/Res.xy));\n  vec4 col2 = texture(iChannel2,fract((pos+v*vec2(-1,1)*2.0)\/Res.xy));\n  vec4 col3 = texture(iChannel3,fract((pos+v*vec2(-1,1)*2.0)\/Res.xy));\n\/\/  col = max(col,col2);\n\/\/  col2= min(col,col2);\n  vec4 blend = mix(col,col2,col3);\n \/\/ blend = (blend*0.5)* ((max(col,blend))*0.5)+ ((min(col,blend))*0.5);\n  blend = clamp(blend, 0., 1.);\n  fragColor=blend,(fract((pos+v*vec2(-1,1)*2.0)\/Res.xy));\n  \/\/  fragColor=texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)\/Res.xy));\n    \n    \/\/ add a little \"motor\" in the center\n \/\/   vec2 scr=(fragCoord.xy\/Res.xy)*2.0-vec2(1.0);\n\/\/    fragColor.xy += (0.001*scr.xy \/ (dot(scr,scr)\/0.1+0.3));\n    \n \/\/   if(iFrame<=4 || KEY_I>0.5) fragColor=texture(iChannel2,fragCoord.xy\/Res.xy);\n}\n","name":"Buffer D","description":"","type":"buffer"}]}}