{
 "ver": "0.1",
 "info": {
  "id": "Nt3BWB",
  "date": "0",
  "viewed": 0,
  "name": "Bubble Magic JiPi",
  "description": "Drag to position the tail target. Try playing with the wobble variables to express different emotions.",
  "likes": 0,
  "published": "Private",
  "usePreview": 0,
  "tags": [
   "2d",
   "ui"
  ],
  "hasliked": 0,
  "parentid": "MltGDH",
  "parentname": "Bubble Magic"
 },
 "renderpass": [
  {
   "inputs": [],
   "outputs": [
    {
     "id": "4dfGRr",
     "channel": 0
    }
   ],
   "code": "\n// Thanks to https://www.shadertoy.com/view/XsX3zB for the 3d simplex noise\n\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\nfloat simplex3d_fractal(vec3 m) {\n    return   0.5333333*simplex3d(m)\n\t\t\t+0.2666667*simplex3d(2.0*m)\n\t\t\t+0.1333333*simplex3d(4.0*m)\n\t\t\t+0.0666667*simplex3d(8.0*m);\n}\n\nvec2 rotate( vec2 p, float rad )\n{\n    float c = cos(rad);\n    float s = sin(rad);\n    mat2  m = mat2(c,-s,s,c);\n    return m*p;\n}\n\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 smin(vec2 a, vec2 b, float k) \n{\n    return vec2(smin(a.x,b.x,k),smin(a.y,b.y,k));\n}\n\n// f(x,y) divided by analytical gradient\nfloat ellipse2(vec2 p, vec2 c, vec2 s)\n{\n    p = p-c;\n    float f = length( p/s );\n    return (f-.5)*f/(length(p/(s*s)));\n}\n    \n\n// signed distance to a 2D triangle\nfloat sdTriangle( in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p )\n{\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    vec2 d = min( min( vec2( dot( pq0, pq0 ), v0.x*e0.y-v0.y*e0.x ),\n                       vec2( dot( pq1, pq1 ), v1.x*e1.y-v1.y*e1.x )),\n                       vec2( dot( pq2, pq2 ), v2.x*e2.y-v2.y*e2.x ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\nfloat udRoundBox( vec2 p, vec2 c, vec2 b, float r )\n{\n  return length(max(abs(p-c)-b,0.0))-r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    vec2 mouse = iMouse.xy / iResolution.y;\n    //vec2 uv = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n    float px = 2.0/iResolution.y;\n    float ratio = iResolution.x/iResolution.y;\n    mouse.x = max(mouse.x,.5*ratio-.4);\n    mouse.x = min(mouse.x,.5*ratio+.4);\n    mouse.y = max(mouse.y,.2);\n    mouse.y = min(mouse.y,.8);\n    \n    vec3 col = vec3(0.0);\n    vec3 emi = vec3(0.0);\n    \n    // board\n    {\n        col = 0.6*vec3(0.4,0.6,0.7)*(1.0-0.4*length( uv ));\n        col *= 1.0 - 0.25*smoothstep( 0.05,0.15,sin(uv.x*140.0)*sin(uv.y*140.0));\n    }\n    \n    const bool box = true; // Set to false for elliptical bubble, true for rounded rectangle\n    const bool bubbly = true; // Set to true for \"thought bubble\" bulbous protrusions\n    \n    float width = .5;\n    float height = .25;\n    float tailW = .075; // Should not be larger than half the smallest dimension\n    float tailRounding = 2.; // Will expand the tail by x pixels\n    float tailTwist = -1.5; // \n    float joinSmoothing = .05;\n    \n    float wobbleSize = 0.25;\n    float wobbleFrequency = 0.5;\n    float bodyWobble = 0.075;\n    float tailWobble = 0.005;\n    \n    \n    vec2 shadowOffset = vec2(-5.5,5.5)*px;\n    \n    float rounding = width*0.15;\n    vec3 color = vec3(.5,.5,.85); // Blue\n        \t\t //vec3(.75,.5,.25); // Orange\n    \n    vec2 bcen = vec2(.5*ratio,.5); \n    float alp = .75;\n    float mouseDist = length(mouse-bcen);\n    float rotation = tailTwist*sign((bcen - mouse).x)*sign((bcen - mouse).y);//*(mouse-bcen).x*-sign((mouse-bcen).y);\n    vec2 offset = normalize(vec2(-(bcen - mouse).y,(bcen - mouse).x));\n    \n    //vec2 uvb = uv + fbm4(uv/wobbleSize,iTime*wobbleFrequency)*wobbleAmplitude;\n    float noise = simplex3d(vec3(uv/wobbleSize,iTime*wobbleFrequency));\n    if(bubbly) noise = -pow(abs(noise),0.75);\n    \n    float fshad = smin(sdTriangle(bcen+tailW*offset,bcen-tailW*offset,\n                              rotate(mouse-bcen,mouseDist*rotation)+bcen,\n                              rotate(uv+shadowOffset-bcen,length(uv+shadowOffset-bcen)*rotation)+bcen)-tailRounding*px+tailWobble*noise, \n                   box?udRoundBox( uv+shadowOffset, bcen, 0.5*vec2(width,height)-rounding, rounding )+noise*bodyWobble: \n                   ellipse2(uv+shadowOffset, bcen, vec2(width,height))+noise*bodyWobble,\n                       joinSmoothing);\n    \n    float f = smin(sdTriangle(bcen+tailW*offset,bcen-tailW*offset,\n                              rotate(mouse-bcen,mouseDist*rotation)+bcen,\n                              rotate(uv-bcen,length(uv-bcen)*rotation)+bcen)-tailRounding*px+tailWobble*noise, \n                   box?udRoundBox( uv, bcen, 0.5*vec2(width,height)-rounding, rounding )+noise*bodyWobble:\n                   ellipse2(uv, bcen, vec2(width,height))+noise*bodyWobble,\n                   joinSmoothing);\n    col -= smoothstep(.05,-.05,fshad)*.15;\n\n    color *= 0.7 + 0.3*smoothstep( -3.0*px, -1.0*px, f );\n    color *= 0.75 + 8.*smoothstep( -3.0*px, -1.0*px, f );\n    col = mix( col, color, alp*(1.0-smoothstep( -px*2., px*1., f )) );\n\n\tfragColor = vec4(col,1.0);\n}",
   "name": "Image",
   "description": "",
   "type": "image"
  }
 ]
}