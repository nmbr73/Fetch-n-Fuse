{"Shader":{"ver":"0.1","info":{"id":"MdtGD2","date":"1452833920","viewed":1258,"name":"2d particle fluid test","username":"RavenWorks","description":"Messing around with the Multipass capabilities! Started this ages ago, but only finished it now&amp;hellip; The math is a huge kludge, but isn't that half the fun of ShaderToy ;) [b]Press+hold to move the slime.[\/b]","likes":15,"published":3,"flags":32,"usePreview":0,"tags":["2d","fluid","blob","slime","goo","physics","particle","multipass"],"hasliked":0},"renderpass":[{"inputs":[{"id":6,"src":"\/media\/a\/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","ctype":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":258,"src":"\/media\/previz\/buffer01.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":259,"src":"\/media\/previz\/buffer02.png","ctype":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":37,"channel":0}],"code":"\/\/COMPOSITE\n\nconst vec3 lightPt = vec3(0.5,0.75,0.0);\nconst float diffuseCheat = 0.85;\nconst vec3 baseColor = vec3(0.0,1.0,0.0);\nconst float specP = 8.0;\nconst float specA = 0.75;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    vec4 normalData = texture(iChannel0,fragCoord\/iResolution.xy);\n    \n    vec3 color = texture(iChannel2,fragCoord\/iResolution.x).xyz;\n    \n    if (normalData.a > 0.0) {\n        \n        vec3 normal = -normalData.xyz;\n        vec3 intersectPt = vec3(fragCoord\/iResolution.x,1.0-normal.z*0.1);\n        vec3 curCameraRayUnit = normalize(intersectPt);\/\/not quite correct but whatever\n        \n        vec3 lightGap = lightPt-intersectPt;\n        vec3 lightGapNorm = normalize(lightGap);\n        float litAmt = dot(normal,lightGapNorm);\n        litAmt = litAmt*(1.0-diffuseCheat)+diffuseCheat;\n\n        float lightDist = length(lightGap);\n        lightDist \/= 16.0;\n        lightDist = max(lightDist,0.0);\n        lightDist = min(lightDist,1.0);\n        lightDist = pow(1.0-lightDist,2.0);\n\n        float specular = max(0.0,dot(normalize(lightGapNorm-curCameraRayUnit),normal));\n\n        color *= (-normal.z)*0.75;\n        color += baseColor*litAmt*lightDist + pow(specular,specP)*specA;\n        \n    } else {\n    \tcolor.g += (texture(iChannel1,fragCoord\/iResolution.xy).r > 0.1) ? 0.5 : 0.0;\n    }\n    \n    fragColor = vec4(min(vec3(1.0),color),1.0);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":257,"channel":0}],"code":"\/\/PHYSICS\nconst float ballRad = 0.01;\nconst float ballCount = 200.0;\n\nvec2 coordToWorld(vec2 fragCoord){\n    vec2 uv = fragCoord\/iResolution.xy;\n    uv.y \/= (iResolution.x\/iResolution.y);\n    uv.y = 1.0-uv.y;\n    return uv;\n}\n\n\/\/\n\n\n\nconst float gravity = 0.001;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    if (fragCoord.y != 0.5 || fragCoord.x >= ballCount+0.5) return;\n    \n    \n    if (iFrame == 0) {\n    \t\n        fragColor = vec4(0.25+fragCoord.x*0.003,0.5+fragCoord.x*0.00005,0.0,0.0);\n        \n    } else {\n        \n        \n        \n        vec4 myData = texture(iChannel0,fragCoord\/iResolution.xy);\n        myData.a += gravity;\n        \n        myData.rg += myData.ba;\n        \n        \n        vec4 myDataOff = vec4(0.0);\n        float intersections = 0.0;\n        \n        for(float i=0.0; i<ballCount; i++){\n            \n            if (intersections < 4.0) {\/\/arbitrary\n\n                vec2 otherCoord = vec2(i,0) + vec2(0.5);\n                if (length(otherCoord-fragCoord) == 0.0) continue;\/\/skip test against self\n\n                vec4 otherData = texture(iChannel0,otherCoord\/iResolution.xy);\n                vec2 gap = myData.xy-otherData.xy;\n                float gapdist = length(gap);\n                \n                if (gapdist < ballRad*0.5) {\/\/fix interlock\n                    \/\/ this DOESN'T move the other particle -- it just lies about my sense of where it is!\n                    float ejectAng = otherCoord.x+otherCoord.y;\n                    otherData.xy += vec2(cos(ejectAng),sin(ejectAng))*ballRad*0.01;\n\n                    gap = myData.xy-otherData.xy;\n                    gapdist = length(gap);\n                }\n                if (gapdist < ballRad*2.0) {\n                    vec2 gapnorm = normalize(gap);\n                    float myVelAlongCollisionAxis = myData.b*gapnorm.x + myData.a*gapnorm.y;\n                    float otherVelAlongCollisionAxis = otherData.b*gapnorm.x + otherData.a*gapnorm.y;\n\n                    myDataOff.ba += (otherVelAlongCollisionAxis-myVelAlongCollisionAxis)*gapnorm*0.5;\n                    myDataOff.rg += ((ballRad*2.0-gapdist)*0.5)*gapnorm;\n                    intersections++;\n                }\n\n            }\n            \n        }\n        \n        myData.rg += myDataOff.rg;\n        myData.ba += myDataOff.ba;\n        \n        \n        \n        \n        if (iMouse.z > 0.0) {\n        \tvec2 worldMouse = coordToWorld(iMouse.xy);\n            vec2 mouseGap = worldMouse-myData.rg;\n            float mouseGapDist = length(mouseGap);\n            vec2 mouseGapNorm = normalize(mouseGap);\n            \n            float pullStrength = mouseGapDist\/0.9;\n            pullStrength = min(1.0,max(pullStrength,0.0));\n            pullStrength = pow(pullStrength,0.75);\n            pullStrength = sin((pullStrength-0.25)*6.28)*0.5+0.5;\n            pullStrength *= 0.0013;\n            \n            myData.ba += mouseGapNorm*pullStrength;\n        }\n        \n        if (myData.g > 1.0-ballRad) {\n            myData.a += -abs(myData.a)*1.5;\n            myData.g = 1.0-ballRad;\n        }\n        if (myData.g < ballRad) {\n            myData.a += abs(myData.a)*1.5;\n            myData.g = ballRad;\n        }\n        if (myData.r > 1.0-ballRad) {\n            myData.b += -abs(myData.b)*1.5;\n            myData.r = 1.0-ballRad;\n        }\n        if (myData.r < ballRad) {\n            myData.b += abs(myData.b)*1.5;\n            myData.r = ballRad;\n        }\n        \n        myData.ba = myData.ba*0.95;\n        \n        fragColor = myData;\n        \n    }\n    \n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":258,"channel":0}],"code":"\/\/CURRENT FRAME'S BLOB\nconst float ballRad = 0.01;\nconst float ballCount = 200.0;\n\nvec2 coordToWorld(vec2 fragCoord){\n    vec2 uv = fragCoord\/iResolution.xy;\n    uv.y \/= (iResolution.x\/iResolution.y);\n    uv.y = 1.0-uv.y;\n    return uv;\n}\n\n\/\/\n\n\n\/\/#define DEBUGVIEW\n\nfloat mySmooth( float a, float b, float k ){\n    float h = clamp(0.5+0.5*(b-a)\/k,0.0,1.0);\n    return mix(b,a,h) - k*h*(1.0-h);\n}\n\nfloat blobDist(vec2 uv){\n    \n    float dist = 9999.9;\n    \n    for(float i=0.0; i<ballCount; i++){\n        vec4 curData = texture(iChannel0,vec2(i+0.5,0.5)\/iResolution.xy);\n        float curDist = length(curData.rg-uv);\n        #ifdef DEBUGVIEW\n        dist = min(dist,curDist);\n        #else\n        dist = mySmooth(dist,curDist,0.07);\n        #endif\n    }\n    \n    return dist;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n        \n    \n\n    vec2 uv = coordToWorld(fragCoord);\n\n    float dist = blobDist(uv);\n    \n    \n    \n    \n    #ifdef DEBUGVIEW\n    fragColor = vec4( (dist < ballRad) ? 1.0 : 0.0 );\n    #else\n    \n    \n    \n    float height = 1.0-dist\/ballRad*0.3;\n    if (height >= 0.0) {\n        height = min(1.0,max(0.0,height));\n        height = height*1.57;\n        \n        const vec2 e = vec2(0.00001,0.0);\n        vec2 normal2d = normalize(vec2(dist-blobDist(uv-e.xy),\n                                       dist-blobDist(uv-e.yx)));\n        \n        vec3 normal3d = vec3(normal2d.x*cos(height),normal2d.y*cos(height),sin(height));\n\n        fragColor = vec4(normal3d,1.0);\n    } else {\n    \tfragColor = vec4(0.0);   \n    }\n    \n    #endif\n    \n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":258,"src":"\/media\/previz\/buffer01.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":259,"src":"\/media\/previz\/buffer02.png","ctype":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":259,"channel":0}],"code":"\/\/TRAIL\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    vec4 curFrame = texture(iChannel0,fragCoord\/iResolution.xy);\n    vec4 oldFrame = texture(iChannel1,fragCoord\/iResolution.xy);\n    \n    fragColor = vec4(oldFrame.a*0.9+curFrame.a*curFrame.z);\n    \n}","name":"Buf C","description":"","type":"buffer"}]}}