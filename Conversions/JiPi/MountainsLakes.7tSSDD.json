{"Shader":{"ver":"0.1","info":{"id":"7tSSDD","date":"1627840518","viewed":1894,"name":"Mountains & Lakes","username":"xjorma","description":"Use the mouse to turn around!\nSuper fast even on my slow Pixel 2!\nWater simulation inspired by this:\nhttps:\/\/hal.inria.fr\/inria-00402079\/document\n","likes":83,"published":3,"flags":32,"usePreview":0,"tags":["terrain","simulation","water","fluid","liquid","river","lake","mountain","diorama"],"hasliked":0},"renderpass":[{"inputs":[{"id":48,"src":"\/media\/a\/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":259,"src":"\/media\/previz\/buffer02.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":37,"channel":0}],"code":"\/\/ Created by David Gallardo - xjorma\/2021\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\n#define AA\n#define GAMMA 1\n\nconst vec3 light = vec3(0.,4.,2.);\nconst float boxHeight = 0.45;\n\n\/*\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 p = ivec2(fragCoord);\n    float h = texelFetch(iChannel0, p, 0).x;\n    float w = texelFetch(iChannel1, p, 0).x; \n    fragColor = vec4(h, w, w, 1.0);\n}*\/\n\n\nvec2 getHeight(in vec3 p)\n{\n    p = (p + 1.0) * 0.5;\n    vec2 p2 = p.xz * vec2(float(textureSize)) \/ iResolution.xy;\n    p2 = min(p2, vec2(float(textureSize) - 0.5) \/ iResolution.xy);\n\t\/\/float h = texture(iChannel0, p2).x;\n\t\/\/float w = h + texture(iChannel1, p2).x;\n    vec2 h = texture(iChannel0, p2).xy;\n    h.y += h.x;\n\treturn h - boxHeight;\n} \n\nvec3 getNormal(in vec3 p, int comp)\n{\n    float d = 2.0 \/ float(textureSize);\n    float hMid = getHeight(p)[comp];\n    float hRight = getHeight(p + vec3(d, 0, 0))[comp];\n    float hTop = getHeight(p + vec3(0, 0, d))[comp];\n    return normalize(cross(vec3(0, hTop - hMid, d), vec3(d, hRight - hMid, 0)));\n}\n\nvec3 terrainColor(in vec3 p, in vec3 n, out float spec)\n{\n    spec = 0.1;\n    vec3 c = vec3(0.21, 0.50, 0.07);\n    float cliff = smoothstep(0.8, 0.3, n.y);\n    c = mix(c, vec3(0.25), cliff);\n    spec = mix(spec, 0.3, cliff);\n    float snow = smoothstep(0.05, 0.25, p.y) * smoothstep(0.5, 0.7, n.y);\n    c = mix(c, vec3(0.95, 0.95, 0.85), snow);\n    spec = mix(spec, 0.4, snow);\n    vec3 t = texture(iChannel1, p.xz * 5.0).xyz;\n    return mix(c, c * t, 0.75);\n}\n\nvec3 undergroundColor(float d)\n{\n    vec3 color[4] = vec3[](vec3(0.5, 0.45, 0.5), vec3(0.40, 0.35, 0.25), vec3(0.55, 0.50, 0.4), vec3(0.45, 0.30, 0.20));\n    d *= 6.0;\n    d = min(d, 3.0 - 0.001);\n    float fr = fract(d);\n    float fl = floor(d);\n    return mix(color[int(fl)], color[int(fl) + 1], fr);\n}\n\n\n\nvec3 Render(in vec3 ro, in vec3 rd)\n{\n    vec3 n;\n    vec2 ret = boxIntersection(ro, rd, vec3(1, boxHeight, 1), n);\n    if(ret.x > 0.0)\n    {\n        vec3 pi = ro + rd * ret.x;\n        \/\/ Find Terrain\n        vec3 tc;\n        vec3 tn;\n        float tt = ret.x;\n        vec2 h = getHeight(pi);\n        float spec;\n        if(pi.y < h.x)\n        {\n            tn = n;\n            tc = undergroundColor(h.x - pi.y);\n        }\n        else\n        {\n            for (int i = 0; i < 80; i++)\n            {\n                vec3 p = ro + rd * tt;\n                float h = p.y - getHeight(p).x;\n                if (h < 0.0002 || tt > ret.y)\n                    break;\n                tt += h * 0.4;\n            }\n            tn = getNormal(ro + rd * tt, 0);\n            tc = terrainColor(ro + rd * tt, tn, spec);\n        }\n        \n        {\n            vec3 lightDir = normalize(light - (ro + rd * tt));\n            tc = tc * (max( 0.0, dot(lightDir, tn)) + 0.3);\n            spec *= pow(max(0., dot(lightDir, reflect(rd, tn))), 10.0);\n            tc += spec;            \n        }\n        \n        if(tt > ret.y)\n        {\n            tc = backgroundColor;\n        }\n        \n        \/\/ Find Water\n        float wt = ret.x;\n        h = getHeight(pi);\n        vec3 waterNormal;\n        if(pi.y < h.y)\n        {\n            waterNormal = n;\n        }\n        else\n        {\n            for (int i = 0; i < 80; i++)\n            {\n                vec3 p = ro + rd * wt;\n                float h = p.y - getHeight(p).y;\n                if (h < 0.0002 || wt > min(tt, ret.y))\n                    break;\n                wt += h * 0.4;\n            }\n            waterNormal = getNormal(ro + rd * wt, 1);\n        }\n        \n        if(wt < ret.y)\n        {\n            float dist = (min(tt, ret.y) - wt);\n            vec3 p = waterNormal;\n            vec3 lightDir = normalize(light - (ro + rd * wt));\n                        \n            tc = applyFog( tc, vec3(0,0,0.4), dist * 15.0);\n\n            float spec = pow(max(0., dot(lightDir, reflect(rd, waterNormal))), 20.0);\n            tc += 0.5 * spec * smoothstep(0.0, 0.1, dist);\n        }\n\n        \n        return tc;\n    }\n   \n    return backgroundColor;\n}\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 up = vec3(0, 1, 0);\n\tvec3 cu = normalize( cross(cw,up) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvec3 vignette(vec3 color, vec2 q, float v)\n{\n    color *= 0.3 + 0.8 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), v);\n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 tot = vec3(0.0);\n    \n    vec2 mouse = iMouse.xy;\n    if(length(mouse.xy) < 10.0)\n        mouse = iResolution.xy * 0.5;\n        \n#ifdef AA\n\tvec2 rook[4];\n    rook[0] = vec2( 1.\/8., 3.\/8.);\n    rook[1] = vec2( 3.\/8.,-1.\/8.);\n    rook[2] = vec2(-1.\/8.,-3.\/8.);\n    rook[3] = vec2(-3.\/8., 1.\/8.);\n    for( int n=0; n<4; ++n )\n    {\n        \/\/ pixel coordinates\n        vec2 o = rook[n];\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))\/iResolution.y;\n#else \/\/AA\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)\/iResolution.y;\n#endif \/\/AA\n \n        \/\/ camera\n        \n        float theta\t= radians(360.)*(mouse.x\/iResolution.x-0.5) + iTime*.2;\n        float phi\t= radians(90.)*(mouse.y\/iResolution.y-0.5)-1.;\n        vec3 ro = 2.0 * vec3( sin(phi)*cos(theta),cos(phi),sin(phi)*sin(theta));\n        \/\/vec3 ro = vec3(0.0,.2,4.0);\n        vec3 ta = vec3( 0 );\n        \/\/ camera-to-world transformation\n        mat3 ca = setCamera( ro, ta );\n        \/\/vec3 cd = ca[2];    \n        \n        vec3 rd =  ca*normalize(vec3(p,1.5));        \n        \n        vec3 col = Render(ro, rd);\n        \n        tot += col;\n            \n#ifdef AA\n    }\n    tot \/= 4.;\n#endif\n    \n    tot = vignette(tot, fragCoord \/ iResolution.xy, 0.6);\n    #if GAMMA\n    \ttot = pow(tot, vec3(1. \/ 2.2));\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const int textureSize = 256;\n\/\/ Render\nconst vec3 backgroundColor = vec3(0.2);\n\/\/ Terrain\nconst float transitionTime = 5.0;\nconst float transitionPercent = 0.3;\nconst int octaves = 7;\n\/\/ Water simulation\nconst float attenuation = 0.995;\nconst float strenght = 0.25;\nconst float minTotalFlow = 0.0001;\nconst float initialWaterLevel = 0.05;\n\nmat2 rot(in float ang) \n{\n   return mat2(\n\t\t\tcos(ang), -sin(ang),\n\t\t\tsin(ang),  cos(ang));\n}\n\n\/\/ hash from Dave_Hoskins https:\/\/www.shadertoy.com\/view\/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\/\/ Box intersection by IQ https:\/\/iquilezles.org\/articles\/boxfunctions\n\nvec2 boxIntersection( in vec3 ro, in vec3 rd, in vec3 rad, out vec3 oN ) \n{\n    vec3 m = 1.0 \/ rd;\n    vec3 n = m * ro;\n    vec3 k = abs(m) * rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if( tN > tF || tF < 0.0) return vec2(-1.0); \/\/ no intersection\n    \n    oN = -sign(rd)*step(t1.yzx, t1.xyz) * step(t1.zxy, t1.xyz);\n\n    return vec2( tN, tF );\n}\n\n\n\/\/ Fog by IQ https:\/\/iquilezles.org\/articles\/fog\n\nvec3 applyFog( in vec3  rgb, vec3 fogColor, in float distance)\n{\n    float fogAmount = exp( -distance );\n    return mix( fogColor, rgb, fogAmount );\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":259,"src":"\/media\/previz\/buffer02.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":260,"src":"\/media\/previz\/buffer03.png","ctype":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":257,"channel":0}],"code":"\/\/ compute Terrain and update water level 1st pass\n\n\nfloat boxNoise( in vec2 p, in float z )\n{\n    vec2 fl = floor(p);\n    vec2 fr = fract(p);\n    fr = smoothstep(0.0, 1.0, fr);    \n    float res = mix(mix( hash13(vec3(fl, z)),             hash13(vec3(fl + vec2(1,0), z)),fr.x),\n                    mix( hash13(vec3(fl + vec2(0,1), z)), hash13(vec3(fl + vec2(1,1), z)),fr.x),fr.y);\n    return res;\n}\n\nfloat Terrain( in vec2 p, in float z, in int octaveNum)\n{\n\tfloat a = 1.0;\n\tfloat f = .0;\n\tfor (int i = 0; i < octaveNum; i++)\n\t{\n\t\tf += a * boxNoise(p, z);\n\t\ta *= 0.45;\n\t\tp = 2.0 * rot(radians(41.0)) * p;\n\t}\n\treturn f;\n}\n\nvec2 readHeight(ivec2 p)\n{\n\tp = clamp(p, ivec2(0), ivec2(textureSize - 1));\n\treturn texelFetch(iChannel0, p, 0).xy;\n} \n\nvec4 readOutFlow(ivec2 p)\n{\n\tif(p.x < 0 || p.y < 0 || p.x >= textureSize || p.y >= textureSize)\n\t\treturn vec4(0);\n\treturn texelFetch(iChannel1, p, 0);\n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ Outside ?\n    if( max(fragCoord.x, fragCoord.y) > float(textureSize) )\n        discard;\n           \n    \/\/ Terrain\n    vec2 uv = fragCoord \/ float(textureSize);\n    float t = iTime \/ transitionTime;\n    float terrainElevation = mix(Terrain(uv * 4.0, floor(t), octaves), Terrain(uv * 4.0, floor(t) + 1.0, octaves), smoothstep(1.0 - transitionPercent, 1.0, fract(t))) * 0.5;\n    \n    \/\/ Water\n    float waterDept = initialWaterLevel;\n    if(iFrame != 0)\n    {\n        ivec2 p = ivec2(fragCoord);\n        vec2 height = readHeight(p);\n        vec4 OutFlow = texelFetch(iChannel1, p, 0);\n        float totalOutFlow = OutFlow.x + OutFlow.y + OutFlow.z + OutFlow.w;\n        float totalInFlow = 0.0;\n        totalInFlow += readOutFlow(p  + ivec2( 1,  0)).z;\n        totalInFlow += readOutFlow(p  + ivec2( 0,  1)).w;\n        totalInFlow += readOutFlow(p  + ivec2(-1,  0)).x;\n        totalInFlow += readOutFlow(p  + ivec2( 0, -1)).y;\n        waterDept = height.y - totalOutFlow + totalInFlow;\n    }\n    fragColor = vec4(terrainElevation, waterDept, 0, 1);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":260,"src":"\/media\/previz\/buffer03.png","ctype":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":258,"channel":0}],"code":"\/\/ Update Outflow 1st pass\n\nvec2 readHeight(ivec2 p)\n{\n\tp = clamp(p, ivec2(0), ivec2(textureSize - 1));\n\treturn texelFetch(iChannel0, p, 0).xy;\n} \n\nfloat computeOutFlowDir(vec2 centerHeight, ivec2 pos)\n{\n\tvec2 dirHeight = readHeight(pos);\n\treturn max(0.0f, (centerHeight.x + centerHeight.y) - (dirHeight.x + dirHeight.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 p = ivec2(fragCoord);\n    \/\/ Init to zero at frame 0\n    if(iFrame == 0)\n    {\n        fragColor = vec4(0);\n        return;\n    }    \n    \n    \/\/ Outside ?\n    if( max(p.x, p.y) > textureSize )\n        discard;\n        \n    \n   \tvec4 oOutFlow = texelFetch(iChannel1, p, 0);\n\tvec2 height = readHeight(p);\n\tvec4 nOutFlow;        \n\tnOutFlow.x = computeOutFlowDir(height, p + ivec2( 1,  0));\n\tnOutFlow.y = computeOutFlowDir(height, p + ivec2( 0,  1));\n\tnOutFlow.z = computeOutFlowDir(height, p + ivec2(-1,  0));\n\tnOutFlow.w = computeOutFlowDir(height, p + ivec2( 0, -1));\n\tnOutFlow = attenuation * oOutFlow + strenght * nOutFlow;\n\tfloat totalFlow = nOutFlow.x + nOutFlow.y + nOutFlow.z + nOutFlow.w;\n\tif(totalFlow > minTotalFlow)\n\t{\n\t\tif(height.y < totalFlow)\n\t\t{\n\t\t\tnOutFlow = nOutFlow * (height.y \/ totalFlow);\n\t\t}\n\t}\n\telse\n\t{\n\t\tnOutFlow = vec4(0);\n\t}\n\n\n    fragColor = nOutFlow;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":258,"src":"\/media\/previz\/buffer01.png","ctype":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":259,"channel":0}],"code":"\/\/ water level 2nd pass\n\nvec2 readHeight(ivec2 p)\n{\n\tp = clamp(p, ivec2(0), ivec2(textureSize - 1));\n\treturn texelFetch(iChannel0, p, 0).xy;\n} \n\nvec4 readOutFlow(ivec2 p)\n{\n\tif(p.x < 0 || p.y < 0 || p.x >= textureSize || p.y >= textureSize)\n\t\treturn vec4(0);\n\treturn texelFetch(iChannel1, p, 0);\n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ Outside ?\n    if( max(fragCoord.x, fragCoord.y) > float(textureSize) )\n        discard;\n           \n    \/\/ Water\n    ivec2 p = ivec2(fragCoord);\n    vec2 height = readHeight(p);\n    vec4 OutFlow = texelFetch(iChannel1, p, 0);\n    float totalOutFlow = OutFlow.x + OutFlow.y + OutFlow.z + OutFlow.w;\n    float totalInFlow = 0.0;\n    totalInFlow += readOutFlow(p  + ivec2( 1,  0)).z;\n    totalInFlow += readOutFlow(p  + ivec2( 0,  1)).w;\n    totalInFlow += readOutFlow(p  + ivec2(-1,  0)).x;\n    totalInFlow += readOutFlow(p  + ivec2( 0, -1)).y;\n    float waterDept = height.y - totalOutFlow + totalInFlow;\n\n    fragColor = vec4(height.x, waterDept, 0, 1);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":258,"src":"\/media\/previz\/buffer01.png","ctype":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":259,"src":"\/media\/previz\/buffer02.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":260,"channel":0}],"code":"\/\/ Update Outflow 2nd pass\n\nvec2 readHeight(ivec2 p)\n{\n\tp = clamp(p, ivec2(0), ivec2(textureSize - 1));\n\treturn texelFetch(iChannel0, p, 0).xy;\n} \n\nfloat computeOutFlowDir(vec2 centerHeight, ivec2 pos)\n{\n\tvec2 dirHeight = readHeight(pos);\n\treturn max(0.0f, (centerHeight.x + centerHeight.y) - (dirHeight.x + dirHeight.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 p = ivec2(fragCoord);\n    \n    \/\/ Outside ?\n    if( max(p.x, p.y) > textureSize )\n        discard;\n        \n    \n   \tvec4 oOutFlow = texelFetch(iChannel1, p, 0);\n\tvec2 height = readHeight(p);\n\tvec4 nOutFlow;        \n\tnOutFlow.x = computeOutFlowDir(height, p + ivec2( 1,  0));\n\tnOutFlow.y = computeOutFlowDir(height, p + ivec2( 0,  1));\n\tnOutFlow.z = computeOutFlowDir(height, p + ivec2(-1,  0));\n\tnOutFlow.w = computeOutFlowDir(height, p + ivec2( 0, -1));\n\tnOutFlow = attenuation * oOutFlow + strenght * nOutFlow;\n\tfloat totalFlow = nOutFlow.x + nOutFlow.y + nOutFlow.z + nOutFlow.w;\n\tif(totalFlow > minTotalFlow)\n\t{\n\t\tif(height.y < totalFlow)\n\t\t{\n\t\t\tnOutFlow = nOutFlow * (height.y \/ totalFlow);\n\t\t}\n\t}\n\telse\n\t{\n\t\tnOutFlow = vec4(0);\n\t}\n\n\n    fragColor = nOutFlow;\n}","name":"Buffer D","description":"","type":"buffer"}]}}