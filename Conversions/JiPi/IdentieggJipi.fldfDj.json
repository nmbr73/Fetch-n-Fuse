{
 "ver": "0.1",
 "info": {
  "id": "fldfDj",
  "date": "0",
  "viewed": 0,
  "name": "IdentiEgg JiPi",
  "description": "Random dyed egg generator inspired by WordPress/Gravatar identicon.\n",
  "likes": 0,
  "published": "Private",
  "usePreview": 0,
  "tags": [
   "color",
   "random",
   "egg",
   "pysanky",
   "pysanka"
  ],
  "hasliked": 0,
  "parentid": "slfXR7",
  "parentname": "IdentiEgg"
 },
 "renderpass": [
  {
   "inputs": [],
   "outputs": [
    {
     "id": "4dfGRr",
     "channel": 0
    }
   ],
   "code": "// Random dyed egg generator inspired by WordPress/Gravatar identicon.\n\n// Common: random egg generation\n// Image: rendering\n\n// Interactive Javascript version:\n// https://harry7557558.github.io/art/dyed-egg/index.html\n\n// =============================== end of description\n\n\n// MODELING\n\nvec3 uEggParameters = vec3(0.0499, 1.1173, -0.1602);\nmat3 uEggOrientation = mat3(1,0,0,0,0.0,1.0,0,-1.0,0.0);\nvec3 uEggTranslation = vec3(0,0,1);\n\nfloat eggEquationPolar(float t) {\n    float s = sin(t);\n    vec3 r = (s*s) * vec3(1.0, exp(-t), cos(t));\n    return 1.0 - dot(r, uEggParameters);\n}\n\nfloat eggSDF(vec3 p) {\n    p = uEggOrientation * (p - uEggTranslation);\n    float d = length(p.xy), z = p.z;\n    float a = atan(abs(d), z);\n    float r = length(vec2(d, z));\n    return r - eggEquationPolar(a);\n}\n\nvec3 getEggNormal(vec3 p) {\n    const float eps = 0.01;\n    return normalize(vec3(\n        eggSDF(p+vec3(eps,0,0))-eggSDF(p-vec3(eps,0,0)),\n        eggSDF(p+vec3(0,eps,0))-eggSDF(p-vec3(0,eps,0)),\n        eggSDF(p+vec3(0,0,eps))-eggSDF(p-vec3(0,0,eps))));\n}\n\n\nbool intersectSphere(vec3 ce, float r, in vec3 ro, in vec3 rd, out float t) {\n    vec3 p = ro-ce;\n    float b = dot(p,rd), c = dot(p,p)-r*r;\n    float delta = b*b-c; if (delta<=0.0) return false;\n    delta = sqrt(delta);\n    t = -b-delta;\n    return true;\n}\n\nbool raymarch(in vec3 ro, in vec3 rd, out float t) {\n    const float eps = 0.001;\n    if (!intersectSphere(uEggTranslation, 1.0+eps, ro, rd, t)) return false;\n    t = max(t, 0.0);\n    ro = ro + rd*t;\n    float t0 = t;\n    t = eps;\n    for (int i=0; i<64; i++) {\n        float dt = 0.9*eggSDF(ro+rd*t);\n        t += dt;\n        if (dt < eps) {\n            vec3 p = ro+rd*t;\n            t += t0;\n            return true;\n        }\n        if (dt>2.0) break;\n    }\n    return false;\n}\n\n\n#define ID_PLANE 0\n#define ID_EGG 1\n\nbool intersectScene(in vec3 ro, in vec3 rd, out float min_t, out vec3 min_n, out vec3 fcol, out int intersect_id) {\n    float t;\n    vec3 n;\n    min_t = 1e+6;\n    intersect_id = -1;\n\n    // intersect with the egg\n    if (raymarch(ro, rd, t)) {\n        min_t = t, min_n = getEggNormal(ro+rd*t);\n        vec3 p = uEggOrientation*(ro+rd*t-uEggTranslation);\n        fcol = eggTexture(p);\n        fcol *= vec3(0.99, 0.95, 0.81);\n        intersect_id = ID_EGG;\n    }\n\n    // intersect with the plane\n    t = -(ro.z+0.0)/rd.z;\n    if (t > 0.0 && t < min_t) {\n        min_t = t, min_n = vec3(0, 0, 1);\n        fcol = vec3(1.0, 1.0, 0.9);\n        vec2 p = ro.xy+rd.xy*t;\n        if (mod(floor(p.x)+floor(p.y),2.0)==0.0) fcol*=0.9;\n        intersect_id = ID_PLANE;\n    }\n\n    if (dot(rd, min_n) > 0.0) min_n = -min_n;\n\n    return intersect_id != -1;\n}\n\n\n// RENDERING\n\nconst vec3 light = vec3(3, 3, 10);\n\n\nfloat calcSoftShadow(vec3 ro, float k) {\n    vec3 rd = light - ro;\n    float col = 1.0;\n    float t = 0.1;\n    float maxt = length(rd);\n    for (int i=0; i<8; i++){\n        float h = eggSDF(ro + rd*t);\n        col = min(col, smoothstep(0.0, 1.0, k*h/t));\n        t += clamp(h, 0.01, 0.2);\n        if (h<0. || t>maxt) break;\n    }\n    return max(col, 0.);\n}\n\nfloat calcAO(vec3 p, vec3 n) {\n    float t = 0.12;\n    vec3 q = p+n*t;\n    float sd = min(eggSDF(q), q.z);\n    float occ = (t - sd)*2.0;\n    return smoothstep(0.0, 1.0, 1.0-occ);\n}\n\n\nvec3 getShade(vec3 pos, vec3 rd, vec3 n, vec3 fcol, int intersect_id) {\n    vec3 lightdir = light - pos;\n    vec3 ambient = (0.5+0.2*dot(n,vec3(0.5,0.5,0.5)))*vec3(1.0,1.0,1.0)*fcol / (0.02*dot(pos,pos)+1.0);\n    vec3 direct = 3.0*max(dot(n,lightdir)/dot(lightdir,lightdir), 0.0) * fcol;\n    vec3 specular = (intersect_id==ID_EGG?0.05:0.1) * vec3(1.0,0.95,0.9)*pow(max(dot(rd, normalize(lightdir)), 0.0), (intersect_id==ID_EGG?5.0:40.0));\n    float shadow = calcSoftShadow(pos, 0.2);\n    float ao = calcAO(pos, n);\n    return ao*(ambient+shadow*(direct+specular));\n}\n\nvec3 traceRay(vec3 ro, vec3 rd) {\n\n    float t;\n    vec3 n;\n    vec3 fcol;\n    int intersect_id;\n    if (!intersectScene(ro, rd, t, n, fcol, intersect_id)) {\n        return vec3(0.0);\n    }\n\n    ro = ro + rd*t;\n    vec3 refl = rd - 2.0*dot(rd, n)*n;\n    vec3 col_direct = getShade(ro, refl, n, fcol, intersect_id);\n    vec3 n0 = n;\n\n    if (intersect_id==ID_EGG) return col_direct;\n\n    vec3 col_refl = vec3(0.0);\n    if (intersectScene(ro+0.01*refl, refl, t, n, fcol, intersect_id)) {\n        col_refl = getShade(ro+refl*t, refl-2.0*dot(refl,n)*n, n, fcol, intersect_id);\n    }\n    else col_refl = vec3(pow(max(dot(refl, normalize(light-ro)), 0.0), 2.0)/(0.02*dot(ro,ro)+1.0));\n\n    return mix(col_direct, col_refl, 0.3+0.2*pow(1.0-abs(dot(refl,n0)),5.0));\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    uint seed = uint(iTime);\n    if (seed>1u) {\n        // random egg texture\n        calcTextureParameters(seed);\n    \n        // random egg shape\n        // the Javascript version has a physically-based (but probably buggy) shape orientation calculation\n        uEggParameters = randomEggShape(seed);\n    }\n    uEggTranslation = vec3(0,0,eggEquationPolar(.5*PI));\n\n    // between -1 and 1\n    vec2 uv = 2. * fragCoord/iResolution.xy - 1.;\n\n    // barrel distortion from https://www.shadertoy.com/view/wslcDS by Shane\n    float r = dot(uv, uv);\n    uv *= 1. + vec2(.03,.02)*(r*r + r);\n\n    // calculate projection\n    float rx = iMouse.w>=0. ? 0.2 : 1.7*iMouse.y/iResolution.y-0.1;\n    float rz = iMouse.w>=0. ? -0.5 : 6.3*iMouse.x/iResolution.x-2.8;\n    vec3 w = vec3(cos(rx)*vec2(cos(rz),sin(rz)), sin(rx));\n    vec3 u = vec3(-sin(rz),cos(rz),0);\n    vec3 v = cross(w,u);\n\n    // camera position\n    vec3 cam = 6.*w + vec3(0, 0, 0.6);\n    if (cam.z < 0.) {\n        cam -= w * (cam.z/w.z+1e-3);  // prevent below horizon\n    }\n\n    // generate ray\n    vec3 rd = normalize(mat3(u,v,-w)*vec3(uv*iResolution.xy, 2.*length(iResolution)));\n    vec3 col = traceRay(cam, rd);\n\n    // adjustment\n    float gamma = 1.2;\n    col = vec3(pow(col.x,gamma), pow(col.y,gamma), pow(col.z,gamma));\n    col = 1.2*col-0.05;\n    fragColor = vec4(col, 1);\n}\n",
   "name": "Image",
   "description": "",
   "type": "image"
  },
  {
   "inputs": [],
   "outputs": [],
   "code": "#define PI 3.1415926\n\n// egg texture parameters\nint uCapShape = 11;\nivec4 uCapShapeOrient = ivec4(0,1,1,0);\nvec3 uCapCol1 = vec3(0.9,0.5,0.5);\nvec3 uCapCol2 = vec3(0.5,0.9,0.9);\nint uRingShape = 21;\nivec4 uRingShapeOrient = ivec4(1,1,0,1);\nvec3 uRingCol1 = vec3(0.5,0.5,0.9);\nvec3 uRingCol2 = vec3(0.5,0.9,0.5);\nint uBodyShape = 43;\nivec4 uBodyShapeOrient = ivec4(1,1,1,0);\nvec3 uBodyCol1 = vec3(0.9,0.9,0.5);\nvec3 uBodyCol2 = vec3(0.5,0.9,0.9);\nint uMidShape = 28;\nivec4 uMidShapeOrient = ivec4(0,0,0,1);\nvec3 uMidCol1 = vec3(0.9,0.8,0.7);\nvec3 uMidCol2 = vec3(0.7,0.5,1.0);\n\n// random\nuint randint(inout uint seed) {\n    return seed = seed*1664525u+1013904223u;\n}\nfloat randfloat(inout uint seed) {\n    return float(randint(seed))/4294967296.0;\n}\nivec4 randvec4(inout uint seed) {\n    uint k = randint(seed)>>4u;\n    return ivec4(k&1u,(k>>1u)&1u,(k>>2u)&1u,(k>>3u)&1u);\n}\nfloat hue2rgb(float t) {\n    if (t<0.0) t+=6.0;\n    if (t>6.0) t-=6.0;\n    if (t<1.0) return t;\n    if (t<3.0) return 1.0;\n    if (t<4.0) return 4.0-t;\n    return 0.0;\n}\nvec3 hsl2rgb(float h, float s, float l) {\n    h*=6.0;\n    float mx = l<=0.5 ? l*(s+1.0) : l+s-l*s;\n    float mn = 2.0*l-mx;\n    float r = mn+(mx-mn)*hue2rgb(h+2.0);\n    float g = mn+(mx-mn)*hue2rgb(h);\n    float b = mn+(mx-mn)*hue2rgb(h-2.0);\n    return vec3(r,g,b);\n}\nvec3 randcol(inout uint seed) {\n    float hue = randfloat(seed);\n    float sat = 0.7+0.3*randfloat(seed);\n    float bri = 0.7+0.25*randfloat(seed);\n    return hsl2rgb(hue, sat, bri);\n}\n\n// random texture parameters\nvoid calcTextureParameters(inout uint seed) {\n    randint(seed);\n    uCapShape = int(randint(seed)%44u);\n    uCapShapeOrient = randvec4(seed);\n    uCapCol1 = randcol(seed);\n    uCapCol2 = randcol(seed);\n    uRingShape = int(randint(seed)%44u);\n    uRingShapeOrient = randvec4(seed);\n    uRingCol1 = randcol(seed);\n    uRingCol2 = randcol(seed);\n    uBodyShape = int(randint(seed)%44u);\n    uBodyShapeOrient = randvec4(seed);\n    uBodyCol1 = randcol(seed);\n    uBodyCol2 = randcol(seed);\n    uMidShape = int(randint(seed)%44u);\n    uMidShapeOrient = randvec4(seed);\n    uMidCol1 = randcol(seed);\n    uMidCol2 = randcol(seed);\n}\n\n\n// Gravatar identicon components, total 44\n// Reference: https://barro.github.io/2018/02/avatars-identicons-and-hash-visualization/\n\n// return a signed number, -1 < u,v < 1\nfloat identiconComponent_raw(int id, float u, float v) {\n    if (id==0) return v;\n    if (id==1) return u-v-2.0;\n    if (id==2) return u+v;\n    if (id==3) return abs(v)-0.5*(u+1.0);\n    if (id==4) return abs(u)+abs(v)-1.0;\n    if (id==5) return abs(u+v)-(u-v+2.0)/3.0;\n    if (id==6) return max(abs(v)-0.5*(u+1.0),-max(abs(v)-0.5*(-u+1.0),-u));\n    if (id==7) return max(abs(u+v)-(u-v+2.0)/3.0,u-v-1.0);\n    if (id==8) return max(abs(u),abs(v))-0.5;\n    if (id==9) return max(min(-u,v),u-v);\n    if (id==10) return max(u,-v);\n    if (id==11) return max(u+abs(v)-1.0,-u);\n    if (id==12) return max(v-u,-v-u);\n    if (id==13) return max(v-u-1.0,max(u,-v));\n    if (id==14) return u-v+1.0;\n    if (id==15) return u*v;\n    if (id==16) return (v+u)*(v-u);\n    if (id==17) return u-2.0*v+1.0;\n    if (id==18) return min(u-2.0*v+1.0,max(u-2.0*v-1.0,v));\n    if (id==19) return min(u-2.0*v+1.0,max(u-v,v));\n    if (id==20) return max(-u-v,u+2.0*v-1.0);\n    if (id==21) return min(max(min(-u,v),u-v),max(max(-u,v),u-v-1.0));\n    if (id==22) return max(1.0-2.0*abs(v)-u,-1.0+2.0*abs(v)-u);\n    if (id==23) return abs(u)-2.0*abs(v)+1.0;\n    if (id==24) return min(abs(u)-2.0*abs(v)+1.0,abs(u)+2.0*abs(v)-1.0);\n    if (id==25) return abs(u)+abs(v)-0.5;\n    if (id==26) return min(1.0+abs(u)-2.0*abs(v),abs(v)-2.0*abs(u)+1.0);\n    if (id==27) return min(max(abs(v)-u-1.0,u),abs(v)-u);\n    if (id==28) return min(max(2.0*v-u-1.0,u-v),max(2.0*v+u-1.0,-u-v));\n    if (id==29) return min(u-2.0*v+1.0,-u+2.0*v+1.0);\n    if (id==30) return min(min(1.0+abs(u)-2.0*abs(v),abs(v)-2.0*abs(u)+1.0),abs(u)+abs(v)-0.5);\n    if (id==31) return max(abs(abs(u)+abs(v)-0.75)-0.25,min(u,-v));\n    if (id==32) return abs(u)+2.0*abs(v)-1.0;\n    if (id==33) return min(u-v+1.0,min(max(u-v-1.0,max(-u,v)),max(min(-u,v),u-v)));\n    if (id==34) return abs(abs(u)+abs(v)-0.75)-0.25;\n    if (id==35) return min(max(u+2.0*v+1.0,u-2.0*v-1.0),min(max(v-2.0*u+1.0,v+2.0*u-1.0),max(-u-2.0*v+1.0,-u+2.0*v-1.0)));\n    if (id==36) return min(max(u+2.0*v+1.0,u-2.0*v-1.0),max(v-2.0*u+1.0,v+2.0*u-1.0));\n    if (id==37) return min(max(u+2.0*v+1.0,u-2.0*v-1.0),max(-u-2.0*v+1.0,-u+2.0*v-1.0));\n    if (id==38) return max(-u+2.0*abs(v)-1.0,u-abs(v));\n    if (id==39) return max(2.0*abs(v)-u-1.0,min(0.5-u,u-abs(v)));\n    if (id==40) return min(u-v+1.0,v-u+1.0);\n    if (id==41) return min(max(u-2.0*v+1.0,u),max(2.0*v-u+1.0,-u));\n    if (id==42) return max(abs(u)+abs(v)-1.0,abs(u)-abs(v));\n    if (id==43) return min(max(max(u-v,-u-v),v-u-1.0),max(max(v-u,u+v),u-v-1.0));\n    return 0.0;\n}\n\nfloat identiconComponent(vec2 uv, int id, ivec4 orient) {\n    float u = uv.x, v = uv.y;\n    if (orient.x==1) u = uv.y, v = uv.x;\n    if (orient.y==1) u = -u;\n    if (orient.z==1) v = -v;\n    return (orient.w==1?-1.0:1.0) * identiconComponent_raw(id, u, v);\n}\n\n\n// texture on different parts of the egg\n// 0<u,v<1 for all functions except textureCap\n\nvec3 textureCap(float u, float v) {\n    float x = v*cos(4.0*u), y = v*sin(4.0*u);\n    float sd = identiconComponent(vec2(x,y), uCapShape, uCapShapeOrient);\n    return sd<0.0 ? uCapCol1 : uCapCol2;\n    return sd<0.0 ? vec3(0.9, 0.5, 0.5) : vec3(0.5, 0.9, 0.9);\n}\n\nvec3 textureRing(float u, float v) {\n    u = 2.0*u-1.0, v=2.0*v-1.0;\n    float sd = identiconComponent(vec2(u,v), uRingShape, ivec4(0));\n    return sd<0.0 ? uRingCol1 : uRingCol2;\n    return sd<0.0 ? vec3(0.5, 0.5, 0.9) : vec3(0.5, 0.9, 0.5);\n}\n\nvec3 textureBody(float u, float v) {\n    u = 2.0*u-1.0, v=2.0*v-1.0;\n    float sd = identiconComponent(vec2(u,v), uBodyShape, ivec4(0));\n    return sd<0.0 ? uBodyCol1 : uBodyCol2;\n    return sd<0.0 ? vec3(0.9, 0.9, 0.5) :  vec3(0.5, 0.9, 0.9);\n}\n\nvec3 textureMiddle(float u, float v) {\n    u = 2.0*u-1.0, v=2.0*v-1.0;\n    vec3 k = abs(v)<0.4 ? vec3(1.0) : vec3(0.9);\n    float sd = identiconComponent(vec2(u,v), uMidShape, ivec4(0));\n    vec3 col = sd<0.0 ? vec3(0.9,0.8,0.7) : vec3(0.7,0.5,1.0);\n    col = sd<0.0 ? uMidCol1 : uMidCol2;\n    return k * col;\n}\n\n// final egg texture\n\nvec3 eggTexture(vec3 p) {\n    float u = atan(p.x, -p.y), v = (PI-atan(length(p.xy), p.z))/PI;\n    float vn = min(v, 1.0-v);\n\n    vec3 col = vec3(1.0);\n\n    if (vn<0.1) {\n        col = textureCap(v<0.5?u:1.0-u, vn/0.1);\n    }\n    else if (vn<0.2) {\n        float un8r = acos(cos(4.0*u))/PI;\n        col = textureRing(v<0.5?un8r:1.0-un8r, (vn-0.1)/(0.2-0.1));\n    }\n    else if (vn<0.38) {\n        float un8 = fract(u * 4.0 / PI);\n        col = textureBody(v<0.5?un8:1.0-un8, (vn-0.2)/(0.38-0.2));\n    }\n    else {\n        float un8 = u * 4.0 + 0.5*PI;\n        float vn = sin(un8)<0.0 ? v : 1.0-v;\n        col = textureMiddle(fract(un8/PI), (vn-0.38)/(1.0-2.0*0.38));\n    }\n\n    return col;\n}\n\n\n// egg geometry\n\n// generated by tracing+fitting real-world egg pictures and find the distribution of the parameters\n// uniform random inside an ellipsoid, not quite perfect\n\n// return three numbers a,b,c\n// the equation of the section of the egg in polar coordinate is\n// r(t) = 1-sin(t)²(a+b*exp(-t)+c*cos(t)), c(t)=r(t)*vec2(sin(t),cos(t))\nvec3 randomEggShape(inout uint seed) {\n    float u = 2.0*PI * randfloat(seed);\n    float v = 2.0*randfloat(seed)-1.0;\n    float w = pow(randfloat(seed), 1.0/3.0);\n    float x = w * sqrt(1.0-v*v) * cos(u);\n    float y = w * sqrt(1.0-v*v) * sin(u);\n    float z = w * v;\n    return vec3(0.050482,1.191725,-0.211361)\n       + x*vec3(-0.112119,0.866281,-0.16593)\n       + y*vec3(0.0514355,0.0009434,-0.0298296)\n       + z*vec3(0.0212091,0.0098094,0.0368813);\n}\n",
   "name": "Common",
   "description": "",
   "type": "common"
  }
 ]
}