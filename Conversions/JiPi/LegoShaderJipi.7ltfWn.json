{
 "ver": "0.1",
 "info": {
  "id": "7ltfWn",
  "date": "0",
  "viewed": 0,
  "name": "Lego Shader JiPi",
  "description": "ducky :)",
  "likes": 0,
  "published": "Private",
  "usePreview": 0,
  "tags": [
   "lego"
  ],
  "hasliked": 0,
  "parentid": "ftjczd",
  "parentname": "Lego Shader"
 },
 "renderpass": [
  {
   "inputs": [
    {
     "id": "Xsf3zn",
     "filepath": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
     "type": "texture",
     "channel": 0,
     "sampler": {
      "filter": "mipmap",
      "wrap": "repeat",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    }
   ],
   "outputs": [
    {
     "id": "4dfGRr",
     "channel": 0
    }
   ],
   "code": "struct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nmat3 rotationMatrix;\nmat3 rotationMatrix_inv;\n\nfloat smoothMin(float a, float b, float k) {\n    float h = max(k - abs(a - b), 0.0) / k;\n    return min(a, b) - h * h * h * 1.0 / 6.0;\n}\n\nfloat sdSphere(vec3 pos, vec3 spherePos, float sphereRadius) {\n    return distance(pos, spherePos) - sphereRadius;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdBox2( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdBox(vec3 pos, vec3 boxPos, vec3 dimensions) {\n    float x = abs(pos.x - boxPos.x) - dimensions.x * 0.5;\n    float y = abs(pos.y - boxPos.y) - dimensions.y * 0.5;\n    float z = abs(pos.z - boxPos.z) - dimensions.z * 0.5;\n    float d = max(x, max(y, z));\n    return d;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdCylinder(vec3 pos, vec3 cylinderPos, float height, float radius) {\n    float y = abs(pos.y - cylinderPos.y) - height * 0.5;\n    float xz = distance(pos.xz, cylinderPos.xz) - radius;\n    float d = max(xz, y);\n    return d;\n}\n\nfloat sdBrick(vec3 pos, vec3 brickPos, vec2 brickSize) {\n    return sdRoundBox(pos - brickPos, vec3(0.4 * brickSize.x - 0.03, 0.47, 0.4 * brickSize.y - 0.03), 0.03);\n}\n\nfloat sdSmallBrick(vec3 pos, vec3 brickPos, vec2 brickSize) {\n    return sdRoundBox(pos - brickPos, vec3(0.4 * brickSize.x - 0.03, 0.13666, 0.4 * brickSize.y - 0.03), 0.03);\n}\n\nfloat sdKnob(vec3 pos, vec3 knobPos) { \n    return sdRoundedCylinder(pos - knobPos, 0.13, 0.01, 0.16);\n}\n\nfloat sdSmallBrick2x2(vec3 pos, vec3 brickPos) {\n    const float offset = 0.29 * 1.5;\n    const float k = 0.0;\n\n    return min(\n        sdRoundBox(pos - brickPos, vec3(0.77, 0.13666, 0.77), 0.03),\n        min(\n            min(\n                sdRoundedCylinder(pos - (brickPos + vec3(+0.4, 0.1666, +0.4)), 0.13, 0.01, 0.16),\n                sdRoundedCylinder(pos - (brickPos + vec3(-0.4, 0.1666, +0.4)), 0.13, 0.01, 0.16)\n            ),\n            min(\n                sdRoundedCylinder(pos - (brickPos + vec3(-0.4, 0.1666, -0.4)), 0.13, 0.01, 0.16),\n                sdRoundedCylinder(pos - (brickPos + vec3(+0.4, 0.1666, -0.4)), 0.13, 0.01, 0.16)\n            )\n        )\n    );\n}\n\nfloat orangeMap(vec3 pos) {\n    float d = pos.y + 0.1666;\n    float t = (-cos(iTime * 0.3) * 0.5 + 0.5) * 1.2 + 0.05;\n    \n    const vec3 brickSize = vec3(0.8, 1.0, 0.8);\n    \n    if(t > 0.1) {\n        float y = 1.0 - (min(t - 0.1, 0.1) / 0.1);\n    \n        d = min(d, sdSmallBrick(pos, vec3(0.0, 0.0 + y * 10.0, 0.0), vec2(2, 2)));\n        d = min(d, sdKnob(pos, vec3(+0.4, 0.1666 + y * 10.0, +0.4)));\n        d = min(d, sdKnob(pos, vec3(-0.4, 0.1666 + y * 10.0, +0.4)));\n        d = min(d, sdKnob(pos, vec3(-0.4, 0.1666 + y * 10.0, -0.4)));\n        d = min(d, sdKnob(pos, vec3(+0.4, 0.1666 + y * 10.0, -0.4)));\n    }\n    \n    if(t > 0.8) {\n        float y = 1.0 - (min(t - 0.8, 0.1) / 0.1);\n        d = min(d, sdSmallBrick(pos, vec3(0.0, 3.7333+ y * 10.0, -0.8), vec2(2, 2)));\n        d = min(d, sdKnob(pos, vec3(+0.4, 3.9+ y * 10.0, -0.4)));\n        d = min(d, sdKnob(pos, vec3(-0.4, 3.9+ y * 10.0, -0.4)));  \n        d = min(d, sdKnob(pos, vec3(+0.4, 3.9+ y * 10.0, -1.2)));\n        d = min(d, sdKnob(pos, vec3(-0.4, 3.9+ y * 10.0, -1.2)));\n    }\n    \n    return d;\n}\n\nfloat map(vec3 pos) {\n    float d = pos.y + 0.1666;\n    float t = (-cos(iTime * 0.3) * 0.5 + 0.5) * 1.2 + 0.05;\n    \n    const vec3 brickSize = vec3(0.8, 1.0, 0.8);\n    \n    //if(t > 0.1) {\n        float y = 1.0 - (min(t - 0.1, 0.1) / 0.1);\n    \n        d = min(d, sdSmallBrick(pos, vec3(0.0, 0.0 + y * 10.0, 0.0), vec2(2, 2)));\n        d = min(d, sdKnob(pos, vec3(+0.4, 0.1666 + y * 10.0, +0.4)));\n        d = min(d, sdKnob(pos, vec3(-0.4, 0.1666 + y * 10.0, +0.4)));\n        d = min(d, sdKnob(pos, vec3(-0.4, 0.1666 + y * 10.0, -0.4)));\n        d = min(d, sdKnob(pos, vec3(+0.4, 0.1666 + y * 10.0, -0.4)));\n    //}\n    \n    //if(t > 0.2) {\n         y = 1.0 - (min(t - 0.2, 0.1) / 0.1);\n        d = min(d, sdBrick(pos, vec3(0.0, 0.6666+ y * 10.0, 0.4), vec2(2, 1)));\n        d = min(d, sdKnob(pos, vec3(+0.4, 1.1666+ y * 10.0, +0.4)));\n        d = min(d, sdKnob(pos, vec3(-0.4, 1.1666+ y * 10.0, +0.4)));\n    //}\n    \n    //if(t > 0.3) {\n         y = 1.0 - (min(t - 0.3, 0.1) / 0.1);\n        d = min(d, sdSmallBrick(pos, vec3(0.0, 1.3666+ y * 10.0, 0.4), vec2(2, 3)));\n        d = min(d, sdKnob(pos, vec3(+0.4, 1.5333+ y * 10.0, +0.4)));\n        d = min(d, sdKnob(pos, vec3(-0.4, 1.5333+ y * 10.0, +0.4)));        \n        d = min(d, sdKnob(pos, vec3(+0.4, 1.5333+ y * 10.0, +1.2)));\n        d = min(d, sdKnob(pos, vec3(-0.4, 1.5333+ y * 10.0, +1.2)));\n        d = min(d, sdKnob(pos, vec3(+0.4, 1.5333+ y * 10.0, -0.4)));\n        d = min(d, sdKnob(pos, vec3(-0.4, 1.5333+ y * 10.0, -0.4)));\n    //}\n    \n    //if(t > 0.4) {\n         y = 1.0 - (min(t - 0.4, 0.1) / 0.1);\n        d = min(d, sdBrick(pos, vec3(0.0, 2.0666+ y * 10.0, 0.0), vec2(2, 2)));\n        d = min(d, sdKnob(pos, vec3(+0.4, 2.5666+ y * 10.0, +0.4)));\n        d = min(d, sdKnob(pos, vec3(-0.4, 2.5666+ y * 10.0, +0.4)));  \n        d = min(d, sdKnob(pos, vec3(+0.4, 2.5666+ y * 10.0, -0.4)));\n        d = min(d, sdKnob(pos, vec3(-0.4, 2.5666+ y * 10.0, -0.4)));\n    //}\n    \n    //if(t > 0.5) {\n         y = 1.0 - (min(t - 0.5, 0.1) / 0.1);\n        d = min(d, sdBrick(pos, vec3(0.0, 2.0666+ y * 10.0, 1.6), vec2(2, 2)));\n        d = min(d, sdKnob(pos, vec3(+0.4, 2.5666+ y * 10.0, +2.0)));\n        d = min(d, sdKnob(pos, vec3(-0.4, 2.5666+ y * 10.0, +2.0)));  \n        d = min(d, sdKnob(pos, vec3(+0.4, 2.5666+ y * 10.0, +1.2)));\n        d = min(d, sdKnob(pos, vec3(-0.4, 2.5666+ y * 10.0, +1.2)));\n    //}\n    \n    //if(t > 0.6) {\n         y = 1.0 - (min(t - 0.6, 0.1) / 0.1);\n        d = min(d, sdBrick(pos, vec3(0.0, 3.0666+ y * 10.0, 0.8), vec2(2, 2)));\n        d = min(d, sdKnob(pos, vec3(+0.4, 3.5666+ y * 10.0, +0.4)));\n        d = min(d, sdKnob(pos, vec3(-0.4, 3.5666+ y * 10.0, +0.4)));  \n        d = min(d, sdKnob(pos, vec3(+0.4, 3.5666+ y * 10.0, +1.2)));\n        d = min(d, sdKnob(pos, vec3(-0.4, 3.5666+ y * 10.0, +1.2)));\n    //}\n    \n    //if(t > 0.7) {\n         y = 1.0 - (min(t - 0.7, 0.1) / 0.1);\n        d = min(d, sdBrick(pos, vec3(0.0, 3.0666+ y * 10.0, -0.4), vec2(4, 1)));\n        d = min(d, sdKnob(pos, vec3(+0.4, 3.5666+ y * 10.0, -0.4)));\n        d = min(d, sdKnob(pos, vec3(-0.4, 3.5666+ y * 10.0, -0.4)));  \n        d = min(d, sdKnob(pos, vec3(+1.2, 3.5666+ y * 10.0, -0.4)));\n        d = min(d, sdKnob(pos, vec3(-1.2, 3.5666+ y * 10.0, -0.4)));\n    //}\n    \n    //if(t > 0.8) {\n         y = 1.0 - (min(t - 0.8, 0.1) / 0.1);\n        d = min(d, sdSmallBrick(pos, vec3(0.0, 3.7333+ y * 10.0, -0.8), vec2(2, 2)));\n        d = min(d, sdKnob(pos, vec3(+0.4, 3.9+ y * 10.0, -0.4)));\n        d = min(d, sdKnob(pos, vec3(-0.4, 3.9+ y * 10.0, -0.4)));  \n        d = min(d, sdKnob(pos, vec3(+0.4, 3.9+ y * 10.0, -1.2)));\n        d = min(d, sdKnob(pos, vec3(-0.4, 3.9+ y * 10.0, -1.2)));\n    //}\n    \n    //if(t > 0.9) {\n         y = 1.0 - (min(t - 0.9, 0.1) / 0.1);\n        d = min(d, sdSmallBrick(pos, vec3(0.0, 3.7333+ y * 10.0, +0.4), vec2(2, 1)));\n        d = min(d, sdKnob(pos, vec3(+0.4, 3.9+ y * 10.0, +0.4)));\n        d = min(d, sdKnob(pos, vec3(-0.4, 3.9+ y * 10.0, +0.4)));\n    //}\n    \n    //if(t > 1.0) {\n         y = 1.0 - (min(t - 1.0, 0.1) / 0.1);\n        d = min(d, sdBrick(pos, vec3(0.0, 4.4+ y * 10.0, 0.0), vec2(2, 2)));\n        d = min(d, sdKnob(pos, vec3(+0.4, 4.9+ y * 10.0, +0.4)));\n        d = min(d, sdKnob(pos, vec3(-0.4, 4.9+ y * 10.0, +0.4)));\n        d = min(d, sdKnob(pos, vec3(+0.4, 4.9+ y * 10.0, -0.4)));\n        d = min(d, sdKnob(pos, vec3(-0.4, 4.9+ y * 10.0, -0.4)));\n    //}\n    \n    return d;\n}\n \n#define ORG //ORG: 4.0s  else 2.7s\n#ifdef ORG\nvec3 calcNormal(vec3 pos) {\n    const float epsilon = 0.001;\n    float dist0 = map(pos);\n    float dist1 = map(pos + vec3(epsilon, 0.0, 0.0));\n    float dist2 = map(pos + vec3(0.0, epsilon, 0.0));\n    float dist3 = map(pos + vec3(0.0, 0.0, epsilon));\n    return (vec3(dist1, dist2, dist3) - dist0) / epsilon;\n}\n\n#else\nvec3 calcNormal(vec3 pos)\n{\n    const float epsilon = 0.001;\n    vec3 n = vec3(0.0);\n    for( int i=min(iFrame,0); i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+epsilon*e);\n    }\n    return normalize(n);\n}\n\n#endif\n\nstruct Hit {\n    vec3 position;\n    float closestDistance;\n    int raySteps;\n    bool hit;\n};\n\nHit castRay(Ray ray) {\n    Hit hit;\n    hit.position = ray.origin;\n    hit.raySteps = 0;\n    hit.hit = false;\n    \n    float hitDist = 0.0;\n    for(; hit.raySteps < 100; ++hit.raySteps) {\n        hit.position = ray.origin + ray.direction * hitDist;\n        \n        float sd = map(hit.position * rotationMatrix);\n        \n        if(sd < 0.01) { \n            hit.hit = true;\n            break;\n        }\n        \n        hitDist += sd;\n    }\n    \n    return hit;\n}\n\nbool obscured(Ray ray) {\n    float occlusion = 1.0;\n    vec3 position;\n    float hitDist = 0.0;\n    for(int raySteps = 0; raySteps < 100; ++raySteps) {\n        position = ray.origin + ray.direction * hitDist;\n        float sd = map(position * rotationMatrix);\n        \n        if(sd < 0.01) { \n            return true;\n        }\n        \n        hitDist += sd;\n    }\n    return false;\n}\n\nfloat softShadow(Ray ray, float k) {\n    float visibility = 1.0;\n    vec3 position;\n    float hitDist = 0.0;\n    for(int raySteps = 0; raySteps < 100; ++raySteps) {\n        position = ray.origin + ray.direction * hitDist;\n        float sd = map(position * rotationMatrix);\n        \n        if(sd < 0.01) { \n            return 0.0;\n        }\n        \n        visibility = max(smoothMin(visibility, k * sd/hitDist, 0.3), 0.0);\n        hitDist += sd;\n    }\n    return visibility;\n}\n\nvec3 calculateColor(vec2 seed, vec3 normal, vec3 viewDir, vec3 position, vec3 albedo, vec3 reflection, int raySteps) {\n    const vec3 lightDir = normalize(vec3(0.4, 1.0, -0.8));\n    float diffuse = max(dot(normal, lightDir), 0.0);\n    \n    const vec3 orange = vec3(pow(1.0,2.2), pow(0.5,2.2), pow(0.3,2.2));\n    const vec3 yellow = vec3(pow(1.0,2.2), pow(0.8,2.2), pow(0.3,2.2));\n    \n    float r0 = 0.05;\n    float ao = 0.0;\n    if(position.y > -0.1) {\n        ao = pow(1.0 / float(raySteps), 0.3);\n        albedo = yellow;\n        if(orangeMap(position * rotationMatrix) < 0.01)\n            albedo = orange;\n    }else{\n        r0 = 0.0;\n        ao = pow(1.0 / float(raySteps), 0.1);\n    }\n    \n    /*float shadow = 0.0;\n    for(int i = 0; i < 4; i++) {\n        vec3 rand = textureLod(iChannel0, seed, 0.0).xyz;\n        seed = rand.xy;\n    \n        Ray shadowRay;\n        shadowRay.direction = lightDir + rand - 0.5;\n        shadowRay.origin = position + shadowRay.direction * 0.15;\n\n        shadow += obscured(shadowRay) ? 0.0 : 1.0;\n    }\n    shadow /= 4.0*/;\n    \n    \n    Ray shadowRay;\n    shadowRay.direction = lightDir;\n    shadowRay.origin = position + shadowRay.direction * 0.15;\n    float shadow = softShadow(shadowRay, 2.0);\n    \n    \n    diffuse = diffuse * shadow * 0.5 + 0.65;\n    \n    float fresnel = r0 + (1.0 - r0) * pow(1.0 - dot(-viewDir, normal), 5.0);\n    \n    float specular = max(dot(reflect(viewDir, normal), lightDir), 0.0) * fresnel;\n    \n    return (albedo * diffuse + fresnel * reflection + specular) * ao;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 screenPos = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    \n    Ray ray;\n    ray.origin = vec3(0.0, 9.0, -8.0);\n    ray.direction = normalize(vec3(screenPos, 1.0));\n    const float cameraRotation = 40.0;\n    const float cameraRotSin = sin(cameraRotation * 0.0174532);\n    const float cameraRotCos = cos(cameraRotation * 0.0174532);\n    const mat3 cameraMatrix = mat3(\n        1.0, 0.0, 0.0,\n        0.0, cameraRotCos, -cameraRotSin,\n        0.0, cameraRotSin, cameraRotCos\n    );\n    ray.direction *= cameraMatrix;\n    \n    float rot = iTime * 0.8;\n    float rotSin = sin(rot);\n    float rotCos = cos(rot);\n    rotationMatrix = mat3(\n    rotCos, 0.0, rotSin,\n    0.0, 1.0, 0.0,\n    -rotSin, 0.0, rotCos);\n    \n    float rot_inv = -rot;\n    float rotSin_inv = sin(rot_inv);\n    float rotCos_inv = cos(rot_inv);\n    rotationMatrix_inv = mat3(\n    rotCos_inv, 0.0, rotSin_inv,\n    0.0, 1.0, 0.0,\n    -rotSin_inv, 0.0, rotCos_inv);\n    \n    \n    Hit hit = castRay(ray);\n    \n    if(hit.hit) {\n        vec3 normal = normalize(calcNormal(hit.position * rotationMatrix));\n        \n        Ray reflectionRay;\n        reflectionRay.direction = reflect(ray.direction, normal);\n        reflectionRay.origin = hit.position + reflectionRay.direction * 0.02;\n        Hit reflection = castRay(reflectionRay);\n        vec3 reflectionCol = vec3(1.0, 1.0, 1.0);\n        if(reflection.hit)\n            reflectionCol = calculateColor(screenPos.xy, normalize(calcNormal(reflection.position * rotationMatrix)) * rotationMatrix_inv, reflectionRay.direction, reflection.position, vec3(1.0, 1.0, 1.0), vec3(1.0, 1.0, 1.0), hit.raySteps);\n        vec3 col = calculateColor(screenPos.xy, normal * rotationMatrix_inv, ray.direction, hit.position, vec3(1.0, 1.0, 1.0), reflectionCol, hit.raySteps);\n        fragColor = vec4(pow(col.x, 1.0 / 2.2), pow(col.y, 1.0 / 2.2), pow(col.z, 1.0 / 2.2), 0.0);//vec4(normal, 1.0) * 0.5 + 0.5;\n    } else {\n        fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n    }   \n}",
   "name": "Image",
   "description": "",
   "type": "image"
  }
 ]
}