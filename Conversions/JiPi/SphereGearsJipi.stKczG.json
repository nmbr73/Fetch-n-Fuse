{
 "ver": "0.1",
 "info": {
  "id": "stKczG",
  "date": "0",
  "viewed": 0,
  "name": "Sphere Gears JiPi",
  "description": "Originally based on [url]https://www.shadertoy.com/view/XlVcWz[/url], but much more optimized and remade. LIVE coding tutorial on it here: [url]https://www.youtube.com/watch?v=sl9x19EnKng[/url]",
  "likes": 0,
  "published": "Private",
  "usePreview": 0,
  "tags": [
   "3d",
   "raymarching",
   "gears",
   "sdf",
   "motionblur"
  ],
  "hasliked": 0,
  "parentid": "tt2XzG",
  "parentname": "Sphere Gears"
 },
 "renderpass": [
  {
   "inputs": [
    {
     "id": "4sXGRn",
     "filepath": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg",
     "type": "texture",
     "channel": 0,
     "sampler": {
      "filter": "mipmap",
      "wrap": "repeat",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    }
   ],
   "outputs": [
    {
     "id": "4dfGRr",
     "channel": 0
    }
   ],
   "code": "// Copyright Inigo Quilez, 2019 - https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work neither\n// as it is or altered, here on Shadertoy or anywhere else, in any\n// form including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it or train a neural\n// network with it without permission. I share this Work for educational\n// purposes, and you can link to it, through an URL, proper attribution\n// and unmodified screenshot, as part of your educational material. If\n// these conditions are too restrictive please contact me and we'll\n// definitely work it out.\n\n// Basically the same as https://www.shadertoy.com/view/XlVcWz\n// but optimized through symmetry so it only needs to evaluate\n// four gears instead of 18. Also I made the gears with actual\n// boxes rather than displacements, which creates an exact SDF\n// allowing me to raymarch the scene at the speed of light, or\n// in other words, without reducing the raymarching step size.\n// Also I'm using a bounding volume to speed things up further\n// so I can affor some nice ligthing and motion blur.\n//\n// Live streamed tutorial on this shader:\n// PART 1: https://www.youtube.com/watch?v=sl9x19EnKng\n// PART 2: https://www.youtube.com/watch?v=bdICU2uvOdU\n//\n// Video capture here: https://www.youtube.com/watch?v=ydTVmDBSGYQ\n//\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2  // Set AA to 1 if your machine is too slow\n#endif\n\n\n// https://iquilezles.org/articles/smin\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdSphere( in vec3 p, in float r )\n{\n    return length(p)-r;\n}\n\nfloat sdVerticalSemiCapsule( vec3 p, float h, float r )\n{\n    p.y = max(p.y-h,0.0);\n    return length( p ) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdCross( in vec2 p, in vec2 b, float r ) \n{\n    p = abs(p); p = (p.y>p.x) ? p.yx : p.xy;\n    \n\tvec2  q = p - b;\n    float k = max(q.y,q.x);\n    vec2  w = (k>0.0) ? q : vec2(b.y-p.x,-k);\n    \n    return sign(k)*length(max(w,0.0)) + r;\n}\n\n// https://www.shadertoy.com/view/MlycD3\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n\n\tp.x = abs(p.x);\n    vec2 ca = vec2(max(0.0,p.x-((p.y<0.0)?r1:r2)), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot2(k2), 0.0, 1.0 );\n    \n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n// https://iquilezles.org/articles/intersectors\nvec2 iSphere( in vec3 ro, in vec3 rd, in float rad )\n{\n\tfloat b = dot( ro, rd );\n\tfloat c = dot( ro, ro ) - rad*rad;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return vec2(-1.0);\n    h = sqrt(h);\n\treturn vec2(-b-h, -b+h );\n}\n\n//----------------------------------\n\nfloat dents( in vec2 q, in float tr, in float y )\n{\n    const float an = 6.283185/12.0;\n    float fa = (atan(q.y,q.x)+an*0.5)/an;\n    float sym = an*floor(fa);\n    vec2 r = mat2(cos(sym),-sin(sym), sin(sym), cos(sym))*q;\n    \n#if 1\n    float d = length(max(abs(r-vec2(0.17,0))-tr*vec2(0.042,0.041*y),0.0));\n#else\n    float d = sdTrapezoid( r.yx-vec2(0.0,0.17), 0.085*y, 0.028*y, tr*0.045 );\n#endif\n\n\treturn d - 0.005*tr;\n}\n\nvec4 gear(vec3 q, float off, float time)\n{\n    {\n    float an = 2.0*time*sign(q.y) + off*6.283185/24.0;\n    float co = cos(an), si = sin(an);\n    q.xz = mat2(co,-si,si,co)*q.xz;\n    }\n    \n    q.y = abs(q.y);\n    \n    float an2 = 2.0*min(1.0-2.0*abs(fract(0.5+time/10.0)-0.5),1.0/2.0);\n    vec3 tr = min( 10.0*an2 - vec3(4.0,6.0,8.0),1.0);\n    \n    // ring\n    float d = abs(length(q.xz) - 0.155*tr.y) - 0.018;\n\n    // add dents\n    float r = length(q);\n    d = min( d, dents(q.xz,tr.z, r) );\n\n    \n    // slice it\n    float de = -0.0015*clamp(600.0*abs(dot(q.xz,q.xz)-0.155*0.155),0.0,1.0);\n    d = smax( d, abs(r-0.5)-0.03+de, 0.005*tr.z );\n\n    // add cross\n    float d3 = sdCross( q.xz, vec2(0.15,0.022)*tr.y, 0.02*tr.y );\n    vec2 w = vec2( d3, abs(q.y-0.485)-0.005*tr.y );\n    d3 = min(max(w.x,w.y),0.0) + length(max(w,0.0))-0.003*tr.y;\n    d = min( d, d3 ); \n        \n    // add pivot\n    d = min( d, sdVerticalSemiCapsule( q, 0.5*tr.x, 0.01 ));\n\n    // base\n    d = min( d, sdSphere(q-vec3(0.0,0.12,0.0),0.025) );\n    \n    return vec4(d,q.xzy);\n}\n\nvec2 rot( vec2 v )\n{\n    return vec2(v.x-v.y,v.y+v.x)*0.707107;\n}\n    \nvec4 map( in vec3 p, float time )\n{\n    // center sphere\n    vec4 d = vec4( sdSphere(p,0.12), p );\n    \n    // gears. There are 18, but we only evaluate 4    \n    vec3 qx = vec3(rot(p.zy),p.x); if(abs(qx.x)>abs(qx.y)) qx=qx.zxy;\n    vec3 qy = vec3(rot(p.xz),p.y); if(abs(qy.x)>abs(qy.y)) qy=qy.zxy;\n    vec3 qz = vec3(rot(p.yx),p.z); if(abs(qz.x)>abs(qz.y)) qz=qz.zxy;\n    vec3 qa = abs(p); qa = (qa.x>qa.y && qa.x>qa.z) ? p.zxy : \n                           (qa.z>qa.y             ) ? p.yzx :\n                                                      p.xyz;\n    vec4 t;\n    t = gear( qa,0.0,time ); if( t.x<d.x ) d=t;\n    t = gear( qx,1.0,time ); if( t.x<d.x ) d=t;\n    t = gear( qz,1.0,time ); if( t.x<d.x ) d=t;\n    t = gear( qy,1.0,time ); if( t.x<d.x ) d=t;\n    \n\treturn d;\n}\n\n#define ZERO min(iFrame,0)\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos, in float time )\n{\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.00025;\n    return normalize( e.xyy*map( pos + e.xyy*eps, time ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps, time ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps, time ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps, time ).x );\n#else\n    // klems's trick to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e,time).x;\n    }\n    return normalize(n);\n#endif    \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor, in float time )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos+h*nor, time ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float k, in float time )\n{\n    float res = 1.0;\n    \n    // bounding sphere\n    vec2 b = iSphere( ro, rd, 0.535 );\n\tif( b.y>0.0 )\n    {\n        // raymarch\n        float tmax = b.y;\n        float t    = max(b.x,0.001);\n        for( int i=0; i<64; i++ )\n        {\n            float h = map( ro + rd*t, time ).x;\n            res = min( res, k*h/t );\n            t += clamp( h, 0.012, 0.2 );\n            if( res<0.001 || t>tmax ) break;\n        }\n    }\n    \n    return clamp( res, 0.0, 1.0 );\n}\n\nvec4 intersect( in vec3 ro, in vec3 rd, in float time )\n{\n    vec4 res = vec4(-1.0);\n    \n    // bounding sphere\n    vec2 tminmax = iSphere( ro, rd, 0.535 );\n\tif( tminmax.y>0.0 )\n    {\n        // raymarch\n        float t = max(tminmax.x,0.001);\n        for( int i=0; i<128 && t<tminmax.y; i++ )\n        {\n            vec4 h = map(ro+t*rd,time);\n            if( h.x<0.001 ) { res=vec4(t,h.yzw); break; }\n            t += h.x;\n        }\n    }\n    \n    return res;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        float d = 0.5*sin(fragCoord.x*147.0)*sin(fragCoord.y*131.0);\n        float time = iTime - 0.5*(1.0/24.0)*(float(m*AA+n)+d)/float(AA*AA-1);\n        #else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        float time = iTime;\n        #endif\n\n\t    // camera\t\n        float an = 6.2831*time/40.0;\n        vec3 ta = vec3( 0.0, 0.0, 0.0 );\n        vec3 ro = ta + vec3( 1.3*cos(an), 0.5, 1.2*sin(an) );\n        \n        ro += 0.005*sin(92.0*time/40.0+vec3(0.0,1.0,3.0));\n        ta += 0.009*sin(68.0*time/40.0+vec3(2.0,4.0,6.0));\n        \n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta, 0.0 );\n        \n        // ray direction\n        float fl = 2.0;\n        vec3 rd = ca * normalize( vec3(p,fl) );\n\n        // background\n        vec3 col = vec3(1.0+rd.y)*0.03;\n        \n        // raymarch geometry\n        vec4 tuvw = intersect( ro, rd, time );\n        if( tuvw.x>0.0 )\n        {\n            // shading/lighting\t\n            vec3 pos = ro + tuvw.x*rd;\n            vec3 nor = calcNormal(pos, time);\n                        \n            vec3 te = 0.5*texture( iChannel0, tuvw.yz*2.0 ).xyz+\n                      0.5*texture( iChannel0, tuvw.yw*1.0 ).xyz;\n            \n            vec3 mate = 0.22*te;\n            float len = length(pos);\n            \n            mate *= 1.0 + vec3(2.0,0.5,0.0)*(1.0-smoothstep(0.121,0.122,len) ) ;\n            \n            float focc  = 0.1+0.9*clamp(0.5+0.5*dot(nor,pos/len),0.0,1.0);\n                  focc *= 0.1+0.9*clamp(len*2.0,0.0,1.0);\n            float ks = clamp(te.x*1.5,0.0,1.0);\n            vec3  f0 = mate;\n            float kd = (1.0-ks)*0.125;\n            \n            float occ = calcAO( pos, nor, time ) * focc;\n            \n            col = vec3(0.0);\n            \n            // side\n            {\n            vec3  lig = normalize(vec3(0.8,0.2,0.6));\n            float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n            vec3  hal = normalize(lig-rd);\n            float sha = 1.0; if( dif>0.001 ) sha = calcSoftshadow( pos+0.001*nor, lig, 20.0, time );\n            vec3  spe = pow(clamp(dot(nor,hal),0.0,1.0),16.0)*(f0+(1.0-f0)*pow(clamp(1.0+dot(hal,rd),0.0,1.0),5.0));\n            col += kd*mate*2.0*vec3(1.00,0.70,0.50)*dif*sha;\n            col += ks*     2.0*vec3(1.00,0.80,0.70)*dif*sha*spe*3.14;\n            }\n\n            // top\n            {\n            vec3  ref = reflect(rd,nor);\n            float fre = clamp(1.0+dot(nor,rd),0.0,1.0);\n            float sha = occ;\n            col += kd*mate*25.0*vec3(0.19,0.22,0.24)*(0.6 + 0.4*nor.y)*sha;\n            col += ks*     25.0*vec3(0.19,0.22,0.24)*sha*smoothstep( -1.0+1.5*focc, 1.0-0.4*focc, ref.y ) * (f0 + (1.0-f0)*pow(fre,5.0));\n            }\n            \n            // bottom\n            {\n            float dif = clamp(0.4-0.6*nor.y,0.0,1.0);\n            col += kd*mate*5.0*vec3(0.25,0.20,0.15)*dif*occ;\n            }\n        }\n        \n        // compress        \n        // col = 1.2*col/(1.0+col);\n        \n        // vignetting\n        col *= 1.0-0.1*dot(p,p);\n        \n        // gamma        \n\t    tot += pow(col,vec3(0.45) );\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // s-curve    \n    tot = min(tot,1.0);\n    tot = tot*tot*(3.0-2.0*tot);\n    \n    // cheap dithering\n    tot += sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1)/512.0;\n\n    fragColor = vec4( tot, 1.0 );\n}",
   "name": "Image",
   "description": "",
   "type": "image"
  }
 ]
}