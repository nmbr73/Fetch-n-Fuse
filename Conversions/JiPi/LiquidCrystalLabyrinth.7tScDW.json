{"Shader":{"ver":"0.1","info":{"id":"7tScDW","date":"1649687885","viewed":5,"name":"Liquid Crystal Labyrinth","username":"tomachi","description":"Fluid-like continuous cellular automata by  cornusammonis in 2016:  [url]https:\/\/shadertoy.com\/view\/Xst3Dj[\/url]\nWebGL2 cleansing by FabriceNeyret2 in 2019:  [url] https:\/\/www.shadertoy.com\/view\/ttjXzR[\/url]\nin 2022 I add colour and crystalisation.","likes":0,"published":3,"flags":32,"usePreview":0,"tags":["diffusion","feedback","reaction"],"hasliked":0},"renderpass":[{"inputs":[{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"\/\/ WebGL2 cleaned-up version of \"Viscous Fingering\" by cornusammonis. https:\/\/shadertoy.com\/view\/Xst3Dj\n\nvoid mainImage(out vec4 O, vec2 u) {\nvec2 U = u;\n\n    \n    O.r += 0.5f * normalize(T()).x; \n    O.g += 0.25f * normalize(T()).y; \n    O.b += 0.25f * normalize(T()).z; \n    O += .5 * normalize(T()).zzzz; \n    \n    \n    }","name":"Image","description":"","type":"image"},{"inputs":[{"id":5,"src":"\/media\/a\/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":257,"channel":0}],"code":"\n\nvoid mainImage( out vec4 O, vec2 U )\n{\nfloat _K0 = -20.\/6., \/\/ center weight\n      _K1 =   4.\/6., \/\/ edge-neighbors\n      _K2 =   1.\/6., \/\/ vertex-neighbors\n       cs =  .12052 + (U.x*0.0000051),    \/\/ curl scale\n       ls =  .12052 + (U.x*0.0000051),    \/\/ laplacian scale\n       ps = -.06,    \/\/ laplacian of divergence scale\n       ds = -.08,    \/\/ divergence scale\n      pwr =  .2,     \/\/ power when deriving rotation angle from curl\n      amp = 0.999+(U.y*0.000051),      \/\/ self-amplification\n      sq2 =  .7;     \/\/ diagonal weight\n\n\/\/ 3x3 neighborhood coordinates\n    vec4 uv = T( ),\n          n = T(vec2( 0,  1 )),\n          e = T(vec2( 1,  0 )),\n          s = T(vec2( 0, -1 )),\n          w = T(vec2(-1,  0 )),\n         nw = T(vec2(-1,  1 )),\n         sw = T(vec2(-1     )),\n         ne = T(vec2( 1     )),\n         se = T(vec2( 1, -1 ));\n    \n    \/\/ uv.x and uv.y are our x and y components, uv.z is divergence \n\n    \/\/ laplacian of all components\n    vec4 lapl  = _K0*uv + _K1*(n + e + w + s) \n                        + _K2*(nw + sw + ne + se);\n    float sp = ps * lapl.z;\n    \n    \/\/ calculate curl\n    \/\/ vectors point clockwise about the center point\n    float curl = n.x - s.x - e.y + w.y \n        + sq2 * (nw.x + nw.y + ne.x - ne.y + sw.y - sw.x - se.y - se.x);\n    \n    \/\/ compute angle of rotation from curl\n    float a = cs * sign(curl) * pow(abs(curl), pwr);\n    \n    \/\/ calculate divergence\n    \/\/ vectors point inwards towards the center point\n    float div  = s.y - n.y - e.x + w.x \n        + sq2 * (nw.x - nw.y - ne.x - ne.y + sw.x + sw.y + se.y - se.x);\n    float sd = ds * div;\n\n    vec2 norm = normalize(uv.xy);\n    \n    \/\/ temp values for the update rule\n     vec2 t = (amp * uv + ls * lapl + uv * sd).xy + norm * sp;\n     float red = sd;\n     float green = div;\n     float blue = t.x;\n     \/\/O = vec4(red,green, blue, 1.0);\n     \/\/O = clamp(vec4(t,div,0), -1., 1.);\n     \n     t *= mat2(cos(a), -sin(a), sin(a), cos(a) );\n    if(iFrame<10)\n        O = -.5 + texture(iChannel1, U\/R), O.a=0.;\n     else \n        O = clamp(vec4(t,div,0), -1., 1.);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define R    iResolution.xy\/\/\n#define T(d) texelFetch(iChannel0, ivec2(d+U)%ivec2(R),0)","name":"Common","description":"","type":"common"}]}}