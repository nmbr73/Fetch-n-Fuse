{"Shader":{"ver":"0.1","info":{"id":"sdVfzy","date":"1658685249","viewed":122,"name":"Tesla Valve","username":"fenix","description":"This is far from the best fluid sim, and the valve itself is far from ideal. And yet somehow it still demonstrates the basic principle that more fluid gets through one way than the other.\n*l\/r arrows to reset sim*\n*mouse to interact*","likes":13,"published":3,"flags":48,"usePreview":0,"tags":["2d","voronoi","simulation","fluid","particles","liquid","sph"],"hasliked":0},"renderpass":[{"inputs":[{"id":5,"src":"\/media\/a\/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","ctype":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":259,"src":"\/media\/previz\/buffer02.png","ctype":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":260,"src":"\/media\/previz\/buffer03.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":14854,"src":"\/media\/a\/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":37,"channel":0}],"code":"\/\/ ---------------------------------------------------------------------------------------\n\/\/\tCreated by fenix in 2022\n\/\/\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\/\/\n\/\/  Same basic engine as \"Self supporting SPH\" https:\/\/www.shadertoy.com\/view\/7ddfRB\n\/\/  Tesla valves were invented in 1920 by Nikola Tesla, but had little practical\n\/\/  use until researchers recently used it to create a microfluidic pump.\n\/\/\n\/\/      https:\/\/en.wikipedia.org\/wiki\/Tesla_valve\n\/\/\n\/\/  I'm not sure why (yet) but the fluid is a lot more active at lower resolutions.\n\/\/  The valve \"works\" though at multiple resolutions, letting relatively more fluid\n\/\/  through from right to left than left to right. The left\/right cycle is 3600 frames\n\/\/  long and is controlled by ANIMATE_FRAMES.\n\/\/ \n\/\/  Buffer A computes the particle positions and neighbors\n\/\/  Buffer B does a traditional voronoi search to help out building neighborhoods\n\/\/  Buffer C renders the particles into a density texture (used for rendering only)\n\/\/  Buffer D blurs the density (used for rendering only)\n\/\/ ---------------------------------------------------------------------------------------\n\nfloat computeSpecular(\n    in float specularCoefficient,\n    in float specularExponent,\n    in vec3 nvNormal,\n    in vec3 nvFragToLight,\n    in vec3 nvFragToCam)\n{\n    vec3 blinnH = normalize(nvFragToLight + nvFragToCam);\n    float valSpecular = pow(max(0.0, dot(nvNormal, blinnH)), specularExponent);\n    valSpecular *= specularCoefficient;\n\n    return valSpecular;\n}\n\nvec2 texGrad(sampler2D sampler, vec2 fragCoord)\n{\n    float dx = texture(sampler, (fragCoord + vec2(1.0, 0.0))\/iResolution.xy).x\n             - texture(sampler, (fragCoord - vec2(1.0, 0.0))\/iResolution.xy).x;\n    float dy = texture(sampler, (fragCoord + vec2(0.0, 1.0))\/iResolution.xy).x\n             - texture(sampler, (fragCoord - vec2(0.0, 1.0))\/iResolution.xy).x;\n    return vec2(dx, dy);\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n    \n    fragColor = vec4(0.0);\n  \tvec2 p = (2.0*fragCoord-iResolution.xy)\/iResolution.xy;\n   \tivec2 iFragCoord = ivec2(fragCoord);\n\n    vec4 state = texture(iChannel3, vec2(0));\n    float frames = state.x;\n\n    float wallSd = distanceFromWalls(p, iResolution, frames);\n    \n    vec4 background = textureLod(iChannel2, fragCoord\/iResolution.xy, 5.0);\n    \n    float lDensity = texture(iChannel0, fragCoord\/iResolution.xy).x;\n    vec2 lNorm2 = texGrad(iChannel0, fragCoord);\n    vec3 lNorm = vec3(-lNorm2.x, 1.0, -lNorm2.y);\n    lNorm = normalize(lNorm);\n\n    vec4 water = texture(iChannel2, fragCoord\/iResolution.xy + lNorm2 * 0.2) * vec4(1.0, 0.0, 0.0, 0.0);\n    float waterSpec = computeSpecular(0.8, 20.0, lNorm, normalize(vec3(1.0, -1.0, 1.0)), vec3(0.0, 1.7+p.x * 0.3, 0.5 - p.y * 0.3));\n    water.xyz += vec3(waterSpec) * 2.0;\n\n    vec4 scene = mix(background, water, smoothstep(0.5, 1.0, lDensity));\n\n    \/\/ Handle animated steel UVs for moving (particle compressing) walls\n    float sideShift = 0.0;\n    if (fragCoord.x > iResolution.x * 0.875)\n    {\n        if (frames > ANIMATE_FRAMES * 0.475)\n        {\n            frames = ANIMATE_FRAMES * 0.475;\n        }\n        sideShift = frames * 0.25;\n        if (fragCoord.y < iResolution.y * 0.6)\n        {\n            sideShift = -sideShift;\n        }\n    }\n    else if (fragCoord.x < iResolution.x * 0.125)\n    {\n        if (frames > ANIMATE_FRAMES * 0.975)\n        {\n            frames = ANIMATE_FRAMES * 0.975;\n        }\n        sideShift = frames * 0.25;\n        if (fragCoord.y < iResolution.y * 0.5)\n        {\n            sideShift = -sideShift;\n        }\n    }\n\n    vec2 steelCoord = vec2(fragCoord.x * 2.0, (fragCoord.y + sideShift) * 0.004);\n    vec3 steelNorm = texture(iChannel1, steelCoord\/iResolution.xy).xyz;\n    steelNorm.xz += getNormalFromWalls(p, iResolution, frames) * (1.0 - smoothstep(0.02, 0.05, -wallSd));\n\n    steelNorm = normalize(steelNorm);\n    float steelSpec = computeSpecular(0.8, 15.0, steelNorm, normalize(vec3(1.0, -1.0, 1.0)), vec3(0.0, 1.75-p.x, 0.5 - p.y));\n    vec4 steel = vec4(vec3(steelSpec), 1.0) * 0.5 + 0.3;\n\n    fragColor = mix(scene, steel, smoothstep(0.02, 0.03, -wallSd));\n\n    fragColor.w = 1.0;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\/\/amount of particles\nconst int MAX_PARTICLES = 5000; \nconst float PARTICLE_REPEL_SIZE = 0.01;\n\nconst float ANIMATE_FRAMES = 3600.0;\n\nconst float PI = 3.141592653598793;\n\n\/\/hashing noise by IQ\nfloat hash( int k ) {\n    uint n = uint(k);\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 world2screenInternal(in vec2 p, in vec2 resolution)\n{\n    return (p + 1.0) * 0.5 * resolution;\n}\n\n#define world2screen(X) world2screenInternal(X, iResolution.xy)\n\nvec2 screen2worldInternal(in vec2 p, in vec2 resolution)\n{\n    return (p \/ resolution) * 2.0 - 1.0;\n}\n\n#define screen2world(X) screen2worldInternal(X, iResolution.xy)\n\nfloat cross2(vec2 a, vec2 b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\nfloat linePointDist2(in vec2 newPos, in vec2 oldPos, in vec2 fragCoord, in vec3 resolution, out vec2 closest)\n{\n    vec2 pDelta = (fragCoord - oldPos);\n    vec2 delta = newPos - oldPos;\n    float deltaLen2 = dot(delta, delta);\n\n    \/\/ Find the closest point on the line segment from old to new\n    closest;\n    if (deltaLen2 > 0.0000001)\n    {\n        float deltaInvSqrt = inversesqrt(deltaLen2);\n        vec2 deltaNorm = delta * deltaInvSqrt;\n        closest = oldPos + deltaNorm * max(0.0, min(1.0 \/ deltaInvSqrt, dot(deltaNorm, pDelta)));\n    }\n    else\n    {\n        closest = oldPos;\n    }\n\n    \/\/ Distance to closest point on line segment\n    vec2 closestDelta = closest - fragCoord;\n    closestDelta *= resolution.xy \/ resolution.y;\n    return dot(closestDelta, closestDelta);\n}\n\nfloat sdBox(in vec2 p, in vec2 boxCenter, in vec2 boxSize)\n{\n    p -= boxCenter;\n    vec2 d = abs(p)-boxSize;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdHorseshoe( in vec2 p, in vec2 c, in float r, in vec2 w )\n{\n    p.x = abs(p.x);\n    float l = length(p);\n    p = mat2(-c.x, c.y, c.y, c.x)*p;\n    p = vec2((p.y>0.0 || p.x>0.0)?p.x:l*sign(-c.x),\n             (p.x>0.0)?p.y:l );\n    p = vec2(p.x,abs(p.y-r))-w;\n    return length(max(p,0.0)) + min(0.0,max(p.x,p.y));\n}\n\nconst float h1ang = 1.8;\nconst mat2 h1rot = mat2(cos(h1ang), -sin(h1ang), sin(h1ang), cos(h1ang));\nconst float h2ang = PI - h1ang;\nconst mat2 h2rot = mat2(cos(h2ang), -sin(h2ang), sin(h2ang), cos(h2ang));\nconst float lang = 1.7;\nconst mat2 lrot = mat2(cos(lang), -sin(lang), sin(lang), cos(lang));\n\nfloat distanceFromWalls(vec2 point, vec3 resolution, float time)\n{\n    time = mod(time, ANIMATE_FRAMES);\n    float rightTime = min(ANIMATE_FRAMES * 0.45, time);\n    float leftTime = min(ANIMATE_FRAMES * 0.45, time - ANIMATE_FRAMES * 0.5);\n    if (leftTime > 0.0) rightTime = 0.0;\n    const float COMPRESS_RATE = 1.0 \/ (0.55 * ANIMATE_FRAMES);\n    float minDist = 1e30;\n    point.y *= resolution.y \/ resolution.x;\n    point *= 2.0;\n    minDist = min(minDist, point.x + 1.9);\n    minDist = min(minDist, 1.9 - point.x);\n    minDist = min(minDist, point.y + 1.0);\n    minDist = min(minDist, 1.0 - point.y);\n    minDist = min(minDist, sdBox(point, vec2(0.0, 0.0), vec2(1.35, 5.00)));\n    minDist = min(minDist, sdBox(point, vec2(0.8, 2.0 - rightTime * COMPRESS_RATE), vec2(2.0, 1.0)));\n    minDist = min(minDist, sdBox(point, vec2(0.8, -2.0 + rightTime * COMPRESS_RATE), vec2(2.0, 1.0)));\n    minDist = min(minDist, sdBox(point, vec2(-0.8, 2.0 - leftTime * COMPRESS_RATE), vec2(2.0, 1.0)));\n    minDist = min(minDist, sdBox(point, vec2(-0.8, -2.0 + leftTime * COMPRESS_RATE), vec2(2.0, 1.0)));\n    minDist = max(minDist, -sdHorseshoe(h1rot*(point - vec2(-0.67, 0.16)), vec2(0.13, 1.0), 0.1, vec2(0.8, 0.04)));\n    minDist = max(minDist, -sdHorseshoe(h2rot*(point - vec2(-0.07, -0.14)), vec2(0.13, 1.0), 0.1, vec2(0.8, 0.04)));\n    minDist = max(minDist, -sdHorseshoe(h1rot*(point - vec2(0.53, 0.16)), vec2(0.13, 1.0), 0.1, vec2(0.8, 0.04)));\n    minDist = max(minDist, -sdHorseshoe(h2rot*(point - vec2(1.13, -0.14)), vec2(0.13, 1.0), 0.1, vec2(0.8, 0.04)));\n    minDist = max(minDist, -sdBox(lrot*(point - vec2(1.3, 0.04)), vec2(0.0, 0.0), vec2(0.04, 0.4)));\n    minDist = max(minDist, -sdBox(lrot*(point - vec2(1.4, 0.02)), vec2(0.0, 0.0), vec2(0.04, 0.3)));\n    return minDist;\n}\n\nvec2 getNormalFromWalls( vec2 point, vec3 resolution, float time )\n{\n\tvec2 tinyChangeX = vec2( 0.001, 0.0 );\n    vec2 tinyChangeY = vec2( 0.0 , 0.001 );\n    \n   \tfloat upTinyChangeInX   = distanceFromWalls( point + tinyChangeX, resolution, time ); \n    float downTinyChangeInX = distanceFromWalls( point - tinyChangeX, resolution, time ); \n    \n    float tinyChangeInX = upTinyChangeInX - downTinyChangeInX;\n    \n    \n    float upTinyChangeInY   = distanceFromWalls( point + tinyChangeY, resolution, time ); \n    float downTinyChangeInY = distanceFromWalls( point - tinyChangeY, resolution, time ); \n    \n    float tinyChangeInY = upTinyChangeInY - downTinyChangeInY;\n    \n    \n\tvec2 normal = vec2(\n         \t\t\ttinyChangeInX,\n        \t\t\ttinyChangeInY\n    \t \t\t  );\n    \n\treturn normalize(normal);\n}\n\n\/\/returns the ids of the four closest particles from the input\nivec4 fxGetClosestInternal(sampler2D sampler, ivec2 xy)\n{\n    return ivec4(texelFetch(sampler, xy, 0));\n}\n\n#define fxGetClosest(X) fxGetClosestInternal(iChannel1, X)\n\n#define UL_NEIGHBORS 0\n#define UR_NEIGHBORS 1\n#define LL_NEIGHBORS 2\n#define LR_NEIGHBORS 3\n#define POS_VEL 4\n#define NUM_PARTICLE_DATA_TYPES 5\n\n\/\/returns the location of the particle within the particle buffer corresponding with the input id \nivec2 fxLocFromIDInternal(int width, int id, int dataType)\n{\n    int index = id * NUM_PARTICLE_DATA_TYPES + dataType;\n    return ivec2( index % width, index \/ width);\n}\n\n#define fxLocFromID(X, Y) fxLocFromIDInternal(int(iResolution.x), X, Y)\n\nstruct fxParticle\n{\n    vec2 pos;\n    vec2 vel;\n    \n    ivec4 neighbors[4];\n};\n\n\/\/get the particle corresponding to the input id\nfxParticle fxGetParticleInternal(sampler2D sampler, int resolutionWidth, int id)\n{\n    vec4 particleData0 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, UL_NEIGHBORS), 0);\n    vec4 particleData1 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, UR_NEIGHBORS), 0);\n    vec4 particleData2 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, LL_NEIGHBORS), 0);\n    vec4 particleData3 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, LR_NEIGHBORS), 0);\n    vec4 particleData4 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, POS_VEL), 0);\n\n    fxParticle particle;\n    particle.neighbors[0] = ivec4(particleData0);\n    particle.neighbors[1] = ivec4(particleData1);\n    particle.neighbors[2] = ivec4(particleData2);\n    particle.neighbors[3] = ivec4(particleData3);\n    particle.pos = particleData4.xy;\n    particle.vel = particleData4.zw;\n    \n    return particle;\n}\n\n\nvec4 fxSaveParticle(fxParticle p, int dataType)\n{    \n    switch(dataType)\n    {\n    case UL_NEIGHBORS:\n        return vec4(p.neighbors[0]);\n    case UR_NEIGHBORS:\n        return vec4(p.neighbors[1]);\n    case LL_NEIGHBORS:\n        return vec4(p.neighbors[2]);\n    case LR_NEIGHBORS:\n        return vec4(p.neighbors[3]);\n    case POS_VEL:  \n        return vec4(p.pos, p.vel);\n    }\n}\n\n#define fxGetParticle(X) fxGetParticleInternal(iChannel0, int(iResolution.x), X)\n\nvec4 fxGetParticleDataInternal(sampler2D sampler, int resolutionWidth, int id, int dataType)\n{\n    return texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, POS_VEL), 0);\n}\n\n#define fxGetParticleData(X, Y) fxGetParticleDataInternal(iChannel0, int(iResolution.x), X, Y)\n\nfloat SPHKernel (float x)\n{\n    if (x < 1.0)\n        return 4.0 * cos(x*PI) + cos((x + x) * PI) + 3.0;\n    else\n        return 0.0;\n}\n\nfloat SPHgradKernel (float x)\n{\n    if (x < 4.0)\n    {\n        float xx = x*x;\n        float xxx = xx*x;\n        float xxxx = xxx*x;\n        return 0.000 + 3.333 * x + -3.167 * xx + 0.917 * xxx + -0.083 * xxxx;\n    }\n    else\n        return 0.0;\n}\n\nfloat length2(vec2 v)\n{\n    return dot(v, v);\n}\n\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\nvoid insertion_sort(inout ivec4 i, inout vec4 d, int i_, float d_){\t\n    if(any(equal(ivec4(i_),i))) return;\n    if     (d_ < d[0])             \n        i = ivec4(i_,i.xyz),    d = vec4(d_,d.xyz);\n    else if(d_ < d[1])             \n        i = ivec4(i.x,i_,i.yz), d = vec4(d.x,d_,d.yz);\n    else if(d_ < d[2])            \n        i = ivec4(i.xy,i_,i.z), d = vec4(d.xy,d_,d.z);\n    else if(d_ < d[3])           \n        i = ivec4(i.xyz,i_),    d = vec4(d.xyz,d_);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":258,"src":"\/media\/previz\/buffer01.png","ctype":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":259,"src":"\/media\/previz\/buffer02.png","ctype":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":257,"channel":0}],"code":"\/\/ Particle Buffer\n\/\/ in this buffer every pixel represents a particle\n\/\/ the particles positions is stored in .xy\n\/\/           its velocity  is stored in .zw\n\/\/ Only MAX_PARTICLES * NUM_PARTICLE_DATA_TYPES pixels are actually used.\n\nconst float PARTICLE_REPEL = 0.00005;\nconst float IDEAL_DENSITY = 20.0;\n\nvoid sort0(inout ivec4 bestIds, inout vec4 bestDists, int id, int searchId, int dataType, in vec2 myPos);\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n    ivec2 iFragCoord = ivec2(fragCoord);\n    \n    int maxParticles = min(int(iResolution.x * iResolution.y) \/ NUM_PARTICLE_DATA_TYPES, MAX_PARTICLES);\n    int index = iFragCoord.x + iFragCoord.y*int(iResolution.x);\n    int id = index \/ NUM_PARTICLE_DATA_TYPES;\n    int dataType = index - id * NUM_PARTICLE_DATA_TYPES;\n    if(id>=maxParticles) return;\n    \n    vec4 state = texture(iChannel3, vec2(0));\n    float frames = state.x;\n\n    fxParticle data = fxGetParticle(id);\n    \n    if (dataType == POS_VEL)\n    {\n        if (iFrame == 0 || frames == 0.0)\n        {\n            \/\/pick a \"random\" starting position\n            float particlesPerRow = sqrt(float(maxParticles));\n            float i = float(id % int(particlesPerRow));\n            float j = float(id \/ int(particlesPerRow)) + float(id & 1) * 0.5;\n            \n            data.pos = vec2(i \/ particlesPerRow, j \/ particlesPerRow) * vec2(0.1, 1.8) + vec2(0.8, -0.9);\n            data.vel = vec2(0);\n        }\n        else if (iFrame == 0 || frames == ANIMATE_FRAMES * 0.5)\n        {\n            \/\/pick a \"random\" starting position\n            float particlesPerRow = sqrt(float(maxParticles));\n            float i = float(id % int(particlesPerRow));\n            float j = float(id \/ int(particlesPerRow)) + float(id & 1) * 0.5;\n            \n            data.pos = vec2(i \/ particlesPerRow, j \/ particlesPerRow) * vec2(0.1, 1.8) + vec2(-0.9, -0.9);\n            data.vel = vec2(0);\n        }\n        else\n        {\n            vec2 force = vec2(0);\n            \n            \/\/ Debug forces\n            vec2 disturbPos = vec2(0.0, 0.0);\n            vec2 disturbDelta = vec2(0.0, 0.0);\n            if (iMouse.z > 0.0 && iMouse.w < 0.0)\n            {\n                disturbPos = ((2.0 * iMouse.xy \/ iResolution.xy) - 1.0) * vec2(iResolution.x \/ iResolution.y, 1.0);\n                disturbDelta = (iMouse.xy - vec2(iMouse.z, -iMouse.w));\n                disturbDelta = clamp(disturbDelta, -100.0, 100.0);\n            }\n            \n            const float MOUSE_FIELD_SIZE = 0.3;\n            float MOUSE_FIELD_STRENGTH = 0.3 \/ sqrt(iFrameRate);\n            float dist = distance(data.pos * iResolution.xy \/ iResolution.y, disturbPos);\n            if (dist < MOUSE_FIELD_SIZE)\n            {\n                force += (MOUSE_FIELD_SIZE - dist) * MOUSE_FIELD_STRENGTH * disturbDelta \/ iResolution.xy;\n            }\n\n            struct solverParticle\n            {\n                vec2 pos;\n                vec2 vel;\n            };\n            \n            solverParticle particles[17];\n            int numSolverParticles = 0;\n            float totalDensity = SPHKernel(0.0);\n           \n            \/\/ Compute neighborhood density and density gradient, and init solver particles\n            for(int i = 0; i < 4; i++){\n                ivec4 neighbors = data.neighbors[i];\n                for (int j = 0; j < 4; ++j)\n                {\n                    int cid = neighbors[j];\n                    if(cid==id || cid==-1 || cid == 0 || cid >= maxParticles) continue;\n                    \n                    vec4 otherPosVel = fxGetParticleData(cid, POS_VEL);\n                    \n                    vec2 deltaPos = otherPosVel.xy - data.pos;\n                    float dist = length(deltaPos) + 0.0001;\n                    float nbDensity = SPHKernel(dist);\n                    totalDensity += nbDensity;\n\n                    particles[numSolverParticles].pos = otherPosVel.xy;\n                    particles[numSolverParticles].vel = otherPosVel.zw;\n                    ++numSolverParticles;\n                }\n            }       \n\n            particles[numSolverParticles].pos = data.pos;\n            particles[numSolverParticles].vel = data.vel;\n            ++numSolverParticles;\n\n            \/\/ Solve local neighborhood\n            float pressure = 0.0;\n            const int NUM_ITERATIONS = 20;\n            for(int iterations = 0; iterations < NUM_ITERATIONS; ++iterations)\n            {\n                for (int i = 0; i < numSolverParticles; ++i)\n                {\n                    float impulse;\n                    for (int j = 0; j < numSolverParticles; ++j)\n                    {\n                        if (i != j)\n                        {\n                            vec2 deltaPos = particles[i].pos - particles[j].pos;\n                            float dist = length(deltaPos) + 0.001;\n                            vec2 dir = deltaPos \/ dist; \n\n                            impulse = (PARTICLE_REPEL * SPHgradKernel(dist \/ PARTICLE_REPEL_SIZE));\n                                                        \n                            particles[i].vel += impulse * dir;\n                            particles[j].vel -= impulse * dir;\n                        }\n                    }\n                    \n                    \/\/ Last particle is the one we're working on\n                    pressure += impulse;\n                }\n                \n                for (int i = 0; i < numSolverParticles; ++i)\n                {\n                    \/\/ Integrate pos\n                    particles[i].pos += particles[i].vel \/ float(NUM_ITERATIONS);\n                }\n            }\n            \n            \/\/ Combine solver results into force\n            force += particles[numSolverParticles - 1].vel - data.vel;\n                   \n            \/\/ Apply force\n            data.vel = data.vel + force;\n            \n            \/\/ Boundary\n            float distToScene = distanceFromWalls(data.pos, iResolution, frames);\n            float distToSceneOld = distanceFromWalls(data.pos, iResolution, frames - 1.0);\n            vec2 distNormal = getNormalFromWalls(data.pos, iResolution, frames);\n\n            if (distToScene < PARTICLE_REPEL_SIZE)\n            {\n                data.pos -= 1.0 * distNormal * (distToScene - PARTICLE_REPEL_SIZE);\n                data.vel -= 1.0 * distNormal * (distToScene - PARTICLE_REPEL_SIZE);\n            }\n            \n            \/\/ Integrate position\n            data.pos = data.pos + data.vel;\n            data.pos = clamp(data.pos, -1.0, 1.0);\n        }\n    }\n    else\n    {\n        \/\/ Nearest particle sort inspired by michael0884's Super SPH: https:\/\/www.shadertoy.com\/view\/tdXBRf\n        \/\/sort neighbors and neighbor neighbors\n        vec4 nb0 = fxGetParticleData(id, dataType);\n        ivec4 closest = fxGetClosest(ivec2(world2screen(data.pos)));\n        ivec4 bestIds = ivec4(nb0);\n        vec4 bestDists = vec4(length2(fxGetParticleData(bestIds[0], POS_VEL).xy - data.pos),\n            length2(fxGetParticleData(bestIds[1], POS_VEL).xy - data.pos),\n            length2(fxGetParticleData(bestIds[2], POS_VEL).xy - data.pos),\n            length2(fxGetParticleData(bestIds[3], POS_VEL).xy - data.pos));\n        \n        for (int i = 0; i < 4; ++i)\n        {\n            sort0(bestIds, bestDists, id, int(nb0[i]), dataType, data.pos);  \/\/sort this\n            sort0(bestIds, bestDists, id, int(closest[i]), dataType, data.pos);  \/\/sort this\n        }\n        \n        int searchIterations = 1;\n        if (iFrame < 5)\n        {\n            searchIterations = 10;\n        }\n        for(int k = 0; k < searchIterations; k++)\n        {\n            \/\/random hash. We should make sure that two pixels in the same frame never make the same hash!\n            float h = hash(\n                iFragCoord.x + \n                iFragCoord.y*int(iResolution.x) + \n                iFrame*int(iResolution.x*iResolution.y) +\n                k\n            );\n            \/\/pick random id of particle\n            int p = int(h*float(MAX_PARTICLES));\n            vec2 randXY = fxGetParticleData(p, POS_VEL).xy;\n            insertion_sort(bestIds, bestDists, p, length2(randXY - data.pos));\n        }\n\n        fragColor = vec4(bestIds);\n        return;\n    }\n    \n    fragColor = fxSaveParticle(data, dataType);\n}\n\nbool iscoincidence(in ivec4 bestIds, int currentId, int id)\n{\n    return id <= 0 ||\n      \tid == currentId ||\n        any(equal(bestIds,ivec4(id)));\n}\n\nvoid sort0(inout ivec4 bestIds, inout vec4 bestDists, int currentId, int searchId, int dataType, in vec2 myPos)\n{\n    if(iscoincidence(bestIds, currentId, searchId)) return; \/\/particle already sorted\n    \n    vec2 nbX = fxGetParticleData(searchId, POS_VEL).xy; \n\n    vec2 dx = nbX - myPos;\n    int dir = int(2.*(atan(dx.y, dx.x)+PI)\/PI); \n\n    if(dir != dataType) return; \/\/not in this sector\n    \n    float t = length2(dx);\n    \n    \/\/if (t > PARTICLE_REPEL_SIZE * 20.0) return;\n   \n    insertion_sort(bestIds, bestDists, searchId, t);\n}\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":258,"src":"\/media\/previz\/buffer01.png","ctype":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":258,"channel":0}],"code":"\/\/ Gijs's Basic : Voronoi Tracking: https:\/\/www.shadertoy.com\/view\/WltSz7\n\n\/\/ Voronoi Buffer\n\/\/ every pixel stores the 4 closest particles to it\n\/\/ every frame this data is shared between neighbours\n\nfloat distance2Particle(int id, vec2 fragCoord){\n    if(id==-1) return 1e20;\n    vec2 delta = fxGetParticleData(id, POS_VEL).xy-fragCoord;\n    return dot(delta, delta);\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n   \tivec2 iFragCoord = ivec2(fragCoord);\n\n    \/\/in this vector the four new closest particles' ids will be stored\n    ivec4 old = fxGetClosest(ivec2(fragCoord));\n    ivec4 new = ivec4(-1);\n    \n    \/\/in this vector the distance to these particles will be stored \n    vec4 dis = vec4(1e6);\n\n    insertion_sort(new, dis, old.x, distance2Particle(old.x, screen2world(fragCoord)));\n    insertion_sort(new, dis, old.y, distance2Particle(old.y, screen2world(fragCoord)));\n    insertion_sort(new, dis, old.z, distance2Particle(old.z, screen2world(fragCoord)));\n    insertion_sort(new, dis, old.w, distance2Particle(old.w, screen2world(fragCoord)));\n    \n    for(int x=-2; x<=2; x++){\n        for(int y=-2; y<=2; y++){\n            ivec4 old   = fxGetClosest( iFragCoord + ivec2( x, y) );      \n\n            for(int j=0; j<4; j++){\n                int id = old[j];\n                float dis2 = distance2Particle(id, screen2world(fragCoord));\n                insertion_sort( new, dis, id, dis2 );\n            }\n        }\n    }\n    \n    int searchIterations = 1;\n    if (iFrame < 5)\n    {\n        searchIterations = 10;\n    }\n    for(int k = 0; k < searchIterations; k++){\n        \/\/random hash. We should make sure that two pixels in the same frame never make the same hash!\n        float h = hash(\n            iFragCoord.x + \n            iFragCoord.y*int(iResolution.x) + \n            iFrame*int(iResolution.x*iResolution.y) +\n            k\n        );\n        \/\/pick random id of particle\n        int p = int(h*float(MAX_PARTICLES));\n        insertion_sort(new, dis, p, distance2Particle(p, screen2world(fragCoord)));\n    }\n    \n    fragColor = vec4(new); \n    \n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":33,"src":"\/presets\/tex00.jpg","ctype":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":258,"src":"\/media\/previz\/buffer01.png","ctype":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":259,"src":"\/media\/previz\/buffer02.png","ctype":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":259,"channel":0}],"code":"\/\/ Render particles and manage persistent state\n\nconst float PARTICLE_RENDER_SIZE = 0.04;\n\nvoid renderParticle(in fxParticle p, in vec2 fragCoord, inout vec4 fragColor)\n{   \n    \/\/if (p.density < 50.0) return;\n    vec2 closest;\n    float dist = linePointDist2(p.pos, p.pos - p.vel, fragCoord, iResolution, closest);\n\n    \/\/fragColor.w += max(0.0, PARTICLE_SDF_SIZE - sqrt(dist)) \/ PARTICLE_SDF_SIZE;\n    \/\/fragColor.xyz += 1000.2 * p.pressure * particleColor(p.uv) * max(0.0, PARTICLE_SIZE - sqrt(dist)) \/ PARTICLE_SIZE;\n    \/\/vec3 color = vec3(000.0*p.pressure, 30.0*length(p.vel), 0.012*p.density);\n    vec3 color = vec3(2);\/\/p.uv.y, sin(p.uv.y*23.0)*0.5 + 0.5, cos(p.uv.y* 10.0)*0.5 + 0.5);\n    fragColor.xyz += color * max(0.0, PARTICLE_RENDER_SIZE - sqrt(dist)) \/ PARTICLE_RENDER_SIZE;\n    \n    \/\/ Render neighbor lines\n    #if 0\n    for(int i = 0; i < 4; i++){\n        ivec4 neighbors = p.neighbors[i];\n        for (int j = 0; j < 4; ++j)\n        {\n            int cid = neighbors[j];\n            if(cid==-1 || cid >= MAX_PARTICLES || cid == 0) continue;\n\n            vec2 otherPos = fxGetParticleData(cid, POS_VEL).xy;\n\n            if (length(otherPos - p.pos) < 0.1)\n            {\n                float distToLin = linePointDist2(p.pos, p.pos + 0.5 * (otherPos - p.pos), fragCoord, iResolution, closest);\n                fragColor.xyz += 0.3*color * max(0.0, PARTICLE_SIZE * 0.3 - sqrt(distToLin)) \/ (PARTICLE_SIZE);\n            }\n        }\n    }\n    #endif\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    if (ivec2(fragCoord) == ivec2(0))\n    {\n        vec4 state = texture(iChannel2, vec2(0));\n\n        if (iFrame == 0 || keyDown(39) || iResolution.xy != state.yz)\n        {\n            state = vec4(0.0, iResolution.x, iResolution.y, 0.0);\n        }\n        else if (keyDown(37))\n        {\n            state = vec4(ANIMATE_FRAMES * 0.5, iResolution.x, iResolution.y, 0.0);\n        }\n        else\n        {\n            state.x += 1.0;\n            if (state.x > ANIMATE_FRAMES || keyDown(32))\n            {\n                state.x = 0.0;\n            }\n        }\n        fragColor = state;\n        return;\n    }\n    \n    fragColor = vec4(0.0);\n  \tvec2 p = (2.0*fragCoord-iResolution.xy)\/iResolution.xy;\n\n    \/\/get the id's of the 4 particles that (should be) closest.\n    \/\/the 4 ids are stored in .x, .y, .z, .w\n    ivec4 ids = fxGetClosest(ivec2(fragCoord));\n    \n    \/\/draw the particles\n    for(int i = 0; i < 4; i++){\n        \/\/get the particles position\n        int id = ids[i];\n        fxParticle particle = fxGetParticle(id);\n\n        renderParticle(particle, p, fragColor);\n    }\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":259,"src":"\/media\/previz\/buffer02.png","ctype":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":260,"channel":0}],"code":"\/\/ gaussian blur from FabriceNeyret2's smart gaussian blur: https:\/\/www.shadertoy.com\/view\/WtKfD3\n\nint           N = 7; \/\/ 7                              \/\/ target sampling rate\nfloat         w = .1,                                   \/\/ filter width\n              z;                                        \/\/ LOD MIPmap level to use for integration \n#define init  w = .01; \\\n              z = ceil(max(0.,log2(w*R.y\/float(N))));   \/\/ N\/w = res\/2^z\n#define R     iResolution.xy\n\n\nfloat convol2D(vec2 U) {                                                     \n    float  O = 0.0;  \n    float r = float(N-1)\/2., g, t=0.;                                       \n    for( int k=0; k<N*N; k++ ) {                                            \n        vec2 P = vec2(k%N,k\/N) \/ r - 1.;                                    \n        t += g = exp(-2.*dot(P,P) );                                        \n        O += g * textureLod(iChannel0, (U+w*P) *R.y\/R, z ).x;                 \n    }                                                                       \n    return O\/t;                                                             \n}      \n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    init \n    vec2 U = u \/ R.y;  \n    O = textureLod(iChannel0, u \/ iResolution.xy, 0.0);\n    O.x = convol2D(U); return;\n  \/\/  O = convol1D(U,vec2(1,0));\n}\n\n","name":"Buffer D","description":"","type":"buffer"}]}}