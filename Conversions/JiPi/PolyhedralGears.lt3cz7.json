{"Shader":{"ver":"0.1","info":{"id":"lt3cz7","date":"1532096995","viewed":2899,"name":"Polyhedral Gears","username":"Shane","description":"Interlocked animated gears mapped onto the surface of a sphere via a polyhedral Goldberg arrangement.","likes":125,"published":3,"flags":0,"usePreview":0,"tags":["sphere","animation","icosahedron","dodecahedron","gear","cog","polyhedron","goldberg"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"id":37,"channel":0}],"code":"\/*\n\n\tPolyhedral Gears\n\t----------------\n\n\tInterlocked animated gears mapped onto the surface of a sphere via a polyhedral \n\tGoldberg arrangement. I've seen a few of these in static and gif form, and have\n\talways wanted to produce one in a pixel shader.\n\n    The GPU compiler genie would disagree, but I was pleasantly surprized by how easily \n\tthis came together. I was expecting it to be difficult, considering that everything \n\twould have to be tiled in a kind of geodesic-related fashion using cheap -- but more \n\tthan likely, confusing -- folded coordinates.\n\n    I had a couple of images with no code nor explanation, so had to wing it. It was\n\tonly after producing a working example that I combed through the polyhedral \n    classifications on Wikipedia and found that the cogs are rendered in an icosahedral \n\t(Goldberg) arrangement. A Goldberg polyhedron is a dual of a geodesic sphere, which \n\tis why the pattern looks similar. In particular, this Goldberg polyhedron has a \n\tGP(3, 0) classification, which means there are 92 faces, 180 vertices and 270 edges. \n\tThat seems about right, considering there are 12 pentagons, 20 large hexagons and 60 \n\tsmaller hexagons spread over the surface.\n\n    Not being aware of the specifics meant that I simply rendered some cogs at the \n\tappropriate positions on an icosahedron and dodecahedron, interspersed a couple of \n\tsmaller cogs within the confines of the icosahedral triangle face, then crossed my \n\tfingers and hoped things magically lined up, which they did... I guess it was my \n\tlucky day. :D\n\n\tI also noticed after combing the net for a while that a lot of the imagery originates \n\tfrom Paul Nylander's site, \"Bugman123.com.\" For anyone not familiar with it, it's \n\twell worth the visit. When I get time, I'd like to produce a few other things from \n\tthere.\n\n\tApologies in advance for the lower frame rate on slower machines in general, and \n\tprobably in fullscreen on a lot of machines, but the detail was fiddly to code.\tI \n\twon't bore you with the details, suffice to say that folded polyhedral cells and \n    detailed moving cogs don't enjoy one another's company. Apologies for the compile \n\ttime too... Having said that, even though the distance function could do with some \n\tstreamlining, I don't feel that it's complicated enough to warrant a ten year compile \n\ttime, so I feel whoever updated WebGL should be doing most of the apologizing. :)\n\n\tBy the way, I'll put together a cleaner, more simplistic example later for anyone \n\twho'd like to make one of these, but doesn't wish to comb through a bunch of \n\tesoteric code.\n\n\t\n\t\/\/ Based on:\n\t\n    \/\/ Not the easiest of geometry to wrap one's head around at the best of times, and \n\t\/\/ from what I understand, DjinnKahn (Tom Sirgedas) was learning about shaders and \n\t\/\/ SDF at the same time. Quite amazing.\n    Icosahedron Weave - DjinnKahn\n\thttps:\/\/www.shadertoy.com\/view\/Xty3Dy\n\n\tOther examples:\n\n\t\/\/ Knighty is more comfortable folding space than most. I fold space about \n    \/\/ as well as I fold laundry. :)\n\tPolyhedron again - knighty\n\thttps:\/\/www.shadertoy.com\/view\/XlX3zB\n\n    \/\/ Tdhooper has some awesome icosahedral examples.\n    Icosahedron twist - tdhooper\n\thttps:\/\/www.shadertoy.com\/view\/Mtc3RX\n\n*\/\n\n#define FAR 20.\n\n\/\/ Color scheme: 0, 1 or 2 -> Gold and aluminium, black and chrome, pink and chrome.\n#define COLOR_SCHEME 0\n\n\/\/ 2D rotation formula.\nmat2 rot2(float a){ float c = cos(a), s = sin(a); return mat2(c, s, -s, c); }\n\n\/\/ I paid hommage to the original and kept the same rotation... OK, I'm lazy. :D\nvec3 rotObj(vec3 p){\n    \n    p.yz *= rot2(iTime*.2\/2.);\n    p.xz *= rot2(iTime*.5\/2.);\n    return p;  \n    \n}\n\n\n\/\/ More concise, self contained version of IQ's original 3D noise function.\nfloat noise3D(in vec3 p){\n    \n    \/\/ Just some random figures, analogous to stride. You can change this, if you want.\n\tconst vec3 s = vec3(113, 157, 1);\n\t\n\tvec3 ip = floor(p); \/\/ Unique unit cell ID.\n    \n    \/\/ Setting up the stride vector for randomization and interpolation, kind of. \n    \/\/ All kinds of shortcuts are taken here. Refer to IQ's original formula.\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    \n\tp -= ip; \/\/ Cell's fractional component.\n\t\n    \/\/ A bit of cubic smoothing, to give the noise that rounded look.\n    p = p*p*(3. - 2.*p);\n    \n    \/\/ Standard 3D noise stuff. Retrieving 8 random scalar values for each cube corner,\n    \/\/ then interpolating along X. There are countless ways to randomize, but this is\n    \/\/ the way most are familar with: fract(sin(x)*largeNumber).\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n\t\n    \/\/ Interpolating along Y.\n    h.xy = mix(h.xz, h.yw, p.y);\n    \n    \/\/ Interpolating along Z, and returning the 3D noise value.\n    float n = mix(h.x, h.y, p.z); \/\/ Range: [0, 1].\n\t\n    return n;\/\/abs(n - .5)*2.;\n}\n\n\/\/ Simple fBm to produce some clouds.\nfloat fbm(in vec3 p){\n    \n    \/\/ Four layers of 3D noise.\n    return 0.5333*noise3D( p ) + 0.2667*noise3D( p*2.02 ) + 0.1333*noise3D( p*4.03 ) + 0.0667*noise3D( p*8.03 );\n\n}\n\n\/\/ There's a neat way to construct an icosohedron using three mutually perpendicular rectangular \n\/\/ planes. If you reference something along the lines of icosahedron golden rectangle, you'll \n\/\/ get a pretty good idea. There's a standard image here:\n\/\/ https:\/\/math.stackexchange.com\/questions\/2538184\/proof-of-golden-rectangle-inside-an-icosahedron\n\/\/\n\/\/ Anyway, even a cursory glance will give you a fair idea where the figures below originate. In \n\/\/ a vertex\\indice list environment, you could produce an icosahedron without too much trouble at \n\/\/ all. However, in a realtime raymarching situation, you need to get to the triangle face \n\/\/ information in as few operations as possible. That's achieved via a bit of space folding using \n\/\/ the same information in a different way.\n\/\/\n\/\/ If weaving wasn't necessary, you could use the concise \"opIcosahedron\" function and be done\n\/\/ with it. Unfortunately, the \"abs\" calls throw out the triangular polarity information, which\n\/\/ you need to distinguish one side of the triangle from the other -- I wasted a lot of time not\n\/\/ realizing this until Djinn Kahn posted his example. He rewrote the folding function with an\n\/\/ additional variable to track polarity (signs) during each iteration.\n\/\/\n\/\/ With this function, you can obtain the triangle face information and use it to render in the\n\/\/ three regions of symmetry -- each with a left and right X axis. From there, you can do whatever \n\/\/ you wish. \n\n\/\/ Vertices: vec3(0, A, B), vec3(B, 0, A), vec3(-B, 0, A).\n\/\/ Face center: (vec3(0, A, B) + vec3(0, 0, A)*2.)\/3..\n\/\/ Edges: (vec3(0, A, B) + vec3(B, 0, A))\/2.,  etc.\n\n\n\/\/ The following have come from DjinnKahn's \"Icosahedron Weave\" example, here:\n\/\/ https:\/\/www.shadertoy.com\/view\/Xty3Dy\n\/\/\n\/\/ It works fine, just the way it is, so I only made trivial changes. I'd like to cut down the\n\/\/ number of operations in the \"opIcosahedronWithPolarity\" function, but so far, I can't see\n\/\/ a way to do that.\n\nconst float PHI = (1. + sqrt(5.))\/2.;\nconst float A = PHI\/sqrt(1. + PHI*PHI);\nconst float B = 1.\/sqrt( 1. + PHI*PHI);\nconst float J = (PHI - 1.)\/2.; \/\/ .309016994375;\nconst float K = PHI\/2.;        \/\/J + .5;\nconst mat3 R0 = mat3(.5,  -K,   J   ,K ,  J, -.5   ,J , .5,  K);\nconst mat3 R1 = mat3( K,   J, -.5   ,J , .5,   K   ,.5 ,-K,  J);\nconst mat3 R2 = mat3(-J, -.5,   K  ,.5 , -K,  -J   ,K ,  J, .5);\n\/\/ A handy matrix that rotates icosahedral vertices into the dual dodecahedron postions. \nconst mat3 R4 = mat3(.587785252292, -K, 0, -.425325404176, -J, .850650808352, .688190960236, .5, .525731112119);\n\n\n\/\/ I wanted all vertices hardcoded.\nconst vec3 v0 = vec3(0, A, B);\nconst vec3 v1 = vec3(B, 0, A);\nconst vec3 v2 = vec3(-B, 0, A);\nconst vec3 mid = (vec3(0,A,B) + vec3(0,0,A)*2.)\/3.; \/\/ (v0 + v1 + v2)\/3.*size.\n\n\n\/*\n\/\/ I could make these constant and hardcode them, but it's so messy... I guess I could get my calculator\n\/\/ out, but life's too short and this is just a shader. :)\nmat3 basisHex, basisHexSm1, basisHexSm2;\n\n\/\/ A cheap orthonormal basis vector function - Taken from Nimitz's \"Cheap Orthonormal Basis\" example, then \n\/\/ modified slightly.\n\/\/\n\/\/Cheap orthonormal basis by nimitz\n\/\/http:\/\/orbit.dtu.dk\/fedora\/objects\/orbit:113874\/datastreams\/file_75b66578-222e-4c7d-abdf-f7e255100209\/content\n\/\/via: http:\/\/psgraphics.blogspot.pt\/2014\/11\/making-orthonormal-basis-from-unit.html\nmat3 basis(in vec3 n){\n    \n    float a = 1.\/(1. + n.z);\n    float b = -n.x*n.y*a;\n    return mat3(1. - n.x*n.x*a, b, n.x, b, 1. - n.y*n.y*a, n.y, -n.x, -n.y, n.z);\n                \n}\n\n\/\/ Precalculating some face normals for various vertex positions, then producing the basis\n\/\/ matrix. Precalculation saves performing several loop calculations over and over. However,\n\/\/ this is at the expense of inline readability and variables. GPUs don't like globals... \n\/\/ Damned if you do, damned if you don't. :) This example needs more speed, so I might \n\/\/ hardcode the following into constants -- or something -- at a later stage.\nvoid initBases(){\n    \n\tconst vec3 hexN = normalize(cross((mid - v0), (mid - v1)));\n\n    basisHex = basis(hexN);\n    basisHexSm1 = basis(normalize(mix(v0, v2, .333)));\n    basisHexSm2 = basis(normalize(mix(v0, v1, .333)));\n    \n}\n*\/\n\n\/\/ Cyberjax suggested the following to replace the above with constants, which, \n\/\/ in theory, should run faster:\n#define a(n) (1.\/(1. + n.z))\n#define b(n) (-n.x*n.y*a(n))\n#define basis(n) mat3(1. - n.x*n.x*a(n), b(n), n.x, b(n), 1. - n.y*n.y*a(n), n.y, -n.x,-n.y,n.z)           \n\nconst vec3 hexN = normalize(cross((mid - v0), (mid - v1)));\nconst vec3 n1 = normalize(mix(v0, v2, .333));\nconst vec3 n2 = normalize(mix(v0, v1, .333));\n\nconst mat3 basisHex = basis(hexN);\nconst mat3 basisHexSm1 = basis(n1);\nconst mat3 basisHexSm2 = basis(n2);\n\n\/\/ Same as opIcosahedron, except without mirroring symmetry, so X-coordinate may be negative.\n\/\/ (note: when this is used as a distance function, it's possible that the nearest object is\n\/\/ on the opposite polarity, potentially causing a glitch).\nvec3 opIcosahedronWithPolarity(in vec3 p){\n   \n\tvec3 pol = sign(p);\n    p = R0*abs(p);\n\tpol *= sign(p);\n    p = R1*abs(p);\n\tpol *= sign(p);\n    p = R2*abs(p);\n\tpol *= sign(p);\n    vec3 ret = abs(p);\n    return ret * vec3(pol.x*pol.y*pol.z, 1, 1);\n}   \n\n\/*\n\/\/ The original function -- sans polarity information -- is neat and concise.\nvec3 opIcosahedron(vec3 p){ \n  \n    p = R0*abs(p);\n    p = R1*abs(p);\n    p = R2*abs(p);\n    return abs(p);  \n} \n*\/\n\n\n\/\/ An object ID container.    \nvec4 objID;\n\/\/ Other global IDs. These are slower as globals, but easier to pass around.\nfloat spokes, sph;\n\n\n\/\/ Three distance fields for each of the three different kinds of gears. I could role them into\n\/\/ one larger, and much messier function, but I prefer it this way. I'll comment them more \n\/\/ thoroughly later, but in short, it's just a bunch of fiddly calls to create the gear's objects. \n\/\/ There's some cyclinder-like calls, and some repeat radial boxish calls for the spokes, etc. \n\/\/ Standard stuff. As always, a lot of these functions are hacky bounds to save some operations, \n\/\/ but they produce very similar results.\n\/\/\n\/\/ The math and physics of the situation is less complicated than you'd think. The radii of the \n\/\/ gears have a ratio of 18:15:12. Since the radius and circumference is directly proportional, \n\/\/ this means the cog teeth ratio would be the same. The scalar rotational speed would be inversely \n\/\/ proportional -- Smaller wheels need to move faster to keep up with the larger wheel arcs. This\n\/\/ means time needs to be in a ratio of: 1.\/18: 1.\/15. : 1.\/12. You can see that implemented\n\/\/ below.\n\/\/\n\/\/ The only annoyance would be that when animating across the boundaries of the underlying \n\/\/ icosahedral structure -- used to position the gears, it's triangle based structure needs to be \n\/\/ considered. This means working with the number 3 and wrapping things... I hacked the wrapping \n\/\/ (the \"mod(iTime\/1.5\" lines) in a hurry to get things working, but I'll take a closer look later \n\/\/ to see if there's a more elegant solution.\n\n\/\/ The pentagonal gear\\cog..\nfloat dist(vec3 p, float r1, float r2){\n    \n    \/\/ Using inverse time values, and wrapping the polar angles to cooincide with\n    \/\/ the underlying icosaheral segments.\n    \/\/p.xy *= rot2(mod(iTime\/1.5, 3.*6.2831\/15.) + 6.2831\/2.);\n    p.xy *= rot2(mod(iTime\/1.5, 6.2831\/5.) + 3.14159265);\n    \n    float a = atan(p.y, abs(p.x)); \/\/ Note the \"abs\" call.\n    \n    \/\/ The outer gear radius needs to taper as it approaches the center to avoid\n    \/\/ overlap.\n    r1 *= (.9 + p.z);\n    \n    \/\/ The outer cog teeth. Basically, we're applying the repeat polar space thing.\n    vec3 q = p; \n    float ia = floor(a\/6.2831*15.) + .5;\n    q.xy = rot2(ia*6.2831\/15.)*q.xy; \/\/ Convert to polar coordinates. X -> radius, Y -> angle.\n    q.x += r1;\/\/ - .03\/3.; \/\/ Move the radial coordinate out to the edge of the rim.\n    q = abs(q);\n    float spike = mix(max(q.x - .05, q.y - .02), length(q.xy*vec2(.7, 1)) - .025, .5);\n    float d2 = max(spike, q.z - r2);\n   \n    \/\/ The inner spokes.\n    q = p; \n    ia = floor(a\/6.2831*5.) + .5;\n    q.xy = rot2(ia*6.2831\/5.)*q.xy;\n    sph = max(max(abs(q.x), abs(q.y)) - .0225, abs(q.z - .07) - .06);\n    \/\/sph = max(length(q.xy) - .0225, abs(q.z - .07) - .06);\n    q = abs(q + vec3(r1\/2., 0, -.07));\n    \/\/spokes = max(max(q.x - r1\/2. + .02, q.y - .03), q.z - .01);\n    spokes = max(q.x - r1\/2. + .02, max(max(q.y - .05, q.z - .015), (q.y + q.z)*.7071 - .025));\n    \n    \/\/ The inner cylindrical cog bit.\n    p = abs(p);\n    float d = length(p.xy);\n    float di = abs(d  -  r1 + .1\/2.) - .05\/2.;\n    d = abs(d  -  r1 + .075\/2.) - .075\/2.;\n    d = min(max(d , p.z - r2), max(di , p.z - r2 - .01));\n    \n    \/\/ Return the minimum of the inner cog and teeth. The inner spokes have been kept global\n    \/\/ for ID purposes and isn't include here... Yeah, messy, but this is a fiddly example\n    \/\/ to work with. :)\n    return min(d, d2);\n    \n}\n\n\/\/ The larger hexagonal gear\\cog.\nfloat dist2(vec3 p, float r1, float r2){\n    \n    \n    \/\/ See the comments in the \"dist\" function.\n    \n    \/\/\/p.xy *= rot2(mod(iTime\/1.8, 3.*6.2831\/18.) + 3.*6.2831\/18.);\n    p.xy *= rot2(mod(iTime\/1.8, 6.2831\/6.) + 6.2831\/6.);\n    \n    float a = atan(p.y, abs(p.x)); \/\/ Note the \"abs\" call.\n    \n    p.z = -p.z;\n    \n    r1 *= (.9 + p.z);\n    \n    vec3 q = p; \n    \n    float ia = floor(a\/6.2831*18.) + .5;\n    q.xy = rot2(ia*6.2831\/18.)*q.xy; \/\/ Convert to polar coordinates. X -> radius, Y -> angle.\n    q.x += r1;\/\/ - .03\/3.; \/\/ Move the radial coordinate out to the edge of the rim.\n    q = abs(q);\n    float spike = mix(max(q.x - .05, q.y - .02), length(q.xy*vec2(.7, 1)) - .025, .5);\n    float d2 = max(spike, q.z - r2);\n    \n    q = p; \n    ia = floor(a\/6.2831*6.) + .5;\n    q.xy = rot2(ia*6.2831\/6.)*q.xy;\n    sph = max(max(abs(q.x), abs(q.y)) - .0275, abs(q.z - .07) - .06);\n    \/\/sph = max(length(q.xy) - .0275, abs(q.z - .07) - .06);\n    q = abs(q + vec3(r1\/2., 0, -.07));\n    \/\/spokes = max(max(q.x - r1\/2. + .02, q.y - .03), q.z - .01);\n    spokes = max(q.x - r1\/2. + .02, max(max(q.y - .05, q.z - .015), (q.y + q.z)*.7071 - .03));\n    \n    p = abs(p);\n    float d = length(p.xy);\n    float di = abs(d  -  r1 + .1\/2.) - .05\/2.;\n    d = abs(d  -  r1 + .075\/2.) - .075\/2.;\n    d = min(max(d , p.z - r2), max(di , p.z - r2 - .0115));\n    \n    return min(d, d2);\n    \n}\n\n\/\/ The smaller hexagonal gear\\cog.\nfloat dist3(vec3 p, float r1, float r2){\n    \n    \/\/ See the comments in the \"dist\" function.\n    \n    \/\/ This is the same as the two functions above, but the smaller cogs cross a boundary line\n    \/\/ and directional polarity has to be considered.\n    float dir = p.x < 0.? -1. : 1.;\n    \n    p.x = abs(p.x);\n    vec3 q2 = p;\n    p.xy *= rot2(mod(iTime\/1.2*dir + 3.14159\/12., 6.2831\/12.) + 5.*6.2831\/12.); \/\/ + 5.*3.14159\/12.\n    \n    \n    float a = atan(p.y, abs(p.x)); \/\/ Note the \"abs\" call.\n    \n    r1 *= (.9 + p.z);\n    \n    vec3 q = p;\n   \n    float ia = floor(a\/6.2831*12.) + .5;\n    q.xy = rot2(ia*6.2831\/12.)*q.xy; \/\/ Convert to polar coordinates. X -> radius, Y -> angle.\n    q.x += r1;\/\/ - .03\/3.; \/\/ Move the radial coordinate out to the edge of the rim.\n    q.xy = abs(q.xy);\n    float spike = mix(max(q.x - .05, q.y - .02), length(q.xy*vec2(.7, 1)) - .025, .5);\n    float d2 = max(spike, abs(q.z) - r2);\n\n    \n    q = q2; \n    q.xy *= rot2(mod(iTime\/1.2*dir, 6.2831\/6.) + 2.*6.2831\/6.);\n    a = atan(q.y, abs(q.x));\n    ia = floor(a\/6.2831*6.) + .5;\n    q.xy = rot2(ia*6.2831\/6.)*q.xy;\n    sph = max(max(abs(q.x), abs(q.y)) - .02, abs(q.z - .07) - .06);\n    \/\/sph = max(length(q.xy) - .02, abs(q.z - .07) - .06);\n    q = abs(q + vec3(r1\/2., 0, -.07));\n    spokes = max(q.x - r1\/2. + .02, max(max(q.y - .04, q.z - .015), (q.y + q.z)*.7071 - .02));\n    \n    \n    p = abs(p);\n    float d = length(p.xy);\n    float di = abs(d  -  r1 + .1\/2.) - .05\/2.;\n    d = abs(d  -  r1 + .075\/2.) - .075\/2.;\n    d = min(max(d , p.z - r2), max(di , p.z - r2 - .007));\n    \n    return min(d, d2);\n    \n}\n\n\/\/Raytraced sphere hit variable. \n\/\/float balHit; \n\nfloat map(in vec3 p){\n   \n    \n    \/\/ Back plane. Six units behind the center of the weaved object.\n    float pln = -p.z + 6.;\n    \n\/*  \n    \/\/ Raytraced sphere hit variable. It saves extra calculation, but\n    \/\/ complicates things. Plus, it can interfere with shadows, add to \n    \/\/ the compile time... It saves a lot of pixel calculations though, \n    \/\/ especially in fullscreen... I'll have a think about it. :)\n    if(balHit < 0.){\n        \n        objID = vec4(1e5, 1e5, 1e5, pln);\n        return pln;\n        \n    }\n*\/   \n    \n    \/\/ Rotate the object.\n    p = rotObj(p);\n    \/\/p.yz *= rot2(-3.14159\/6.);\n    \n    vec3 oP = p;\n    \n    \n    float d = 1e5, d2 = 1e5, d3 = 1e5;\n    \n   \n    \/\/ DjinnKahn's icosahedral distance function that produces a triangular face\n    \/\/ and allows you to determine between the negative and positive X axis.\n    \n    \/\/ Large hexagonal face positions.\n    vec3 hexFace = opIcosahedronWithPolarity(p); \n    \n    \/\/ Rotating the points above to the dual pentagonal face positions. This saves\n    \/\/ a lot of extra operations. We're able to do this because of the icosahedron\n    \/\/ and dodecahedron duality.\n    vec3 pentFace = R4*hexFace; \n    \n    \/\/ Pentagon.\n    vec3 p1 = (pentFace - vec3(0, 0, 1));\n    d3 = min(d3, dist( p1, .185, .1) );\n    d = min(d, spokes);\n    d3 = min(d3, sph);\n    \n    \/\/ Hexagon. \n    p1 = basisHex*(hexFace - mid*1.2425);\n    d3 = min( d3, dist2( p1, .25, .1) );\n    d = min(d, spokes);\n    d3 = min(d3, sph);\n    \n    \/\/ Small cogs.\n    p1 = basisHexSm1*(hexFace - mix(v0, v2, .333)*1.1547);\n    d2 = min( d2, dist3( p1, .16, .1) );\n    d = min(d, spokes);\n    d3 = min(d3, sph);\n    p1 = basisHexSm2*(hexFace - mix(v0, v1, .333)*1.1547);\n    d2 = min( d2, dist3( p1, .16, .1) );\n    d = min(d, spokes);\n    d3 = min(d3, sph);\n    \n   \n    \/\/ Capping off the edges of the gears with the outer sphere itself.\n    float mainSph = length(oP);\n    d = max(d, mainSph - 1.0825);\n    d2 = max(d2, mainSph - 1.116);\n    d3 = max(d3, mainSph - 1.118);\n \n    \n\n    \n    \/\/ Store the individual object values for sorting later. Sorting multiple objects\n    \/\/ inside a raymarching loop probably isn't the best idea. :)\n    objID = vec4(d, d2, d3, pln);\n    \n    return min(min(d, d2), min(d3, pln));\n}\n\n\/*\n\/\/ Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ. In instances where there's no descernible \n\/\/ aesthetic difference between it and the six tap version, it's worth using.\nvec3 calcNormal(in vec3 p){\n\n    \/\/ Note the slightly increased sampling distance, to alleviate artifacts due to hit point inaccuracies.\n    vec2 e = vec2(0.0025, -0.0025); \n    return normalize(e.xyy * map(p + e.xyy) + e.yyx * map(p + e.yyx) + e.yxy * map(p + e.yxy) + e.xxx * map(p + e.xxx));\n}\n*\/\n\n\/*\n\/\/ Standard normal function. 6 taps.\nvec3 calcNormal(in vec3 p) {\n\tconst vec2 e = vec2(0.002, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n*\/\n\n\/*\n\/\/ Normal calculation, with some edging and curvature bundled in.\nvec3 calcNormal(vec3 p, inout float edge, inout float crv, float t) { \n\t\n    \/\/ It's worth looking into using a fixed epsilon versus using an epsilon value that\n    \/\/ varies with resolution. Each affects the look in different ways. Here, I'm using\n    \/\/ a mixture. I want the lines to be thicker at larger resolutions, but not too thick.\n    \/\/ As for accounting for PPI; There's not a lot I can do about that.\n    vec2 e = vec2(3.\/mix(450., min(850., iResolution.y), .35), 0);\/\/*(1. + t*t*.7);\n\n\tfloat d1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\tfloat d3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\tfloat d5 = map(p + e.yyx), d6 = map(p - e.yyx);\n\tfloat d = map(p)*2.;\n\n    edge = abs(d1 + d2 - d) + abs(d3 + d4 - d) + abs(d5 + d6 - d);\n    \/\/edge = abs(d1 + d2 + d3 + d4 + d5 + d6 - d*3.);\n    edge = smoothstep(0., 1., sqrt(edge\/e.x*2.));\n     \n    \/\/ Wider sample spread for the curvature.\n    \/\/e = vec2(12.\/450., 0);\n\t\/\/d1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\t\/\/d3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\t\/\/d5 = map(p + e.yyx), d6 = map(p - e.yyx);\n    \/\/crv = clamp((d1 + d2 + d3 + d4 + d5 + d6 - d*3.)*32. + .5, 0., 1.);\n \n    \n    e = vec2(.001, 0); \/\/iResolution.y - Depending how you want different resolutions to look.\n\td1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\td3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\td5 = map(p + e.yyx), d6 = map(p - e.yyx);\n\t\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n*\/\n\n\/\/ IQ rewrote the function above, and for reasons that defy my own sense \n\/\/ of logic, has cut the compile time down by at least half. For whatever\n\/\/ reason, restricting an unroll in the larger iteration \"trace\" function\n\/\/ has virtually no effect on compile time, yet doing the same with the\n\/\/ fewer \"map\" calls in the following function does... I'll leave the\n\/\/ explanation for that conundrum to the GPU instruction experts. :)\n\/\/\nvec3 calcNormal(vec3 p, inout float edge, inout float crv, float t) { \n    \n    float eps = 3.\/mix(450., min(850., iResolution.y), .35);\n\n    float d = map(p);\n    \n    vec3 e = vec3(eps, 0, 0);\n    \n    vec3 da = vec3(-2.*d);\n    for( int i = min(iFrame,0); i<3; i++ )\n    {\n        for( int j=min(iFrame,0); j<2; j++ )\n            da[i] += map(p + e*float(1-2*j));\n        e = e.zxy;\n    }\n    da = abs(da);\n    \n    edge = da.x + da.y + da.z;\n    edge = smoothstep(0., 1., sqrt(edge\/e.x*2.));\n    \n    vec3 n = vec3(0.0);\n    for( int i=min(iFrame, 0); i<4; i++ )\n    {\n        vec3 e = .57735*(2.*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1)) - 1.);\n        n += e*map(p + .001*e);\n    }\n    \n    return normalize(n);\n}\n\n\/\/ Raymarching: The distance function is a little on the intensive side, so I'm \n\/\/ using as fewer iterations as necessary. Even though there's a breat, the compiler\n\/\/ still has to unroll everything, and larger numbers make a difference.\nfloat trace(in vec3 ro, in vec3 rd){\n    \n    float t = 0., d;\n    \n    for(int i = 0; i<64; i++){\n    \n        d = map(ro + rd*t);\n        if(abs(d)<.001*(1. + t*.05) || t > FAR) break;\n        t += d;\n    }\n    \n    return min(t, FAR);\n}\n\n\/*\nfloat hash( float n ){ return fract(cos(n)*45758.5453); }\n\n\/\/ Ambient occlusion, for that self shadowed look. Based on the original by XT95. I love this \n\/\/ function and have been looking for an excuse to use it. For a better version, and usage, \n\/\/ refer to XT95's examples below:\n\/\/\n\/\/ Hemispherical SDF AO - https:\/\/www.shadertoy.com\/view\/4sdGWN\n\/\/ Alien Cocoons - https:\/\/www.shadertoy.com\/view\/MsdGz2\nfloat calculateAO( in vec3 p, in vec3 n, float maxDist )\n{\n\tfloat ao = 0.0, l;\n\tconst float nbIte = 6.0;\n\t\/\/const float falloff = 0.9;\n    for( float i=1.; i< nbIte + .5; i++ ){\n    \n        l = (i + hash(i))*.5\/nbIte*maxDist;\n        ao += (l - map( p + n*l ))\/(1.+ l);\/\/ \/ pow(1.+l, falloff);\n    }\n\t\n    return clamp( 1.-ao\/nbIte, 0., 1.);\n}\n*\/\n\n\/\/ Ambient occlusion, for that self shadowed look.\n\/\/ Based on the original by IQ.\nfloat calcAO(in vec3 p, in vec3 n)\n{\n\tfloat sca = 4., occ = 0.0;\n    for( int i=1; i<6; i++ ){\n    \n        float hr = float(i)*.125\/5.;        \n        float dd = map(p + hr*n);\n        occ += (hr - dd)*sca;\n        sca *= .75;\n    }\n    return clamp(1. - occ, 0., 1.);   \n    \n}\n\n\/\/ The iterations should be higher for proper accuracy.\nfloat softShadow(in vec3 ro, in vec3 rd, float t, in float end, in float k){\n\n    float shade = 1.0;\n    \/\/ Increase this and the shadows will be more accurate, but more iterations slow things down.\n    const int maxIterationsShad = 24; \n\n    \/\/ The \"start\" value, or minimum, should be set to something more than the stop-threshold, so as to avoid a collision with \n    \/\/ the surface the ray is setting out from. It doesn't matter how many times I write shadow code, I always seem to forget this.\n    \/\/ If adding shadows seems to make everything look dark, that tends to be the problem.\n    float dist = .001*(1. + t*.05);\n    float stepDist = end\/float(maxIterationsShad);\n\n    \/\/ Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    \/\/ number to give a decent shadow is the best one to choose. \n    for (int i = 0; i<maxIterationsShad; i++){\n        \/\/ End, or maximum, should be set to the distance from the light to surface point. If you go beyond that\n        \/\/ you may hit a surface not between the surface and the light.\n        float h = map(ro + rd*dist);\n        shade = min(shade, k*h\/dist);\n        \/\/shade = min(shade, smoothstep(0.0, 1.0, k*h\/dist));\n        \n        \/\/ What h combination you add to the distance depends on speed, accuracy, etc. To be honest, I find it impossible to find \n        \/\/ the perfect balance. Faster GPUs give you more options, because more shadow iterations always produce better results.\n        \/\/ Anyway, here's some posibilities. Which one you use, depends on the situation:\n        \/\/ +=max(h, 0.001), +=clamp( h, 0.01, 0.25 ), +=min( h, 0.1 ), +=stepDist, +=min(h, stepDist*2.), etc.\n        \n        dist += clamp(h, 0.01, 0.25);\n        \n        \/\/ There's some accuracy loss involved, but early exits from accumulative distance functions can help.\n        if (h<0.0001 || dist > end) break; \n    }\n\n    \/\/ Return the shadow value. Note that I'm not using clamp. The shadow value should be capped to zero\n    \/\/ prior to adding a constant... Unless you're not adding a constant. :)\n    return min(max(shade, 0.) + .1, 1.); \n}\n\n\n\/\/ Very basic pseudo environment mapping... and by that, I mean it's fake. :) However, it \n\/\/ does give the impression that the surface is reflecting the surrounds in some way.\n\/\/\n\/\/ More sophisticated environment mapping:\n\/\/ UI easy to integrate - XT95    \n\/\/ https:\/\/www.shadertoy.com\/view\/ldKSDm\nvec3 envMap(vec3 p){\n    \n    p *= 3.;\n    \n    float n3D2 = noise3D(p*3.);\n   \n    \/\/ A bit of fBm.\n    float c = noise3D(p)*.57 + noise3D(p*2.)*.28 + noise3D(p*4.)*.15;\n    c = smoothstep(.25, 1., c); \/\/ Putting in some dark space.\n    \n    p = vec3(c, c*c, c*c*c); \/\/ Bluish tinge.\n    \n    return mix(p, p.zyx, n3D2*.5 + .5); \/\/ Mixing in a bit of purple.\n\n}\n\n\/*\n\/\/ Intersection of a sphere. IQ's formula - trimmed down a little.\nfloat traceSphere( in vec3 ro, in vec3 rd, in vec4 sph ){\n\n\tro -= sph.xyz;\n\tfloat b = dot(ro, rd);\n\tfloat h = b*b - dot(ro, ro) + sph.w*sph.w;\n    return h<0. ? -1. : -b - sqrt( h );\n}\n*\/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ Aspect correct screen coordinates. Restricting the size of the\n    \/\/ fullscreen object to maintain a little detail on larger screens.\n    \/\/ A consequence is a larger background. By the way, this was coded\n    \/\/ for the 800 by 450 canvas or smaller, rather than fullscreen.\n    vec2 p = (fragCoord - iResolution.xy*.5)\/min(850., iResolution.y);\n    \n    \/\/ Unit direction ray.\n    vec3 rd = normalize(vec3(p, 1));\n    \n    \/\/ Ray origin, doubling as the camera postion.\n    vec3 ro = vec3(0, 0, -2.75);\n    \n    \/\/ Light position. Near the camera.\n    vec3 lp = ro + vec3(.25, 2, -.1);\n    \n    \/\/ Basic camera rotation.\n    rd.xy *= rot2(sin(iTime\/8.)*.2);\n    rd.xz *= rot2(sin(iTime\/4.)*.1);\n    \n    \/\/ Precalculating some basis matrix values.\n    \/\/ Replaced with Cyberjax's suggestion.\n    \/\/initBases();\n    \n    \/\/balHit = traceSphere(ro, rd, vec4(vec3(0), 1.2)); \/\/ Main object pixel flag.\n    \n    \/\/ Ray march.\n    float t = trace(ro, rd);\n    \n    \/\/ Object identification: Back plane: 3, Golden joins: 2., \n    \/\/ Ball joins: 1., Silver pipes:  0.\n    float svObjID = objID.x<objID.y && objID.x<objID.z && objID.x<objID.w? 0.: \n    objID.y<objID.z && objID.y<objID.w ? 1. : objID.z<objID.w? 2. : 3.;\n\n    \n    \/\/ Initiate the scene color zero.\n    vec3 sceneCol = vec3(0);\n    \n    \/\/ Surface hit. Color it up.\n    if(t < FAR){\n    \n        \/\/ Position.\n        vec3 pos = ro + rd*t;\n        \/\/ Normal.\n        \/\/vec3 nor = calcNormal(pos);\n        \/\/ Normal, plus edges and curvature. The latter isn't used.\n        float edge = 0., crv = 1.;\n        vec3 nor = calcNormal(pos, edge, crv, t);\n        \n        \/\/vec3 rp = rotObj(pos);\n        \n        \/\/ Light direction vector.\n        vec3 li = lp - pos;\n        float lDist = max(length(li), .001);\n        li \/= lDist;\n        \n        \/\/ Light falloff - attenuation.\n        float atten = 1.\/(1. + lDist*.05 + lDist*lDist*0.025);\n        \n        \/\/ Soft shadow and occlusion.\n        float shd = softShadow(pos + nor*.0015, li, t, lDist, 8.); \/\/ Shadows.\n        float ao = calcAO(pos, nor);\n        \n        \n        float diff = max(dot(li, nor), .0); \/\/ Diffuse.\n        float spec = pow(max(dot(reflect(-li, nor), -rd), 0.), 16.); \/\/ Specular.\n        \/\/ Ramping up the diffuse. Sometimes, it can make things look more metallic.\n        float od = diff;\n        diff = pow(diff, 4.)*2.; \n        \n        \n        float Schlick = pow( 1. - max(dot(rd, normalize(rd + li)), 0.), 5.0);\n\t\tfloat fre2 = mix(.5, 1., Schlick);  \/\/F0 = .5.\n\t\t\n        \/\/ Spokes: ObjID == 0.;\n        #if COLOR_SCHEME == 0\n        vec3 col = vec3(.6); \/\/ Silver.\n        #elif COLOR_SCHEME == 1\n        vec3 col = vec3(.1); \/\/ Black.\n        #else\n        vec3 col = vec3(.9, .2, .4); \/\/ Pink.\n        #endif\n\n        \n        if(svObjID == 1.) { \/\/ Smaller hexagon cogs.\n            #if COLOR_SCHEME == 0\n            col = vec3(1, .5, .2)*.7; \/\/ Gold.\n            #else \n            col = vec3(.6); \/\/ Chrome.\n            #endif\n         }\n        if(svObjID == 2.){ \/\/ Larger hexagon and pentagon cogs.\n            \n            #if COLOR_SCHEME == 0\n            col = vec3(1, .65, .3)*.7; \/\/ Gold-Copper\n            #else \n            col = vec3(.6); \/\/ Chrome.\n            #endif\n        }\n        if(svObjID == 3.) { \/\/ Back plane.\n            \n            \/\/ Dark background color. Noise is applied afterward (See below).\n            #if COLOR_SCHEME == 0\n            col = vec3(1, .7, .4)*.045; \/\/ Brown.\n            #elif COLOR_SCHEME == 1\n            col = vec3(.7)*.045; \/\/ Charcoal.\n            #else\n            col = vec3(.6, .7, 1)*.045; \/\/ Blue.\n            #endif\n        }\n        \n        \n        \/\/ Applying some subtle 3D fBm noise to the gear object and back plane to grunge\n        \/\/ it up slightly. Technically, I should be keeping a copy of the individual gear\n        \/\/ rotations and applying those, but the compiler is hating on this example enough\n        \/\/ already, so I've lowered these noise intensity and added noisy environmental \n        \/\/ reflection so that the sliding UV effect is negigible.       \n        float txSz = 1.;\n        vec3 txPos = pos; \n        if(svObjID == 3.) txSz \/= 4.;\n        else txPos = rotObj(txPos);\n        col *= fbm(txPos*64.*txSz)*.75 + .5;\n        \n    \n        \n        \/\/ Diffuse plus ambient term.\n        sceneCol = col*(diff + .25); \n        \n        \/\/ Specular term.\n        if(svObjID == 3.) sceneCol += col*vec3(1, .6, .2).zyx*spec*.25; \/\/ Less specular on the back plane.\n        else sceneCol += col*vec3(.5, .75, 1.)*spec*2.;\n        \n        \/\/ Fake environment mapping.\n        float envF = 4.;\n        if(svObjID == 0.) envF = 8.;\n        sceneCol += sceneCol*envMap(reflect(rd, nor))*envF;\n        \n        \/\/ Edges.\n        sceneCol *= 1. - edge*.8;\n        \/\/col = col*.7 + edge*.3;\n        \n        sceneCol *= atten*shd*ao; \/\/ Applying the light falloff, shadows and AO.\n        \n        \n        \n         \n    }\n    \n    \/\/ Screen color. Rough gamma correction. No fog or postprocessing.\n    fragColor = vec4(sqrt(clamp(sceneCol, 0., 1.)), 1);\n}","name":"Image","description":"","type":"image"}]}}