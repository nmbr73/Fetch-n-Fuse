{"Shader":{"ver":"0.1","info":{"id":"NtjcDG","date":"1650210675","viewed":124,"name":"SDF collision","username":"jcyuan","description":"SDF collision","likes":7,"published":3,"flags":32,"usePreview":0,"tags":["collision","sdf"],"hasliked":0},"renderpass":[{"inputs":[{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":37,"channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2. * fragCoord - iResolution.xy) \/ iResolution.y;\n    \n    float w = length(fwidth(uv));\n    \n    float d = map(uv);\n    float c = smoothstep(-w, w, abs(d));\n\n    vec3 col = vec3(c);\n    \n    vec4 buf = texture(iChannel0, uv);\n    vec2 bp = buf.xy;\n    \n    float ball = length(uv - bp) - BALL_R;\n    ball = smoothstep(-w, w, abs(ball));\n    \n    col *= ball;\n    \n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":257,"channel":0}],"code":"const float ia = BALL_INIT_ANGLE * 3.1415926536 \/ 180.;\nconst vec2 ip = BALL_INIT_POS;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy \/ iResolution.xy;\n    \n    vec4 d = texture(iChannel0, uv);\n    \n    if (d.z == 0.) {\n        d.zw = vec2(cos(ia), sin(ia)) * .5 + .5;\n        d.xy = ip;\n    } else {\n        vec2 v = d.zw * 2. - 1.;\n        vec2 p = d.xy;\n        p += v * .0166 * MOVE_SPEED;\n        \n        float dist = map(p);\n        if (dist > -BALL_R) {\n            p -= (dist + BALL_R) * v;\n            \n            vec2 n = nrm(p);\n            vec2 o = reflect(v, n);\n            \n            d.zw = o * .5 + .5;\n        }\n        \n        d.xy = p;\n    }\n    \n    fragColor = d;\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\/\/ Header: Enable access to inputs from Common tab (Author: https:\/\/www.shadertoy.com\/view\/ttf3R4)\n#if __LINE__ < 17\n    #define _ST_TAB_COMMON\n#endif\n#ifdef _ST_TAB_COMMON\n    uniform float iTime;\n#endif\n\/\/ End header\n\n\/\/ ------------------------------------------------------------\n\n#define BALL_R .05\n#define BALL_INIT_POS vec2(0., .3)\n#define BALL_INIT_ANGLE 45.\n\n#define MOVE_SPEED 2.2\n\nfloat box(vec2 p, vec2 s) {\n    vec2 bd = abs(p) - s;\n    return length(max(bd, 0.)) + min(max(bd.x, bd.y), 0.);\n}\n\nfloat star(vec2 p, float r, float rf) {\n    const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n    const vec2 k2 = vec2(-k1.x, k1.y);\n    p.x = abs(p.x);\n    p -= 2.0 * max(dot(k1,p),0.0) * k1;\n    p -= 2.0 * max(dot(k2,p),0.0) * k2;\n    p.x = abs(p.x);\n    p.y -= r;\n    vec2 ba = rf * vec2(-k1.y, k1.x) - vec2(0, 1);\n    float h = clamp( dot(p, ba) \/ dot(ba, ba), 0.0, r);\n    return length(p - ba * h) * sign(p.y * ba.x - p.x * ba.y);\n}\n\nfloat moon(vec2 p, float d, float ra, float rb) {\n    p.y = abs(p.y);\n    float a = (ra * ra - rb * rb + d * d) \/ (2. * d);\n    float b = sqrt(max(ra * ra - a * a, 0.));\n    if (d * (p.x * b - p.y * a) > d * d * max(b - p.y, 0.))\n        return length(p - vec2(a, b));\n    return max((length(p) - ra), -(length(p - vec2(d, 0)) - rb));\n}\n\nfloat map(vec2 p) {\n    float d = 0.;\n    \n    vec4 r = vec4(.0, .5, .2, .3);\n    r.xy = (p.x > 0.0) ? r.xy : r.zw;\n    r.x  = (p.y > 0.0) ? r.x : r.y;\n    vec2 q = abs(p) - vec2(1.6, .9) + r.x;\n    d = min(max(q.x, q.y), 0.) + length(max(q, 0.)) - r.x;\n    \n    float c = length(p) - .2;\n    \n    float cs = cos(iTime), ss = sin(iTime);\n    mat2 rot1 = mat2(cs, -ss, ss, cs);\n    mat2 rot2 = mat2(cs, ss, -ss, cs);\n    \n    vec2 cp = abs(rot1 * (p - vec2(-1., .5)));\n    c = min(c, length(cp - min(cp.x + cp.y, .25) * .5) - .025);\n    \n    c = min(c, box(rot1 * (p - vec2(-1., -.5)), vec2(.1, .2)));\n    \n    c = min(c, star(rot2 * (p - vec2(1., .5)), .18, .4));\n    \n    c = min(c, moon(rot2 * (p - vec2(1., -.5)), .05, .18, .14));\n    \n    d = max(-c, d);\n    \n    return d;\n}\n\nvec2 nrm(vec2 p) {\n    vec2 eps = vec2(.001, .0);\n\treturn normalize(vec2(\n\t\tmap(p + eps.xy) - map(p-eps.xy),\n\t\tmap(p + eps.yx) - map(p-eps.yx)\n\t));\n}\n","name":"Common","description":"","type":"common"}]}}