{
 "ver": "0.1",
 "info": {
  "id": "NdfBz7",
  "date": "0",
  "viewed": 0,
  "name": "The meaning of Life JiPi 914",
  "description": "What the frog? Just playing with deformabed textures",
  "likes": 0,
  "published": "Private",
  "usePreview": 0,
  "tags": [
   "texture",
   "frog"
  ],
  "hasliked": 0,
  "parentid": "3s2XWW",
  "parentname": "The meaning of life"
 },
 "renderpass": [
  {
   "inputs": [
    {
     "id": "4dX3Rn",
     "filepath": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg",
     "type": "texture",
     "channel": 0,
     "sampler": {
      "filter": "mipmap",
      "wrap": "repeat",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    },
    {
     "id": "4sf3Rr",
     "filepath": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png",
     "type": "texture",
     "channel": 2,
     "sampler": {
      "filter": "mipmap",
      "wrap": "repeat",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    }
   ],
   "outputs": [
    {
     "id": "4dfGRr",
     "channel": 0
    }
   ],
   "code": "// Created by Sebastien DURAND - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//----------------------------------------------------------------\n// Thanks to\n// Iq: Deformed tubes, distance field, shadows, etc. \n// Shane: Texture 3D, render\n//----------------------------------------------------------------\n\n// The far plane. I'd like this to be larger, but the extra iterations required to render the \n// additional scenery starts to slow things down on my slower machine.\n#define FAR 80.\n#define PI 3.14159265\n#define ZERO min(0,iFrame)\n\nconst float slab = 0.05;\nconst float ani0 = 2.,  // Start Grow\n      ani1 = 6.,  \n      ani2 = 10.,  // start graine\n      ani3 = 20.,  // start move cam up\n      ani4 = 30.,  // start move to frogs\n\t  ani5 = 46.,  // start turn arround frogs\n      ani5b = 64., // To center of frogs\n      ani5b2 = 83., // Eye bottom\n      ani5c = 86., // Move hand \n      ani5d = 101., // Enter the ground\n\t  ani6 = 122., // Under the ground\n \t  ani7 = 129.;\n\nconst mat2 rot = mat2(cos(-.3),sin(-.3),-sin(-.3),cos(-.3));\n\nfloat dhaloLight, dhaloFrog;\nfloat sanim01, sanim12, sanim23, sanim34, sanim45, sanim56, sanim5cd, sanim56r, sanim67;\nfloat gPulse, gPulseGround;\n\n// --------------------------------------------------------------\n\nvec2 rotate( vec2 v, float a ) { return vec2( v.x*cos(a)+v.y*sin(a), -v.x*sin(a)+v.y*cos(a) ); }\nvec2 sincos( float x ) { return vec2( sin(x), cos(x) ); }\nvec3 opU( vec3 d1, vec3 d2 ){ return (d1.x<d2.x) ? d1 : d2;}\n\n\n// --------------------------------------------------------------\n// hash functions\n// --------------------------------------------------------------\nfloat hash( vec2 p ) { return fract(sin(1.0+dot(p,vec2(127.1,311.7)))*43758.545); }\nfloat hash( float n ){ return fract(cos(n)*45758.5453); }\nfloat hash( vec3 p ) { return fract(sin(dot(p, vec3(7, 157, 113)))*45758.5453); }\nvec3 hash3( vec2 p ) {\n    vec3 q = vec3( dot(p,vec2(127.1,311.7)), \n\t\t\t\t   dot(p,vec2(269.5,183.3)), \n\t\t\t\t   dot(p,vec2(419.2,371.9)) );\n\treturn fract(sin(q)*43758.5453);\n}\n// --------------------------------------------------------------\n\n\n\n// Grey scale.\nfloat getGrey(vec3 p){ return dot(p, vec3(0.299, 0.587, 0.114)); }\n\n\n// IQ's smooth minium function. \nfloat sminP(float a, float b , float s){\n    float h = clamp(.5 + .5*(b-a)/s, 0. , 1.);\n    return mix(b, a, h) - h*(1.-h)*s;\n}\n\n// Smooth maximum, based on the function above.\nfloat smaxP(float a, float b, float s){\n    float h = clamp( .5 + .5*(a-b)/s, 0., 1.);\n    return mix(b, a, h) + h*(1.-h)*s;\n}\n\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n    n = max(n*n, 0.001);\n    n /= (n.x + n.y + n.z );  \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n\n\n//--------------------------------------------------\n// From Mercury\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float rep) {\n\tfloat angle = 2.*PI/rep,\n         a = atan(p.y, p.x) + angle*.5,\n         r = length(p),\n         c = floor(a/angle);\n\ta = mod(a, angle) - angle*.5;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= rep*.5) c = abs(c);\n\treturn c;\n}\n//-----------------------------------------------------\n\n\nfloat sdSegment( vec3 p, vec3 a, vec3 b, float r) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1. );\t\n    return length(pa - ba*h) - r;\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r) {\n    float k0 = length(p/r), k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n// capsule with bump in the middle -> use for arms and legs\nfloat sdBumpCapsule( vec3 p, vec3 a, vec3 b, float r, float k) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba), 0., 1. ),\n    \t dd = k*cos(3.141592*h+1.57);  // Little adaptation\n    return length(pa - ba*h) - r+dd; \n}\n\n// ------------------------------------------------------------------\n\nfloat sdFrog(vec3 p) {\n\n    float id = pModPolar(p.xz, 12.);\n    p.x -= 12.;\n    p.y += .1;\n    \n    float scale = .4 + .2*hash(id);\n    p /= scale;\n    p.xz += 2.*fract(11.*scale);\n    \n    float dFrog = length(p-vec3(.31,1.6,0));\n    if (dFrog> 3.3+1./scale) return dFrog;\n    \n    float kRot = sanim5cd*.2*cos(id + 5.*iTime); \n    p.xz = rotate(p.xz, .5*kRot);\n    vec3 pr = p;\n    pr.xy *= rot;\n    \n    float sgn = sign(p.z);\n    p.z = abs(p.z);\n    pr.z = abs(pr.z);\n    \n    float dEye = length(pr-vec3(-2.,2.,.7)) - .7;\n  \n    float dLeg = sminP(sdBumpCapsule(p,vec3(2.1,.7,.3),vec3(.0,2.5, 2.7),.2,.3),\n                     sminP(sdBumpCapsule(p,vec3(0.,2.4,2.8),vec3(1.8,.6,1.3),.2,.2),\n                           sdSegment(p,vec3(1.8,.6,1.3),vec3(1.2,.3,1.6),.2),.05) ,.05);\n    float dFeet =  min(sdSegment(p,vec3(1.1,.25,1.55),vec3(.2,.3,1.5),.08),\n                       min(sdSegment(p,vec3(1.2,.25,1.6),vec3(-.0,.3,2.),.08),\n    \t\t\t\t\t   sdSegment(p,vec3(1.1,.25,1.75),vec3(.3,.3,2.3),.08)));\n    float dFinger = min(min(length(p-vec3(.3,.3,1.5)),\n                        length(p-vec3(.1,.3,2.))),\n                        length(p-vec3(.4,.3,2.3))) - .12;\n  \n    vec3 pFinger = p;\n    pFinger.z += 4.*sgn*kRot;\n    \n    float dLeg2 = sminP(sdBumpCapsule(p,vec3(-1.,1.6,1.6),vec3(-.2,1.2, 2.2-sgn*kRot),.2,.1),\n                     sdBumpCapsule(p,vec3(-.2,1.2,2.3-sgn*kRot),vec3(-1.,.3,2.-4.*sgn*kRot),.2,.1),.1);\n    \n    float dFeet2 =  min(sdSegment(pFinger,vec3(-1.,.2,2.),vec3(-1.8,.3,1.5),.1),\n                       min(sdSegment(pFinger,vec3(-1.,.2,2.),vec3(-2.,.3,2.),.1),\n    \t\t\t\t       min(sdSegment(pFinger,vec3(-1.,.2,2.),vec3(-1.3,.3,1.1),.1),\n                               sdSegment(pFinger,vec3(-1.,.2,2.),vec3(-.85,.3,1.2),.1)\n                              )));\n    float dFinger2 = min(min(length(pFinger-vec3(-1.8,.3,1.5)),\n                             length(pFinger-vec3(-2.,.3,2.))),\n                         min(length(pFinger-vec3(-1.3,.3,1.1)),\n                             length(pFinger-vec3(-.85,.3,1.2))) ) - .12;\n    \n    dFeet2 = sminP(dFinger2, dFeet2,.1); \n    dFeet = sminP(dFinger, dFeet,.1); \n    dLeg = sminP(dLeg, dFeet,.2);\n    dLeg2 = sminP(dLeg2, dFeet2,.2);\n    \n    float dd = max(max(.5-p.y, dot(pr-vec3(3.,1.3,0), normalize(vec3(1,2,1)))),\n                   max(dot(pr-vec3(-3.4,1.8,-.1), normalize(vec3(-1.9,1.,2))),\n                       min(.8-pr.y, dot(pr-vec3(-.5,.3,2.), normalize(vec3(-1.5,-2.2,1))))));\n\t\n    float dBody = sdEllipsoid(pr-vec3(-.5,1.2,0), vec3(2.7,1.3,2));\n    dBody = smaxP(dd, dBody, .1);\n    dBody = sminP(dBody, dEye, .2);\n    \n    float d = dBody;\n    \n    d = smaxP(dd, d, .1);\n    d = sminP(d, dEye, .2);\n    d = smaxP(d, -min(dLeg,dLeg2), .3);\n    d = sminP(d, dLeg, .2);\n    d = sminP(d, dLeg2, .15);\n    d = smaxP(d, -(length(p - vec3(-1.5,2.4,.8)) - .5), .4);\n    d = smaxP(d, -(length(pr - vec3(-3.05,1.55,.18))), .1);\n    \n    float kFrog = .55*smoothstep(.9,1.,cos(iTime+102.*id));\n    d = sminP(d, sdEllipsoid(pr-vec3(-2.,.65-.2*kFrog,0.), mix(vec3(.5,.15,.9), vec3(1.,1.,1.8), kFrog)), .2);\n    dEye = length(p-vec3(-1.5,2.4,.8)) - .5;\n    \n    return scale*min(d,dEye);\n}\n\n\nfloat mapTube( vec3 p ) {\n    vec2 id = floor( (p.xz+5.0)/10. );\n    \n    float k = hash(id.x+101.*id.y);\n    if (k>.3 || k<.1) return 999.;\n    \n    float tt = mod(iTime,1.5)/1.5;\n    float ss = pow(tt,.2)*0.5 + 0.5;\n    float pulseY = sanim01*(.25+ss*0.5*sin(tt*6.2831*3.+p.y)*exp(-tt*4.0));\n    ss = pulseY*.25;\n\n    p.xz = mod(p.xz+5.0, 10.) - 5.;\n    p.xz += .5*sin( 2.0 + p.y*vec2(.53,.32) - vec2(1.57,.0) );\n\n    return min( min(length(p.xz+.15*sincos(p.y)), \n                    length(p.xz+.15*sincos(p.y+4.))) - .15*(.8+.2*sin(2.*p.y)) - ss, \n                min(length(p.xz+.15*sincos(p.y+2.)) - .15*(.8+.2*sin(2.*p.y + 2.*(p.y-iTime)))-ss-.01, \n                    length(p.xz+.15*sincos(p.y+5.)) - .08*(.8+.2*sin(2.*p.y + ss + 8.*(p.y-iTime)))-.02-.3*ss));\n}\n\n\nfloat map( vec3 pos, bool light) {\n    vec3 p0 = pos;\n\n    float h = mix(1.,.1, smoothstep(20., 14., length(pos.xz))) + gPulseGround;\n    h *= texture(iChannel2, -p0.xz*.02).x;\n    pos.y -= h;\n    \n    float kEat = sanim56*(1.+.1*gPulse); \n    vec3 pFrog = p0-vec3(0, - 1.5*kEat,0);\n    \n    float dFrog = iTime < ani4 ? 999. : sdFrog(pFrog);\n\n    float dTube = mapTube(pos);\n\n    vec2 id = floor( (pos.xz-1.)/2.);\n    \n    pos.xz = mod(pos.xz+1., 2.) - 1.;\n    pos.xz += .2*sin(dot(120.*id,vec2(1213.15,1317.34)));\n    pos.xz += vec2(1,-1)*.2*sin(3.5*iTime +3.*cos(pos.y))*sin(.5*pos.y);\n\n    vec3 posButton = pos;\n    \n    float len = max(sanim01,.1)*(.5+.4*smoothstep(.4,.5,cos(.3*iTime+id.x))+0.3*sin(dot(110.*id,vec2(1213.15,1317.34))));\n    float thi = sanim01*(.8+.4*cos(.4*iTime)) * slab * (0.5+0.3*sin(-3.151592*posButton.y/len));\n   \n    float d = 999.;\n     \n    if (hash(id.x+11.*id.y) > .6) {\n        d = sdSegment( posButton, vec3(0.,-len*.25,0.), vec3(0,len,0), 4.*thi);\n        float dlight = length(pos-vec3(0,fract(1.+cos(id.x+3.1*id.y)+iTime*.1)*15.,0))-.05*sanim23;\n        if (light) dhaloLight = min(dhaloLight, pos.y > len ? dlight-.02*sanim23 : 9999.);\n        if (sanim23 > 0.) {\n            d = sminP(d, dlight, .3);\n        }\n    }\n    if (light && sanim56 > 0.) {\n        dhaloFrog = min(dhaloFrog, dFrog -.02*sanim56); \n    }\n\n    // Bump arround frog ---------------------------------\n\n    float idFrog = pModPolar(pFrog.xz, 12.);\n    pFrog.x -= 12.;\n    float scale = .4 + .2*hash(idFrog);\n    pFrog /= scale;\n    pFrog.xz += 2.*fract(11.*scale);\n \n    float dBumpFrog = scale*(length(pFrog-vec3(-1.,1.7-2.1*kEat*kEat,0))-4.*kEat);\n    // ---------------------------------------------------\n\n    d = sminP(d, pos.y, .3);\n    d = sminP(d, dBumpFrog, .6);\n    d = smaxP(d,-dFrog, .3);\n\n    \n//    return min(dFrog, min(dTube, smaxP(-min(dTube-.3,length(p0.xz)-4.2), d, 1.)));\n    return min(dFrog, min(dTube, smaxP(-dTube+.3, d, 1.)));\n}\n\n\nfloat textureFrog(vec3 p, out vec4 out_posIdFrog) {\n    float id = pModPolar(p.xz, 12.);\n    p.x -= 12.;\n    p.y += .1;\n    \n    float scale = .4 + .2*hash(id);\n    p /= scale;\n    p.xz += 2.*fract(11.*scale);\n    \n    float dFrog = length(p-vec3(.31,1.6,0));\n    if (dFrog> 3.3+1./scale) return dFrog;\n        \n   \n    float kRot = sanim5cd*.2*cos(id + 5.*iTime); \n    p.xz = rotate(p.xz, .5*kRot);\n    vec3 p0 = p;\n    vec3 pr = p;\n    pr.xy *= rot;\n    \n    float sgn = sign(p.z);\n    p.z = abs(p.z);\n    pr.z = abs(pr.z);\n    \n    float dEye = length(pr-vec3(-2.,2.,.7)) - .7;\n  \n    float dLeg = sminP(sdBumpCapsule(p,vec3(2.1,.7,.3),vec3(.0,2.5, 2.7),.2,.3),\n                     sminP(sdBumpCapsule(p,vec3(0.,2.4,2.8),vec3(1.8,.6,1.3),.2,.2),\n                          sdSegment(p,vec3(1.8,.6,1.3),vec3(1.2,.3,1.6),.2),.05) ,.05);\n    float dFeet =  min(sdSegment(p,vec3(1.1,.25,1.55),vec3(.2,.3,1.5),.08),\n                       min(sdSegment(p,vec3(1.2,.25,1.6),vec3(-.0,.3,2.),.08),\n    \t\t\t\tsdSegment(p,vec3(1.1,.25,1.75),vec3(.3,.3,2.3),.08)));\n    float dFinger = min(min(length(p-vec3(.3,.3,1.5)),\n                        length(p-vec3(.1,.3,2.))),\n                        length(p-vec3(.4,.3,2.3))) - .12;\n  \n    vec3 pFinger = p;\n    pFinger.z += 4.*sgn*kRot;\n    float dLeg2 = sminP(sdBumpCapsule(p,vec3(-1.,1.6,1.6),vec3(-.2,1.2, 2.2-sgn*kRot),.2,.1),\n                     sdBumpCapsule(p,vec3(-.2,1.2,2.3-sgn*kRot),vec3(-1.,.3,2.-4.*sgn*kRot),.2,.1),.1);\n    \n    float dFeet2 =  min(sdSegment(pFinger,vec3(-1.,.2,2.),vec3(-1.8,.3,1.5),.1),\n                       min(sdSegment(pFinger,vec3(-1.,.2,2.),vec3(-2.,.3,2.),.1),\n    \t\t\t\t       min(sdSegment(pFinger,vec3(-1.,.2,2.),vec3(-1.3,.3,1.1),.1),\n                               sdSegment(pFinger,vec3(-1.,.2,2.),vec3(-.85,.3,1.2),.1)\n                              )));\n    float dFinger2 = min(min(length(pFinger-vec3(-1.8,.3,1.5)),\n                             length(pFinger-vec3(-2.,.3,2.))),\n                         min(length(pFinger-vec3(-1.3,.3,1.1)),\n                             length(pFinger-vec3(-.85,.3,1.2))) ) - .12;\n    \n    dFeet2 = sminP(dFinger2, dFeet2,.1); \n    dFeet = sminP(dFinger, dFeet,.1); \n    dLeg = sminP(dLeg, dFeet,.2);\n    dLeg2 = sminP(dLeg2, dFeet2,.2);\n    \n    float dd = max(max(.5-p.y, dot(pr-vec3(3.,1.3,0), normalize(vec3(1,2,1)))),\n                   max(dot(pr-vec3(-3.4,1.8,-.1), normalize(vec3(-1.9,1.,2))),\n                       min(.8-pr.y, dot(pr-vec3(-.5,.3,2.), normalize(vec3(-1.5,-2.2,1))))));\n\t\n    float dBody = sdEllipsoid(pr-vec3(-.5,1.2,0), vec3(2.7,1.3,2));\n    dBody = smaxP(dd, dBody, .1);\n    dBody = sminP(dBody, dEye, .2);\n    \n    float d = dBody;\n    \n    d = smaxP(dd, d, .1);\n    d = sminP(d, dEye, .2);\n    d = smaxP(d, -min(dLeg,dLeg2), .3);\n    d = sminP(d, dLeg, .2);\n    d = sminP(d, dLeg2, .15);\n    d = smaxP(d, -(length(p - vec3(-1.5,2.4,.8)) - .5), .4);\n    d = smaxP(d, -(length(pr - vec3(-3.05,1.55,.18))), .1);\n    \n    float kFrog = .55*smoothstep(.9,1.,cos(iTime+102.*id));\n    d = sminP(d, sdEllipsoid(pr-vec3(-2.,.65-.2*kFrog,0.), mix(vec3(.5,.15,.9), vec3(1.,1.,1.8), kFrog)), .2);\n    vec3 pEye = p-vec3(-1.5,2.4,.8);\n    dEye = length(pEye) - .5;\n    \n    out_posIdFrog = d<dEye ? vec4(p0, 20.+abs(id)) : vec4(pEye, 31.+abs(id));\n    \n    return scale*min(d,dEye);\n}\n\n\nfloat texturePtTube(vec3 p, out vec4 out_idPosTube) {\n\n    vec2 id = floor( (p.xz+5.0)/10. );\n\n    float k = hash(id.x+101.*id.y);\n    if (k>.3 || k<.1) return 999.;\n    \n    float tt = mod(iTime,1.5)/1.5;\n    float ss = pow(tt,.2)*0.5 + 0.5;\n    float pulseY = sanim01*(.25+ss*0.5*sin(tt*6.2831*3.0+p.y)*exp(-tt*4.0));\n    ss = pulseY*.25;\n\n    p.xz = mod( p.xz+5.0, 10.0 ) - 5.0;\n    p.xz += 0.5*sin( 2.0 + (p.y)*vec2(0.53,0.32) - vec2(1.57,0.0) );\n\n    vec3 p1 = p; p1.xz += 0.15*sincos(p.y);\n    vec3 p2 = p; p2.xz += 0.15*sincos(p.y+2.0);\n    vec3 p3 = p; p3.xz += 0.15*sincos(p.y+4.0);\n    vec3 p4 = p; p4.xz += 0.15*sincos(p.y+5.0);   \n    \n    float h1 = length(p1.xz),\n         h2 = length(p2.xz),\n     \t h3 = length(p3.xz),\n     \t h4 = length(p4.xz);\n\n    vec3 res = opU( opU(vec3(h1-0.15*(0.8+0.2*sin(2.*p.y))-ss, 10., p.y), \n                    \tvec3(h2-0.15*(0.8+0.2*sin(2.*p.y+2.0*(p2.y-iTime)))-ss-.01, 11., p.y)), \n                    opU(vec3(h3-0.15*(0.8+0.2*sin(2.*p.y))-ss, 12., p.y),\n        \t\t\t\tvec3(h4-0.08*(0.8+0.2*sin(2.*p.y+ss+8.0*(p.y-iTime)))-.02-.3*ss, 13., p.y) ));\n\n    out_idPosTube = vec4(res.y == 10. ? p1 : res.y == 11. ? p2 : res.y == 12. ? p3 : p4, res.y);\n    return res.x;\n}\n\n\nvec4 texturePt(vec3 pos) {\n    vec3 p0 = pos;\n\n    float h = mix(1.,.1, smoothstep(20., 14., length(pos.xz))) + gPulseGround;\n    h *= texture(iChannel2, -p0.xz*.02).x;\n    pos.y -= h;\n    \n   \n    float kEat = sanim56*(1.+.1*gPulse); \n    vec3 pFrog = p0-vec3(0,-1.5*kEat,0);\n    vec4 idPosFrog;\n    float dFrog = textureFrog(pFrog, idPosFrog);\n\n    vec4 idPosTube;\n    float dTube = texturePtTube(pos, idPosTube);\n         \n    vec2 id = floor( (pos.xz-1.)/2.);    \n    pos.xz -= .2*sin(dot(120.*id,vec2(1213.15,1317.34)));\n    pos.xz += vec2(1,-1)*.2*sin(3.5*iTime +3.*cos(pos.y))*sin(.5*pos.y);\n\n    return dTube < .01 ? idPosTube : dFrog < .01 ? idPosFrog : vec4(pos,1.);\n}\n\n\n#define EDGE_WIDTH .001\n\nvec3 trace(in vec3 ro, in vec3 rd, in float maxd) {\n\t// edge detection\n    dhaloLight = 9999.; // reset closest trap\n    dhaloFrog = 9999.;\n    float lastt,lastDistEval = 1e10;\n\tfloat edge = 0.0;\n    float iter = 0.;\n\n    float t = hash(rd);\n    float d = 999.;//map(rd*t + ro);\n    for (int i=ZERO; i<240; i++){\n\t\td = .7*map(rd*t + ro, true);\n        if ( abs(d) < 0.002 || t > maxd) break;\n        t += min(.9,d);\n    }\n    return vec3(t);\n}\n\n\n// Tetrahedral normal, courtesy of IQ.\n// -- Calculate normals -------------------------------------\n\nvec3 calcNormal(in vec3 pos, in vec3 ray, in float t) {\n\n\tfloat pitch = .2 * t / iResolution.x;\n\tpitch = max( pitch, .002 );\n\t\n\tvec2 d = vec2(-1,1) * pitch;\n\n\tvec3 p0 = pos+d.xxx, p1 = pos+d.xyy, p2 = pos+d.yxy, p3 = pos+d.yyx;\n\tfloat f0 = map(p0,false), f1 = map(p1,false), f2 = map(p2,false), f3 = map(p3,false);\n\t\n\tvec3 grad = p0*f0+p1*f1+p2*f2+p3*f3 - pos*(f0+f1+f2+f3);\n\t// prevent normals pointing away from camera (caused by precision errors)\n\treturn normalize(grad - max(.0, dot (grad,ray))*ray);\n}\n\n\n\n\n// The iterations should be higher for proper accuracy, but in this case, I wanted less accuracy, just to leave\n// behind some subtle trails of light in the caves. They're fake, but they look a little like light streaming \n// through some cracks... kind of.\nfloat softShadow(in vec3 ro, in vec3 rd, in float start, in float end, in float k){\n\n    float shade = 1.0;\n    const int maxIterationsShad = 32; \n    float dist = start;\n    float stepDist = end/float(maxIterationsShad);\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i=ZERO; i<maxIterationsShad; i++){\n        float h = map(ro + rd*dist,false);\n        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist));\n        dist += clamp(h, 0.1, stepDist*2.);\n        if (abs(h)<0.001 || dist > end) break; \n    }\n    return min(max(shade, 0.) + 0.1, 1.0); \n}\n\n\n\n// Ambient occlusion, for that self shadowed look. Based on the original by XT95. I love this \n// function and have been looking for an excuse to use it. For a better version, and usage, \n// refer to XT95's examples below:\n//\n// Hemispherical SDF AO - https://www.shadertoy.com/view/4sdGWN\n// Alien Cocoons - https://www.shadertoy.com/view/MsdGz2\nfloat calculateAO(in vec3 pos, in vec3 nor) {\n    float dd, hr=.01, totao=.0, sca=1.;\n    for(int aoi=ZERO; aoi<4; aoi++ ) {\n        dd = map(nor * hr + pos,false);\n        totao += -(dd-hr)*sca;\n        sca *= .8;\n        hr += .06;\n    }\n    return clamp(1.-4.*totao, 0., 1.);\n}\n\n\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total.\nvec3 doBumpMap( sampler2D tex, in vec3 p, in vec3 nor, float bumpfactor){\n   \n    const float eps = 0.001;\n    vec3 grad = vec3( getGrey(tex3D(tex, vec3(p.x-eps, p.y, p.z), nor)),\n                      getGrey(tex3D(tex, vec3(p.x, p.y-eps, p.z), nor)),\n                      getGrey(tex3D(tex, vec3(p.x, p.y, p.z-eps), nor)));\n    \n    grad = (grad - getGrey(tex3D(tex,  p , nor)))/eps;             \n    grad -= nor*dot(nor, grad);          \n    return normalize( nor + grad*bumpfactor );\n\t\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 palette(float id, float k) {\n    return 2.*pal( k, vec3(0.5,0.8,0.8),vec3(0.6,0.3,0.5),vec3(1.0,.2,1.0), vec3((id-10.)*.01) );\n}\n\n\n// HSV to RGB conversion \n// [iq: https://www.shadertoy.com/view/MsS3Wc]\nvec3 hsv2rgb_smooth(float x, float y, float z) {\n    vec3 rgb = clamp( abs(mod(x*6.+vec3(0.,4.,2.),6.)-3.)-1., 0., 1.);\n\trgb = rgb*rgb*(3.-2.*rgb); // cubic smoothing\t\n\treturn z * mix( vec3(1), rgb, y);\n}\n\n\n// -------------------------------------------------------------------\n// pupils effect came from lexicobol shader:\n// https://www.shadertoy.com/view/XsjXz1\n// -------------------------------------------------------------------\n\n\n\nfloat iqnoise( in vec2 x, float u, float v )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\tfloat k = 1.0+63.0*pow(1.0-v,4.0);\n\tfloat va = 0.0;\n\tfloat wt = 0.0;\n    for( int j=-2+ZERO; j<=2; j++ )\n    for( int i=-2+ZERO; i<=2; i++ ) {\n        vec2 g = vec2(i,j);\n\t\tvec3 o = hash3( p + g )*vec3(u,u,1.0);\n\t\tvec2 r = g - f + o.xy;\n\t\tfloat d = dot(r,r);\n\t\tfloat ww = pow( 1.0-smoothstep(0.0,1.414,sqrt(d)), k );\n\t\tva += o.z*ww;\n\t\twt += ww;\n    }\n\t\n    return va/wt;\n}\n\nfloat noise ( vec2 x)\n{\n\treturn iqnoise(x, 0.0, 1.0);\n}\n\nmat2 m = mat2( 0.8, 0.6, -0.6, 0.8);\n\nfloat fbm( vec2 p)\n{\n\tfloat f = 0.0;\n    f += 0.5000 * noise(p); p *= m* 2.02;\n    f += 0.2500 * noise(p); p *= m* 2.03;\n    f += 0.1250 * noise(p); p *= m* 2.01;\n    f += 0.0625 * noise(p); p *= m* 2.04;\n    f /= 0.9375;\n    return f;\n}\n\nvec3 iris(vec2 p, float open)\n{\n\n    float r = sqrt( dot (p,p));\n    float r_pupil = .15 + .15*smoothstep(.5,2.,open);\n    \n    float dPupil = length(vec2(abs(p.x)+.2, p.y)) - .35;// + .15*smoothstep(.5,2.,open);\n\n    float a = atan(p.y, p.x); // + 0.01*iTime;\n    vec3 col = vec3(1.0);\n    \n    float ss = 0.5;// + 0.5 * sin(iTime * 2.0);\n    float anim = 1.0 + 0.05*ss* clamp(1.0-r, 0.0, 1.0);\n    r *= anim;\n        \n    if( r< .8) {\n\t\tcol = vec3(0.12, 0.60, 0.57);\n        float f = fbm(5.0 * p);\n        col = mix(col, 2.*vec3(1.,.8,0.12), f); \n        \n        f = 1.0 - smoothstep( 0., .1, dPupil);\n        col = mix(col, vec3(0.12,1., 0.30), f); \n        \n        a += 0.05 * fbm(20.0*p);\n        \n        f = smoothstep(0.3, 1.0, fbm(vec2(5.0 * r, 20.0 * a))); // white highlight\n        col = mix(col, vec3(1.0), f);\n        \n        f = smoothstep(0.3, 1.0, fbm(vec2(5.0 * r, 5.0 * a))); // yellow highlight\n        col = mix(col, vec3(1.5,.8,0.12), f);\n        \n        f = smoothstep(0.5, 1.0, fbm(vec2(5.0 * r, 15.0 * a))); // dark highlight\n        col *= 1.0 - f;\n        \n        f = smoothstep(0.55, 0.8, r); //dark at edge\n        col *= 1.0 - 0.6*f;\n        \n        f = smoothstep( 0., .05, dPupil); //pupil\n        col *= f; \n        \n        f = smoothstep(0.75, 0.8, r);\n        col = .5*mix(col, vec3(1.0), f);\n    }\n    \n\treturn 3.*col;\n}\n\n\n\n#ifdef STEREOGRAPHIC\nvec3 getStereoDir(vec2 fragCoord)\n{\n\tvec2 p = fragCoord.xy / iResolution.xy;\n    float t = 3.+iTime*.08, ct = cos(t), st = sin(t);\n\tfloat m = .5;\n    p = (p * 2. * m - m)*.7;\n    p.x *= iResolution.x/iResolution.y;\n    p *= mat2(ct,st,-st,ct);\n\n\treturn normalize(vec3(2.*p.x,dot(p,p)-1.,2.*p.y));\n}  \n#endif\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\t\n\tfloat tt = mod(iTime,1.5)/1.5;\n    float ss = pow(tt,.2)*0.5 + 0.5;\n\n    sanim01 = smoothstep(ani0,ani1,iTime);\n    sanim12 = smoothstep(ani1,ani2,iTime);\n    sanim23 = smoothstep(ani2,ani3,iTime);\n    sanim34 = smoothstep(ani3,ani4,iTime);\n    sanim45 = smoothstep(ani4,ani5,iTime);\n    sanim56r = smoothstep(ani5b,ani5c,iTime); \n    float sanim5c = smoothstep(ani5,ani5c,iTime); \n    sanim5cd = smoothstep(ani5c,ani5d,iTime); \n    sanim56 = smoothstep(ani5d,ani6,iTime); \n    sanim67 = smoothstep(ani6,ani7,iTime);\n    \n    // Heart pulse\n    gPulse = (.25+ss*0.5*sin(tt*6.2831*3.0)*exp(-tt*4.0));\n    \n    // Ground Pulse\n    gPulseGround = .2+.8*mix(gPulse, 0., sanim45 + sanim67);\n    \n\t// Screen coordinates.\n\tvec2 u = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n\t    \n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n    // Camera Setup.\n    float a = .1*iTime + 2.*3.141592*iMouse.x/iResolution.x;\n    \n\tvec3 ro = vec3(-92.0,  4.5, -78.);\n    ro = mix(ro, vec3(-106.0,  8.0, -84.), sanim34); \n    ro = mix(ro, vec3(cos(-a), .3, sin(-a))*26., sanim45);\n    ro = mix(ro, vec3(1,3,0), sanim5c);\n    ro = mix(ro, vec3(1,3,0) + vec3(1.,.2,.8)*(iTime - ani6), sanim67);\n    \n\tvec3 lookAt = ro + vec3(.25, -.22, .5); // Camera position, doubling as the ray origin.\n\tlookAt = mix(lookAt, vec3(0, 0, 0), sanim34); // Camera position, doubling as the ray origin.\n\tlookAt = mix(lookAt, vec3(cos(a), .25, sin(a))*7., sanim5c); // Camera position, doubling as the ray origin.\n \n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159/6.; // FOV - Field of view.\n    vec3 forward = normalize(lookAt-ro);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x )); \n    vec3 up = cross(forward, right);\n\n    // rd - Ray direction.\n    vec3 rd = normalize(forward + FOV*u.x*right + FOV*u.y*up);\n\n\n    // Swiveling the camera about the XY-plane (from left to right) when turning corners.\n    // Naturally, it's synchronized with the path in some kind of way.\n\t//rd.xz = rot2( /*iMouse.x/iResolution.x +*/ path(lookAt.z).x/64. )*rd.xz;\n\n    // Usually, you'd just make this a unit directional light, and be done with it, but I\n    // like some of the angular subtleties of point lights, so this is a point light a\n    // long distance away. Fake, and probably not advisable, but no one will notice.\n\n\tvec3 res = trace(ro, rd, FAR);\n    float t = res.x;\n    \n    // Standard sky routine. Worth learning. For outdoor scenes, you render the sky, then the\n    // terrain, then mix together with a fog falloff. Pretty straight forward.\n    vec3 sky = .3*vec3(1.,1.3,1.3);//getSky(ro, rd, normalize(lp - ro));\n    vec3 col = sky;\n\t\n //   vec3 lp = mix(ro+vec3(5.05,-1.5,-5.05), ro+vec3(.05,12.5,-5.05), sanim56r);\n //   lp = mix(lp, ro+vec3(5.05,-1.5,-5.05), sanim67);\n    \n     vec3 lp = (forward*.5+up-right)*FAR/*vec3(FAR*.5, FAR, FAR)*/ + vec3(0, 0, ro.z);\n\n    if (t < FAR){\n    \t\n        vec3 sp = ro+t*rd; // Surface point.\n        vec4 spt = texturePt(sp); // Surface points on objects coords (to enable textures to follow object moves)\n        vec3 sn = calcNormal( sp, rd, t ); // Surface normal.\n\n\t\t// Light direction\n        vec3 ld = normalize(lp-sp);\n\n        // Texture scale factor.        \n        const float tSize1 = 1./3.;\n        float k;\n        vec3 colTxt;\n        \n        if (spt.w > 30.) {\n            // Frog eyes\n            vec3 pe = spt.xyz;\n            float a = .2*cos(.1*iTime),\n                  ca = cos(a), sa = sin(a);\n            pe.xz *= mat2(ca, sa, -sa, ca);\n            float b = mix(3.1-1.5*fract(iTime*.2+.17*spt.w), 4.2, step(ani5b2, iTime)),//sanim56r),\n                  cb = cos(b), sb = sin(b);\n            pe.xy *= mat2(cb, sb, -sb, cb);\n            colTxt = iris((pe.zy), 20.5);\n\n        } else if (spt.w > 19.) {\n            // Frog Body\n            vec3 hh = hash3(vec2(spt.w,spt.w));\n            colTxt = hsv2rgb_smooth(spt.w*.2, .6, .7);\n            colTxt = mix(colTxt, vec3(0.), .7*smoothstep(.6,.7, hh*.5+tex3D(iChannel2, spt.xyz*tSize1, sn).x));\n            colTxt = mix(colTxt, vec3(0,1,1), .1*smoothstep(.0,1., -sn.y));\n            colTxt = .7*sqrt(colTxt);\n\t        sn = doBumpMap(iChannel2, 2.*spt.xyz*tSize1, sn, .2/(1. + t/FAR));\n            \n        } else if (spt.w > 5.) {\n\n\t        float k = tex3D(iChannel0, spt.xyz*tSize1 + .1*spt.w, sn).x;\n            colTxt = mix(vec3(1.2,.5,.4), palette(1., spt.w), .7+.3*cos(spt.w+4.*spt.y-5.*iTime));     \n            colTxt = mix(colTxt, vec3(1,0,0), .2+.5*smoothstep(.2,.8,k));\n\n    \t    sn = doBumpMap(iChannel0, spt.xyz*tSize1, sn, .007/(1. + t/FAR));\n\n        }  else {\n            k = tex3D(iChannel0, spt.xyz*tSize1, sn).x;\n           // colTxt = mix(vec3(1,.5,.3), 4.*(.6+.5*sin(.1*iTime+.01*length(spt.xz)))*vec3(0,1,1), .5+.5*smoothstep(.4,.7,k+.05*cos(2.*iTime)));\n            colTxt = mix(.3*vec3(1,.5,.3), 1.3*vec3(0,1,1), .4+.6*smoothstep(.4,.7,k+.05*cos(2.*iTime)));\n            colTxt = mix(colTxt, 1.7*vec3(1.8,1.8,.5), sanim01*smoothstep(.4,0.,abs(.8-spt.y)));\n       \t\tsn = doBumpMap(iChannel0, spt.xyz*tSize1, sn, .007/(1. + t/FAR));//max(1.-length(fwidth(sn)), .001)*hash(sp)/(1.+t/FAR)\n        }\n       \n    \t// prevent normals pointing away from camera (caused by precision errors)\n\t\tsn = normalize(sn - max(.0, dot(sn,rd))*rd);       \n                \n        float d2 = 1.;//RayMarchOut(sp+rd*(.05*4. + noise.x*0.05), ld);\n        \n        float shd = softShadow(sp, ld, 0.005, 4., 8.); // Shadows.\n        float ao = calculateAO(sp, sn); // Ambient occlusion.\n        float dif = max( dot( ld, sn ), 0.0); // Diffuse term.\n        float spe = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 29.); // Specular term.\n        float fre = clamp(1.0 + dot(rd, sn), 0.0, 1.0); // Fresnel reflection term.\n       \n        // Schlick approximation. I use it to tone down the specular term. It's pretty subtle,\n        // so could almost be aproximated by a constant, but I prefer it. Here, it's being\n        // used to give a hard clay consistency... It \"kind of\" works.\n\t\tfloat Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.0);\n\t\tfloat fre2 = mix(.2, 1., Schlick);  //F0 = .2 - Hard clay... or close enough.\n       \n        // Overal global ambience. Without it, the cave sections would be pretty dark. It's made up,\n        // but I figured a little reflectance would be in amongst it... Sounds good, anyway. :)\n        float amb = fre*fre2 + .06*ao;\n        \n        // Coloring the soil - based on depth. Based on a line from Dave Hoskins's \"Skin Peeler.\"\n        col = colTxt;\n        col = (col*(dif*d2 + .1) + fre2*spe*2.)*shd*ao + amb*col;\n    } \n    \n    col = .5*mix(col, sky, smoothstep(5., FAR, t));\n   \n    // Light\n    if (dhaloLight < t) {\n        float BloomFalloff = 50000.; \n \t\tcol += mix(1.5*vec3(1.,1.,.4), sky, .5+.5*smoothstep(5., FAR, dhaloLight))/(1.+dhaloLight*dhaloLight*dhaloLight*BloomFalloff);\n    }\n    if (dhaloFrog < t) {\n        float BloomFalloff = 50000.; \n \t\tcol += mix(sanim56*vec3(1.,1.,.4), vec3(0), .5+.5*smoothstep(5., FAR, dhaloFrog))/(1.+dhaloFrog*dhaloFrog*dhaloFrog*BloomFalloff);\n    }\n   \n    \n    // gamma correction\n    col = pow(max(col, 0.), vec3(.7));\n\n    u = fragCoord/iResolution.xy;\n    col *= pow( 16.0*u.x*u.y*(1.0-u.x)*(1.0-u.y) , .32);\n\n    \n\tfragColor = vec4(clamp(col, 0., 1.), 1.0 );\n}",
   "name": "Image",
   "description": "",
   "type": "image"
  }
 ]
}