{
 "ver": "0.1",
 "info": {
  "id": "fddBWs",
  "date": "0",
  "viewed": 0,
  "name": "impulse_glass_morph JiPi",
  "description": "Improve https://www.shadertoy.com/view/lttBzN  by mrange\nto add morph \nAnd I also tested AR camera data with it [url=https://youtube.com/shorts/jGe8Zc_rhJA]https://youtube.com/shorts/jGe8Zc_rhJA[/url] ",
  "likes": 0,
  "published": "Private",
  "usePreview": 0,
  "tags": [
   "glass"
  ],
  "hasliked": 0,
  "parentid": "NddfDX",
  "parentname": "impulse_glass_morph"
 },
 "renderpass": [
  {
   "inputs": [
    {
     "id": "4dfGzn",
     "filepath": "/media/a/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3",
     "type": "music",
     "channel": 0,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    }
   ],
   "outputs": [
    {
     "id": "4dfGRr",
     "channel": 0
    }
   ],
   "code": "// Created by mrange/2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// \n// Messing around with refractions. I am quite new to shader programming\n//  and raymarching so while I think the code might not be very good I also think that\n//  what makes ShaderToy.com so good is that programmers are sharing what they do, \n//  big and small. I too want to share in the hope it might help someone on my level.\n// \n// Inpiration and code from shaders:\n//  https://www.shadertoy.com/view/4ds3zn (iq, inspirations and various functions)\n//  https://www.shadertoy.com/view/XljGDz (otaviogood, \"skybox\")\n//  https://www.shadertoy.com/view/Xl2GDW (purton, inspiration for reflection)\n// Music: Levi Patel - As she passes (Soundcloud)\n// Blogs:\n//  Raymarching explained: http://9bitscience.blogspot.com/2013/07/raymarching-distance-fields_14.html\n//  Distance Estimators: iquilezles.org/articles/distfunctions\n//  Cool primitives: http://mercury.sexy/hg_sdf/\n#define TOLERANCE       0.000001\n#define MAX_RAY_LENGTH  16.0\n#define MAX_BOUNCES     8\n#define MAX_RAY_MARCHES 90\n#define ABSORB_COLOR    1.0,2.0,3.0\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n\n#define DEG2RAD         (PI/180.0)\n\n#define PERIODTIME      10.0\n#define FADE_RATE         0.5\n#define ITIME (iTime*2.)\n#define TIMEINPERIOD    (mod(ITIME, PERIODTIME))\n#define PERIOD          (mod(floor(ITIME / PERIODTIME), 9.0))\n//#define PERIOD          8\n\n#define AA              0\n\nfloat sgn(float x)\n{\n  return (x<0.0)?-1.0:1.0;\n}\n\nfloat smin(float a, float b, float k)\n{\n  float res = exp( -k*a ) + exp( -k*b );\n  return -log( res )/k;\n}\n\nfloat pReflect(inout vec3 p, vec3 planeNormal, float offset)\n{\n  float t = dot(p, planeNormal)+offset;\n  if (t < 0.0)\n  {\n    p = p - (2.0*t)*planeNormal;\n  }\n  return sgn(t);\n}\n\nvoid pR(inout vec2 p, float a)\n{\n  p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat maxComp(in vec3 p)\n{\n  return max(p.x,max(p.y,p.z));\n}\n\nfloat lengthN(in vec3 v, in float n)\n{\n  v = abs(v);\n  v = pow(v, vec3(n));\n  return pow(v.x + v.y + v.z, 1.0/n);\n}\n\nfloat sdRoundCube(in vec3 p, float r)\n{\n  return lengthN(p, 8.0) - r;\n}\n\nvec3 pMod3(inout vec3 p, vec3 size)\n{\n  vec3 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5, size) - size*0.5;\n  return c;\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n  vec3  di = abs(p) - b;\n  float mc = maxComp(di);\n  return min(mc,length(max(di,0.0)));\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n  return length(p) - r;\n}\n\nfloat impulse1(in vec3 p, out vec3 col, out float ref, out float trans, out vec3 absorb)\n{\n  col    = vec3(0.3);\n  ref    = 0.2;\n  trans  = 0.9;\n  absorb = 0.5*vec3(ABSORB_COLOR);\n\n  float s  = sdSphere(p, 0.6);\n  float is = sdSphere(p, 0.8);\n  float rc = sdRoundCube(p, 1.0);\n\n  float d = rc;\n  d = max(d, -is);\n  d = min(d, s);\n  if (d == s)\n  {\n    absorb = 1.0*vec3(1.0, -1.0, -2.0);\n  }\n  return d;\n}\n\nfloat impulse2(in vec3 p, out vec3 col, out float ref, out float trans, out vec3 absorb)\n{\n  col    = vec3(0.3);\n  ref    = 0.2;\n  trans  = 0.9;\n  absorb = 0.5*vec3(ABSORB_COLOR);\n\n  float s1 = sdBox(p, vec3(1.0));\n  float s3 = sdSphere(p, 0.4);\n  pMod3(p, vec3(1.0));\n  float s2 = sdSphere(p, 0.48);\n  float s = max(s1, -s2);\n  s = min(s, s3);\n  if (s == s3)\n  {\n    absorb = 1.0*vec3(1.0, -1.0, -2.0);\n  }\n\n  return s;\n}\n\nfloat mandelbulb(in vec3 p)\n{\n  vec3 w = p;\n  float m = dot(w,w);\n\n  float dz = 1.0;\n\n  dz = 8.0*pow(sqrt(m),7.0)*dz + 1.0;\n\n  float r = length(w);\n  float b = 8.0*acos(w.y/r);\n  float a = 8.0*atan(w.x, w.z);\n  vec3 v  = vec3(sin(b)*sin(a), cos(b), sin(b)*cos(a));\n  w = p + pow(r,8.0)*v;\n\n  m = dot(w,w);\n\n  return 0.25*log(m)*sqrt(m)/dz;\n}\n\n\nfloat impulse3(in vec3 p, out vec3 col, out float ref, out float trans, out vec3 absorb)\n{\n  col    = vec3(0.3);\n  ref    = 0.2;\n  trans  = 0.9;\n  absorb = 0.5*vec3(ABSORB_COLOR);\n\n  float rc = sdRoundCube(p, 1.0);\n  float s  = 0.9;\n  float mb = mandelbulb(p/s)*s;\n  float s1 = sdSphere(p, 0.4);\n  float d = rc;\n  d = max(d, -mb);\n  d = min(d, s1);\n  if (d == s1)\n  {\n    absorb = 1.0*vec3(1.0, -1.0, -2.0);\n  }\n  return d;\n}\n\nfloat bubbles(in vec3 p)\n{\n  vec3 pp = p - vec3(0.1) - vec3(0.0, ITIME*0.15 + 10.0, 0.0);\n  pReflect(pp, normalize(vec3(1.0, 0.5, 0.2)), 0.3);\n  pReflect(pp, normalize(vec3(0.2, 0.5, 1.0)), 0.2);\n  pMod3(pp, vec3(0.5, 0.3, 0.4));\n\n  vec3 ppp = p - vec3(0.2) - vec3(0.0, ITIME*0.05 + 10.0, 0.0);\n  pReflect(ppp, normalize(vec3(0.7, 0.5, 0.4)), 0.3);\n  pReflect(ppp, normalize(vec3(0.5, 0.4, 0.7)), 0.1);\n  pMod3(ppp, vec3(0.7, 0.6, 0.4));\n\n  float ss = sdSphere(pp, 0.05);\n  float sss = sdSphere(ppp, 0.1);\n\n  return smin(ss, sss, 20.0);\n}\nfloat impulse5(in vec3 p, float t  ,out vec3 col, out float ref, out float trans, out vec3 absorb)\n{\n  col    = vec3(0.3);\n  ref    = 0.2;\n  trans  = 0.9;\n  absorb = 0.5*vec3(ABSORB_COLOR);\n\n  float sb = sdRoundCube(p, 1.0);\n  \n  float s  = 25. / (1.0 + 9.0*t/PERIODTIME);\n  float bs = bubbles(p/s)*s;\n\n  return max(sb, -bs);\n}\n\nfloat impulse7(in vec3 p,   out vec3 col, out float ref, out float trans, out vec3 absorb)\n{\n  col    = vec3(0.3);\n  ref    = 0.2;\n  trans  = 0.9;\n  absorb = 0.5*vec3(ABSORB_COLOR);\n\n  float sb = sdRoundCube(p, 1.0);\n  float s = 2.5;\n  float bs = bubbles(p/s)*s;\n\n  return max(sb, -bs);\n}\n\n\nfloat distanceField(in vec3 p, out vec3 col, out float ref, out float trans, out vec3 absorb)\n{\n  int period = int(PERIOD);\n \n  float i = 10000000.0;\n\n  if (period == 0)      i = impulse1(p, col, ref, trans, absorb);\n  else if (period == 1) i = impulse5(p,TIMEINPERIOD, col, ref, trans, absorb);\n  else if (period == 2) i = impulse7(p, col, ref, trans, absorb);\n  else if (period == 3) i = impulse3(p, col, ref, trans, absorb);\n  else if (period == 4) i = impulse2(p, col, ref, trans, absorb);\n  else if (period == 5) i = impulse3(p, col, ref, trans, absorb);\n  else if (period == 6) i = impulse2(p, col, ref, trans, absorb);\n  else if (period == 7) i = impulse7(p, col, ref, trans, absorb);\n  else if (period == 8) i = impulse2(p, col, ref, trans, absorb);\n\n  float rr=TIMEINPERIOD/PERIODTIME;\n  float rat=sin(rr/FADE_RATE*PI/2.);\n  if (rr<FADE_RATE)\n  {\n      vec3 col2,absorb2;\n      float trans2,ref2;\n      float i2=10000000.0;\n      if (period == 0)      i2= impulse2(p, col2, ref2, trans2, absorb2);\n      else if (period == 1) i2= impulse1(p, col2, ref2, trans2, absorb2);\n      else if (period == 2) i2= impulse5(p,TIMEINPERIOD+PERIODTIME, col2, ref2, trans2, absorb2);\n      else if (period == 3) i2= impulse7(p, col2, ref2, trans2, absorb2);\n      else if (period == 4) i2= impulse3(p, col2, ref2, trans2, absorb2);\n      else if (period == 5) i2= impulse2(p, col2, ref2, trans2, absorb2);\n      else if (period == 6) i2= impulse3(p, col2, ref2, trans2, absorb2);\n      else if (period == 7) i2= impulse2(p, col2, ref2, trans2, absorb2);\n      else if (period == 8) i2= impulse7(p, col2, ref2, trans2, absorb2);\n    //i=i2*(rr-0.8)/0.2 +i*(1-(rr-0.8)/0.2);\n      float inv=1.-rat;\n      i=      i*rat+      i2*inv;\n      col=    col*rat+    col2*inv;\n      absorb= absorb*rat+ absorb2*inv;\n      ref=    ref*rat+    ref2*inv;\n      trans=  trans*rat+  trans2*inv;\n  }\n  float rc = sdRoundCube(p - vec3(0.0, -5.05, 0.0), 4.0);\n\n  float d = min(rc, i);\n  if (d == rc)\n  {\n    col    = vec3(1.0);\n    ref    = 0.2;\n    trans  = 0.0;\n  }\n  return d;\n}\n\nvec3 saturate(in vec3 a)   { return clamp(a, 0.0, 1.0); }\nvec2 saturate(in vec2 a)   { return clamp(a, 0.0, 1.0); }\nfloat saturate(in float a) { return clamp(a, 0.0, 1.0); }\n\nconst vec3 lightPos1 = 100.0*vec3(-0.3, 0.0, 1.0);\nconst vec3 lightPos2 = 100.0*vec3(-0.5, -0.1, -1.2);\n\nconst vec3 lightCol1 = vec3(8.0/8.0,7.0/8.0,6.0/8.0);\nconst vec3 lightCol2 = vec3(8.0/8.0,6.0/8.0,7.0/8.0);\n\nvec3 getSkyColor(vec3 rayDir)\n{\n  vec3 lightDir1 = normalize(lightPos1);\n  vec3 lightDir2 = normalize(lightPos2);\n\n  float ld1      = max(dot(lightDir1, rayDir), 0.0);\n  float ld2      = max(dot(lightDir2, rayDir), 0.0);\n  vec3 final     = vec3(0.125);\n\n  if ((rayDir.y > abs(rayDir.x)*1.0) && (rayDir.y > abs(rayDir.z*0.25))) final = vec3(2.0)*rayDir.y;\n  float roundBox = length(max(abs(rayDir.xz/max(0.0,rayDir.y))-vec2(0.9, 4.0),0.0))-0.1;\n  final += vec3(0.8)* pow(saturate(1.0 - roundBox*0.5), 6.0);\n\n  final += pow(lightCol1, vec3(2.0, 1.5, 1.5)) * pow(ld1, 8.0);\n  final += lightCol1 * pow(ld1, 200.0);\n  final += pow(lightCol2, vec3(2.0, 1.5, 1.5)) * pow(ld2, 8.0);\n  final += lightCol2 * pow(ld2, 200.0);\n  return final;\n}\n\nvec3 normal(in vec3 pos)\n{\n  vec3  eps = vec3(.0001,0.0,0.0);\n  vec3 col;\n  float ref;\n  float trans;\n  vec3 nor;\n  vec3 absorb;\n  nor.x = distanceField(pos+eps.xyy, col, ref, trans, absorb) - distanceField(pos-eps.xyy, col, ref, trans, absorb);\n  nor.y = distanceField(pos+eps.yxy, col, ref, trans, absorb) - distanceField(pos-eps.yxy, col, ref, trans, absorb);\n  nor.z = distanceField(pos+eps.yyx, col, ref, trans, absorb) - distanceField(pos-eps.yyx, col, ref, trans, absorb);\n  return normalize(nor);\n}\n\nfloat rayMarch(in float dmod, in vec3 ro, inout vec3 rd, float mint, float minstep, out int rep, out vec3 col, out float ref, out float trans, out vec3 absorb)\n{\n  float t = mint;\n  for (int i = 0; i < MAX_RAY_MARCHES; i++)\n  {\n    float distance_ = distanceField(ro + rd*t, col, ref, trans, absorb);\n    float distance = dmod*distance_;\n    if (distance < TOLERANCE*t || t > MAX_RAY_LENGTH) break;\n    t += max(distance, minstep);\n    rep = i;\n  }\n  return t;\n}\n\nfloat softShadow(in vec3 pos, in vec3 ld, in float ll, float mint, float k)\n{\n  const float minShadow = 0.25;\n  float res = 1.0;\n  float t = mint;\n  vec3 col;\n  float ref;\n  float trans;\n  vec3 absorb;\n  for (int i=0; i<24; i++)\n  {\n    float distance = distanceField(pos + ld*t, col, ref, trans, absorb);\n    res = min(res, k*distance/t);\n    if (ll <= t) break;\n    if(res <= minShadow) break;\n    t += max(mint*0.2, distance);\n  }\n  return clamp(res,minShadow,1.0);\n}\n\nvec3 postProcess(in vec3 col, in vec2 q)\n{\n  col=pow(clamp(col,0.0,1.0),vec3(0.75));\n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n  vec3 lightPos = 1.5*vec3(1.5, 3.0, 1.0);\n\n  vec3 final  = vec3(0.0);\n\n  vec3 ragg   = vec3(1.0);\n\n  float tdist = 0.0;\n\n  int period = int(PERIOD);\n\n  float refraction = 0.9;\n\n  if (period == 4) refraction = 1.2;\n  if (period == 5) refraction = 0.75;\n  if (period == 6) refraction = -0.8;\n\n  bool inside = false;\n\n  float mint    = 0.01;\n  float minstep = 0.001;\n\n  for (int i = 0; i < MAX_BOUNCES; ++i)\n  {\n    if (maxComp(ragg) <  0.01) break;\n    float dmod  = inside ? -1.0 : 1.0;\n    vec3 absorb ;\n    vec3 col    ;\n    float ref   ;\n    float trans ;\n    int rep     ;\n    float t     = rayMarch(dmod, ro, rd, mint, minstep, rep, col, ref, trans, absorb);\n    tdist       += t;\n\n    vec3 pos    = ro + t*rd;\n\n    vec3 nor = vec3(0.0, 1.0, 0.0);\n\n    if (t < MAX_RAY_LENGTH)\n    {\n      // Ray intersected object\n      nor = normal(pos);\n    }\n    else\n    {\n      // Ray intersected sky\n      final += ragg*getSkyColor(rd);\n      break;\n    }\n\n    float fresnel = pow(1.0 - abs(dot(nor, rd)), 2.0);\n\n    ref = mix(ref, 1.0, fresnel);\n    trans = mix(trans, 0.0, fresnel);\n\n    float mref = refraction;\n\n    if (inside)\n    {\n      nor = -nor;\n      mref = 1.0/refraction;\n    }\n\n    vec3 refl = reflect(rd, nor);\n    vec3 refr = refract(rd, nor, mref);\n\n    vec3 lv   = lightPos - pos;\n    vec3  ld  = normalize(lv);\n    float ll  = length(lv);\n    // TODO: Rework shadow to \"work\" with transparent objects\n    float sha = 1.0;\n    if (!inside)\n    {\n      sha = softShadow(pos, ld, ll, 0.01, 64.0);\n    }\n\n    float dif = max(dot(nor,ld),0.0);\n    float occ = 1.0 - float(rep)/float(MAX_RAY_MARCHES);\n    float l   = dif*sha*occ;\n\n\n    vec3 lr   = vec3(0.0);\n\n    float lin = mix(0.2, 1.0, l);\n\n    vec3 sky  = getSkyColor(refl);\n    vec3 mcol = mix(lin*col + lr, sky, ref);\n\n    vec3 beer = vec3(1.0);\n\n    if (inside)\n    {\n      beer = exp(-absorb*t);\n    }\n    final      += (1.0 - trans)*ragg*beer*mcol;\n    ragg       *= trans*beer;\n\n    ro        = pos;\n\n    if (refr == vec3(0.0))\n    {\n        rd = refl;\n    }\n    else\n    {\n      rd = refr;\n      inside = !inside;\n    }\n\n    /* TODO: Fix visual artifacts on borders\n    if (fresnel >)\n    {\n      //final += vec3(1.0);\n      mint = 0.1;\n      minstep = 0.01;\n    }\n    else\n    {\n      minstep = 0.001;\n    }\n    */\n  }\n\n\n  return final;\n}\n\nvec3 getSample(in vec2 p)\n{\n  float time   = TIMEINPERIOD;\n  int period   = int(PERIOD);\n\n  vec3 ro  = vec3(3.0, 0.1, 0.0);\n  if (period == 5) ro = 1.5*vec3(1.0, 1.5, 0.0);\n\n  vec3 la  = vec3(0.0);\n\n  pR(ro.xz, ITIME/PERIODTIME);\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(vec3(0.0,1.0,0.0), ww ));\n  vec3 vv = normalize(cross(ww,uu));\n  vec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n\n  vec3 col = render(ro, rd);\n\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  float time = TIMEINPERIOD;\n  vec2 q=fragCoord.xy/iResolution.xy;\n  vec2 p = -1.0 + 2.0*q;\n  p.x *= iResolution.x/iResolution.y;\n\n#if AA == 0\n  vec3 col = getSample(p);\n#elif AA == 1\n  vec3 col  = vec3(0.0);\n  vec2 unit = 1.0/iResolution.xy;\n  for(int y = 0; y < 2; ++y)\n  {\n    for(int x = 0; x < 2; ++x)\n    {\n      col += getSample(p - 0.5*unit + unit*vec2(x, y));\n    }\n  }\n\n  col /= 4.0;\n#endif\n\n\n  fragColor = vec4(postProcess(col, q), 1.0);\n}\n",
   "name": "Image",
   "description": "",
   "type": "image"
  }
 ]
}