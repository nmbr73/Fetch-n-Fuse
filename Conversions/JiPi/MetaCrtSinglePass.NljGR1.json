{"Shader":{"ver":"0.1","info":{"id":"NljGR1","date":"1626808516","viewed":1205,"name":"Meta CRT - Single Pass","username":"P_Malin","description":"A single pass version of Meta CRT : https:\/\/www.shadertoy.com\/view\/4dlyWX","likes":22,"published":3,"flags":2,"usePreview":1,"tags":["crt"],"hasliked":0},"renderpass":[{"inputs":[{"id":31,"src":"\/presets\/webcam.png","ctype":"webcam","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":37,"channel":0}],"code":"\/\/ Meta CRT - Single Pass - @P_Malin\n\/\/ A single pass version of Meta CRT : https:\/\/www.shadertoy.com\/view\/4dlyWX\n\n\/\/ This can be used as a webcam fiter in Memix\n\/\/ See github here : https:\/\/github.com\/pmalin\/pmalin-memix-shaders\n\n\/\/#define FIXED_CAMERA_INDEX 2\n\n#define FLIP_V 0\n\n#define USE_MOUSE 0\n\n\n#define PI 3.141592654\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Hash Functions\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/\/ From: Hash without Sine by Dave Hoskins\n\/\/ https:\/\/www.shadertoy.com\/view\/4djSRW\n\n\/\/ *** Use this for integer stepped ranges, ie Value-Noise\/Perlin noise functions.\n\/\/#define HASHSCALE1 .1031\n\/\/#define HASHSCALE3 vec3(.1031, .1030, .0973)\n\/\/#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n\n\/\/ For smaller input rangers like audio tick or 0-1 UVs use these...\n#define HASHSCALE1 443.8975\n#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n#define HASHSCALE4 vec3(443.897, 441.423, 437.195, 444.129)\n\n\n\/\/----------------------------------------------------------------------------------------\n\/\/  1 out, 1 in...\nfloat hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\/\/  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n\/\/\/  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n\/\/  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\n#define kMaxTraceDist 1000.0\n#define kFarDist 1100.0\n\n#define MAT_FG_BEGIN \t10\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Scene\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nstruct SceneResult\n{\n\tfloat fDist;\n\tint iObjectId;\n    vec3 vUVW;\n};\n    \nvoid Scene_Union( inout SceneResult a, in SceneResult b )\n{\n    if ( b.fDist < a.fDist )\n    {\n        a = b;\n    }\n}\n\n    \nvoid Scene_Subtract( inout SceneResult a, in SceneResult b )\n{\n    if ( a.fDist < -b.fDist )\n    {\n        a.fDist = -b.fDist;\n        a.iObjectId = b.iObjectId;\n        a.vUVW = b.vUVW;\n    }\n}\n\nSceneResult Scene_GetDistance( vec3 vPos );    \n\nvec3 Scene_GetNormal(const in vec3 vPos)\n{\n    const float fDelta = 0.0001;\n    vec2 e = vec2( -1, 1 );\n    \n    vec3 vNormal = \n        Scene_GetDistance( e.yxx * fDelta + vPos ).fDist * e.yxx + \n        Scene_GetDistance( e.xxy * fDelta + vPos ).fDist * e.xxy + \n        Scene_GetDistance( e.xyx * fDelta + vPos ).fDist * e.xyx + \n        Scene_GetDistance( e.yyy * fDelta + vPos ).fDist * e.yyy;\n    \n    return normalize( vNormal );\n}    \n    \nSceneResult Scene_Trace( const in vec3 vRayOrigin, const in vec3 vRayDir, float minDist, float maxDist )\n{\t\n    SceneResult result;\n    result.fDist = 0.0;\n    result.vUVW = vec3(0.0);\n    result.iObjectId = -1;\n    \n\tfloat t = minDist;\n\tconst int kRaymarchMaxIter = 128;\n\tfor(int i=0; i<kRaymarchMaxIter; i++)\n\t{\t\t\n        float epsilon = 0.0001 * t;\n\t\tresult = Scene_GetDistance( vRayOrigin + vRayDir * t );\n        if ( abs(result.fDist) < epsilon )\n\t\t{\n\t\t\tbreak;\n\t\t}\n                        \n        if ( t > maxDist )\n        {\n            result.iObjectId = -1;\n\t        t = maxDist;\n            break;\n        }       \n        \n        if ( result.fDist > 1.0 )\n        {\n            result.iObjectId = -1;            \n        }    \n        \n        t += result.fDist;        \n\t}\n    \n    result.fDist = t;\n\n\n    return result;\n}    \n\nfloat Scene_TraceShadow( const in vec3 vRayOrigin, const in vec3 vRayDir, const in float fMinDist, const in float fLightDist )\n{\n    \/\/return 1.0;\n    \/\/return ( Scene_Trace( vRayOrigin, vRayDir, 0.1, fLightDist ).fDist < fLightDist ? 0.0 : 1.0;\n    \n\tfloat res = 1.0;\n    float t = fMinDist;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = Scene_GetDistance( vRayOrigin + vRayDir * t ).fDist;\n        res = min( res, 8.0*h\/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.0001 || t>fLightDist ) break;\n    }\n    return clamp( res, 0.0, 1.0 );    \n}\n\nfloat Scene_GetAmbientOcclusion( const in vec3 vPos, const in vec3 vDir )\n{\n    float fOcclusion = 0.0;\n    float fScale = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float fOffsetDist = 0.001 + 0.1*float(i)\/4.0;\n        vec3 vAOPos = vDir * fOffsetDist + vPos;\n        float fDist = Scene_GetDistance( vAOPos ).fDist;\n        fOcclusion += (fOffsetDist - fDist) * fScale;\n        fScale *= 0.4;\n    }\n    \n    return clamp( 1.0 - 30.0*fOcclusion, 0.0, 1.0 );\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Lighting\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \nstruct SurfaceInfo\n{\n    vec3 vPos;\n    vec3 vNormal;\n    vec3 vBumpNormal;    \n    vec3 vAlbedo;\n    vec3 vR0;\n    float fSmoothness;\n    vec3 vEmissive;\n};\n    \nSurfaceInfo Scene_GetSurfaceInfo( const in vec3 vRayOrigin,  const in vec3 vRayDir, SceneResult traceResult );\n\nstruct SurfaceLighting\n{\n    vec3 vDiffuse;\n    vec3 vSpecular;\n};\n    \nSurfaceLighting Scene_GetSurfaceLighting( const in vec3 vRayDir, in SurfaceInfo surfaceInfo );\n\nfloat Light_GIV( float dotNV, float k)\n{\n\treturn 1.0 \/ ((dotNV + 0.0001) * (1.0 - k)+k);\n}\n\nvoid Light_Add(inout SurfaceLighting lighting, SurfaceInfo surface, const in vec3 vViewDir, const in vec3 vLightDir, const in vec3 vLightColour)\n{\n\tfloat fNDotL = clamp(dot(vLightDir, surface.vBumpNormal), 0.0, 1.0);\n\t\n\tlighting.vDiffuse += vLightColour * fNDotL;\n    \n\tvec3 vH = normalize( -vViewDir + vLightDir );\n\tfloat fNdotV = clamp(dot(-vViewDir, surface.vBumpNormal), 0.0, 1.0);\n\tfloat fNdotH = clamp(dot(surface.vBumpNormal, vH), 0.0, 1.0);\n    \n\tfloat alpha = 1.0 - surface.fSmoothness;\n\t\/\/ D\n\n\tfloat alphaSqr = alpha * alpha;\n\tfloat denom = fNdotH * fNdotH * (alphaSqr - 1.0) + 1.0;\n\tfloat d = alphaSqr \/ (PI * denom * denom);\n\n\tfloat k = alpha \/ 2.0;\n\tfloat vis = Light_GIV(fNDotL, k) * Light_GIV(fNdotV, k);\n\n\tfloat fSpecularIntensity = d * vis * fNDotL;    \n\tlighting.vSpecular += vLightColour * fSpecularIntensity;    \n}\n\nvoid Light_AddPoint(inout SurfaceLighting lighting, SurfaceInfo surface, const in vec3 vViewDir, const in vec3 vLightPos, const in vec3 vLightColour)\n{    \n    vec3 vPos = surface.vPos;\n\tvec3 vToLight = vLightPos - vPos;\t\n    \n\tvec3 vLightDir = normalize(vToLight);\n\tfloat fDistance2 = dot(vToLight, vToLight);\n\tfloat fAttenuation = 100.0 \/ (fDistance2);\n\t\n\tfloat fShadowFactor = Scene_TraceShadow( surface.vPos, vLightDir, 0.1, length(vToLight) );\n\t\n\tLight_Add( lighting, surface, vViewDir, vLightDir, vLightColour * fShadowFactor * fAttenuation);\n}\n\nvoid Light_AddDirectional(inout SurfaceLighting lighting, SurfaceInfo surface, const in vec3 vViewDir, const in vec3 vLightDir, const in vec3 vLightColour)\n{\t\n\tfloat fAttenuation = 1.0;\n\tfloat fShadowFactor = Scene_TraceShadow( surface.vPos, vLightDir, 0.1, 10.0 );\n\t\n\tLight_Add( lighting, surface, vViewDir, vLightDir, vLightColour * fShadowFactor * fAttenuation);\n}\n\nvec3 Light_GetFresnel( vec3 vView, vec3 vNormal, vec3 vR0, float fGloss )\n{\n    float NdotV = max( 0.0, dot( vView, vNormal ) );\n\n    return vR0 + (vec3(1.0) - vR0) * pow( 1.0 - NdotV, 5.0 ) * pow( fGloss, 20.0 );\n}\n\nvoid Env_AddPointLightFlare(inout vec3 vEmissiveGlow, const in vec3 vRayOrigin, const in vec3 vRayDir, const in float fIntersectDistance, const in vec3 vLightPos, const in vec3 vLightColour)\n{\n    vec3 vToLight = vLightPos - vRayOrigin;\n    float fPointDot = dot(vToLight, vRayDir);\n    fPointDot = clamp(fPointDot, 0.0, fIntersectDistance);\n\n    vec3 vClosestPoint = vRayOrigin + vRayDir * fPointDot;\n    float fDist = length(vClosestPoint - vLightPos);\n\tvEmissiveGlow += sqrt(vLightColour * 0.05 \/ (fDist * fDist));\n}\n\nvoid Env_AddDirectionalLightFlareToFog(inout vec3 vFogColour, const in vec3 vRayDir, const in vec3 vLightDir, const in vec3 vLightColour)\n{\n\tfloat fDirDot = clamp(dot(vLightDir, vRayDir) * 0.5 + 0.5, 0.0, 1.0);\n\tfloat kSpreadPower = 2.0;\n\tvFogColour += vLightColour * pow(fDirDot, kSpreadPower) * 0.25;\n}\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Rendering\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvec4 Env_GetSkyColor( const vec3 vViewPos, const vec3 vViewDir );\nvec3 Env_ApplyAtmosphere( const in vec3 vColor, const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist );\nvec3 FX_Apply( in vec3 vColor, const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist);\n\nvec4 Scene_GetColorAndDepth( vec3 vRayOrigin, vec3 vRayDir )\n{\n\tvec3 vResultColor = vec3(0.0);\n            \n\tSceneResult firstTraceResult;\n    \n    float fStartDist = 0.0f;\n    float fMaxDist = 10.0f;\n    \n    vec3 vRemaining = vec3(1.0);\n    \n\tfor( int iPassIndex=0; iPassIndex < 3; iPassIndex++ )\n    {\n    \tSceneResult traceResult = Scene_Trace( vRayOrigin, vRayDir, fStartDist, fMaxDist );\n\n        if ( iPassIndex == 0 )\n        {\n            firstTraceResult = traceResult;\n        }\n        \n        vec3 vColor = vec3(0);\n        vec3 vReflectAmount = vec3(0);\n        \n\t\tif( traceResult.iObjectId < 0 )\n\t\t{\n            vColor = Env_GetSkyColor( vRayOrigin, vRayDir ).rgb;\n        }\n        else\n        {\n            \n            SurfaceInfo surfaceInfo = Scene_GetSurfaceInfo( vRayOrigin, vRayDir, traceResult );\n            SurfaceLighting surfaceLighting = Scene_GetSurfaceLighting( vRayDir, surfaceInfo );\n                \n            \/\/ calculate reflectance (Fresnel)\n\t\t\tvReflectAmount = Light_GetFresnel( -vRayDir, surfaceInfo.vBumpNormal, surfaceInfo.vR0, surfaceInfo.fSmoothness );\n\t\t\t\n\t\t\tvColor = (surfaceInfo.vAlbedo * surfaceLighting.vDiffuse + surfaceInfo.vEmissive) * (vec3(1.0) - vReflectAmount); \n            \n            vec3 vReflectRayOrigin = surfaceInfo.vPos;\n            vec3 vReflectRayDir = normalize( reflect( vRayDir, surfaceInfo.vBumpNormal ) );\n            fStartDist = 0.001 \/ max(0.0000001,abs(dot( vReflectRayDir, surfaceInfo.vNormal ))); \n\n            vColor += surfaceLighting.vSpecular * vReflectAmount;            \n\n\t\t\tvColor = Env_ApplyAtmosphere( vColor, vRayOrigin, vRayDir, traceResult.fDist );\n\t\t\tvColor = FX_Apply( vColor, vRayOrigin, vRayDir, traceResult.fDist );\n            \n            vRayOrigin = vReflectRayOrigin;\n            vRayDir = vReflectRayDir;\n        }\n        \n        vResultColor += vColor * vRemaining;\n        vRemaining *= vReflectAmount;        \n    }\n \n    return vec4( vResultColor, firstTraceResult.fDist );\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Scene Description\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/\/ Materials\n\n#define MAT_SKY\t\t \t-1\n#define MAT_DEFAULT \t 0\n#define MAT_SCREEN\t\t 1\n#define MAT_TV_CASING    2\n#define MAT_TV_TRIM      3\n#define MAT_CHROME       4\n\n\nvec3 PulseIntegral( vec3 x, float s1, float s2 )\n{\n    \/\/ Integral of function where result is 1.0 between s1 and s2 and 0 otherwise        \n\n    \/\/ V1\n    \/\/if ( x > s2 ) return s2 - s1;\n\t\/\/else if ( x > s1 ) return x - s1;\n\t\/\/return 0.0f; \n    \n    \/\/ V2\n    \/\/return clamp( (x - s1), 0.0f, s2 - s1);\n    \/\/return t;\n    \n    return clamp( (x - s1), vec3(0.0f), vec3(s2 - s1));\n}\n\nfloat PulseIntegral( float x, float s1, float s2 )\n{\n    \/\/ Integral of function where result is 1.0 between s1 and s2 and 0 otherwise        \n\n    \/\/ V1\n    \/\/if ( x > s2 ) return s2 - s1;\n\t\/\/else if ( x > s1 ) return x - s1;\n\t\/\/return 0.0f; \n    \n    \/\/ V2\n    \/\/return clamp( (x - s1), 0.0f, s2 - s1);\n    \/\/return t;\n    \n    return clamp( (x - s1), (0.0f), (s2 - s1));\n}\n\nvec3 Bayer( vec2 vUV, vec2 vBlur )\n{\n    vec3 x = vec3(vUV.x);\n    vec3 y = vec3(vUV.y);           \n\n    x += vec3(0.66, 0.33, 0.0);\n    y += 0.5 * step( fract( x * 0.5 ), vec3(0.5) );\n        \n    \/\/x -= 0.5f;\n    \/\/y -= 0.5f;\n    \n    x = fract( x );\n    y = fract( y );\n    \n    \/\/ cell centered at 0.5\n    \n    vec2 vSize = vec2(0.16f, 0.75f);\n    \n    vec2 vMin = 0.5 - vSize * 0.5;\n    vec2 vMax = 0.5 + vSize * 0.5;\n    \n    vec3 vResult= vec3(0.0);\n    \n    vec3 vResultX = (PulseIntegral( x + vBlur.x, vMin.x, vMax.x) - PulseIntegral( x - vBlur.x, vMin.x, vMax.x)) \/ min( vBlur.x, 1.0);\n    vec3 vResultY = (PulseIntegral(y + vBlur.y, vMin.y, vMax.y) - PulseIntegral(y - vBlur.y, vMin.y, vMax.y))  \/ min( vBlur.y, 1.0);\n    \n    vResult = min(vResultX,vResultY)  * 5.0;\n        \n    \/\/vResult = vec3(1.0);\n    \n    return vResult;\n}\n\nvec3 GetPixelMatrix( vec2 vUV )\n{\n#if 1\n    vec2 dx = dFdx( vUV );\n    vec2 dy = dFdy( vUV );\n    float dU = length( vec2( dx.x, dy.x ) );\n    float dV = length( vec2( dx.y, dy.y ) );\n    if (dU <= 0.0 || dV <= 0.0 ) return vec3(1.0);\n    return Bayer( vUV, vec2(dU, dV) * 1.0);\n#else\n    return vec3(1.0);\n#endif\n}\n\nfloat Scanline( float y, float fBlur )\n{   \n    float fResult = sin( y * 10.0 ) * 0.45 + 0.55;\n    return mix( fResult, 1.0f, min( 1.0, fBlur ) );\n}\n\n\nfloat GetScanline( vec2 vUV )\n{\n#if 1\n    vUV.y *= 0.25;\n    vec2 dx = dFdx( vUV );\n    vec2 dy = dFdy( vUV );\n    float dV = length( vec2( dx.y, dy.y ) );\n    if (dV <= 0.0 ) return 1.0;\n    return Scanline( vUV.y, dV * 1.3 );\n#else\n    return 1.0;\n#endif\n}\n\n\nvec2 kScreenRsolution = vec2(480.0f, 576.0f);\n\nstruct Interference\n{\n    float noise;\n    float scanLineRandom;\n};\n\nfloat InterferenceHash(float p)\n{\n    float hashScale = 0.1031;\n\n    vec3 p3  = fract(vec3(p, p, p) * hashScale);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nfloat InterferenceSmoothNoise1D( float x )\n{\n    float f0 = floor(x);\n    float fr = fract(x);\n\n    float h0 = InterferenceHash( f0 );\n    float h1 = InterferenceHash( f0 + 1.0 );\n\n    return h1 * fr + h0 * (1.0 - fr);\n}\n\n\nfloat InterferenceNoise( vec2 uv )\n{\n\tfloat displayVerticalLines = 483.0;\n    float scanLine = floor(uv.y * displayVerticalLines); \n    float scanPos = scanLine + uv.x;\n\tfloat timeSeed = fract( iTime * 123.78 );\n    \n    return InterferenceSmoothNoise1D( scanPos * 234.5 + timeSeed * 12345.6 );\n}\n    \nInterference GetInterference( vec2 vUV )\n{\n    Interference interference;\n        \n    interference.noise = InterferenceNoise( vUV );\n    interference.scanLineRandom = InterferenceHash(vUV.y * 100.0 + fract(iTime * 1234.0) * 12345.0);\n    \n    return interference;\n}\n    \nvec3 SampleScreen( vec3 vUVW )\n{   \n    vec3 vAmbientEmissive = vec3(0.1);\n    vec3 vBlackEmissive = vec3(0.02);\n    float fBrightness = 1.75;\n    vec2 vResolution = vec2(480.0f, 576.0f);\n    vec2 vPixelCoord = vUVW.xy * vResolution;\n    \n    vec3 vPixelMatrix = GetPixelMatrix( vPixelCoord );\n    float fScanline = GetScanline( vPixelCoord );\n      \n    vec2 vTextureUV = vUVW.xy;\n    \/\/vec2 vTextureUV = vPixelCoord;\n    vTextureUV = floor(vTextureUV * vResolution * 2.0) \/ (vResolution * 2.0f);\n \n    \n    Interference interference = GetInterference( vTextureUV );\n\n    float noiseIntensity = 0.1;\n    \n    \/\/vTextureUV.x += (interference.scanLineRandom * 2.0f - 1.0f) * 0.025f * noiseIntensity;\n           \n    vec2 vSampleUV = vTextureUV;\n    #if FLIP_V\n    vSampleUV.y = 1.0 - vSampleUV.y;\n    #endif\n    \n    vec3 vPixelEmissive = textureLod( iChannel0, vSampleUV.xy, 0.0 ).rgb;\n        \n    vPixelEmissive = vPixelEmissive * vPixelEmissive;\n        \n    vPixelEmissive = clamp( vPixelEmissive + (interference.noise - 0.5) * 2.0 * noiseIntensity, 0.0, 1.0 );\n    \n\tvec3 vResult = (vPixelEmissive * fBrightness + vBlackEmissive) * vPixelMatrix * fScanline + vAmbientEmissive;\n    \n    \/\/ TODO: feather edge?\n    if( any( greaterThanEqual( vUVW.xy, vec2(1.0) ) ) || any ( lessThan( vUVW.xy, vec2(0.0) ) ) || ( vUVW.z > 0.0 ) )\n    {\n        return vec3(0.0);\n    }\n    \n    return vResult;\n    \n}\n\nfloat Checker(vec2 vUV)\n{\n\treturn step(fract((floor(vUV.x) + floor(vUV.y)) * 0.5), 0.25);\n}\n\nSurfaceInfo Scene_GetSurfaceInfo( const in vec3 vRayOrigin,  const in vec3 vRayDir, SceneResult traceResult )\n{\n    SurfaceInfo surfaceInfo;\n    \n    surfaceInfo.vPos = vRayOrigin + vRayDir * (traceResult.fDist);\n    \n    surfaceInfo.vNormal = Scene_GetNormal( surfaceInfo.vPos ); \n    surfaceInfo.vBumpNormal = surfaceInfo.vNormal;\n    surfaceInfo.vAlbedo = vec3(1.0);\n    surfaceInfo.vR0 = vec3( 0.02 );\n    surfaceInfo.fSmoothness = 1.0;\n    surfaceInfo.vEmissive = vec3( 0.0 );\n    \/\/return surfaceInfo;\n        \n    if ( traceResult.iObjectId == MAT_DEFAULT )\n    {\n    \tsurfaceInfo.vR0 = vec3( 0.02 );\n        float checker = Checker(traceResult.vUVW.xz * 4.0);\n\t    surfaceInfo.vAlbedo = mix( vec3(.9,.2,.2),vec3(.2,.2,.9), checker );                        \n    \tsurfaceInfo.fSmoothness = clamp( 1.0 - surfaceInfo.vAlbedo.r * surfaceInfo.vAlbedo.r * 2.0, 0.0, 1.0);\n        \n    }\n    \n    if ( traceResult.iObjectId == MAT_SCREEN )\n    {\n        surfaceInfo.vAlbedo = vec3(0.02); \n        surfaceInfo.vEmissive = SampleScreen( traceResult.vUVW );        \n    }\n\n    if ( traceResult.iObjectId == MAT_TV_CASING )\n    {\n        surfaceInfo.vAlbedo = vec3(0.5, 0.4, 0.3); \n\t    surfaceInfo.fSmoothness = 0.4;        \n    }\n    \n    if ( traceResult.iObjectId == MAT_TV_TRIM )\n    {\n        surfaceInfo.vAlbedo = vec3(0.03, 0.03, 0.05); \n\t    surfaceInfo.fSmoothness = 0.5;\n    }    \n\n    if ( traceResult.iObjectId == MAT_CHROME )\n    {\n        surfaceInfo.vAlbedo = vec3(0.01, 0.01, 0.01); \n\t    surfaceInfo.fSmoothness = 0.9;\n    \tsurfaceInfo.vR0 = vec3( 0.8 );\n    }    \n \n    return surfaceInfo;\n}\n\n\/\/ Scene Description\n\nfloat SmoothMin( float a, float b, float k )\n{\n\t\/\/return min(a,b);\n\t\n\t\n    \/\/float k = 0.06;\n\tfloat h = clamp( 0.5 + 0.5*(b-a)\/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat UdRoundBox( vec3 p, vec3 b, float r )\n{\n    \/\/vec3 vToFace = abs(p) - b;\n    \/\/vec3 vConstrained = max( vToFace, 0.0 );\n    \/\/return length( vConstrained ) - r;\n    return length(max(abs(p)-b,0.0))-r;\n}\n\nSceneResult Scene_GetCRT( vec3 vScreenDomain, vec2 vScreenWH, float fScreenCurveRadius, float fBevel, float fDepth )\n{\n    SceneResult resultScreen;\n#if 1\n    vec3 vScreenClosest;\n    vScreenClosest.xy = max(abs(vScreenDomain.xy)-vScreenWH,0.0);\n    vec2 vCurveScreenDomain = vScreenDomain.xy;\n    vCurveScreenDomain = clamp( vCurveScreenDomain, -vScreenWH, vScreenWH );\n    float fCurveScreenProjection2 = fScreenCurveRadius * fScreenCurveRadius - vCurveScreenDomain.x * vCurveScreenDomain.x - vCurveScreenDomain.y * vCurveScreenDomain.y;\n    float fCurveScreenProjection = sqrt( fCurveScreenProjection2 ) - fScreenCurveRadius;\n    vScreenClosest.z = vScreenDomain.z - clamp( vScreenDomain.z, -fCurveScreenProjection, fDepth );\n    resultScreen.vUVW.z = vScreenDomain.z + fCurveScreenProjection;        \n    resultScreen.fDist = (length( vScreenClosest ) - fBevel) * 0.95;\n    \/\/resultScreen.fDist = (length( vScreenDomain - vec3(0,0,fScreenCurveRadius)) - fScreenCurveRadius - fBevel);    \n#endif    \n    \n#if 0\n    vec3 vScreenClosest;\n    vScreenClosest.xyz = max(abs(vScreenDomain.xyz)-vec3(vScreenWH, fDepth),0.0);\n    float fRoundDist = length( vScreenClosest.xyz ) - fBevel;\n    float fSphereDist = length( vScreenDomain - vec3(0,0,fScreenCurveRadius) ) - (fScreenCurveRadius + fBevel);    \n    resultScreen.fDist = max(fRoundDist, fSphereDist);\n#endif    \n    \n    resultScreen.vUVW.xy = (vScreenDomain.xy \/ vScreenWH) * 0.5 + 0.5f;\n\tresultScreen.iObjectId = MAT_SCREEN;\n    return resultScreen;\n}\n\nSceneResult Scene_GetComputer( vec3 vPos )\n{\n    SceneResult resultComputer;\n    resultComputer.vUVW = vPos.xzy;\n\t\n    float fXSectionStart = -0.2;\n    float fXSectionLength = 0.15;\n    float fXSectionT = clamp( (vPos.z - fXSectionStart) \/ fXSectionLength, 0.0, 1.0);\n    float fXSectionR1 = 0.03;\n    float fXSectionR2 = 0.05;\n    float fXSectionR = mix( fXSectionR1, fXSectionR2, fXSectionT );\n    float fXSectionZ = fXSectionStart + fXSectionT * fXSectionLength;\n    \n    vec2 vXSectionCentre = vec2(fXSectionR, fXSectionZ );\n    vec2 vToPos = vPos.yz - vXSectionCentre;\n    float l = length( vToPos );\n    if ( l > fXSectionR ) l = fXSectionR;\n    vec2 vXSectionClosest = vXSectionCentre + normalize(vToPos) * l;\n    \/\/float fXSectionDist = length( vXSectionClosest ) - fXSectionR;\n    \n    float x = max( abs( vPos.x ) - 0.2f, 0.0 );\n\n    resultComputer.fDist = length( vec3(x, vXSectionClosest - vPos.yz) )-0.01;\n    \/\/resultComputer.fDist = x;\n        \n    resultComputer.iObjectId = MAT_TV_CASING;\n\/*\n    vec3 vKeyPos = vPos.xyz - vec3(0,0.125,0);\n    vKeyPos.y -= vKeyPos.z * (fXSectionR2 - fXSectionR1) * 2.0 \/ fXSectionLength;\n    float fDomainRepeatScale = 0.02;\n    if ( fract(vKeyPos.z * 0.5 \/ fDomainRepeatScale + 0.25) > 0.5) vKeyPos.x += fDomainRepeatScale * 0.5;\n    vec2 vKeyIndex = round(vKeyPos.xz \/ fDomainRepeatScale);\n    vKeyIndex.x = clamp( vKeyIndex.x, -8.0, 8.0 );\n    vKeyIndex.y = clamp( vKeyIndex.y, -10.0, -5.0 );\n    \/\/vKeyPos.xz = (fract( vKeyPos.xz \/ fDomainRepeatScale ) - 0.5) * fDomainRepeatScale;\n    vKeyPos.xz = (vKeyPos.xz - (vKeyIndex) * fDomainRepeatScale);\n    vKeyPos.xz \/= 0.7 + vKeyPos.y;\n    SceneResult resultKey;    \n    resultKey.vUVW = vPos.xzy;\n    resultKey.fDist = UdRoundBox( vKeyPos, vec3(0.01), 0.001 );\n    resultKey.iObjectId = MAT_TV_TRIM;\n    Scene_Union( resultComputer, resultKey );\n*\/    \n    return resultComputer;\n}\n\nSceneResult Scene_GetDistance( vec3 vPos )\n{\n    SceneResult result;\n    \n\t\/\/result.fDist = vPos.y;\n    float fBenchBevel = 0.01;\n    result.fDist = UdRoundBox( vPos - vec3(0,-0.02-fBenchBevel,0.0), vec3(2.0, 0.02, 1.0), fBenchBevel );\n    result.vUVW = vPos;\n\tresult.iObjectId = MAT_DEFAULT;        \n    \n    vec3 vSetPos = vec3(0.0, 0.0, 0.0);\n    vec3 vScreenPos = vSetPos + vec3(0.0, 0.25, 0.00);\n    \n    \/\/vPos.x = fract( vPos.x - 0.5) - 0.5;\n    \n    vec2 vScreenWH = vec2(4.0, 3.0) \/ 25.0;\n\n    SceneResult resultSet;\n    resultSet.vUVW = vPos.xzy;\n\tresultSet.fDist = UdRoundBox( vPos - vScreenPos - vec3(0.0,-0.01,0.2), vec3(.21, 0.175, 0.18), 0.01 );\n    resultSet.iObjectId = MAT_TV_CASING;\n    Scene_Union( result, resultSet );\n\n    SceneResult resultSetRecess;\n    resultSetRecess.vUVW = vPos.xzy;\n    resultSetRecess.fDist = UdRoundBox( vPos - vScreenPos - vec3(0.0,-0.0, -0.05), vec3(vScreenWH + 0.01, 0.05) + 0.005, 0.015 );\n    resultSetRecess.iObjectId = MAT_TV_TRIM;\n\tScene_Subtract( result, resultSetRecess );\n    \n    SceneResult resultSetBase;\n    resultSetBase.vUVW = vPos.xzy;\n    float fBaseBevel = 0.03;\n\tresultSetBase.fDist = UdRoundBox( vPos - vSetPos - vec3(0.0,0.04,0.22), vec3(0.2, 0.04, 0.17) - fBaseBevel, fBaseBevel );\n    resultSetBase.iObjectId = MAT_TV_CASING;\n    Scene_Union( result, resultSetBase );\n\n\tSceneResult resultScreen = Scene_GetCRT( vPos - vScreenPos, vScreenWH, 0.75f, 0.02f, 0.1f );\n    Scene_Union( result, resultScreen );    \n    \n    \/\/SceneResult resultComputer = Scene_GetComputer( vPos - vec3(0.0, 0.0, -0.1) );\n    \/\/Scene_Union( result, resultComputer );\n\n    SceneResult resultSphere;\n    resultSet.vUVW = vPos.xzy;\n\tresultSet.fDist = length(vPos - vec3(0.35,0.075,-0.1)) - 0.075;\n    resultSet.iObjectId = MAT_CHROME;\n    Scene_Union( result, resultSet );    \n    \n    return result;\n}\n\n\n\n\/\/ Scene Lighting\n\nvec3 g_vSunDir = normalize(vec3(0.3, 0.4, -0.5));\nvec3 g_vSunColor = vec3(1, 0.95, 0.8) * 3.0;\nvec3 g_vAmbientColor = vec3(0.8, 0.8, 0.8) * 1.0;\n\nSurfaceLighting Scene_GetSurfaceLighting( const in vec3 vViewDir, in SurfaceInfo surfaceInfo )\n{\n    SurfaceLighting surfaceLighting;\n    \n    surfaceLighting.vDiffuse = vec3(0.0);\n    surfaceLighting.vSpecular = vec3(0.0);    \n    \n    Light_AddDirectional( surfaceLighting, surfaceInfo, vViewDir, g_vSunDir, g_vSunColor );\n    \n    Light_AddPoint( surfaceLighting, surfaceInfo, vViewDir, vec3(1.4, 2.0, 0.8), vec3(1,1,1) * 0.2 );\n    \n    float fAO = Scene_GetAmbientOcclusion( surfaceInfo.vPos, surfaceInfo.vNormal );\n    \/\/ AO\n    surfaceLighting.vDiffuse += fAO * (surfaceInfo.vBumpNormal.y * 0.5 + 0.5) * g_vAmbientColor;\n    \n    return surfaceLighting;\n}\n\n\/\/ Environment\n\nvec4 Env_GetSkyColor( const vec3 vViewPos, const vec3 vViewDir )\n{\n\tvec4 vResult = vec4( 0.0, 0.0, 0.0, kFarDist );\n\n#if 0\n    vec3 vEnvMap = textureLod( iChannel1, vViewDir.zyx, 0.0 ).rgb;\n    vResult.rgb = vEnvMap;\n#endif    \n    \n#if 0\n    vec3 vEnvMap = textureLod( iChannel1, vViewDir.zyx, 0.0 ).rgb;\n    vEnvMap = vEnvMap * vEnvMap;\n    float kEnvmapExposure = 0.999;\n    vResult.rgb = -log2(1.0 - vEnvMap * kEnvmapExposure);\n\n#endif\n    \n    vResult.rgb = mix( vec3(0.3,0.8,0.9),vec3(0.3,0.4,0.9), vViewDir.y );\n    \n    \/\/ Sun\n    float NdotV = dot( g_vSunDir, vViewDir );\n    vResult.rgb += smoothstep( cos(radians(.7)), cos(radians(.5)), NdotV ) * g_vSunColor * 100.0;\n\n    return vResult;\t\n}\n\nfloat Env_GetFogFactor(const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist )\n{    \n\tfloat kFogDensity = 0.00001;\n\treturn exp(fDist * -kFogDensity);\t\n}\n\nvec3 Env_GetFogColor(const in vec3 vDir)\n{    \n\treturn vec3(0.2, 0.5, 0.6) * 2.0;\t\t\n}\n\nvec3 Env_ApplyAtmosphere( const in vec3 vColor, const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist )\n{\n    \/\/return vColor;\n    vec3 vResult = vColor;\n    \n    \n\tfloat fFogFactor = Env_GetFogFactor( vRayOrigin, vRayDir, fDist );\n\tvec3 vFogColor = Env_GetFogColor( vRayDir );\t\n\t\/\/Env_AddDirectionalLightFlareToFog( vFogColor, vRayDir, g_vSunDir, g_vSunColor * 3.0);    \n    vResult = mix( vFogColor, vResult, fFogFactor );\n\n    return vResult;\t    \n}\n\n\nvec3 FX_Apply( in vec3 vColor, const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist)\n{    \n    return vColor;\n}\n\n\nvec4 MainCommon( vec3 vRayOrigin, vec3 vRayDir )\n{\n\tvec4 vColorLinAndDepth = Scene_GetColorAndDepth( vRayOrigin, vRayDir );    \n    vColorLinAndDepth.rgb = max( vColorLinAndDepth.rgb, vec3(0.0) );\n    \n    vec4 vFragColor = vColorLinAndDepth;\n    \n    float fExposure = 2.0f;\n    \n    vFragColor.rgb *= fExposure;\n    \n    vFragColor.a = vColorLinAndDepth.w;\n    \n    return vFragColor;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Camera\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nstruct CameraState\n{\n    vec3 vPos;\n    vec3 vTarget;\n    float fFov;\n    vec2 vJitter;\n    float fPlaneInFocus;\n};\n\nmat3 Cam_GetWorldToCameraRotMatrix( const CameraState cameraState )\n{\n    vec3 vForward = normalize( cameraState.vTarget - cameraState.vPos );\n\tvec3 vRight = normalize( cross(vec3(0, 1, 0), vForward) );\n\tvec3 vUp = normalize( cross(vForward, vRight) );\n    \n    return mat3( vRight, vUp, vForward );\n}\n\nvec2 Cam_GetViewCoordFromUV( vec2 vUV, vec2 res )\n{\n\tvec2 vWindow = vUV * 2.0 - 1.0;\n\tvWindow.x *= res.x \/ res.y;\n\n\treturn vWindow;\t\n}\n\nvoid Cam_GetCameraRay( vec2 vUV, vec2 res, CameraState cam, out vec3 vRayOrigin, out vec3 vRayDir )\n{\n    vec2 vView = Cam_GetViewCoordFromUV( vUV, res );\n    vRayOrigin = cam.vPos;\n    float fPerspDist = 1.0 \/ tan( radians( cam.fFov ) );\n    vRayDir = normalize( Cam_GetWorldToCameraRotMatrix( cam ) * vec3( vView, fPerspDist ) );\n}\n\nvec2 Cam_GetUVFromWindowCoord( vec2 vWindow, vec2 res )\n{\n    vec2 vScaledWindow = vWindow;\n    vScaledWindow.x *= res.y \/ res.x;\n\n    return (vScaledWindow * 0.5 + 0.5);\n}\n\nvec2 Cam_WorldToWindowCoord(const in vec3 vWorldPos, const in CameraState cameraState )\n{\n    vec3 vOffset = vWorldPos - cameraState.vPos;\n    vec3 vCameraLocal;\n\n    vCameraLocal = vOffset * Cam_GetWorldToCameraRotMatrix( cameraState );\n\t\n    vec2 vWindowPos = vCameraLocal.xy \/ (vCameraLocal.z * tan( radians( cameraState.fFov ) ));\n    \n    return vWindowPos;\n}\n\n\nCameraState GetCameraPosition( int index )\n{\n    CameraState cam;\n\n    vec3 vFocus = vec3(0,0.25,-0.012);   \n    \n    if ( index > 9 )\n    {\n    \tindex = int(hash11(float(index) \/ 10.234) * 100.0);\n    \tindex = index % 10;\n    }\n\n    #ifdef FIXED_CAMERA_INDEX\n    index=FIXED_CAMERA_INDEX; \/\/ Force a camera position\n    #endif\n    \n    if ( index == 0 )\n    {\n        cam.vPos = vec3(-0.1,0.24,-0.08);\n        cam.vTarget = vec3(0.15,0.25,0.1);\n        cam.fFov = 10.0;\n    }\n    if ( index == 1 )\n    {\n        cam.vPos = vec3(0.01,0.25,-0.8);\n        cam.vTarget = vec3(0,0.25,0.1);\n        cam.fFov = 10.0;\n    }\n    if ( index == 2 )\n    {\n        cam.vPos = vec3(-0.4,0.3,-1.0);\n        cam.vTarget = vec3(0.25,0.18,0.5);\n        cam.fFov = 10.0;\n    }\n    if ( index == 3 )\n    {\n        cam.vPos = vec3(-0.8,0.5,-1.5);\n        cam.vTarget = vec3(0.2,0.1,0.5);\n        cam.fFov = 8.0;\n    }\n    if ( index == 4 )\n    {\n        cam.vPos = vec3(0.5,0.3,-0.5);\n        cam.vTarget = vec3(-0.4,0.1,0.5);\n        cam.fFov = 16.0;\n    }\n    if ( index == 5 )\n    {\n        cam.vPos = vec3(-0.244,0.334,-0.0928);\n        cam.vTarget = vec3(0,0.25,0.1);\n        cam.fFov = 20.0;\n    }\n    if ( index == 6 )\n    {\n        cam.vPos = vec3(0.0,0.1,-0.5);\n        cam.vTarget = vec3(0.08,0.2,-0.1);\n        vFocus = cam.vTarget; \n        cam.fFov = 20.0;\n    }\n    if ( index == 7 )\n    {\n        cam.vPos = vec3(-0.01,0.01,-0.25);\n        cam.vTarget = vec3(0.01,0.27,0.1);\n        vFocus = cam.vTarget; \n        cam.fFov = 23.0;\n    }\n    if ( index == 8 )\n    {\n        cam.vPos = vec3(-0.23,0.3,-0.05);\n        cam.vTarget = vec3(0.1,0.2,0.1);\n        cam.fFov = 15.0;\n    }\n    if ( index == 9 )\n    {\n        cam.vPos = vec3(0.4,0.2,-0.2);\n        cam.vTarget = vec3(-0.1,0.25,0.1);\n        cam.fFov = 12.0;\n    }\n    \n    cam.fPlaneInFocus = length( vFocus - cam.vPos);\n    cam.vJitter = vec2(0.0);        \n    \n    return cam;\n}\n\n\nvec3 Tonemap( vec3 x )\n{\n#if 0 \n    \n    vec3 luminanceCoeffsBT709 = vec3( 0.2126f, 0.7152f, 0.0722f );\n    float f = dot( x, luminanceCoeffsBT709 );\n    x \/= f;        \n    f = 1.0f - exp(-f);    \n    x *= f;    \n    x = mix( x, vec3(f), f*f );\n    \n    return x;\n#else       \n    float a = 0.010;\n    float b = 0.132;\n    float c = 0.010;\n    float d = 0.163;\n    float e = 0.101;\n\n    return ( x * ( a * x + b ) ) \/ ( x * ( c * x + d ) + e );    \n#endif    \n}\n\n\nfloat GetVignetting( const in vec2 vUV, float fScale, float fPower, float fStrength )\n{\n\tvec2 vOffset = (vUV - 0.5) * sqrt(2.0) * fScale;\n\t\n\tfloat fDist = max( 0.0, 1.0 - length( vOffset ) );\n    \n\tfloat fShade = 1.0 - pow( fDist, fPower );\n    \n    fShade = 1.0 - fShade * fStrength;\n\n\treturn fShade;\n}\n\n\nvoid mainImage( out vec4 vFragColor, in vec2 vFragCoord )\n{\n    vec2 vUV = vFragCoord.xy \/ iResolution.xy; \n\n    CameraState cam;\n    \n    {\n    \tCameraState camA;\n    \tCameraState camB;\n    \n        float fSeqTime = iTime;\n        float fSequenceSegLength = 5.0;\n        float fSeqIndex = floor(fSeqTime \/ fSequenceSegLength);\n        float fSeqPos = fract(fSeqTime \/ fSequenceSegLength);\n        int iIndex = int(fSeqIndex);\n\t\tint iIndexNext = int(fSeqIndex) + 1;\n        camA = GetCameraPosition(iIndex);\n        camB = GetCameraPosition(iIndexNext);\n        \n        float t = smoothstep(0.3, 1.0, fSeqPos);\n        cam.vPos = mix(camA.vPos, camB.vPos, t );\n        cam.vTarget = mix(camA.vTarget, camB.vTarget, t );\n        cam.fFov = mix(camA.fFov, camB.fFov, t );\n        cam.fPlaneInFocus = mix(camA.fPlaneInFocus, camB.fPlaneInFocus, t );\n    }\n    \n#if USE_MOUSE    \n    if ( iMouse.z > 0.0 )\n    {\n        float fDist = 0.01 + 3.0 * (iMouse.y \/ iResolution.y);\n\n        float fAngle = (iMouse.x \/ iResolution.x) * radians(360.0);\n    \t\/\/float fElevation = (iMouse.y \/ iResolution.y) * radians(90.0);\n    \tfloat fElevation = 0.15f * radians(90.0);    \n\n        cam.vPos = vec3(sin(fAngle) * fDist * cos(fElevation),sin(fElevation) * fDist,cos(fAngle) * fDist * cos(fElevation));\n        cam.vTarget = vec3(0,0.25,0.1);\n        cam.vPos +=cam.vTarget;\n        cam.fFov = 20.0 \/ (1.0 + fDist * 0.5);\n    \tvec3 vFocus = vec3(0,0.25,-0.012);\t    \n\t    cam.fPlaneInFocus = length( vFocus - cam.vPos );\n    }\n#endif    \n    \n#if 0\n    {\n        float fDist = 0.5;\n\n        float fAngle = 0.6 * PI * 2.0f;\n        float fElevation = 0.2;\n        \n        cam.vPos = vec3(sin(fAngle) * fDist * cos(fElevation),sin(fElevation) * fDist,cos(fAngle) * fDist * cos(fElevation));\n        cam.vTarget = vec3(0.05,0.25,0.1);\n        cam.vPos +=cam.vTarget;\n        cam.fFov = 22.0;\n    \tvec3 vFocus = vec3(0,0.25,-0.012);\t    \n\t    cam.fPlaneInFocus = length( vFocus - cam.vPos );\n    }\n#endif\n    \n#ifdef ENABLE_TAA_JITTER\n    cam.vJitter = hash21( fract( iTime ) ) - 0.5f;\n#endif\n    \n            \n    vec3 vRayOrigin, vRayDir;\n    vec2 vJitterUV = vUV + cam.vJitter \/ iResolution.xy;\n    Cam_GetCameraRay( vJitterUV, iResolution.xy, cam, vRayOrigin, vRayDir );\n \n    float fHitDist = 0.0f;\n    vFragColor = MainCommon( vRayOrigin, vRayDir );\n    \n    float fShade = GetVignetting( vUV, 0.7, 2.0, 1.0 );\n    \n    vFragColor.rgb *= fShade;\n    \n    vFragColor.rgb = Tonemap( vFragColor.rgb );        \n}\n","name":"Image","description":"","type":"image"}]}}