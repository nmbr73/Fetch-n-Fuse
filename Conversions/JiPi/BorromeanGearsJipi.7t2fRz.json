{
 "ver": "0.1",
 "info": {
  "id": "7t2fRz",
  "date": "0",
  "viewed": 0,
  "name": "Borromean Gears JiPi",
  "description": "Click & drag to rotate.\n\nBig thanks to iq for his raymarching articles!",
  "likes": 0,
  "published": "Private",
  "usePreview": 0,
  "tags": [
   "gears",
   "borromean"
  ],
  "hasliked": 0,
  "parentid": "flXfWs",
  "parentname": "Borromean Gears"
 },
 "renderpass": [
  {
   "inputs": [
    {
     "id": "XdXGzr",
     "filepath": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg",
     "type": "texture",
     "channel": 0,
     "sampler": {
      "filter": "mipmap",
      "wrap": "repeat",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    }
   ],
   "outputs": [
    {
     "id": "4dfGRr",
     "channel": 0
    }
   ],
   "code": "const float INFLATION = .02;\nconst float BIG_GEAR_RADIUS = 1.2;\nconst float SMALL_GEAR_RADIUS = BIG_GEAR_RADIUS*.65;\nconst float NUM_OUTER_TEETH = 40.;\nconst float NUM_INNER_TEETH = NUM_OUTER_TEETH*.65;\nconst float PI = 3.14159265359;\nconst float GEAR_DEPTH = .03;\nconst float GEAR_THICKNESS = .14;\nconst float TOOTH_SIZE = .06;\n\nconst float TOUCH_DIST = .0001;\n\nmat3 rotateY( float a )\n{\n    return mat3x3(cos(a), 0.0, sin(a),\n                     0.0, 1.0, 0.0,\n                 -sin(a), 0.0, cos(a));\n}\nmat3 rotateX( float a )\n{\n    return mat3x3(1.0, 0.0, 0.0,\n                  0.0, cos(a), sin(a),\n                  0.0, -sin(a),cos(a));\n}\n\n// from iq\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n   vec2 d = abs(vec2(length(p.xy),p.z)) - vec2(r,h);\n   return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat sdCylinder( vec3 p, float r )\n{\n    return length(p.xy) - r;\n}\n\nvec2 cos_sin( float angle )\n{\n    return vec2( cos(angle), sin(angle) );\n}\n\nvec2 rotate( vec2 pos, float angle )\n{\n    return vec2( pos.x * cos(angle) + pos.y * sin(angle)\n               , pos.x *-sin(angle) + pos.y * cos(angle) );\n}\n\nvec3 modAngle( vec3 pos, float fractionOfCircle )\n{\n    float angle = atan( pos.y, pos.x );\n    float newAngle = mod( angle + PI*fractionOfCircle, 2.*PI*fractionOfCircle ) - PI*fractionOfCircle;\n    return vec3( length(pos.xy)*cos_sin(newAngle), pos.z );\n}\n\nfloat sdGear( vec3 pos_, float thickness, float outerRadius, float innerRadius, float toothSize )\n{\n    //float angle = atan( pos_.y, pos_.x );\n    vec3 pos = modAngle( pos_, 1./NUM_INNER_TEETH);\n\n    // bulk\n    float ret = sdCappedCylinder( pos, thickness, outerRadius );\n    \n    // tooth\n    ret = min( ret, sdCappedCylinder( pos-vec3(outerRadius+INFLATION,0.,0.), thickness, toothSize ) );\n    \n    // carve out center\n    ret = max( ret, -sdCylinder( pos, innerRadius ) );\n    \n    // this makes the gears bumpy!\n    //ret += sin(20.*pos_.x)*sin(20.*pos_.y)*sin(20.*pos_.z)*.02;    \n    return ret;\n}\n\nfloat bump( float val )\n{\n    float TOLERANCE = .15;\n    if ( abs(val) >= TOLERANCE )\n        return 0.;\n    float t = abs(val)/TOLERANCE;\n    return exp(-1./(1.-t*t));\n}\n\nfloat gear( vec3 pos, float gearMotionAngle, out vec3 texturePos )\n{\n    float gearMotionRadius = BIG_GEAR_RADIUS - SMALL_GEAR_RADIUS;\n    float gearAngle = gearMotionAngle * ( BIG_GEAR_RADIUS / SMALL_GEAR_RADIUS - 1. );\n    vec2 gearPos = gearMotionRadius * cos_sin( gearMotionAngle );\n    \n    float posAngle = atan( pos.y-gearPos.y, pos.x-gearPos.x );\n    \n    // warp the gears so that they weave together\n    float WARP_AMOUNT = .18 + INFLATION*2.;\n    float warpAngle = fract( (posAngle-gearMotionAngle)/(2.*PI) );\n    float warpZ = 0.;\n    warpZ += bump( warpAngle-.28 ) * WARP_AMOUNT * .8;\n    warpZ -= bump( warpAngle-.74 ) * WARP_AMOUNT * .8;\n    warpZ += bump( warpAngle-.56 ) * WARP_AMOUNT;\n    warpZ -= bump( warpAngle-.44 ) * WARP_AMOUNT;    \n\n    vec3 rotatedPos = vec3( rotate( pos.xy - gearPos, -gearAngle ), pos.z+warpZ );\n    texturePos = rotatedPos;\n    return sdGear( rotatedPos, GEAR_DEPTH, SMALL_GEAR_RADIUS-INFLATION, SMALL_GEAR_RADIUS-GEAR_THICKNESS, TOOTH_SIZE-INFLATION );\n}\n\nfloat sdOuterGear( vec3 pos_, float thickness, float innerRadius, float outerRadius, float toothSize )\n{\n    vec3 pos = modAngle( pos_, 1./NUM_OUTER_TEETH);\n\n    // bulk\n    float ret = sdCappedCylinder( pos, thickness, outerRadius );\n    \n    // tooth\n    ret = max( ret, -sdCylinder( pos-vec3(innerRadius-INFLATION,0.,0.), toothSize+INFLATION ) );\n    \n    // carve out center\n    ret = max( ret, -sdCylinder( pos, innerRadius ) );\n    \n    //ret += sin(20.*pos_.x)*sin(20.*pos_.y)*sin(20.*pos_.z)*.05;\n    \n    return ret;\n}\n\nfloat sdScene( vec3 pos, out int objectId, out vec3 texturePos )\n{    \n    float dist = 999.;\n    float d;\n    vec3 tp;\n    d = sdOuterGear( pos, GEAR_DEPTH, BIG_GEAR_RADIUS+INFLATION, BIG_GEAR_RADIUS+GEAR_THICKNESS, TOOTH_SIZE ) - INFLATION;\n    dist = min( dist, d );\n    if ( d <= TOUCH_DIST ) { objectId = 0; texturePos = pos; }\n            \n    float gearMotionAngle = iTime * .7;\n    d = gear( pos, gearMotionAngle + PI*0./3., tp ) - INFLATION;\n    dist = min( dist, d );\n    if ( d <= TOUCH_DIST ) { objectId = 1; texturePos = tp; }\n        \n    d = gear( pos, gearMotionAngle + PI*2./3., tp ) - INFLATION;\n    dist = min( dist, d );\n    if ( d <= TOUCH_DIST ) { objectId = 2; texturePos = tp; }\n        \n    d = gear( pos, gearMotionAngle + PI*4./3., tp ) - INFLATION;\n    dist = min( dist, d );\n    if ( d <= TOUCH_DIST ) { objectId = 3; texturePos = tp; }\n    \n    // wall\n    d = .15 - pos.z;\n    dist = min( dist, d );\n    if ( d <= TOUCH_DIST ) { objectId = 4; texturePos = pos; }\n    \n            \n    return dist;\n}\n\nvec3 calcNormal( in vec3 p ) // for function f(p)\n{\n    const float h = 0.001; // replace by an appropriate value\n    const vec2 k = vec2(1,-1);\n    int objectId = -1;\n    vec3 texturePos;\n    return normalize( k.xyy*sdScene( p + k.xyy*h, objectId, texturePos ) + \n                      k.yyx*sdScene( p + k.yyx*h, objectId, texturePos ) + \n                      k.yxy*sdScene( p + k.yxy*h, objectId, texturePos ) + \n                      k.xxx*sdScene( p + k.xxx*h, objectId, texturePos ) );\n}\n\n// iq\nfloat shadow( in vec3 ro, in vec3 rd, float mint, float maxt )\n{\n    int objectId = -1;\n    vec3 texturePos;\n    for( float t=mint; t<maxt; )\n    {\n        float h = sdScene( ro + rd*t, objectId, texturePos );\n        if( h<0.001 )\n            return 0.0;\n        t += h;\n    }\n    return 1.0;\n}\n\n// iq\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    int objectId = -1;\n    vec3 texturePos;\n    for( float t=mint; t<maxt; )\n    {\n        float h = sdScene( ro + rd*t, objectId, texturePos );\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.y;\n    \n    // camera\n    vec3 pos = vec3( 0., 0., -5. );\n    vec3 dir = normalize( vec3( uv, 5. ) );\n    \n    float tilt = cos( (iTime+10.)*.2 ) * -.6 - .85;\n    mat3 modelMatrix = rotateX(tilt);    \n    if ( iMouse.z > 0. )\n    {    \n        modelMatrix = rotateX((iMouse.y/iResolution.y-.5)*-2.9);\n        modelMatrix = modelMatrix * rotateY((iMouse.x/iResolution.x-.5)*-2.9);    \n    }\n    pos = modelMatrix * pos;\n    dir = modelMatrix * dir;\n    \n    vec3 LIGHT_DIR = modelMatrix * normalize( vec3( 2., -1., .5 ) );    \n    //vec3 LIGHT_DIR = modelMatrix * normalize( vec3( 2., -1., 3. ) );    \n    //vec3 LIGHT_DIR = modelMatrix * normalize( vec3( 5., -3., 1. ) );\n    \n    float shadow = 1.;\n    int objectId = -1; // which object did we hit\n    vec3 texturePos;\n    \n    //vec3 col = texture( iChannel1, dir ).rgb*.3;\n    vec3 col = vec3( 0. );\n    for ( int i = 0; ; i++ )\n    {\n        float dist = sdScene( pos, objectId, texturePos );\n        if ( dist < TOUCH_DIST )\n        {                     \n            shadow = softshadow( pos, -LIGHT_DIR, .05, 10., 8. );\n            break;\n        }\n        if ( dist > 99. || i >= 200 )\n        {\n            objectId = 4; // wall            \n            break;\n        }\n        pos += dir * dist * .7;    \n    }\n    \n    \n    // calc lighting\n    {\n        vec3 norm = calcNormal( pos );\n        float ambientLight = ( max( 0., dot( norm, -LIGHT_DIR ) ) ) * .25;\n        float specularLight = pow( max( 0., dot( -reflect( LIGHT_DIR, norm ), dir ) ), 15. );\n        ambientLight *= shadow;\n        col = vec3( ambientLight + specularLight ); \n\n\n        if ( objectId == 4 )\n        {                \n            col += vec3(.1, .2, .5);\n        }\n        else if ( objectId == 0 )\n        {                \n            col += (texture( iChannel0, texturePos.xy ).rgb-.5) * .3;\n        }\n        else\n        {\n            col += float(objectId-2)*.2 + .1;\n            col += max( 0., (texture( iChannel0, texturePos.xy*.25 ).r-.5) ) * .3;\n        }        \n    }\n    \n    \n    \n    \n    \n    // gamma correction\n    col = pow( col, vec3(1.0/2.2) );\n\n    fragColor = vec4( col, 1. );\n}",
   "name": "Image",
   "description": "",
   "type": "image"
  }
 ]
}