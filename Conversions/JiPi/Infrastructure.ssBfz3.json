{"Shader":{"ver":"0.1","info":{"id":"ssBfz3","date":"1649884041","viewed":80,"name":"Infrastructure","username":"R3N","description":"A raymarching scene with a simple greeble technique to add details to surfaces, although there's still some artifacts and aliasing issues resulting from this technique.","likes":10,"published":3,"flags":0,"usePreview":0,"tags":["procedural","3d","architecture","greeble"],"hasliked":0},"renderpass":[{"inputs":[{"id":3,"src":"\/media\/a\/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":37,"channel":0}],"code":"#define MAX_STEPS 100.0\n#define MIN_DIST 0.001\n#define MAX_DIST 75.0\n#define pi 3.14159\n#define oz vec2(0.01,0)\n#define rot(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n#define c1 mix(2.0*vec4(0.3, 0.25, 0.2, 0), vec4(0.5), 0.75)\n#define c2 mix(2.0*vec4(0.2, 0.25, 0.3, 1.0), vec4(0.5), 0.75)\n#define sat(t) clamp(t, 0.0, 1.0)\n\n\/\/ Ray marching result struct\nstruct RayMarch {\n    float dist;     \/\/ Raymarch distance\n    float steps;    \/\/ Raymarch steps\n    vec3 pos;       \/\/ Surface position\n    vec3 normal;    \/\/ Surface normal\n    vec4 col;       \/\/ Surface color\n};\n\n\/\/ Random [0,1]\nfloat rand(vec2 p) {\n\treturn fract(sin(dot(p, vec2(12.543,514.123)))*4732.12);\n}\n\n\/\/ 3D Box SDF by iq\nfloat box(vec2 p, vec2 r) {\n    vec2 d = abs(p) - r;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\n\/\/ Greeble surface detail\nfloat greeble(vec3 p) {\n    float r = 0.0;\n    for (int i = 0; i < 4; i++) {\n        p += 2.*rand(floor(p.xz));\n        r += sign(sin(p.x)*sin(p.y)*sin(p.z));\n        p *= 2.0;\n    }\n    return r;\n}\n\n\/\/ Scene distance function\nfloat scene(vec3 p) {\n    float gr = 0.01*greeble(0.5*p);\n    vec3 pc = p;\n    pc.z = mod(pc.z,40.0)-20.0;\n    p.xy = abs(p.xy);\n    p.x = mod(p.x,2.0)-1.0;\n    p.z = mod(p.z,2.0)-1.0;\n    p.y = mod(p.y,2.0)-.0;\n    float r = 1.0-p.y;\n    r = max(r, -box(pc.yz, vec2(2.5,10.)));\n    r = min(r, box(p.xz, vec2(0.1)));\n    r = min(r, box(p.xy-vec2(0,1), vec2(0.1)));\n    r = min(r, box(p.zy-vec2(0,1), vec2(0.1)));\n    return 0.9*r+gr;\n}\n\n\/\/ Texturing\nvec4 textureColor(vec3 p, vec3 n) {\n    int axis = (abs(n.y)>=0.9 ? 0 : (abs(n.z)>=0.9 ? 1 : 2));\n    vec2 tc = (axis==0 ? p.xz : (axis==1 ? p.xy : p.yz));\n    tc *= 0.5;\n    tc += 0.1*p.z;\n    tc += 0.25*p.y;\n    vec4 col = texture(iChannel0, tc);\n    col *= col*col;\n    col = vec4(3.0*col.r);\n    return sat(col);\n}\n\n\/\/ Ray marching\nRayMarch march(vec3 cam, vec3 ray) {\n    float dist = 0.0;\n    float d = 0.0;\n    float steps = 0.0;\n    vec3 p;\n    while (steps < MAX_STEPS) {\n        p = cam + ray * dist;\n        d = scene(p);\n        dist += d;\n        if (d < MIN_DIST || dist > MAX_DIST) break;\n        steps++;\n    }\n    vec3 n = normalize(d-vec3(scene(p-oz.xyy), scene(p-oz.yxy), scene(p-oz.yyx)));\n    vec4 col = textureColor(p,n);\n    return RayMarch(dist, steps, p, n, col);\n\n}\n\n\/\/ Main\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord\/iResolution.y;\n    uv -= iResolution.xy\/iResolution.y\/2.0;\n    \/\/ Camera setup\n    vec3 cam = vec3(0);\n    cam.z += 0.5*iTime;\n    vec3 ray = normalize(vec3(uv.x, uv.y, 0.8));\n    float rx = (iMouse.z >= 0.5 ? iMouse.x\/iResolution.x*2.0*pi-pi\n                : 0.25*sin(0.2*iTime));\n    float ry = (iMouse.z >= 0.5 ? iMouse.y\/iResolution.y*pi-pi\/2.0\n                : sin(0.3*iTime)*smoothstep(-1.0, 1.0, sin(0.6*iTime)));\n    ray.yz *= rot(ry);\n    ray.xz *= rot(rx);\n    ray.xy *= rot(pi\/2.0);\n    \/\/ Ray march\n    RayMarch rm = march(cam, ray);\n    \/\/ Lighting\n    float l1 = max(dot(rm.normal, normalize(vec3(1, -1.0, 0))), 0.0);\n    float l2 = max(dot(rm.normal, normalize(vec3(1, 1.0, 0))), 0.0);\n    float l3 = max(dot(rm.normal, normalize(vec3(0, 0, -1))), 0.0);\n    float l4 = max(dot(rm.normal, normalize(vec3(-1, 0, 0))), 0.0);\n    float l5 = max(dot(rm.normal, normalize(vec3(0, 0, 1))), 0.0);\n    vec4 l = rm.col*2.0*c1*((l1+l2)+0.3*(l3+l5)+0.2*l4);\n    float drk = sat(rm.pos.x\/15.0+1.0);\n    drk *= drk*drk;\n    float lght = sat(rm.pos.x\/20.0-0.1);\n    float d = 1.0-rm.dist\/MAX_DIST;\n    d *= d*d*d;\n    \/\/ Final composition\n    fragColor = drk*l*d+2.5*c1*lght;\n}","name":"Image","description":"","type":"image"}]}}