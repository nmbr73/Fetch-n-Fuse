{
 "ver": "0.1",
 "info": {
  "id": "ssScWV",
  "date": "0",
  "viewed": 0,
  "name": "Fork Smoke ball JiPi 871",
  "description": "Shows how to use Bitangent Noise (a fast divergence-free noise generator) to mimic fluid motion.\nDetails: https://atyuwen.github.io/posts/bitangent-noise/\nSource: https://github.com/atyuwen/bitangent_noise/\n\n\n\n",
  "likes": 0,
  "published": "Private",
  "usePreview": 0,
  "tags": [
   "noise",
   "fluid",
   "smoke",
   "bitangentnoise"
  ],
  "hasliked": 0,
  "parentid": "ftl3zN",
  "parentname": "Smoke ball"
 },
 "renderpass": [
  {
   "inputs": [],
   "outputs": [
    {
     "id": "4dfGRr",
     "channel": 0
    }
   ],
   "code": "// Shows how to use Bitangent Noise (a fast divergence-free noise generator) to mimic fluid motion.\n// Details: https://atyuwen.github.io/posts/bitangent-noise/\n// Source: https://github.com/atyuwen/bitangent_noise/\n// The checkerboard ground is stolen from iq's work: https://www.shadertoy.com/view/Xds3zN\n\n// Set to 1 to make the ball moves.\n// Set to 0 to disable movement and get higher framerate.\n#define ENABLE_MOVEMENT 1 \n\n//\t--------------------------------------------------------------------\n//\tOptimized implementation of 3D/4D bitangent noise.\n//\tBased on stegu's simplex noise: https://github.com/stegu/webgl-noise.\n//\tContact : atyuwen@gmail.com\n//\tAuthor : Yuwen Wu (https://atyuwen.github.io/)\n//\tLicense : Distributed under the MIT License.\n//\t--------------------------------------------------------------------\n\n// Permuted congruential generator (only top 16 bits are well shuffled).\n// References: 1. Mark Jarzynski and Marc Olano, \"Hash Functions for GPU Rendering\".\n//             2. UnrealEngine/Random.ush. https://github.com/EpicGames/UnrealEngine\nuvec2 _pcg3d16(uvec3 p)\n{\n\tuvec3 v = p * 1664525u + 1013904223u;\n\tv.x += v.y*v.z; v.y += v.z*v.x; v.z += v.x*v.y;\n\tv.x += v.y*v.z; v.y += v.z*v.x;\n\treturn v.xy;\n}\nuvec2 _pcg4d16(uvec4 p)\n{\n\tuvec4 v = p * 1664525u + 1013904223u;\n\tv.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n\tv.x += v.y*v.w; v.y += v.z*v.x;\n\treturn v.xy;\n}\n\n// Get random gradient from hash value.\nvec3 _gradient3d(uint hash)\n{\n\tvec3 g = vec3(uvec3(hash) & uvec3(0x80000, 0x40000, 0x20000));\n\treturn g * (1.0 / vec3(0x40000, 0x20000, 0x10000)) - 1.0;\n}\nvec4 _gradient4d(uint hash)\n{\n\tvec4 g = vec4(uvec4(hash) & uvec4(0x80000, 0x40000, 0x20000, 0x10000));\n\treturn g * (1.0 / vec4(0x40000, 0x20000, 0x10000, 0x8000)) - 1.0;\n}\n\n// Optimized 3D Bitangent Noise. Approximately 113 instruction slots used.\n// Assume p is in the range [-32768, 32767].\nvec3 BitangentNoise3D(vec3 p)\n{\n\tconst vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);\n\tconst vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n\t// First corner\n\tvec3 i = floor(p + dot(p, C.yyy));\n\tvec3 x0 = p - i + dot(i, C.xxx);\n\n\t// Other corners\n\tvec3 g = step(x0.yzx, x0.xyz);\n\tvec3 l = 1.0 - g;\n\tvec3 i1 = min(g.xyz, l.zxy);\n\tvec3 i2 = max(g.xyz, l.zxy);\n\n\t// x0 = x0 - 0.0 + 0.0 * C.xxx;\n\t// x1 = x0 - i1  + 1.0 * C.xxx;\n\t// x2 = x0 - i2  + 2.0 * C.xxx;\n\t// x3 = x0 - 1.0 + 3.0 * C.xxx;\n\tvec3 x1 = x0 - i1 + C.xxx;\n\tvec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n\tvec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n\ti = i + 32768.5;\n\tuvec2 hash0 = _pcg3d16(uvec3(i));\n\tuvec2 hash1 = _pcg3d16(uvec3(i + i1));\n\tuvec2 hash2 = _pcg3d16(uvec3(i + i2));\n\tuvec2 hash3 = _pcg3d16(uvec3(i + 1.0 ));\n\n\tvec3 p00 = _gradient3d(hash0.x); vec3 p01 = _gradient3d(hash0.y);\n\tvec3 p10 = _gradient3d(hash1.x); vec3 p11 = _gradient3d(hash1.y);\n\tvec3 p20 = _gradient3d(hash2.x); vec3 p21 = _gradient3d(hash2.y);\n\tvec3 p30 = _gradient3d(hash3.x); vec3 p31 = _gradient3d(hash3.y);\n\n\t// Calculate noise gradients.\n\tvec4 m = clamp(0.5 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0, 1.0);\n\tvec4 mt = m * m;\n\tvec4 m4 = mt * mt;\n\n\tmt = mt * m;\n\tvec4 pdotx = vec4(dot(p00, x0), dot(p10, x1), dot(p20, x2), dot(p30, x3));\n\tvec4 temp = mt * pdotx;\n\tvec3 gradient0 = -8.0 * (temp.x * x0 + temp.y * x1 + temp.z * x2 + temp.w * x3);\n\tgradient0 += m4.x * p00 + m4.y * p10 + m4.z * p20 + m4.w * p30;\n\n\tpdotx = vec4(dot(p01, x0), dot(p11, x1), dot(p21, x2), dot(p31, x3));\n\ttemp = mt * pdotx;\n\tvec3 gradient1 = -8.0 * (temp.x * x0 + temp.y * x1 + temp.z * x2 + temp.w * x3);\n\tgradient1 += m4.x * p01 + m4.y * p11 + m4.z * p21 + m4.w * p31;\n\n\t// The cross products of two gradients is divergence free.\n\treturn cross(gradient0, gradient1) * 3918.76;\n}\n\n// 4D Bitangent noise. Approximately 163 instruction slots used.\n// Assume p is in the range [-32768, 32767].\nvec3 BitangentNoise4D(vec4 p)\n{\n\tconst vec4 F4 = vec4( 0.309016994374947451 );\n\tconst vec4  C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4\n\t                      0.276393202250021,  // 2 * G4\n\t                      0.414589803375032,  // 3 * G4\n\t                     -0.447213595499958 ); // -1 + 4 * G4\n\n\t// First corner\n\tvec4 i  = floor(p + dot(p, F4) );\n\tvec4 x0 = p -   i + dot(i, C.xxxx);\n\n\t// Other corners\n\n\t// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n\tvec4 i0;\n\tvec3 isX = step( x0.yzw, x0.xxx );\n\tvec3 isYZ = step( x0.zww, x0.yyz );\n\t// i0.x = dot( isX, vec3( 1.0 ) );\n\ti0.x = isX.x + isX.y + isX.z;\n\ti0.yzw = 1.0 - isX;\n\t// i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n\ti0.y += isYZ.x + isYZ.y;\n\ti0.zw += 1.0 - isYZ.xy;\n\ti0.z += isYZ.z;\n\ti0.w += 1.0 - isYZ.z;\n\n\t// i0 now contains the unique values 0,1,2,3 in each channel\n\tvec4 i3 = clamp( i0, 0.0, 1.0 );\n\tvec4 i2 = clamp( i0 - 1.0, 0.0, 1.0 );\n\tvec4 i1 = clamp( i0 - 2.0, 0.0, 1.0 );\n\n\t// x0 = x0 - 0.0 + 0.0 * C.xxxx\n\t// x1 = x0 - i1  + 1.0 * C.xxxx\n\t// x2 = x0 - i2  + 2.0 * C.xxxx\n\t// x3 = x0 - i3  + 3.0 * C.xxxx\n\t// x4 = x0 - 1.0 + 4.0 * C.xxxx\n\tvec4 x1 = x0 - i1 + C.xxxx;\n\tvec4 x2 = x0 - i2 + C.yyyy;\n\tvec4 x3 = x0 - i3 + C.zzzz;\n\tvec4 x4 = x0 + C.wwww;\n\n\ti = i + 32768.5;\n\tuvec2 hash0 = _pcg4d16(uvec4(i));\n\tuvec2 hash1 = _pcg4d16(uvec4(i + i1));\n\tuvec2 hash2 = _pcg4d16(uvec4(i + i2));\n\tuvec2 hash3 = _pcg4d16(uvec4(i + i3));\n\tuvec2 hash4 = _pcg4d16(uvec4(i + 1.0 ));\n\n\tvec4 p00 = _gradient4d(hash0.x); vec4 p01 = _gradient4d(hash0.y);\n\tvec4 p10 = _gradient4d(hash1.x); vec4 p11 = _gradient4d(hash1.y);\n\tvec4 p20 = _gradient4d(hash2.x); vec4 p21 = _gradient4d(hash2.y);\n\tvec4 p30 = _gradient4d(hash3.x); vec4 p31 = _gradient4d(hash3.y);\n\tvec4 p40 = _gradient4d(hash4.x); vec4 p41 = _gradient4d(hash4.y);\n\n\t// Calculate noise gradients.\n\tvec3 m0 = clamp(0.6 - vec3(dot(x0, x0), dot(x1, x1), dot(x2, x2)), 0.0, 1.0);\n\tvec2 m1 = clamp(0.6 - vec2(dot(x3, x3), dot(x4, x4)             ), 0.0, 1.0);\n\tvec3 m02 = m0 * m0; vec3 m03 = m02 * m0;\n\tvec2 m12 = m1 * m1; vec2 m13 = m12 * m1;\n\n\tvec3 temp0 = m02 * vec3(dot(p00, x0), dot(p10, x1), dot(p20, x2));\n\tvec2 temp1 = m12 * vec2(dot(p30, x3), dot(p40, x4));\n\tvec4 grad0 = -6.0 * (temp0.x * x0 + temp0.y * x1 + temp0.z * x2 + temp1.x * x3 + temp1.y * x4);\n\tgrad0 += m03.x * p00 + m03.y * p10 + m03.z * p20 + m13.x * p30 + m13.y * p40;\n\n\ttemp0 = m02 * vec3(dot(p01, x0), dot(p11, x1), dot(p21, x2));\n\ttemp1 = m12 * vec2(dot(p31, x3), dot(p41, x4));\n\tvec4 grad1 = -6.0 * (temp0.x * x0 + temp0.y * x1 + temp0.z * x2 + temp1.x * x3 + temp1.y * x4);\n\tgrad1 += m03.x * p01 + m03.y * p11 + m03.z * p21 + m13.x * p31 + m13.y * p41;\n\n\t// The cross products of two gradients is divergence free.\n\treturn cross(grad0.xyz, grad1.xyz) * 81.0;\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec2 p, in vec2 dpdx, in vec2 dpdy )\n{\n    // filter kernel\n    vec2 w = abs(dpdx)+abs(dpdy) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n#if ENABLE_MOVEMENT\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\nfloat map(in vec3 p)\n{\n    const float r = 1.0;\n    float x = r * sin(iTime);\n    float z = r * cos(iTime);\n    \n    vec3 c = vec3(x, 1, z);\n    vec3 v = vec3(z, 0,-x) * 2.;\n    float d = length(p - c) - 0.5;\n    float d2 = sdCapsule(p, c, c - v * 0.2, 0.5);\n    if (d < -0.2 || d2 > 0.3) return min(d, d2);\n   \n    p = p + (normalize(BitangentNoise4D(vec4(3. * p, iTime))) + v) * 0.05;\n    d = length(p - c);\n    if (d < 0.5) return d - 0.5;\n\n    p = p + (normalize(BitangentNoise4D(vec4(3. * p, iTime))) + v) * 0.05;\n    d = length(p - c);\n    if (d < 0.5) return d - 0.5;\n    \n    p = p + (normalize(BitangentNoise4D(vec4(3. * p, iTime))) + v) * 0.05;\n    d = length(p - c);\n    if (d < 0.5) return d - 0.5;\n    \n    p = p + (normalize(BitangentNoise4D(vec4(3. * p, iTime))) + v) * 0.05;\n    d = length(p - c);\n    return d - 0.5;\n}\n#else\nfloat map(in vec3 p)\n{\n    float d = length(p - vec3(0, 1, 0));\n    if (abs(d - 0.5) > 0.2)\n    {\n        // early quit for optimization.\n        return d - 0.5;\n    }\n\n    p = p + normalize(BitangentNoise4D(vec4(3. * p, iTime))) * 0.05;\n    p = p + normalize(BitangentNoise4D(vec4(3. * p, iTime))) * 0.05;\n    p = p + normalize(BitangentNoise4D(vec4(3. * p, iTime))) * 0.05;\n    p = p + normalize(BitangentNoise4D(vec4(3. * p, iTime))) * 0.05;\n    d = length(p - vec3(0, 1, 0)) - 0.5;\n    return d;\n}\n#endif\n\nconst vec3 sundir = vec3(-1, 1, 0);\nconst vec3 fog = vec3(0.242, 0.334, 0.42) * 2.;\n\nvec4 raymarch(in vec3 ro, in vec3 rd)\n{\n    vec4 acc = vec4(0.);\n    float t = 0.0;\n    for (int i = 0; i < 32 && acc.a < 0.95; ++i)\n    {\n        vec3 pos = ro + t * rd;\n        float d = map(pos);\n        float a = clamp(d * -30., 0.0, 0.2);\n        float s = map(pos + 0.3 * sundir);\n        float diff = clamp((s - d) * 0.4, 0.0, 1.0);\n        vec3 brdf = vec3(0.65,0.68,0.7)* 0.2 + 3.*vec3(0.7, 0.5, 0.3)*diff;\n        acc.w += (1. - acc.w) * a;\n        acc.xyz += a * brdf;\n        t += max(d * 0.5, 0.02);\n    }\n    \n    acc.xyz /= (0.001 + acc.w);\n    return acc;\n}\n\nvec3 shade(vec3 diff, float m, vec3 N, vec3 L, vec3 V)\n{\n  vec3 H = normalize(V + L);\n  float F = 0.05 + 0.95 * pow(1. - dot(V, H), 5.);\n  float R = F * pow(max(dot(N, H), 0.), m);\n  return diff + R * (m + 8.) / 8.;\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    float res = 1.0;\n    for( float t=mint; t<tmax; )\n    {\n        float h = map(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, 4.*h/t );\n        t += h;\n    }\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 32.0 + iTime * 1.2;\n\n    // camera\n#if ENABLE_MOVEMENT    \n    const float dist = 4.5;\n#else\n    const float dist = 3.0;\n#endif\n    vec3 ta = vec3( 0, 1, 0 );\n    vec3 ro = ta + vec3( dist*cos(0.1*time + 7.0*mo.x), 0.6 + 2.0*mo.y, dist*sin(0.1*time + 7.0*mo.x) );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    // focal length\n    const float fl = 2.5;\n        \n    // ray direction\n    vec3 rd = ca * normalize( vec3(p,fl) );\n\n    // ray differentials\n    vec2 px = (2.0*(fragCoord+vec2(1.0,0.0))-iResolution.xy)/iResolution.y;\n    vec2 py = (2.0*(fragCoord+vec2(0.0,1.0))-iResolution.xy)/iResolution.y;\n    vec3 rdx = ca * normalize( vec3(px,fl) );\n    vec3 rdy = ca * normalize( vec3(py,fl) );\n    \n    // raymarch the smoke ball\n    vec4 col = raymarch(ro, rd);\n    \n    // raytrace floor plane\n    float tp1 = (0.0-ro.y)/rd.y;\n    if( tp1 > 0.0 )\n    {\n        vec3 pos = ro + rd * tp1;\n        vec3 dpdx = ro.y*(rd/rd.y-rdx/rdx.y);\n        vec3 dpdy = ro.y*(rd/rd.y-rdy/rdy.y);\n        float f = checkersGradBox( 3.0*pos.xz, 3.0*dpdx.xz, 3.0*dpdy.xz );\n        vec3 ground = shade(0.15 + f * vec3(0.5), 5., vec3(0,1,0), sundir, -rd) * vec3(1.3, 1.2, 1.1);\n        \n        float shadow = calcSoftshadow(pos, normalize(sundir), 0.1, 4.0);\n        ground = ground * mix(0.3, 1.0, shadow);\n        ground = mix(ground, fog, clamp(tp1 * 0.06, 0., 1.));\n        \n        col.xyz = mix(ground, col.xyz, col.w);\n    }\n    else\n    {\n        col.xyz = mix(fog, col.xyz, col.w);\n    }\n    \n    float sun = clamp(dot(sundir,rd), 0.0, 1.0);\n    col.xyz += vec3(1.0,.6,0.1) * 0.6 * (pow(sun, 6.) * 0.5 + max(rd.y * 3., 0.05));\n     \n    // Output to screen\n    fragColor = vec4(pow(col.xyz, vec3(0.4545)),1.0);\n}",
   "name": "Image",
   "description": "",
   "type": "image"
  }
 ]
}