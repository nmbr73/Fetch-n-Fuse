{"Shader":{"ver":"0.1","info":{"id":"7s3Bz2","date":"1656828284","viewed":109,"name":"Flowing Water","username":"fenix","description":"*drag with mouse* *space to reset* Added boundary handling and water-on-window effect inspired stylistically by Heartfelt by BigWIngs https:\/\/www.shadertoy.com\/view\/ltffzl","likes":12,"published":3,"flags":48,"usePreview":1,"tags":["2d","voronoi","simulation","particles","flow","liquid","sph"],"hasliked":0},"renderpass":[{"inputs":[{"id":5,"src":"\/media\/a\/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":6,"src":"\/media\/a\/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","ctype":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":260,"src":"\/media\/previz\/buffer03.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":37,"channel":0}],"code":"\/\/ ---------------------------------------------------------------------------------------\n\/\/\tCreated by fenix in 2022\n\/\/\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\/\/\n\/\/  Multipass particle physics simulation, attempting to approximate smoothed particle\n\/\/  hydrodynamics. \n\/\/ \n\/\/  Buffer A computes the particle positions and neighbors\n\/\/  Buffer B does a traditional voronoi search to help out building neighborhoods\n\/\/  Buffer C renders the particles into a density texture\n\/\/  Buffer D blurs the density\n\/\/\n\/\/ ---------------------------------------------------------------------------------------\n\nvec2 getGradFromHeightMap( vec2 point )\n{\n\tvec2 tinyChangeX = vec2( 0.002, 0.0 );\n    vec2 tinyChangeY = vec2( 0.0 , 0.002 );\n    \n   \tfloat upTinyChangeInX0   = texture(iChannel0, point + tinyChangeX).x; \n   \tfloat upTinyChangeInX1   = texture(iChannel0, point + tinyChangeX + tinyChangeX).x; \n    float downTinyChangeInX0 = texture(iChannel0, point - tinyChangeX).x; \n    float downTinyChangeInX1 = texture(iChannel0, point - tinyChangeX - tinyChangeX).x; \n    \n    float tinyChangeInX = upTinyChangeInX0 + upTinyChangeInX1 - downTinyChangeInX0 - downTinyChangeInX1;\n    \n    \n    float upTinyChangeInY0   = texture(iChannel0, point + tinyChangeY).x; \n    float upTinyChangeInY1   = texture(iChannel0, point + tinyChangeY + tinyChangeY).x; \n    float downTinyChangeInY0 = texture(iChannel0, point - tinyChangeY).x; \n    float downTinyChangeInY1 = texture(iChannel0, point - tinyChangeY - tinyChangeY).x; \n    \n    float tinyChangeInY = upTinyChangeInY0 + upTinyChangeInY1 - downTinyChangeInY0 - downTinyChangeInY1;\n    \n    \n\tvec2 normal = vec2(\n         \t\t\ttinyChangeInX,\n        \t\t\ttinyChangeInY\n    \t \t\t  );\n    \n\treturn normal * 0.5;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    vec2 p = fragCoord\/iResolution.xy;\n    float density = textureLod(iChannel0, p, 1.0).x;\n    if (p.x > 0.15 && ((p.y > 0.725 && p.y < 0.775) || (p.y > 0.225 && p.y < 0.275))\n        || p.x < 0.85 && (p.y > 0.475 && p.y < 0.525))\n    {\n        fragColor = texture(iChannel2, p);\n    }\n    else\n    {\n        vec4 background = textureLod(iChannel1, p, 5.0);\n        vec2 grad = getGradFromHeightMap(p);\n        if (p.y < 0.25) grad.y -= p.y - 0.25; \/\/ Hack to make bottom layer more visible\n        vec4 water = texture(iChannel1, p + grad * 0.7); \/\/ Refract :)\n        fragColor = mix(background, water, smoothstep(0.5, 1.0, density)); \/\/ Blur water edges\n    }\n    \/\/fragColor = texture(iChannel0, p);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\/\/amount of particles\nconst int MAX_PARTICLES = 6000; \nconst int PARTICLE_INIT_X = 10;\nconst float PARTICLE_SIZE = 0.03;\nconst float PARTICLE_REPEL_SIZE = 0.010;\nconst float MOVING_WALL_MAG = 0.0;\nconst float MOVING_WALL_TIME = 3.0;\n\n\/\/hashing noise by IQ\nfloat hash( int k ) {\n    uint n = uint(k);\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 world2screenInternal(in vec2 p, in vec2 resolution)\n{\n    return (p + 1.0) * 0.5 * resolution;\n}\n\n#define world2screen(X) world2screenInternal(X, iResolution.xy)\n\nvec2 screen2worldInternal(in vec2 p, in vec2 resolution)\n{\n    return (p \/ resolution) * 2.0 - 1.0;\n}\n\n#define screen2world(X) screen2worldInternal(X, iResolution.xy)\n\nfloat cross2(vec2 a, vec2 b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\nfloat length2(vec2 v)\n{\n    return dot(v, v);\n}\n\nfloat linePointDist2(in vec2 newPos, in vec2 oldPos, in vec2 fragCoord, in vec3 resolution, out vec2 closest)\n{\n    vec2 pDelta = (fragCoord - oldPos);\n    vec2 delta = newPos - oldPos;\n    float deltaLen2 = dot(delta, delta);\n\n    \/\/ Find the closest point on the line segment from old to new\n    if (deltaLen2 > 0.0000001)\n    {\n        float deltaInvSqrt = inversesqrt(deltaLen2);\n        vec2 deltaNorm = delta * deltaInvSqrt;\n        closest = oldPos + deltaNorm * max(0.0, min(1.0 \/ deltaInvSqrt, dot(deltaNorm, pDelta)));\n    }\n    else\n    {\n        closest = oldPos;\n    }\n\n    \/\/ Distance to closest point on line segment\n    vec2 closestDelta = closest - fragCoord;\n    closestDelta *= resolution.xy \/ resolution.y;\n    return length2(closestDelta);\n}\n\nconst vec4 SCENE_LINES[13] = vec4[]( vec4(-1.0, -1.0, 1.0, -1.0),\n    vec4(-1.0, 1.0, 1.0, 1.0),\n    vec4(-1.0, -1.0, -1.0, 1.0),\n    vec4(1.0, -1.0, 1.0, 1.0),\n    vec4(-0.7, 0.55, 1.0, 0.55),\n    vec4(-0.7, 0.45, 1.0, 0.45),\n    vec4(-0.7, 0.55, -0.7, 0.45),\n    vec4(0.7, 0.05, -1.0, 0.05),\n    vec4(0.7, -0.05, -1.0, -0.05),\n    vec4(0.7, 0.05, 0.7, -0.05),\n    vec4(-0.7, -0.55, 1.0, -0.55),\n    vec4(-0.7, -0.45, 1.0, -0.45),\n    vec4(-0.7, -0.55, -0.7, -0.45));\n    \nconst int NUM_SCENE_LINES = 13;\n\nbool intersectPlane(vec2 p0, vec2 p1, vec2 p2, vec2 p3, in float minT, out float t, out vec2 n)\n{ \n    vec2 CmP = p2 - p0;\n    vec2 r = p1 - p0;\n    vec2 s = p3 - p2;\n\n    float CmPxr = cross2(CmP, r);\n    float CmPxs = cross2(CmP, s);\n    float rxs = cross2(r, s);\n\n    if (CmPxr == 0.0)\n    {\n        \/\/ Lines are collinear, and so intersect if they have any overlap\n        return false;\n        \/\/return ((C.X - A.X < 0f) != (C.X - B.X < 0f))\n          \/\/  || ((C.Y - A.Y < 0f) != (C.Y - B.Y < 0f));\n    }\n\n    if (rxs == 0.0)\n        return false; \/\/ Lines are parallel.\n\n    float rxsr = 1.0 \/ rxs;\n    t = CmPxs * rxsr;\n    float u = CmPxr * rxsr;\n\n    if (t >= 0.0 && t <= minT && u >= 0.0 && u <= 1.0)\n    {\n        n = normalize(vec2(-s.y, s.x));\n        \n        if (rxs < 0.0) n = -n;\n        \n        return true;\n    }\n    \n    return false;\n} \n\nbool intersectScene(float animate, vec2 from, vec2 to, out float t, out vec2 n)\n{\n    float intersectT;\n    vec2 intersectNormal;\n\n    float minT = 1.0;\n    bool hit = false;\n    for (int index = 0; index < NUM_SCENE_LINES; ++index)\n    {\n        vec2 sceneFrom = SCENE_LINES[index].xy;\n        vec2 sceneTo = SCENE_LINES[index].zw;\n        \n        if(intersectPlane(from, to, sceneFrom, sceneTo, minT, intersectT, intersectNormal))\n        {\n            t = minT = intersectT;\n            n = intersectNormal;\n            hit = true;\n        }\n    }\n\n    return hit;\n}\n\nfloat distanceFromWalls(vec2 point, vec3 resolution, float time)\n{\n    float minDist = 1e30;\n#if 1\n    minDist = min(minDist, (point.x + 1.0 - MOVING_WALL_MAG - MOVING_WALL_MAG*sin(time \/ MOVING_WALL_TIME)) * resolution.x \/ resolution.y);\n    minDist = min(minDist, (1.0 - point.x) * resolution.x \/ resolution.y);\n    minDist = min(minDist, point.y + 1.0);\n    minDist = min(minDist, 1.0 - point.y);\n#else\n    for (int index = 0; index < NUM_SCENE_LINES; ++index)\n    {\n        vec2 sceneFrom = SCENE_LINES[index].xy;\n        vec2 sceneTo = SCENE_LINES[index].zw;\n        \n        vec2 closest;\n        float dist = linePointDist2(sceneFrom, sceneTo, point, resolution, closest);\n        \n        if (dist < minDist)\n        {\n            minDist = dist;\n        }\n    }\n#endif\n    return minDist;\n}\n\nvec2 getNormalFromWalls( vec2 point, vec3 resolution, float time )\n{\n\tvec2 tinyChangeX = vec2( 0.001, 0.0 );\n    vec2 tinyChangeY = vec2( 0.0 , 0.001 );\n    \n   \tfloat upTinyChangeInX   = distanceFromWalls( point + tinyChangeX, resolution, time ); \n    float downTinyChangeInX = distanceFromWalls( point - tinyChangeX, resolution, time ); \n    \n    float tinyChangeInX = upTinyChangeInX - downTinyChangeInX;\n    \n    \n    float upTinyChangeInY   = distanceFromWalls( point + tinyChangeY, resolution, time ); \n    float downTinyChangeInY = distanceFromWalls( point - tinyChangeY, resolution, time ); \n    \n    float tinyChangeInY = upTinyChangeInY - downTinyChangeInY;\n    \n    \n\tvec2 normal = vec2(\n         \t\t\ttinyChangeInX,\n        \t\t\ttinyChangeInY\n    \t \t\t  );\n    \n\treturn normalize(normal);\n}\n\n\/\/returns the ids of the four closest particles from the input\nivec4 fxGetClosestInternal(sampler2D sampler, ivec2 xy)\n{\n    return ivec4(texelFetch(sampler, xy, 0));\n}\n\n#define fxGetClosest(X) fxGetClosestInternal(iChannel1, X)\n\n#define UL_NEIGHBORS 0\n#define UR_NEIGHBORS 1\n#define LL_NEIGHBORS 2\n#define LR_NEIGHBORS 3\n#define POS_VEL 4\n#define FLUID 5\n#define NUM_PARTICLE_DATA_TYPES 6\n\n\/\/returns the location of the particle within the particle buffer corresponding with the input id \nivec2 fxLocFromIDInternal(int width, int id, int dataType)\n{\n    int index = id * NUM_PARTICLE_DATA_TYPES + dataType;\n    return ivec2( index % width, index \/ width);\n}\n\n#define fxLocFromID(X, Y) fxLocFromIDInternal(int(iResolution.x), X, Y)\n\nstruct fxParticle\n{\n    vec2 pos;\n    vec2 vel;\n    \n    ivec4 neighbors[4];\n    vec2 uv;\n    float density;\n    float pressure;\n};\n\n\/\/get the particle corresponding to the input id\nfxParticle fxGetParticleInternal(sampler2D sampler, int resolutionWidth, int id)\n{\n    vec4 particleData0 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, UL_NEIGHBORS), 0);\n    vec4 particleData1 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, UR_NEIGHBORS), 0);\n    vec4 particleData2 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, LL_NEIGHBORS), 0);\n    vec4 particleData3 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, LR_NEIGHBORS), 0);\n    vec4 particleData4 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, POS_VEL), 0);\n    vec4 particleData5 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, FLUID), 0);\n\n    fxParticle particle;\n    particle.neighbors[0] = ivec4(particleData0);\n    particle.neighbors[1] = ivec4(particleData1);\n    particle.neighbors[2] = ivec4(particleData2);\n    particle.neighbors[3] = ivec4(particleData3);\n    particle.pos = particleData4.xy;\n    particle.vel = particleData4.zw;\n    particle.uv = particleData5.xy;\n    particle.density = particleData5.z;\n    particle.pressure = particleData5.w;\n    \n    return particle;\n}\n\n\nvec4 fxSaveParticle(fxParticle p, int dataType)\n{    \n    switch(dataType)\n    {\n    case UL_NEIGHBORS:\n        return vec4(p.neighbors[0]);\n    case UR_NEIGHBORS:\n        return vec4(p.neighbors[1]);\n    case LL_NEIGHBORS:\n        return vec4(p.neighbors[2]);\n    case LR_NEIGHBORS:\n        return vec4(p.neighbors[3]);\n    case POS_VEL:  \n        return vec4(p.pos, p.vel);\n    case FLUID:\n        return vec4(p.uv, p.density, p.pressure);\n    }\n}\n\n#define fxGetParticle(X) fxGetParticleInternal(iChannel0, int(iResolution.x), X)\n\nvec4 fxGetParticleDataInternal(sampler2D sampler, int resolutionWidth, int id, int dataType)\n{\n    return texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, POS_VEL), 0);\n}\n\n#define fxGetParticleData(X, Y) fxGetParticleDataInternal(iChannel0, int(iResolution.x), X, Y)\n\nconst float PI = 3.141592653589793;\n\nfloat SPHKernel (float x)\n{\n    if (x < 1.0)\n        return 4.0 * cos(x*PI) + cos((x + x) * PI) + 3.0;\n    else\n        return 0.0;\n}\n\nfloat SPHgradKernel (float x)\n{\n    if (x < 4.0)\n    {\n        float xx = x*x;\n        float xxx = xx*x;\n        float xxxx = xxx*x;\n        return 0.000 + 3.333 * x + -3.167 * xx + 0.917 * xxx + -0.083 * xxxx;\n    }\n    else\n        return 0.0;\n}\n\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\nvoid insertion_sort(inout ivec4 i, inout vec4 d, int i_, float d_){\t\n    if(any(equal(ivec4(i_),i))) return;\n    if     (d_ < d[0])             \n        i = ivec4(i_,i.xyz),    d = vec4(d_,d.xyz);\n    else if(d_ < d[1])             \n        i = ivec4(i.x,i_,i.yz), d = vec4(d.x,d_,d.yz);\n    else if(d_ < d[2])            \n        i = ivec4(i.xy,i_,i.z), d = vec4(d.xy,d_,d.z);\n    else if(d_ < d[3])           \n        i = ivec4(i.xyz,i_),    d = vec4(d.xyz,d_);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":33,"src":"\/presets\/tex00.jpg","ctype":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":258,"src":"\/media\/previz\/buffer01.png","ctype":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":260,"src":"\/media\/previz\/buffer03.png","ctype":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":257,"channel":0}],"code":"\/\/ Particle Buffer\n\/\/ in this buffer every pixel represents a particle\n\/\/ the particles positions is stored in .xy\n\/\/           its velocity  is stored in .zw\n\/\/ Only the first PARTICLES amount of pixels are actually used.\n\nconst vec2 GRAVITY = vec2(0.0000, -0.00012);\nconst float DAMPING = 1.0;\nconst float PARTICLE_REPEL = 0.0001;\nconst float WALL_REPEL = 0.0;\nconst float IDEAL_DENSITY = 106.0;\n\nvoid sort0(inout ivec4 bestIds, inout vec4 bestDists, int id, int searchId, int dataType, in vec2 myPos);\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n    ivec2 iFragCoord = ivec2(fragCoord);\n    \n    \/\/we only simulate PARTICLES amount of particles\n    int maxParticles = min(int(iResolution.x * iResolution.y) \/ NUM_PARTICLE_DATA_TYPES, MAX_PARTICLES);\n    int index = iFragCoord.x + iFragCoord.y*int(iResolution.x);\n    int id = index \/ NUM_PARTICLE_DATA_TYPES;\n    int dataType = index - id * NUM_PARTICLE_DATA_TYPES;\n    if(id>=maxParticles) return;\n    \n    fxParticle data = fxGetParticle(id);\n    \n    if (dataType == POS_VEL || dataType == FLUID)\n    {\n        if (iFrame == 0 || keyDown(32))\n        {\n            \/\/pick a \"random\" starting position\n            float particlesPerRow = sqrt(float(maxParticles)) * 5.0;\n            float i = float(id % int(particlesPerRow));\n            float j = float(id \/ int(particlesPerRow)) + float(id & 1) * 0.5;\n            float k = float(id % 4);\n            \n            data.pos = vec2(i \/ particlesPerRow, j \/ particlesPerRow) * vec2(1.8, -0.2) - vec2(0.9, -0.8 + 0.5 * k);\n            data.vel = vec2(0);\n            data.uv = vec2(data.pos.x * 0.5 + 0.5, data.pos.y * 0.5 + 0.5);\n        }\n        else\n        {\n            vec2 force = vec2(0);\n            \n            \/\/ Debug forces\n            vec2 disturbPos = vec2(0.0, 0.0);\n            vec2 disturbDelta = vec2(0.0, 0.0);\n            if (iMouse.z > 0.0 && iMouse.w < 0.0)\n            {\n                disturbPos = ((2.0 * iMouse.xy \/ iResolution.xy) - 1.0) * vec2(iResolution.x \/ iResolution.y, 1.0);\n                disturbDelta = (iMouse.xy - vec2(iMouse.z, -iMouse.w));\n                disturbDelta = clamp(disturbDelta, -100.0, 100.0);\n            }\n            else\n            {\n                \/\/ auto disturb\n                \/\/disturbPos = vec2(sin(iTime * 0.5), sin(iTime * 1.0))* vec2(1.2, 0.2) + vec2(0.0, 0.2);\n                \/\/disturbDelta = 80.0 * vec2(cos(iTime * 0.5), cos(iTime * 1.0));\n            }\n            \n            const float MOUSE_FIELD_SIZE = 0.3;\n            float MOUSE_FIELD_STRENGTH = 0.1 \/ sqrt(iFrameRate);\n            float dist = distance(data.pos * iResolution.xy \/ iResolution.y, disturbPos);\n            if (dist < MOUSE_FIELD_SIZE)\n            {\n                force += (MOUSE_FIELD_SIZE - dist) * MOUSE_FIELD_STRENGTH * disturbDelta \/ iResolution.xy;\n            }\n\n            struct solverParticle\n            {\n                vec2 pos;\n                vec2 vel;\n                float density;\n                int id;\n            };\n            \n            solverParticle particles[17];\n            int numSolverParticles = 0;\n            float totalDensity = SPHKernel(0.0);\n            vec2 densityGrad = vec2(0);\n            \n            \/\/ Compute neighborhood density and density gradient, and init solver particles\n            for(int i = 0; i < 4; i++){\n                ivec4 neighbors = data.neighbors[i];\n                for (int j = 0; j < 4; ++j)\n                {\n                    int cid = neighbors[j];\n                    if(cid==id || cid==-1 || cid == 0 || cid >= maxParticles) continue;\n                    \n                    vec4 otherPosVel = fxGetParticleData(cid, POS_VEL);\n                    \n                    \/\/ Don't affect particles on the other side of a wall\n                    vec2 normal;\n                    float t;\n                    if (intersectScene(iTime, data.pos, otherPosVel.xy, t, normal)) continue;\n                    \n                    vec4 otherFluid = fxGetParticleData(cid, FLUID);\n                    \n                    vec2 deltaPos = otherPosVel.xy - data.pos;\n                    float dist = length(deltaPos) + 0.0001;\n                    float nbDensity = SPHKernel(dist);\n                    totalDensity += nbDensity;\n                    densityGrad += nbDensity * deltaPos \/ dist;\n\n                    particles[numSolverParticles].pos = otherPosVel.xy;\n                    particles[numSolverParticles].vel = otherPosVel.zw;\n                    particles[numSolverParticles].density = otherFluid.z;\n                    particles[numSolverParticles].id = cid;\n                    ++numSolverParticles;\n                }\n            }       \n\n            particles[numSolverParticles].pos = data.pos;\n            particles[numSolverParticles].vel = data.vel;\n            particles[numSolverParticles].id = id;\n            ++numSolverParticles;\n\n            \/\/ Solve local neighborhood\n            float pressure = 0.0;\n            const int NUM_ITERATIONS = 20;\n            for(int iterations = 0; iterations < NUM_ITERATIONS; ++iterations)\n            {\n                for (int i = 0; i < numSolverParticles; ++i)\n                {\n                    float impulse;\n                    for (int j = 0; j < numSolverParticles; ++j)\n                    {\n                        if (i != j)\n                        {\n                            vec2 deltaPos = particles[i].pos - particles[j].pos;\n                            float dist = length(deltaPos) + 0.001;\n                            vec2 dir = deltaPos \/ dist; \n\n                            impulse = (PARTICLE_REPEL * SPHgradKernel(dist \/ PARTICLE_REPEL_SIZE));\n                                                        \n                            particles[i].vel += impulse * dir;\n                            particles[j].vel -= impulse * dir;\n                        }\n                    }\n                    \n                    \/\/ Last particle is the one we're working on\n                    pressure += impulse;\n                }\n                \n                for (int i = 0; i < numSolverParticles; ++i)\n                {\n                    \/\/ Integrate vel\n                    particles[i].vel -= particles[i].vel * 0.000004 - GRAVITY \/ float(NUM_ITERATIONS);\n                    \n                    \/\/ Integrate pos\n                    particles[i].pos += particles[i].vel \/ float(NUM_ITERATIONS);\n                }\n            }\n            \n            \/\/ Combine solver results into force\n            force += particles[numSolverParticles - 1].vel - data.vel;\n            \n            \/\/ Record misc solver results\n            data.pressure = pressure;\n            data.density = totalDensity;\n                   \n            \/\/ Apply force\n            data.vel = data.vel + force;\n            \n            \/\/ Boundary\n            float distToScene = distanceFromWalls(data.pos, iResolution, iTime);\n            float distToSceneOld = distanceFromWalls(data.pos, iResolution, iTime - iTimeDelta);\n            vec2 distNormal = getNormalFromWalls(data.pos, iResolution, iTime);\n\n            if (distToScene < PARTICLE_REPEL_SIZE)\n            {\n                data.pos -= 1.0 * distNormal * (distToScene - PARTICLE_REPEL_SIZE);\n                data.vel -= 1.0 * distNormal * (distToScene - PARTICLE_REPEL_SIZE);\n                float velToClip = dot(data.vel, distNormal);\n                if (velToClip > 0.0)\n                {\n                    data.vel -= distNormal * (distToSceneOld - distToScene);                    \n                }\n            }\n            \n            const int NUM_SCENE_ITERATIONS = 4;\n            for (int i = 0; i < NUM_SCENE_ITERATIONS; ++i)\n            {\n                float t;\n                vec2 normal;\n                vec2 newPos = data.pos + data.vel;\n                if (intersectScene(iTime, data.pos, newPos, t, normal))\n                {    \n                    vec2 intersection = data.pos + t * data.vel;\n                    vec2 reflected = intersection + (1.0 - t) * reflect(data.vel, normal);\n                    data.vel = reflect(data.vel, normal);\n                }\n            }\n\n            \/\/ Damping\n            data.vel -= data.vel * length2(data.vel) * 200.0;\n            data.vel -= data.vel * 0.9 * smoothstep(50.0, 100.0, data.density);\n\n            \/\/ Clamping\n            float maxSpeed = 30.0 \/ (iResolution.x + iResolution.y); \/\/ Dictated by voronoi update speed\n            float velLength2 = length2(data.vel);\n            if (velLength2 > maxSpeed * maxSpeed)\n            {\n                data.vel *= inversesqrt(velLength2) * maxSpeed;\n            }\n\n            \/\/ Integrate position\n            data.pos = data.pos + data.vel;\n            data.pos = clamp(data.pos, -1.0, 1.0);\n            \n            if (data.pos.x > 0.7 && data.pos.y < -0.99)\n            {\n                data.pos.y += 1.98;\n            }\n        }\n    }\n    else\n    {\n        \/\/ Nearest particle sort inspired by michael0884's Super SPH: https:\/\/www.shadertoy.com\/view\/tdXBRf\n        \/\/sort neighbors and neighbor neighbors\n        vec4 nb0 = fxGetParticleData(id, dataType);\n        ivec4 closest = fxGetClosest(ivec2(world2screen(data.pos)));\n        ivec4 bestIds = ivec4(nb0);\n        vec4 bestDists = vec4(length2(fxGetParticleData(bestIds[0], POS_VEL).xy - data.pos),\n            length2(fxGetParticleData(bestIds[1], POS_VEL).xy - data.pos),\n            length2(fxGetParticleData(bestIds[2], POS_VEL).xy - data.pos),\n            length2(fxGetParticleData(bestIds[3], POS_VEL).xy - data.pos));\n\n        \/\/random sorts\n        for (int i = 0; i < 4; ++i)\n        {\n            int searchId = int(float(iResolution.x*iResolution.y)*hash13(vec3(iFrame, id, i)));\n            sort0(bestIds, bestDists, id, searchId, dataType, data.pos);\n        }\n        \n        \/\/see if the rendering buffer found anything better\n        for (int i = 0; i < 4; ++i)\n        {\n            sort0(bestIds, bestDists, id, int(closest[i]), dataType, data.pos);\n        }\n        \n        fragColor = vec4(bestIds);\n        return;\n    }\n    \n    fragColor = fxSaveParticle(data, dataType);\n}\n\nbool iscoincidence(in ivec4 bestIds, int currentId, int id)\n{\n    return id <= 0 ||\n      \tid == currentId ||\n        any(equal(bestIds,ivec4(id)));\n}\n\nvoid sort0(inout ivec4 bestIds, inout vec4 bestDists, int currentId, int searchId, int dataType, in vec2 myPos)\n{\n    if(iscoincidence(bestIds, currentId, searchId)) return; \/\/particle already sorted\n    \n    vec2 nbX = fxGetParticleData(searchId, POS_VEL).xy; \n\n    vec2 dx = nbX - myPos;\n    int dir = int(2.*(atan(dx.y, dx.x)+PI)\/PI); \n\n    if(dir != dataType) return; \/\/not in this sector\n    \n    float t = length2(dx);\n    \n    if (t > PARTICLE_REPEL_SIZE * 20.0) return;\n   \n    insertion_sort(bestIds, bestDists, searchId, t);\n}\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":258,"src":"\/media\/previz\/buffer01.png","ctype":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":258,"channel":0}],"code":"\/\/ Gijs's Basic : Voronoi Tracking: https:\/\/www.shadertoy.com\/view\/WltSz7\n\n\/\/ Voronoi Buffer\n\/\/ every pixel stores the 4 closest particles to it\n\/\/ every frame this data is shared between neighbours\n\nfloat distance2Particle(int id, vec2 fragCoord){\n    if(id==-1) return 1e20;\n    vec2 delta = fxGetParticleData(id, POS_VEL).xy-fragCoord;\n    return dot(delta, delta);\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n   \tivec2 iFragCoord = ivec2(fragCoord);\n\n    \/\/in this vector the four new closest particles' ids will be stored\n    ivec4 new = fxGetClosest(ivec2(fragCoord));\n    \/\/in this vector the distance to these particles will be stored \n    vec4 dis = vec4(distance(fxGetParticleData(new[0], POS_VEL).xy, screen2world(fragCoord)),\n        distance(fxGetParticleData(new[1], POS_VEL).xy, screen2world(fragCoord)),\n        distance(fxGetParticleData(new[2], POS_VEL).xy, screen2world(fragCoord)),\n        distance(fxGetParticleData(new[3], POS_VEL).xy, screen2world(fragCoord)));\n    \n    for(int x=-2; x<=2; x++){\n        for(int y=-2; y<=2; y++){\n            ivec4 old   = fxGetClosest( iFragCoord + ivec2( x, y) );      \n\n            for(int j=0; j<4; j++){\n                int id = old[j];\n                float dis2 = distance2Particle(id, screen2world(fragCoord));\n                insertion_sort( new, dis, id, dis2 );\n            }\n        }\n    }\n    \n    int searchIterations = 1;\n    if (iFrame < 5)\n    {\n        searchIterations = 10;\n    }\n    for(int k = 0; k < searchIterations; k++){\n        \/\/random hash. We should make sure that two pixels in the same frame never make the same hash!\n        float h = hash(\n            iFragCoord.x + \n            iFragCoord.y*int(iResolution.x) + \n            iFrame*int(iResolution.x*iResolution.y) +\n            k\n        );\n        int maxParticles = min(iFragCoord.x * iFragCoord.y \/ NUM_PARTICLE_DATA_TYPES, MAX_PARTICLES);\n        \/\/pick random id of particle\n        int p = int(h*float(maxParticles));\n        insertion_sort(new, dis, p, distance2Particle(p, screen2world(fragCoord)));\n    }\n    \n    fragColor = vec4(new); \n    \n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":258,"src":"\/media\/previz\/buffer01.png","ctype":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":259,"channel":0}],"code":"vec3 renderLine(in vec2 from, in vec2 to, in vec3 color, in float size, in vec2 fragCoord)\n{\n    vec2 closest;\n    float dist = linePointDist2(from, to, fragCoord, iResolution, closest);\n    return color * max(0.0, (size - sqrt(dist)) \/ (size));\n}\n\nvec3 renderParticle(in fxParticle p, in vec2 fragCoord)\n{   \n    \/\/if (p.density < 50.0) return;\n    int maxParticles = min(int(iResolution.x * iResolution.y) \/ NUM_PARTICLE_DATA_TYPES, MAX_PARTICLES);\n\n    \/\/fragColor.xyz += 1000.2 * p.pressure * particleColor(p.uv) * max(0.0, PARTICLE_SIZE - sqrt(dist)) \/ PARTICLE_SIZE;\n    vec3 color = vec3(1.0, 1.0, 1.0);\/\/vec3(150.0*p.pressure, 10000.0*dot(p.vel, p.vel), 0.000012*p.density*p.density*p.density);\n    vec3 fragColor = renderLine(p.pos, p.pos - p.vel, color, PARTICLE_SIZE, fragCoord);\n    \n    \/\/ Render neighbor lines\n    #if 0\n    for(int i = 0; i < 4; i++){\n        ivec4 neighbors = p.neighbors[i];\n        for (int j = 0; j < 4; ++j)\n        {\n            int cid = neighbors[j];\n            if(cid==-1 || cid >= maxParticles || cid == 0) continue;\n\n            vec2 otherPos = fxGetParticleData(cid, POS_VEL).xy;\n\n            if (length(otherPos - p.pos) < 0.1)\n            {\n                \/\/float distToLin = linePointDist2(p.pos, p.pos + 0.5 * (otherPos - p.pos), fragCoord, iResolution, closest);\n                fragColor += renderLine(p.pos, p.pos + 0.5 * (otherPos - p.pos), color, PARTICLE_SIZE * 0.3, fragCoord);\/\/color * max(0.0, PARTICLE_SIZE * 0.3 - sqrt(distToLin)) \/ (PARTICLE_SIZE);\n            }\n        }\n    }\n    #endif\n    \n    return fragColor;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n    \n    fragColor = vec4(0.0);\n    \n  \tvec2 p = (2.0*fragCoord-iResolution.xy)\/iResolution.xy;\n\n#if 0\n    for (int line = 0; line < NUM_SCENE_LINES; ++line)\n    {\n        fragColor.xyz += renderLine(SCENE_LINES[line].xy, SCENE_LINES[line].zw, vec3(1.0, 0.0, 0.0), PARTICLE_SIZE, p);\n    }\n#endif\n\n    \/\/get the id's of the 4 particles that (should be) closest.\n    \/\/the 4 ids are stored in .x, .y, .z, .w\n    ivec4 ids = fxGetClosest(ivec2(fragCoord));\n    \n    \/\/draw the particles\n    for(int i = 0; i < 4; i++){\n        \/\/get the particles position\n        int id = ids[i];\n        fxParticle particle = fxGetParticle(id);\n\n        fragColor.xyz += renderParticle(particle, p);\n    }\n    \n    \/\/fragColor.xyz = vec3(distanceFromWalls(p, iResolution, iTime));\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":259,"src":"\/media\/previz\/buffer02.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":260,"channel":0}],"code":"\/\/ gaussian blur from FabriceNeyret2's smart gaussian blur: https:\/\/www.shadertoy.com\/view\/WtKfD3\n\nint           N = 11; \/\/ 7                              \/\/ target sampling rate\nfloat         w = .1,                                   \/\/ filter width\n              z;                                        \/\/ LOD MIPmap level to use for integration \n#define init  w = .02; \\\n              z = ceil(max(0.,log2(w*R.y\/float(N))));   \/\/ N\/w = res\/2^z\n#define R     iResolution.xy\n\n\nfloat convol2D(vec2 U) {                                                     \n    float  O = 0.0;  \n    float r = float(N-1)\/2., g, t=0.;                                       \n    for( int k=0; k<N*N; k++ ) {                                            \n        vec2 P = vec2(k%N,k\/N) \/ r - 1.;                                    \n        t += g = exp(-2.*dot(P,P) );                                        \n        O += g * textureLod(iChannel0, (U+w*P) *R.y\/R, z ).x;                 \n    }                                                                       \n    return O\/t;                                                             \n}      \n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    init \n    vec2 U = u \/ R.y;  \n    O = texture(iChannel0, u \/ iResolution.xy);\n    O.x = convol2D(U); return;\n  \/\/  O = convol1D(U,vec2(1,0));\n}\n\n","name":"Buffer D","description":"","type":"buffer"}]}}