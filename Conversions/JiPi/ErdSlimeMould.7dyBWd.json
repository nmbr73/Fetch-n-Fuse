{"Shader":{"ver":"0.1","info":{"id":"7dyBWd","date":"1659005263","viewed":132,"name":"ERD slime mould","username":"xenn","description":"featuring a two-pass 9x9 Gaussian Blur pipeline for the diffusion, gradient lookup for morphological expansion, and a simple differential \"Turing Pattern\" reaction. Lookout, there are 3 more diffused channels ","likes":14,"published":3,"flags":32,"usePreview":0,"tags":["gaussianblur","reactiondiffusion"],"hasliked":0},"renderpass":[{"inputs":[{"id":8,"src":"\/media\/a\/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","ctype":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":259,"src":"\/media\/previz\/buffer02.png","ctype":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":37,"channel":0}],"code":"\n\/\/ shortcut to sample texture\n#define TEX(uv) texture(iChannel0, uv).r\n\n\n\/\/ Fork of \" expansive reaction-diffusion\" by Flexi. https:\/\/shadertoy.com\/view\/4dcGW2\n\/\/ 2022-07-28 10:46:34\n\n\/\/ and\n\n\/\/ Brush toy by Leon Denise 2022-05-17\n\n\/\/ I wanted to play further with shading and lighting from 2D heightmap.\n\/\/ I started by generating a heightmap from noise, then shape and curves.\n\/\/ Once the curve was drawing nice brush strokes, I wanted to add motion.\n\/\/ Also wanted to add droplets of paints falling, but that will be\n\/\/ for another sketch.\n\n\/\/ This is the color pass\n\/\/ Click on left edge to see layers\n\n\/\/ The painting pass (Buffer A) is using FBM noise to simulate brush strokes\n\/\/ The curve was generated with a discrete Fourier Transform,\n\/\/ from https:\/\/www.shadertoy.com\/view\/3ljXWK\n\n\/\/ Frame buffer sampling get offset from brush motion,\n\/\/ and the mouse also interact with the buffer.\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = vec3(.0);\n    \n    \/\/ coordinates\n    vec2 uv = fragCoord.xy \/ iResolution.xy;\n    vec3 dither = texture(iChannel1, fragCoord.xy \/ 1024.).rgb;\n    \n    \/\/ value from noise buffer A\n    vec3 noise = texture(iChannel0, uv).rgb;\n    float gray = noise.x;\n    \n    \/\/ gradient normal from gray value\n    vec3 unit = vec3(3.\/iResolution.xy,0);\n    vec3 normal = normalize(vec3(\n        TEX(uv + unit.xz)-TEX(uv - unit.xz),\n        TEX(uv - unit.zy)-TEX(uv + unit.zy),\n        gray*gray));\n    \n    \n    \/\/ specular light\n    vec3 dir = normalize(vec3(0,1,2.));\n    float specular = pow(dot(normal, dir)*.5+.5,20.);\n    color += vec3(.5)*specular;\n    \n    \/\/ rainbow palette\n    vec3 tint = .5+.5*cos(vec3(1,2,3)*(1.+(.5*sin(iTime\/3.)))+gray*5.+uv.x*5.);\n    dir = normalize(vec3(uv-.5, 0.));\n    color += tint*pow(dot(normal, -dir)*.5+.5, 0.5);\n    \n    \/\/ background blend\n    vec3 background = vec3(.8)*smoothstep(1.5,0.,length(uv-.5));\n    color = mix(background, clamp(color, 0., 1.), smoothstep(.2,.5,noise.x));\n    \n    \/\/ display layers when clic\n    if (iMouse.z > 0.5 && iMouse.x\/iResolution.x < .1)\n    {\n        if (uv.x < .33) color = vec3(gray);\n        else if (uv.x < .66) color = normal*.5+.5;\n        else color = vec3(.2+specular)*gray;\n    }\n\n    fragColor = vec4(color, 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":30,"src":"\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","ctype":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":259,"src":"\/media\/previz\/buffer02.png","ctype":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":260,"src":"\/media\/previz\/buffer03.png","ctype":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":257,"channel":0}],"code":"\/\/ main reaction-diffusion loop\n\n\/\/ actually the diffusion is realized as a separated two-pass Gaussian blur kernel and is stored in buffer C\n\n#define pi2_inv 0.159154943091895335768883763372\n\nvec2 complex_mul(vec2 factorA, vec2 factorB){\n    return vec2( factorA.x*factorB.x - factorA.y*factorB.y, factorA.x*factorB.y + factorA.y*factorB.x);\n}\n\nvec2 spiralzoom(vec2 domain, vec2 center, float n, float spiral_factor, float zoom_factor, vec2 pos){\n    vec2 uv = domain - center;\n    float d = length(uv);\n    return vec2( atan(uv.y, uv.x)*n*pi2_inv + d*spiral_factor, -log(d)*zoom_factor) + pos;\n}\n\nvec2 complex_div(vec2 numerator, vec2 denominator){\n    return vec2( numerator.x*denominator.x + numerator.y*denominator.y,\n                numerator.y*denominator.x - numerator.x*denominator.y)\/\n        vec2(denominator.x*denominator.x + denominator.y*denominator.y);\n}\n\nfloat circle(vec2 uv, vec2 aspect, float scale){\n    return clamp( 1. - length((uv-0.5)*aspect*scale), 0., 1.);\n}\n\nfloat sigmoid(float x) {\n    return 2.\/(1. + exp2(-x)) - 1.;\n}\n\nfloat smoothcircle(vec2 uv, vec2 aspect, float radius, float ramp){\n    return 0.5 - sigmoid( ( length( (uv - 0.5) * aspect) - radius) * ramp) * 0.5;\n}\n\nfloat conetip(vec2 uv, vec2 pos, float size, float min)\n{\n    vec2 aspect = vec2(1.,iResolution.y\/iResolution.x);\n    return max( min, 1. - length((uv - pos) * aspect \/ size) );\n}\n\nfloat warpFilter(vec2 uv, vec2 pos, float size, float ramp)\n{\n    return 0.5 + sigmoid( conetip(uv, pos, size, -16.) * ramp) * 0.5;\n}\n\nvec2 vortex_warp(vec2 uv, vec2 pos, float size, float ramp, vec2 rot)\n{\n    vec2 aspect = vec2(1.,iResolution.y\/iResolution.x);\n\n    vec2 pos_correct = 0.5 + (pos - 0.5);\n    vec2 rot_uv = pos_correct + complex_mul((uv - pos_correct)*aspect, rot)\/aspect;\n    float _filter = warpFilter(uv, pos_correct, size, ramp);\n    return mix(uv, rot_uv, _filter);\n}\n\nvec2 vortex_pair_warp(vec2 uv, vec2 pos, vec2 vel)\n{\n    vec2 aspect = vec2(1.,iResolution.y\/iResolution.x);\n    float ramp = 5.;\n\n    float d = 0.2;\n\n    float l = length(vel);\n    vec2 p1 = pos;\n    vec2 p2 = pos;\n\n    if(l > 0.){\n        vec2 normal = normalize(vel.yx * vec2(-1., 1.))\/aspect;\n        p1 = pos - normal * d \/ 2.;\n        p2 = pos + normal * d \/ 2.;\n    }\n\n    float w = l \/ d * 2.;\n\n    \/\/ two overlapping rotations that would annihilate when they were not displaced.\n    vec2 circle1 = vortex_warp(uv, p1, d, ramp, vec2(cos(w),sin(w)));\n    vec2 circle2 = vortex_warp(uv, p2, d, ramp, vec2(cos(-w),sin(-w)));\n    return (circle1 + circle2) \/ 2.;\n}\n\nvec2 mouseDelta(){\n    vec2 pixelSize = 1. \/ iResolution.xy;\n    float eighth = 1.\/8.;\n    vec4 oldMouse = texture(iChannel2, vec2(7.5 * eighth, 2.5 * eighth));\n    vec4 nowMouse = vec4(iMouse.xy \/ iResolution.xy, iMouse.zw \/ iResolution.xy);\n    if(oldMouse.z > pixelSize.x && oldMouse.w > pixelSize.y && \n       nowMouse.z > pixelSize.x && nowMouse.w > pixelSize.y)\n    {\n        return nowMouse.xy - oldMouse.xy;\n    }\n    return vec2(0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n    vec2 pixelSize = 1. \/ iResolution.xy;\n    \n\n    vec2 mouseV = mouseDelta();\n    vec2 aspect = vec2(1.,iResolution.y\/iResolution.x);\n    uv = vortex_pair_warp(uv, iMouse.xy*pixelSize, mouseV*aspect*1.4);\n\n    vec4 blur1 = texture(iChannel1, uv);\n    \n    vec4 noise = texture(iChannel3, fragCoord.xy \/ iChannelResolution[3].xy + fract(vec2(42,56)*iTime));\n\n    \/\/ get the gradients from the blurred image\n\tvec2 d = pixelSize*4.;\n\tvec4 dx = (texture(iChannel1, fract(uv + vec2(1,0)*d)) - texture(iChannel1, fract(uv - vec2(1,0)*d))) * 0.5;\n\tvec4 dy = (texture(iChannel1, fract(uv + vec2(0,1)*d)) - texture(iChannel1, fract(uv - vec2(0,1)*d))) * 0.5;\n    \n    vec2 uv_red = uv + vec2(dx.x, dy.x)*pixelSize*8.; \/\/ add some diffusive expansion\n    \n    float new_red = texture(iChannel0, fract(uv_red)).x + (noise.x - 0.5) * 0.0025 - 0.002; \/\/ stochastic decay\n\tnew_red -= (texture(iChannel1, fract(uv_red + (noise.xy-0.5)*pixelSize)).x -\n\t\t\t\ttexture(iChannel0, fract(uv_red + (noise.xy-0.5)*pixelSize))).x * 0.047; \/\/ reaction-diffusion\n        \n    if(iFrame<10)\n    {\n        fragColor = noise; \n    }\n    else\n    {\n        fragColor.x = clamp(new_red, 0., 1.);\n    }\n\n\/\/    fragColor = noise; \/\/ need a restart?\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":258,"channel":0}],"code":"\/\/ horizontal Gaussian blur pass\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixelSize = 1.\/ iChannelResolution[0].xy;\n    vec2 uv = fragCoord.xy * pixelSize;\n    \n    float h = pixelSize.x;\n\tvec4 sum = vec4(0.0);\n\tsum += texture(iChannel0, fract(vec2(uv.x - 4.0*h, uv.y)) ) * 0.05;\n\tsum += texture(iChannel0, fract(vec2(uv.x - 3.0*h, uv.y)) ) * 0.09;\n\tsum += texture(iChannel0, fract(vec2(uv.x - 2.0*h, uv.y)) ) * 0.12;\n\tsum += texture(iChannel0, fract(vec2(uv.x - 1.0*h, uv.y)) ) * 0.15;\n\tsum += texture(iChannel0, fract(vec2(uv.x + 0.0*h, uv.y)) ) * 0.16;\n\tsum += texture(iChannel0, fract(vec2(uv.x + 1.0*h, uv.y)) ) * 0.15;\n\tsum += texture(iChannel0, fract(vec2(uv.x + 2.0*h, uv.y)) ) * 0.12;\n\tsum += texture(iChannel0, fract(vec2(uv.x + 3.0*h, uv.y)) ) * 0.09;\n\tsum += texture(iChannel0, fract(vec2(uv.x + 4.0*h, uv.y)) ) * 0.05;\n    \n    fragColor.xyz = sum.xyz\/0.98; \/\/ normalize\n\tfragColor.a = 1.;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":258,"src":"\/media\/previz\/buffer01.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":259,"channel":0}],"code":"\/\/ vertical Gaussian blur pass\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixelSize = 1.\/ iChannelResolution[0].xy;\n    vec2 uv = fragCoord.xy * pixelSize;\n\n    float v = pixelSize.y;\n\tvec4 sum = vec4(0.0);\n\tsum += texture(iChannel0, fract(vec2(uv.x, uv.y - 4.0*v)) ) * 0.05;\n\tsum += texture(iChannel0, fract(vec2(uv.x, uv.y - 3.0*v)) ) * 0.09;\n\tsum += texture(iChannel0, fract(vec2(uv.x, uv.y - 2.0*v)) ) * 0.12;\n\tsum += texture(iChannel0, fract(vec2(uv.x, uv.y - 1.0*v)) ) * 0.15;\n\tsum += texture(iChannel0, fract(vec2(uv.x, uv.y + 0.0*v)) ) * 0.16;\n\tsum += texture(iChannel0, fract(vec2(uv.x, uv.y + 1.0*v)) ) * 0.15;\n\tsum += texture(iChannel0, fract(vec2(uv.x, uv.y + 2.0*v)) ) * 0.12;\n\tsum += texture(iChannel0, fract(vec2(uv.x, uv.y + 3.0*v)) ) * 0.09;\n\tsum += texture(iChannel0, fract(vec2(uv.x, uv.y + 4.0*v)) ) * 0.05;\n    \n    fragColor.xyz = sum.xyz\/0.98; \/\/ normalize\n\tfragColor.a = 1.;\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":260,"channel":0}],"code":"\/\/ not used (yet), but hooray for 8 channel feedback\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n    vec2 pixelSize = 1. \/ iResolution.xy;\n    float eighth = 1.\/8.;\n    if(uv.x > 7.*eighth && uv.x < 8.*eighth && uv.y > 2.*eighth && uv.y < 3.*eighth)\n    {\n        fragColor = vec4(iMouse.xy \/ iResolution.xy, iMouse.zw \/ iResolution.xy);\n    }\n}","name":"Buffer D","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n\/\/ rotation matrix\nmat2 rot (float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }\n\n\/\/ generated with discrete Fourier transform\nvec2 cookie(float t) {\n\treturn vec2(0.08+cos(t-1.58)*0.23+cos(t*2.-1.24)*0.14+cos(t*3.-1.12)*0.09+cos(t*4.-0.76)*0.06+cos(t*5.-0.59)*0.05+cos(t*6.+0.56)*0.03+cos(t*7.-2.73)*0.03+cos(t*8.-1.26)*0.02+cos(t*9.-1.44)*0.02+cos(t*10.-2.09)*0.03+cos(t*11.-2.18)*0.01+cos(t*12.-1.91)*0.02,cos(3.14)*0.05+cos(t+0.35)*0.06+cos(t*2.+0.54)*0.09+cos(t*3.+0.44)*0.03+cos(t*4.+1.02)*0.07+cos(t*6.+0.39)*0.03+cos(t*7.-1.48)*0.02+cos(t*8.-3.06)*0.02+cos(t*9.-0.39)*0.07+cos(t*10.-0.39)*0.03+cos(t*11.-0.03)*0.04+cos(t*12.-2.08)*0.02);\n}\n","name":"Common","description":"","type":"common"}]}}