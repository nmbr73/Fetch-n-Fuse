{
 "ver": "0.1",
 "info": {
  "id": "7sSBRz",
  "date": "0",
  "viewed": 0,
  "name": "Stranger Tides JiPi 742",
  "description": "Eon flux from stranger tides #mood",
  "likes": 0,
  "published": "Private",
  "usePreview": 0,
  "tags": [
   "voronoi",
   "particles",
   "bubbles",
   "abstractwater"
  ],
  "hasliked": 0,
  "parentid": "ssBfzR",
  "parentname": "Stranger Tides"
 },
 "renderpass": [
  {
   "inputs": [],
   "outputs": [
    {
     "id": "4dfGRr",
     "channel": 0
    }
   ],
   "code": "\n//\n//\n// Stranger Tides   \n//\n// I like the kinda abstract and fluid looks that go along with when distributing and\n// animating voronoi´s to surfaces. I have always wanted to get get it working in one of\n// my 50 cents of shadertoy´ing. This mood is not perfect at all, but with surprising \n// ease to get this started...\n//\n//\n// This shader shall exist in its/this form on shadertoy.com only \n// You shall not use this shader in any commercial or non-commercial product, website or project. \n// This shader is not for sale nor can´t be minted as NFT.\n//\n//\n// Related examples\n//\n//\n// IQ´s 2nd order voronoi algorithm:\n// https://www.shadertoy.com/view/MsXGzM      \n//\n//\n//\n\n\n#define PI 3.14159265359\n#define MAX_ITER_INTERNAL 0\n#define MAX_DIST 10.0\n#define MIN_DIST 0.01\n#define FOV 1.05\n#define FK(k) floatBitsToInt(cos(k))^floatBitsToInt(k)\n\n\n\nstruct ray {\n\tvec4 c;\n\tvec3 p;\n\tvec3 d;\n\tvec3 n;\n\tfloat t;\n\tint i;\n};\n\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// x,y,z rotation(s)\n//////////////////////////////////////////////////////////////////////////////////////\n\nmat3 rotx(float a) {\n\tfloat c=cos(a);\n\tfloat s=sin(a);\n\treturn mat3(1.0,0.0,0.0,0.0,c,-s,0.0,s,c);\n}\nmat3 roty(float a) {\n\tfloat c=cos(a);\n\tfloat s=sin(a);\n\treturn mat3(c,0.0,s,0.0,1.0,0.0,-s,0.0,c);\n}\nmat3 rotz(float a) {\n\tfloat c=cos(a);\n\tfloat s=sin(a);\n\treturn mat3(c,-s,0.0,s,c,0.0,0.0,0.0,1.0);\n}\nmat3 rot(vec3 z,float a) {\n\tfloat c=cos(a);\n\tfloat s=sin(a);\n\tfloat b=1.0-c;\n\treturn mat3(\n\t\tb*z.x*z.x+c,b*z.x*z.y-z.z*s,b*z.z*z.x+z.y*s,\n\t\tb*z.x*z.y+z.z*s,b*z.y*z.y+c,b*z.y*z.z-z.x*s,\n\t\tb*z.z*z.x-z.y*s,b*z.y*z.z+z.x*s,b*z.z*z.z+c);\n}\nmat2 rot2d(float a) {\n\tfloat c=cos(a);\n\tfloat s=sin(a);\n\treturn mat2(\n\t\tc,-s,\n\t\ts, c);\n}\n\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// smooth minimum(s) -> https://iquilezles.org/www/articles/smin/smin.htm\n//////////////////////////////////////////////////////////////////////////////////////\n\nfloat smin(float a,float b,float k) {\n\tfloat h=clamp(0.5+0.5*(b-a)/k,0.0,1.0);\n    return mix(b,a,h)-k*h*(1.0-h);\n}\n\n//Smooth min by IQ\nfloat smin( float a, float b ) {\n    float k = 0.95;\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// randomness and hash´ing like a pro\n//////////////////////////////////////////////////////////////////////////////////////\n\nfloat s;\n\nvoid srand(vec2 p) {\n\ts=sin(dot(p,vec2(423.62431,321.54323)));\n}\n\nfloat rand() {\n\ts=fract(s*32322.65432+0.12333);\n\treturn abs(fract(s));\n}\n\nfloat hash( in vec3 p ) {\n    return fract(sin(p.x*15.32758341+p.y*39.786792357+p.z*59.4583127+7.5312) * 43758.236237153)-.5;\n}\n\nfloat hash(vec2 k) {\n  int x = FK(k.x);int y = FK(k.y);\n  return float((x*x-y)*(y*y+x)-x)/3.14e9;\n}\n\nfloat hash3(vec3 k) {\n  float h1 = hash(k.xy);\n  return hash(vec2(h1, k.z));\n}\n\n\nvec3 hash33(vec3 k) {\n  float h1 = hash3(k);\n  float h2 = hash3(k*h1);\n  float h3 = hash3(k*h2);\n  return vec3(h1, h2, h3);\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// As in IQ´s rocks\n//////////////////////////////////////////////////////////////////////////////////////\n\nvec3 voronoi3d(const in vec3 x) {\n\n  vec3 p = floor(x);\n  vec3 f = fract(x);\n\n  float id = 0.0;\n  vec2 res = vec2(100.0);\n  for (int k = -1; k <= 1; k++) {\n    for (int j = -1; j <= 1; j++) {\n      for (int i = -1; i <= 1; i++) {\n        vec3 b = vec3(float(i), float(j), float(k));\n        vec3 r = vec3(b) - f + hash(p + b );\n         //r.x *= 0.5 + 0.5*sin( iTime );\n         //r.z *= 0.5 + 2.5*cos( iTime );\n         //r *= rot( r, iTime );\n\n\n        float d = dot(r, r);\n\n        float cond = max(sign(res.x - d), 0.0);\n        float nCond = 1.0 - cond;\n\n        float cond2 = nCond * max(sign(res.y - d), 0.0);\n        float nCond2 = 1.0 - cond2;\n\n        id = (dot(p + b, vec3(1.0, 57.0, 113.0)) * cond) + (id * nCond);\n        res = vec2(d, res.x) * cond + res * nCond;\n\n        res.y = cond2 * d + nCond2 * res.y;\n      }\n    }\n  }\n  return vec3(sqrt(res), abs(id));\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// Voronoi 2d\n//////////////////////////////////////////////////////////////////////////////////////\n\nfloat voronoi2d(vec2 p,float t) {\n\tfloat v=0.0;\n\tvec2 f=floor(p)+vec2(0.25);\n\tfor(float i=-3.0;i<3.0;i++)\n        for(float j=-3.0;j<3.0;j++){\n            srand(f+vec2(i,j));\n            vec2 o;\n            o.x=rand();\n            o.y=rand();\n            o*=rot2d(iTime*(rand()-0.5));\n            float r=distance(p,f+vec2(i,j)+o);\n            v+=exp(-16.0*r);\n        }\n\treturn -smin((1.0/16.0)*log(v),-0.1,0.1);\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// Torus\n//////////////////////////////////////////////////////////////////////////////////////\n\nfloat torus(inout ray r) {\n    vec3 vt = r.p + ((voronoi3d(r.p * 2.6 + iTime * .1).x)*0.5 + 0.5);\n    vt.x -= 0.5;\n    vt.y -= 1.5;\n    vt.z -= 0.60;\n    vt *= rotz( sin(iTime * 0.5) );\n    vt *= rotx( cos(iTime * 0.25) );\n    return length(vec2(length(vt.xy) -1.74, vt.z)) -0.55;\t\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// Dome\n//////////////////////////////////////////////////////////////////////////////////////\n\nfloat dome(inout ray r) {\n\tfloat v=voronoi2d(r.p.xy,r.t);\n\tfloat d=dot(r.p,vec3(0.0,0.0,0.75))+0.5-0.5*v;\n\tif(d<0.0){\n\t\tr.c=vec4(1.0);\n\t\tr.i=MAX_ITER_INTERNAL+1;\n\t}\n\treturn d;\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// Bubbles\n//////////////////////////////////////////////////////////////////////////////////////\n\nvec3 sphercoord(vec2 p) {\n  float l1 = acos(p.x);\n  float l2 = acos(-.5)*p.y;\n  return vec3(cos(l1), sin(l1)*sin(l2), sin(l1)*cos(l2));\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(p,ax)*ax, p, cos(ro)) + sin(ro)*cross(p,ax);\n}\n\nfloat comp(vec3 p, vec3 ro, float t) {\n  vec3 ax = sphercoord(ro.xy);\n  p.z -= t;\n  p = erot(p, ax, ro.z*acos(-1.));\n  float scale = 7. + hash(ro.xz)*0.25+0.25;\n  p = (fract(p/scale)-0.65)*scale;\n  return length(p) - 0.2;\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// distance field\n//////////////////////////////////////////////////////////////////////////////////////\n\nfloat dist(inout ray r) {\n  \n  float d=MAX_DIST;\n  float dist = d;\n  \n  for( int i = 0; i < 4; i++ ) {\n       vec3 rot = hash33(vec3(float(i+1), cos(float(i)), sin(float(i))));\n       float d_ = comp(r.p, rot, iTime/2.*(float(i+1)));\n       dist = smin(dist, d_, .5);\n  }\n   \n  d=smin(d,dome(r));\n  d=smin(d,smin(torus(r),dist, .2));\n    \n  return d;\n\n}\n\n\n\nvec4 trace(inout ray r) {\n\tr.c=vec4(1.0);\n\tfor(int i=0;i<32;i++){\n\t\tfloat d=dist(r);\n\t\tif(r.i>MAX_ITER_INTERNAL)break;\n\t\tr.p+=r.d*max(d,MIN_DIST);\n\t}\n\n    \n\treturn vec4(2.0/exp(abs(r.p.z)));\n}\n\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// particles ( --> by Andrew Baldwin)\n//////////////////////////////////////////////////////////////////////////////////////\n\nfloat particles(vec3 direction)\n{\n\tfloat help = 0.0;\n\tconst mat3 p = mat3(13.323122,23.5112,21.71123,21.1212,28.7312,11.9312,21.8112,14.7212,61.3934);\n\tvec2 uvx = vec2(direction.x,direction.z)-vec2(1.,iResolution.y/iResolution.x)*gl_FragCoord.xy / iResolution.xy;\n\n    float acc = 0.0;\n\tfloat DEPTH = direction.y*direction.y-0.3;\n\tfloat WIDTH =0.1;\n\tfloat SPEED = 0.09;\n\tfor (int i=0;i<10;i++) \n\t{\n\t\tfloat fi = float(i);\n\t\tvec2 q = uvx*(1.+fi*DEPTH);\n\t\tq += vec2(q.y*(WIDTH*mod(fi*7.238917,1.)-WIDTH*.5),SPEED*iTime/(1.+fi*DEPTH*.03));\n\t\tvec3 n = vec3(floor(q),31.189+fi);\n\t\tvec3 m = floor(n)*.00001 + fract(n);\n\t\tvec3 mp = (31415.9+m)/fract(p*m);\n\t\tvec3 r = fract(mp);\n\t\tvec2 s = abs(mod(q,1.)-.5+.9*r.xy-.45);\n\t\tfloat d = .7*max(s.x-s.y,s.x+s.y)+max(s.x,s.y)-.01;\n\t\tfloat edge = .04;\n\t\tacc += smoothstep(edge,-edge,d)*(r.x/1.0);\n\t\thelp = acc;\n\t}\n\treturn help;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\t\n    float t = iTime;\n\tfloat r = iResolution.x/iResolution.y;\n    \n\tvec2 m=vec2(\n\t\t(iMouse.x-iResolution.x/2.0)/iResolution.x*r,\n\t\t(iMouse.y-iResolution.y/2.0)/iResolution.y);\n\tvec2 s=vec2(\n\t\t(fragCoord.x-iResolution.x/2.0)/iResolution.x*r,\n\t\t(fragCoord.y-iResolution.y/2.0)/iResolution.y);\t    \n\t\n    vec3 l=vec3(0.0,0.0,0.0);\n\tvec3 tmp=vec3(2.0,3.0,2.0);//2.0\n\ttmp*=roty((PI*m.y)/4.0-PI/8.0);\n\ttmp*=rotz(2.0*PI*m.x);\n\n\tvec3 e=l+tmp;\n\tvec3 u=vec3(0.0,0.0,1.0);\n\tvec3 d=normalize(l-e);\n\tvec3 h=normalize(cross(d,u));\n\tvec3 v=normalize(cross(h,d));\n\tfloat f=0.75;\n\td*=rot(v,FOV*s.x);\n\td*=rot(h,FOV*s.y);\n\tray a=ray(vec4(0.0),e,d,vec3(0.0),t,0);\n\t\n    vec4 col = trace(a);\n    col.r -= 0.98;\n    col.g -= 0.48;\n    col.b -= .018;\n    \n    vec2 position = fragCoord.xy / iResolution.xy;   \n\tposition.y *=-1.0;\n\n\tcol *= 0.27 + 5.5 * position.x * position.y * ( 1.0 - position.x ) * ( -1.0 - position.y );\n    col.rgb = col.rgb + particles(a.c.xyz);\n  \n    vec2 rnd1  = vec2(12.9898,78.233);\n    float rnd2 = 43758.5453;\n    float c = fract(sin(dot(s.xy ,rnd1)) * rnd2+(iTime*0.5));\n    col.xyz = (col.xyz*0.85)+(col.xyz*0.12*vec3(c));    \n\n\tcol.xyz *= 1.1;\n\n    fragColor = col * col * 2.1;\n    \n}",
   "name": "Image",
   "description": "",
   "type": "image"
  }
 ]
}