{"Shader":{"ver":"0.1","info":{"id":"NstSDs","date":"1634176278","viewed":1357,"name":"Hyperbolic Group Limit Set","username":"neozhaoliang","description":"old version of https:\/\/www.shadertoy.com\/view\/WdGBz3","likes":81,"published":3,"flags":0,"usePreview":0,"tags":["3d","tiling","hyperbolic","limitset"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"id":37,"channel":0}],"code":"\/*\n=============================================\n\nLimit set of rank 4 hyperbolic Coxeter groups\n\n                                by Zhao Liang\n=============================================\n\nThis program shows the limit set of rank 4 hyperbolic Coxeter groups.\n\nSome math stuff:\n\nLet G be a hyperbolic Coxeter group and x a point inside the hyperbolic\nunit ball, the orbit S_x = { gx, g \\in G } has accumulation points\n(under Euclidean metric) only on the boundary of the space. We call the\naccumulation points of S_x the limit set of the group, it can be proved that\nthis set is independent of the way x is chosen, and it's the smallest\nclosed subset of the boundary that is invariant under the action of the group.\n\nThe Coxeter-Dynkin diagram of a rank 4 Coxeter group of string type has the form\n\n   A --- B --- C --- D\n      p     q     r\n\nHere A, B, D can be chosen as ususal Euclidean planes, C is a sphere orthongonal\nto the unit ball. This is taken from mla's notation, and as far as I know this\nhas long been used by users on fractalforums. (fragmentarium)\n\nIn this animation these points are colored in \"brass metal\".\n\n==========\n!important\n==========\n\nThe limit set is a closed set with no interior points, to show them we have\nto use an approximate procedure: we simply try to reflect a point p on the\nboundary to the fundamental domain up to a maximum steps, once failed then we\nthink p belongs to the limit set.\n\n**So the number MAX_REFLECTIONS is an important param**, if' its set to a high\nthreshold then little limit set will be shown, or if it's not high enough then\nthe boundary of the set will look too coarse, so beware of this.\n\nAs always, you can do whatever you want to this work.\n\nUpdate: thanks @mla for helping fix some bugs!\n*\/\n\/\/ ------------------------------------------\n\n\/\/ --------------------------\n\/\/ You can try more patterns like\n\/\/ (3, 7, 3), (4, 6, 3), (4, 4, 5), (5, 4, 4), (7, 3, 4), ..., etc. (5, 4, 4) is now\n\/\/ my favorite! set PQR below to see the result.\n\/\/ For large PQRs the limit set will become too small to be visible, you need to adjust\n\/\/ MAX_REFLECTIONS and tweak with the function chooseColor to get appealling results.\n\n#define inf        -1.\n\nconst vec3 PQR = vec3(3, 3, 7);\n\n\/\/ --------------------------\n\/\/ some global settings\n\n#define MAX_TRACE_STEPS  100\n#define MIN_TRACE_DIST   0.1\n#define MAX_TRACE_DIST   100.0\n#define PRECISION        0.0001\n#define AA               2\n#define MAX_REFLECTIONS  500\n#define PI               3.141592653\n\n\/\/ another pattern\n\/\/#define CHECKER1  vec3(0.196078, 0.33, 0.82)\n\/\/#define CHECKER2  vec3(0.75, 0.35, 0.196078)\n\n\/*\n#define CHECKER1  vec3(0.82, 0.196078, 0.33)\n#define CHECKER2  vec3(0.196078, 0.35, 0.92)\n#define MATERIAL  vec3(0.71, 0.65, 0.26)\n#define FUNDCOL   vec3(0., 0.82, .33)\n*\/\n\n\/\/ Shane's color scheme\n#define CHECKER1  vec3(0., 0., 0.05)\n#define CHECKER2  vec3(0.2)\n#define MATERIAL  vec3(10, 0.3, 0.2)\n#define FUNDCOL   vec3(.3, 1, 8)\n\n\n\/\/ used to highlight the limit set\n#define LighteningFactor 8.\n\/\/ --------------------------\n\nvec3 A, B, D;\nvec4 C;\nfloat orb;\n\nfloat dihedral(float x) { return x == inf ? 1. : cos(PI \/ x); }\n\n\/\/ minimal distance to the four mirrors\nfloat distABCD(vec3 p)\n{\n    float dA = abs(dot(p, A));\n    float dB = abs(dot(p, B));\n    float dD = abs(dot(p, D));\n    float dC = abs(length(p - C.xyz) - C.w);\n    return min(dA, min(dB, min(dC, dD)));\n}\n\n\/\/ try to reflect across a plane with normal n and update the counter\nbool try_reflect(inout vec3 p, vec3 n, inout int count)\n{\n    float k = dot(p, n);\n    \/\/ if we are already inside, do nothing and return true\n    if (k >= 0.0)\n    \treturn true;\n\n    p -= 2.0 * k * n;\n    count += 1;\n    return false;\n}\n\n\/\/ similar with above, instead this is a sphere inversion\nbool try_reflect(inout vec3 p, vec4 sphere, inout int count)\n{\n    vec3 cen = sphere.xyz;\n    float r = sphere.w;\n    vec3 q = p - cen;\n    float d2 = dot(q, q);\n    if (d2 == 0.0)\n    \treturn true;\n    float k = (r * r) \/ d2;\n    if (k < 1.0)\n    \treturn true;\n    p = k * q + cen;\n    count += 1;\n    orb *= k;\n    return false;\n}\n\n\/\/ sdf of the unit sphere at origin\nfloat sdSphere(vec3 p, float radius) { return length(p) - 1.0; }\n\n\/\/ sdf of the plane y=-1\nfloat sdPlane(vec3 p, float offset) { return p.y + 1.0; }\n\n\/\/ inverse stereo-graphic projection, from a point on plane y=-1 to\n\/\/ the unit ball centered at the origin\nvec3 planeToSphere(vec2 p)\n{\n    float pp = dot(p, p);\n    return vec3(2.0 * p, pp - 1.0).xzy \/ (1.0 + pp);\n}\n\n\/\/ iteratively reflect a point on the unit sphere into the fundamental cell\n\/\/ and update the counter along the way\nbool iterateSpherePoint(inout vec3 p, inout int count)\n{\n    bool inA, inB, inC, inD;\n    for(int iter=0; iter<MAX_REFLECTIONS; iter++)\n    {\n        inA = try_reflect(p, A, count);\n        inB = try_reflect(p, B, count);\n        inC = try_reflect(p, C, count);\n        inD = try_reflect(p, D, count);\n        p =  normalize(p);  \/\/ avoid floating error accumulation\n        if (inA && inB && inC && inD)\n            return true;\n    }\n    return false;\n}\n\n\/\/ colors for fundamental domain, checker pattern and limit set.\nvec3 chooseColor(bool found, int count)\n{\n    vec3 col;\n    if (found)\n    {\n        if (count == 0) return FUNDCOL;\n        else if (count >= 300) col = MATERIAL;\n        else\n            col = (count % 2 == 0) ? CHECKER1 : CHECKER2;\n\n    }\n    else\n        col = MATERIAL;\n\n    float t =  float(count) \/ float(MAX_REFLECTIONS);\n    col = mix(MATERIAL*LighteningFactor, col, 1. - t * smoothstep(0., 1., log(orb) \/ 32.));\n    return col;\n}\n\n\/\/ 2d rotation\nvec2 rot2d(vec2 p, float a) { return p * cos(a) + vec2(-p.y, p.x) * sin(a); }\n\nvec2 map(vec3 p)\n{\n    float d1 = sdSphere(p, 1.0);\n    float d2 = sdPlane(p, -1.0);\n    float id = (d1 < d2) ? 0.: 1.;\n    return vec2(min(d1, d2), id);\n}\n\n\/\/ standard scene normal\nvec3 getNormal(vec3 p)\n{\n    const vec2 e = vec2(0.001, 0.);\n    return normalize(\n        vec3(\n            map(p + e.xyy).x - map(p  - e.xyy).x,\n            map(p + e.yxy).x - map(p  - e.yxy).x,\n            map(p + e.yyx).x - map(p  - e.yyx).x\n            )\n        );\n}\n\n\/\/ get the signed distance to an object and object id\nvec2 raymarch(in vec3 ro, in vec3 rd)\n{\n    float t = MIN_TRACE_DIST;\n    vec2 h;\n    for(int i=0; i<MAX_TRACE_STEPS; i++)\n    {\n        h = map(ro + t * rd);\n        if (h.x < PRECISION * t)\n            return vec2(t, h.y);\n\n        if (t > MAX_TRACE_DIST)\n            break;\n\n        t += h.x;\n    }\n    return vec2(-1.0);\n}\n\nfloat calcOcclusion(vec3 p, vec3 n) {\n    float occ = 0.0;\n    float sca = 1.0;\n    for (int i = 0; i < 5; i++) {\n        float h = 0.01 + 0.15 * float(i) \/ 4.0;\n        float d = map(p + h * n).x;\n        occ += (h - d) * sca;\n        sca *= 0.75;\n    }\n    return clamp(1.0 - occ, 0.0, 1.0);\n}\n\n\nfloat softShadow(vec3 ro, vec3 rd, float tmin, float tmax, float k) {\n    float res = 1.0;\n    float t = tmin;\n    for (int i = 0; i < 12; i++) {\n        float h = map(ro + rd * t).x;\n        res = min(res, k * h \/ t);\n        t += clamp(h, 0.01, 0.2);\n        if (h < 0.0001 || t > tmax)\n            break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\n\nvec3 getColor(vec3 ro, vec3 rd, vec3 pos, vec3 nor, vec3 lp, vec3 basecol)\n{\n    vec3 col = vec3(0.0);\n    vec3 ld = lp - pos;\n    float lDist = max(length(ld), .001);\n    ld \/= lDist;\n    float ao = calcOcclusion(pos, nor);\n    float sh = softShadow(pos+0.001*nor, ld, 0.02, lDist, 32.);\n    float diff = clamp(dot(nor, ld), 0., 1.);\n    float atten = 2. \/ (1. + lDist * lDist * .01);\n\n    float spec = pow(max( dot( reflect(-ld, nor), -rd ), 0.0 ), 32.);\n    float fres = clamp(1.0 + dot(rd, nor), 0.0, 1.0);\n\n    col += basecol * diff;\n    col += basecol * vec3(1., 0.8, 0.3) * spec * 4.;\n    col += basecol * vec3(0.8) * fres * fres * 2.;\n    col *= ao * atten * sh;\n    col += basecol * clamp(0.8 + 0.2 * nor.y, 0., 1.) * 0.5;\n    return col;\n}\n\nmat3 sphMat(float theta, float phi)\n{\n    float cx = cos(theta);\n    float cy = cos(phi);\n    float sx = sin(theta);\n    float sy = sin(phi);\n    return mat3(cy, -sy * -sx, -sy * cx,\n                0,   cx,  sx,\n                sy,  cy * -sx, cy * cx);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 finalcol = vec3(0.);\n    int count = 0;\n    vec2 m = vec2(0.0, 1.0) + iMouse.xy \/ iResolution.xy;\n    float rx = m.y * PI;\n    float ry = -m.x * 2. * PI;\n    mat3 mouRot = sphMat(rx, ry);\n\n\/\/ ---------------------------------\n\/\/ initialize the mirrors\n\n    float P = PQR.x, Q = PQR.y, R = PQR.z;\n    float cp = dihedral(P), sp = sqrt(1. - cp*cp);\n    float cq = dihedral(Q);\n    float cr = dihedral(R);\n    A = vec3(0,  0,   1);\n    B = vec3(0, sp, -cp);\n    D = vec3(1,  0,   0);\n\n    float r = 1.0 \/ cr;\n    float k = r * cq \/ sp;\n    vec3 cen = vec3(1, k, 0);\n    C = vec4(cen, r) \/ sqrt(dot(cen, cen) - r * r);\n\n\/\/ -------------------------------------\n\/\/ view setttings\n\n    vec3 camera = vec3(3., 3.2, -3.);\n    vec3 lp = vec3(0.5, 3.0, -0.8); \/\/light position\n    camera.xz = rot2d(camera.xz, iTime*0.3);\n    vec3 lookat  = vec3(0., -0.5, 0.);\n    vec3 up = vec3(0., 1., 0.);\n    vec3 forward = normalize(lookat - camera);\n    vec3 right = normalize(cross(forward, up));\n    up = normalize(cross(right, forward));\n\n\/\/ -------------------------------------\n\/\/ antialiasing loop\n\n    for(int ii=0; ii<AA; ii++)\n    {\n        for(int jj=0; jj<AA; jj++)\n        {\n            vec2 o = vec2(float(ii), float(jj)) \/ float(AA);\n            vec2 uv = (2. * fragCoord + o - iResolution.xy) \/ iResolution.y;\n            vec3 rd = normalize(uv.x * right + uv.y * up + 3.0 * forward);\n            orb = 1.0;\n            \/\/ ---------------------------------\n            \/\/ hit the scene and get distance, object id\n\n            vec2 res = raymarch(camera, rd);\n            float t = res.x;\n            float id = res.y;\n            vec3 pos = camera + t * rd;\n\n            bool found;\n            float edist;\n            vec3 col;\n            \/\/ the sphere is hit\n            if (id == 0.)\n            {\n                vec3 nor = pos;\n                vec3 q = pos * mouRot;\n                found = iterateSpherePoint(q, count);\n                edist = distABCD(q);\n                vec3 basecol = chooseColor(found, count);\n\n                col = getColor(camera, rd, pos, nor, lp, basecol);\n            }\n            \/\/ the plane is hit\n            else if (id == 1.)\n            {\n                vec3 nor = vec3(0., 1., 0.);\n                vec3 q = planeToSphere(pos.xz);\n                q = q * mouRot;\n                found = iterateSpherePoint(q, count);\n                edist = distABCD(q);\n                vec3 basecol = chooseColor(found, count);\n                col = getColor(camera, rd, pos, nor, lp, basecol) * .9;\n            }\n            \/\/ draw the arcs\n            col = mix(col, vec3(0.), (1.0 - smoothstep(0., 0.005, edist))*0.85);\n            col = mix(col, vec3(0.), 1.0 - exp(-0.01*t*t));\n            finalcol += col;\n        }\n    }\n    finalcol \/= (float(AA) * float(AA));\n\n\/\/ ------------------------------------\n\/\/ a little post-processing\n\n    finalcol = mix(finalcol, 1. - exp(-finalcol), .35);\n    fragColor = vec4(sqrt(max(finalcol, 0.0)), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}}