{"Shader":{"ver":"0.1","info":{"id":"lts3RX","date":"1423979225","viewed":483,"name":"heart u 2015","username":"mattz","description":"<3","likes":13,"published":3,"flags":0,"usePreview":0,"tags":["happyvalentimes"],"hasliked":0},"renderpass":[{"inputs":[{"id":25,"src":"\/media\/a\/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","ctype":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"\nconst float dmax = 1000.0;\nconst int rayiter = 60;\n\nconst float wrap = 64.0;\n\nvec3 L = normalize(vec3(0.1, 1.0, 0.5));\n\nconst vec3 tgt = vec3(0.0);\nconst vec3 cpos = vec3(3.0, -1.0, 7.0);\n\nvec2 miss = vec2(1e5, -1.0);\n\n\nvec2 opU(vec2 a, vec2 b) {\n\treturn a.x < b.x ? a : b;\n}\n\n\nfloat sdRect(in vec3 pos, in vec2 rmin, in vec2 rmax) {\n    vec3 pc = vec3(clamp(pos.xy, rmin, rmax), 0);\n    return distance(pos, pc);                   \n}\n\nfloat sdDisc(in vec3 pos, in float r) {\n    float l = length(pos.xy);\n    vec3 pc = vec3(min(l, r)*pos.xy\/l, 0);\n    return distance(pos, pc);\n}\n\nfloat sdHeart(in vec3 pos, in float r, in float d) {\n    \n    pos.x = abs(pos.x);\n    pos.xy = sqrt(2.)*0.5*mat2(1.,-1.,1.,1.)*pos.xy;\n        \n\tfloat ds = sdRect(pos, vec2(-r+d), vec2(r,r-d));\n    float dc = sdDisc(pos-vec3(r, 0, 0),r-d);\n    \n\treturn min(ds, dc)-d;\n\n}\n\nfloat sdPlane(in vec3 pos, float t) {\n    return pos.x*cos(t) + pos.y*sin(t);\n}\n    \n\nvec2 map(in vec3 pos) {\n\t\n    const float r = 1.5;\n    const float d = .9;\n    const float x = .05;\n    \n\n    pos.y += 0.4;\n    \n    float t = 2.0*(iTime - 0.625*sin(2.*iTime));\n    \n    vec2 rval = vec2(1e6, -1);\n    \n    for (float i=0.; i<6.; i++) {              \n        \n        float h1 = sdHeart(pos, r-(2.*i)*x, d-(2.*i)*x);\n        float h2 = sdHeart(pos, r-(2.*i+1.)*x, d-(2.*i+1.)*x);\n        float p = i<4.?sdPlane(pos, t) : -1e6;\n\t\trval = opU(rval, vec2(max(max(h1, -h2), p), 0.99-0.08*i));\n       \tt *= -1.25;\n\n    }\n    \n    return rval;\n    \n}\n\nvec3 hue(float h) {\n\t\n\tvec3 c = mod(h*6.0 + vec3(2, 0, 4), 6.0);\n\treturn h >= 1.0 ? vec3(h-1.0) : clamp(min(c, -c+4.0), 0.0, 1.0);\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd, in float maxd )\n{\n\tfloat precis = 0.001;\n    float h=precis*2.0;\n    float t = 0.0;\n    float m = -1.0;\n    for( int i=0; i<rayiter; i++ )\n    {\n        if( abs(h)<precis||t>maxd ) continue;\/\/break;\n        t += h;\n\t    vec2 res = map( ro+rd*t );\n        h = res.x;\n\t    m = res.y;\n    }\n\tif (t > maxd) { m = -1.0; }\n    return vec2( t, m );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nvec3 shade( in vec3 ro, in vec3 rd ){\n    \n    vec3 c = vec3(0.);\n    float a = 1.;\n    bool hit = true;\n    \n    for (int i=0; i<2; ++i) {\n        \n        if (hit) {\n\n            vec2 tm = castRay(ro, rd, dmax);\n            vec3 b;\n            \n            if (tm.y >= 0.0) {\n                vec3 n = calcNormal(ro + tm.x * rd);\n                vec3 color = hue(tm.y) * 0.55 + 0.45;\n                vec3 diffamb = (0.8*dot(n,L)+0.2) * color;\n                vec3 R = 2.0*n*dot(n,L)-L;\n                float spec = 0.5*pow(clamp(-dot(R, rd), 0.0, 1.0), 20.0);\n                b = diffamb + spec;\n                ro = ro + tm.x * rd;\n                rd = reflect(rd, n);\n                ro += 1e-4*rd;\n                hit = true;\n            } else {\n                b = i>0 ? texture(iChannel0, rd).xyz*2.5 : vec3(1.);\n                hit = false;\n            }\n\n            c = mix(c, b, a);\n            a *= .3;\n            \n        }\n        \n    }\n    \n    return c;\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t\n\n\n\tconst float yscl = 720.0;\n\tconst float f = 900.0;\n\t\n\tvec2 uv = (fragCoord.xy - 0.5*iResolution.xy) * yscl \/ iResolution.y;\n\n\tvec3 up = vec3(0.0, 1.0, 0.0);\n\t\n\tvec3 rz = normalize(tgt - cpos);\n\tvec3 rx = normalize(cross(rz,up));\n\tvec3 ry = cross(rx,rz);\n\t\n\tfloat thetax = 0.0;\n\tfloat thetay = 0.0;\n\t\n\tif (max(iMouse.x, iMouse.y) > 20.0) { \n\t\tthetax = (iMouse.y - 0.5*iResolution.y) * 3.14\/iResolution.y; \n\t\tthetay = (iMouse.x - 0.5*iResolution.x) * -6.28\/iResolution.x; \n\t}\n\n\tfloat cx = cos(thetax);\n\tfloat sx = sin(thetax);\n\tfloat cy = cos(thetay);\n\tfloat sy = sin(thetay);\n\t\n\tmat3 Rx = mat3(1.0, 0.0, 0.0, \n\t\t\t\t   0.0, cx, sx,\n\t\t\t\t   0.0, -sx, cx);\n\t\n\tmat3 Ry = mat3(cy, 0.0, -sy,\n\t\t\t\t   0.0, 1.0, 0.0,\n\t\t\t\t   sy, 0.0, cy);\n\n\tmat3 R = mat3(rx,ry,rz);\n\tmat3 Rt = mat3(rx.x, ry.x, rz.x,\n\t\t\t\t   rx.y, ry.y, rz.y,\n\t\t\t\t   rx.z, ry.z, rz.z);\n\n\tvec3 rd = R*Rx*Ry*normalize(vec3(uv, f));\n\t\n\tvec3 ro = tgt + R*Rx*Ry*Rt*(cpos-tgt);\n    \n    L = R*Rx*Ry*Rt*L;\n\n\tfragColor.xyz = shade(ro, rd);\n\n\t\n}\n","name":"Image","description":"","type":"image"}]}}