{"Shader":{"ver":"0.1","info":{"id":"wdlGRN","date":"1545287412","viewed":692,"name":"Fast Elastic N-Ball Collision","username":"mathmasterzach","description":"Uses particle buckets for elastic collisions. Occasionally balls get stuck in each other when multiple collide at the same time. Click to zoom in; space to spawn a ball in the center with random velocity. Modify the ballRadius in the Common Tab.","likes":14,"published":3,"flags":48,"usePreview":0,"tags":["fast","balls","collisions","billiards","elastic","buckets"],"hasliked":0},"renderpass":[{"inputs":[{"id":259,"src":"\/media\/previz\/buffer02.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":37,"channel":0}],"code":"\/\/main rendering\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor=texture(iChannel0,fragCoord\/iResolution.xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":33,"src":"\/presets\/tex00.jpg","ctype":"keyboard","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":258,"src":"\/media\/previz\/buffer01.png","ctype":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":257,"channel":0}],"code":"\/\/controls moving the particles\nvec4 getParticle(vec2 p)\n{\n    float R=ceil(ballRadius);\n    vec4 np=vec4(-1.);\n    float s=.5;\n    for(float i=-R;i<=R;i++){\n    \tfor(float j=-R;j<=R;j++){\n            vec4 prt = texture(iChannel0,(p+vec2(j,i))\/iResolution.xy);\n            if(prt!=vec4(-1.)){\n                if( abs(prt.x+prt.z+j)<=s && abs(prt.y+prt.w+i)<=s ){\n                    np=vec4(prt.x+prt.z+j,prt.y+prt.w+i,prt.z,prt.w);\n            \t}\n            }\n            \n    \t}\n    }\n    return np;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord\/iResolution.xy;\n    if(map(fragCoord)<=0.){\n        fragColor = vec4(-1.);\n    }else if(iFrame<=5){\n        float A=10.*ceil(ballRadius);\n        if(int(fragCoord.x\/A)!=int((1.+fragCoord.x)\/A)&&\n           int(fragCoord.y\/A)!=int((1.+fragCoord.y)\/A)){\n            fragColor = 1.*vec4(0.,0.,2.*(hash22(fragCoord.xy+vec2(iDate.w))-.5));\n        }else{\n            fragColor = vec4(-1.);\n        }\n    }else if(int(fragCoord.x)==int(iResolution.x\/2.)&&\n             int(fragCoord.y)==int(iResolution.y\/2.)&&\n             texelFetch(iChannel1, ivec2(32,1),0 ).x==1.){\n        fragColor = 1.*vec4(0.,0.,2.*(hash22(fragCoord.xy+vec2(iDate.w))-.5));\n    }else{\n        vec4 p=getParticle(fragCoord);\n        if(p.x!=-1.){\n            \/\/handles ball with too much speed (rarely happens)\n            if(length(p.zw)>ceil(ballRadius)){\n\t\t\t\tp.zw*=ceil(ballRadius)\/length(p.zw);\n            }\n            \/\/friction goes here\n            \/\/p.zw*=.99;\n            fragColor = p;\n        }else{\n            fragColor = vec4(-1.);\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":258,"channel":0}],"code":"\/\/controls particle collisions\n\/\/there is no restitution in this sim\n\/\/sometimes clumps form as a result with multiple balls colliding at the same time\n\nvec4 getNewVelocity(vec4 mp, vec2 p)\n{\n    float R=ceil(ballRadius*2.);\n    vec2 nv=vec2(0.);\n    float collisionCount=0.;\n    vec4 nMP=mp;\n    \/\/check collisions with other balls\n    for(float i=-R;i<=R;i++){\n    \tfor(float j=-R;j<=R;j++){\n            if(i!=0.&&j!=0.){\n                vec4 prt = texture(iChannel0,(p+vec2(j,i))\/iResolution.xy);\n            \tif(prt.x!=-1.){\n                    vec2 collision=mp.xy-(prt.xy+vec2(j,i));\n                    \/\/vec2 collision1=mp.xy+mp.zw-(prt.xy+vec2(j,i)-prt.zw);\n                    float d=length(collision);\n                    float r=ballRadius*2.;\n                \tif(d<=r){\n                        collision = collision\/d;\n                        float a = dot(mp.zw,collision);\n                        float b = dot(prt.zw,collision);\n                        \n                        \/\/possible to add a fake restitution by applying collisions based on overlap\n                        \/*nv+=(mp.zw+((b-a)*collision))*((r+1.)-d);\n                        collisionCount+=((r+1.)-d);*\/\n                        \n                        \/\/basic 2D elastic collision equation\n                        nv+=(mp.zw+((b-a)*collision));\n                        collisionCount+=1.;\n                        \n                        \/\/here's basic 1D math which creates a lot of clumps\n                        \/\/Might be useful if that's what you want\n                        \/*nv+=prt.zw;\n                        collisionCount+=1.;*\/   \n            \t\t}\n            \t}\n            }     \n    \t}\n    }\n    \/\/check collisions with non-kinematic obstacles\n    float d=map(p+mp.xy);\n    if(d<=ballRadius){\n        vec2 normal=mapNormal(p+mp.xy);\n        nv+=reflect(mp.zw,normal);\n        collisionCount+=1.;\n    }\n    \/\/apply all collisions\n    if(collisionCount>0.){\n    \tnMP.zw=nv\/collisionCount;\n    }\n    return nMP;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord\/iResolution.xy;\n    if(iFrame<=5){\n        fragColor=texture(iChannel0,uv);\n    }else{\n\t\tvec4 mp=texture(iChannel0,uv);\n        if(mp.x!=-1.){\n            fragColor = getNewVelocity(mp,fragCoord);\n        }else{\n            fragColor = vec4(-1.);\n        }\n    }\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define HASHSCALE3 vec3(.1031, .1030, .0973)\n\nfloat ballRadius=2.*sqrt(2.);\/\/min of sqrt(2.), max is how big your computer can handle\n\n\/\/utility functions\n\n\/\/can be used for solid, non-kinematic obstacles\n\/\/unless you use a higher than 1. bouse value then the balls get stuck\nfloat map(vec2 p){\n    \/\/float d=length(p-vec2(100.,50.))-30.;\n    \/*d=min(d,p.x-5.);\n    d=min(d,165.-p.x);\n    d=min(d,p.y-5.);\n    d=min(d,90.-p.y);*\/\n\t\/\/return d;\n    return 100.;\n}\nvec2 mapNormal(vec2 p)\n{\n\tvec2 eps = vec2(0.0, 0.001);\n    vec2 normal = normalize(vec2(\n        map(p + eps.yx) - map(p - eps.yx),\n        map(p + eps.xy) - map(p - eps.xy)));\n    return normal;\n}\n\/\/from https:\/\/www.shadertoy.com\/view\/4djSRW\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":259,"src":"\/media\/previz\/buffer02.png","ctype":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":259,"channel":0}],"code":"\/\/main rendering with trails for balls\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord;\n    float d=100.;\n    float md=2.;\n    if(max(fract(fragCoord.x\/10.),fract(fragCoord.y\/10.))-.9>0.){\n    \tmd\/=1.5;\n    }\n    if(length(fragCoord-iMouse.xy)<200.&&iMouse.z > 0.){\n    \tp = iMouse.xy+(fragCoord-iMouse.xy)\/3.;\n        d=abs(length(fragCoord-iMouse.xy)-200.)-3.;\n        md=1.5;\n        if(max(fract(fragCoord.x\/30.),fract(fragCoord.y\/30.))-.9>0.){\n            md\/=1.5;\n        }\n    }\n    float R=ceil(ballRadius);\n    for(float i=-R;i<=R;i++){\n        for(float j=-R;j<=R;j++){\n            vec4 prt = texture(iChannel0,(floor(p)+vec2(j,i))\/iResolution.xy);\n            if(prt!=vec4(-1.)){\n                d=min(d,length(p-(floor(p)+vec2(j,i)+prt.xy))-ballRadius);\n            }\n\n        }\n    }\n    d=min(d,map(p));\n    float trail=.9;\n    float nc=trail*texture(iChannel1,fragCoord\/iResolution.xy).x+(1.-trail)*step(-d,0.)\/md;\n    fragColor=vec4(min(nc,step(-d,0.)\/md));\n}","name":"Buf C","description":"","type":"buffer"}]}}