{
 "ver": "0.1",
 "info": {
  "id": "7lccz2",
  "date": "0",
  "viewed": 0,
  "name": "Bloody JiPi",
  "description": "More of a remix of my last shader Msy3D1 than something new, but i thought the result came out pretty well and was worth sharing. Worth trying with a webcam too (change channel2, buf B).",
  "likes": 0,
  "published": "Private",
  "usePreview": 0,
  "tags": [
   "fluid",
   "blood",
   "waveequation",
   "jeanclaudevandamme"
  ],
  "hasliked": 0,
  "parentid": "4sKGWw",
  "parentname": "Bloody"
 },
 "renderpass": [
  {
   "inputs": [
    {
     "id": "4dXGR8",
     "filepath": "/media/previz/buffer00.png",
     "type": "buffer",
     "channel": 0,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    }
   ],
   "outputs": [
    {
     "id": "4dfGRr",
     "channel": 0
    }
   ],
   "code": "// remix of milky: https://www.shadertoy.com/view/Msy3D1\n// which is based in turn on https://www.shadertoy.com/view/Xsd3DB\n\n// turns out two sim steps per frame is important for motion to\n// get nice, fast waves and oscillation\n\n// this makes pretty terrible use of the simulation domain (comment\n// out RAYMARCH to see it) but i like how the result looks at this scale.\n// i should reduce the simulation domain size a la https://www.shadertoy.com/view/4dKGDw\n\n\n#define RAYMARCH\n#define HEIGHTMAPSCALE 90.\n#define MARCHSTEPS 8\n\nfloat hscale = 4.;\n\nvec3 cam( in vec2 p, out vec3 cameraPos );\n\nfloat h( vec3 p ) { return hscale*texture(iChannel0, p.xz/HEIGHTMAPSCALE + 0.5 ).x; }\n// boost the step size, we resort to the secant method if we overstep the surface\nfloat DE( vec3 p ) { return 1.2 * ( p.y - h(p) ); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy/iResolution.xy;\n    vec2 qq = q*2.-1.;\n    float eps = 0.1;\n    \n#ifdef RAYMARCH\n    \n    vec3 L = normalize(vec3(.3,.9,1.));\n    \n    // raymarch the milk surface\n    vec3 ro;\n    vec3 rd = cam( qq, ro );\n    float t = 0.;\n    float d = DE(ro+t*rd);\n    \n    for( int i = 0; i < MARCHSTEPS; i++ )\n    {\n        if( abs(d) < eps )\n            break;\n        \n        float dNext = DE(ro+(t+d)*rd);\n        \n        // detect surface crossing, if so use secant method\n        // https://www.shadertoy.com/view/Mdj3W3\n\t\tfloat dNext_over_d = dNext/d;\n        if( dNext_over_d < 0.0 )\n        {\n            // estimate position of crossing\n\t\t\td /= 1.0 - dNext_over_d;\n\t\t\tdNext = DE( ro+rd*(t+d) );\n        }\n        \n\t\tt += d;\n\t\td = dNext;\n    }\n    \n    // hit the BLOOD\n    {\n        vec3 p = ro+t*rd;\n        \n        // finite difference normal\n        float h0 = h(p);\n        vec2 dd = vec2(0.01,0.);\n        vec3 n = normalize(vec3( h0-h(p + dd.xyy), dd.x, h0-h(p + dd.yyx) ));\n        \n        // diffuse / subtle subsurface\n        float ndotL = clamp(dot(n,L),0.,1.);\n        float dif = 1.52*(0.7+0.3*ndotL);\n        float ao = mix( 0.6, .64, smoothstep(0.,1.,(h0+1.5)/6.));\n        vec3 difCol = vec3(0.82,0.,0.);\n        fragColor.xyz = difCol*(dif)*ao;\n        \n        // specular\n        float s = .6*pow( clamp( dot( L, reflect( rd, n ) ), 0., 1. ), 4000. );\n        fragColor.xyz += s;\n    }\n    \n\t// vignette (borrowed from donfabio's Blue Spiral)\n\tvec2 uv =  q.xy-0.5;\n\tfloat distSqr = dot(uv, uv);\n\tfragColor.xyz *= 1.0 - 1.*distSqr;\n    \n#else\n    float sh = 1. - texture(iChannel0, q).x;\n    vec3 c =\n       vec3(exp(pow(sh-.25,2.)*-5.),\n            exp(pow(sh-.4,2.)*-5.),\n            exp(pow(sh-.7,2.)*-20.));\n    fragColor = vec4(c,1.);\n#endif\n}\n\nvec3 cam( in vec2 p, out vec3 cameraPos )\n{\n    // camera orbits around origin\n    float camRadius = 50.;\n\tfloat theta = -3.141592653/2.;\n    float xoff = camRadius * cos(theta);\n    float zoff = camRadius * sin(theta);\n    cameraPos = vec3(xoff,30.,zoff);\n     \n    // camera target\n    vec3 target = vec3(0.,0.,-30.);\n     \n    // camera frame\n    vec3 fo = normalize(target-cameraPos);\n    vec3 ri = normalize(vec3(fo.z, 0., -fo.x ));\n    vec3 up = normalize(cross(fo,ri));\n     \n    // multiplier to emulate a fov control\n    float fov = .5;\n\t\n    // ray direction\n    vec3 rayDir = normalize(fo + fov*p.x*ri + fov*p.y*up);\n\t\n\treturn rayDir;\n}\n\n",
   "name": "Image",
   "description": "",
   "type": "image"
  },
  {
   "inputs": [
    {
     "id": "4dXGR8",
     "filepath": "/media/previz/buffer00.png",
     "type": "buffer",
     "channel": 0,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    },
    {
     "id": "XsXGR8",
     "filepath": "/media/previz/buffer01.png",
     "type": "buffer",
     "channel": 1,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    }
   ],
   "outputs": [
    {
     "id": "4dXGR8",
     "channel": 0
    }
   ],
   "code": "// Originally from tomkh's wave equation solver\n// https://www.shadertoy.com/view/Xsd3DB\n//\n\n#define HEIGHTMAPSCALE 90.0\n\nvec3 cam( in vec2 p, out vec3 cameraPos );\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 e = vec3(vec2(1.)/iResolution.xy,0.);\n    vec2 q = fragCoord.xy/iResolution.xy;\n\n    float p11 = texture(iChannel0, q).x;\n    float p10 = texture(iChannel1, q-e.zy).x;\n    float p01 = texture(iChannel1, q-e.xz).x;\n    float p21 = texture(iChannel1, q+e.xz).x;\n    float p12 = texture(iChannel1, q+e.zy).x;\n\n    // accel on fluid surface\n    float d = 0.;\n\n    if( iMouse.z > 0. )\n    {\n        vec3 ro;\n        vec3 rd = cam( 2.*iMouse.xy/iResolution.xy - 1., ro );\n        if( rd.y < 0. )\n        {\n            vec3 mp = ro + rd * ro.y/-rd.y;\n            vec2 uv = mp.xz/HEIGHTMAPSCALE + 0.5;\n            float screenscale = iResolution.x/640.;\n            d += .06*smoothstep(20.*screenscale,5.*screenscale,length(uv*iResolution.xy - fragCoord.xy));\n        }\n    }\n    \n    // force from video sampled by buffer B to avoid vid sync problems\n    d += texture(iChannel1, q).y;\n\n    // The actual propagation:\n    d += -(p11-.5)*2. + (p10 + p01 + p21 + p12 - 2.);\n    d *= .97; // damping\n    if( iFrame == 0 ) d = 0.;\n    d = d*.5 + .5;\n\n    fragColor = vec4(d, 0.0, 0.0, 0.0);\n}\n\nvec3 cam( in vec2 p, out vec3 cameraPos )\n{\n    // camera orbits around origin\n    float camRadius = 50.;\n\tfloat theta = -3.141592653/2.;\n    float xoff = camRadius * cos(theta);\n    float zoff = camRadius * sin(theta);\n    cameraPos = vec3(xoff,30.,zoff);\n     \n    // camera target\n    vec3 target = vec3(0.,0.,-30.);\n     \n    // camera frame\n    vec3 fo = normalize(target-cameraPos);\n    vec3 ri = normalize(vec3(fo.z, 0., -fo.x ));\n    vec3 up = normalize(cross(fo,ri));\n     \n    // multiplier to emulate a fov control\n    float fov = .5;\n\t\n    // ray direction\n    vec3 rayDir = normalize(fo + fov*p.x*ri + fov*p.y*up);\n\t\n\treturn rayDir;\n}\n",
   "name": "Buffer A",
   "description": "",
   "type": "buffer"
  },
  {
   "inputs": [
    {
     "id": "XdfGRr",
     "filepath": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm",
     "type": "video",
     "channel": 2,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    },
    {
     "id": "4dXGR8",
     "filepath": "/media/previz/buffer00.png",
     "type": "buffer",
     "channel": 1,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    },
    {
     "id": "XsXGR8",
     "filepath": "/media/previz/buffer01.png",
     "type": "buffer",
     "channel": 0,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    }
   ],
   "outputs": [
    {
     "id": "XsXGR8",
     "channel": 0
    }
   ],
   "code": "// Originally from tomkh's wave equation solver\n// https://www.shadertoy.com/view/Xsd3DB\n//\n\n#define HEIGHTMAPSCALE 90.0\n\nvec3 cam( in vec2 p, out vec3 cameraPos );\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 e = vec3(vec2(1.)/iResolution.xy,0.);\n    vec2 q = fragCoord.xy/iResolution.xy;\n\n    float p11 = texture(iChannel0, q).x;\n\n    float p10 = texture(iChannel1, q-e.zy).x;\n    float p01 = texture(iChannel1, q-e.xz).x;\n    float p21 = texture(iChannel1, q+e.xz).x;\n    float p12 = texture(iChannel1, q+e.zy).x;\n\n    // accel on fluid surface\n    float d = 0.;\n\n    if( iMouse.z > 0. )\n    {\n        vec3 ro;\n        vec3 rd = cam( 2.*iMouse.xy/iResolution.xy - 1., ro );\n        if( rd.y < 0. )\n        {\n            vec3 mp = ro + rd * ro.y/-rd.y;\n            vec2 uv = mp.xz/HEIGHTMAPSCALE + 0.5;\n            float screenscale = iResolution.x/640.;\n            d += .06*smoothstep(20.*screenscale,5.*screenscale,length(uv*iResolution.xy - fragCoord.xy));\n        }\n    }\n    \n    // sample video\n    vec2 vuv = q*3.-vec2(1.,.17);\n    float d_vid = 0.;\n    //if( vuv.x > 0. && vuv.x < 1. && vuv.y > 0. && vuv.y < 0. )\n\t    d_vid = 0.106*(texture(iChannel2,vuv).x-0.7);\n    d += d_vid;\n    \n    // The actual propagation:\n    d += -(p11-.5)*2. + (p10 + p01 + p21 + p12 - 2.);\n    d *= .97; // damping\n    if( iFrame == 0 ) d = 0.;\n    d = d*.5 + .5;\n\n    fragColor = vec4(d, d_vid, 0.0, 0.0);\n}\n\nvec3 cam( in vec2 p, out vec3 cameraPos )\n{\n    // camera orbits around origin\n    float camRadius = 50.;\n\tfloat theta = -3.141592653/2.;\n    float xoff = camRadius * cos(theta);\n    float zoff = camRadius * sin(theta);\n    cameraPos = vec3(xoff,30.,zoff);\n     \n    // camera target\n    vec3 target = vec3(0.,0.,-30.);\n     \n    // camera frame\n    vec3 fo = normalize(target-cameraPos);\n    vec3 ri = normalize(vec3(fo.z, 0., -fo.x ));\n    vec3 up = normalize(cross(fo,ri));\n     \n    // multiplier to emulate a fov control\n    float fov = .5;\n\t\n    // ray direction\n    vec3 rayDir = normalize(fo + fov*p.x*ri + fov*p.y*up);\n\t\n\treturn rayDir;\n}\n",
   "name": "Buffer B",
   "description": "",
   "type": "buffer"
  }
 ]
}