{
 "ver": "0.1",
 "info": {
  "id": "stscWX",
  "date": "0",
  "viewed": 0,
  "name": "SunMoonCloud Neu",
  "description": "Rebuild - unknown Char<chter",
  "likes": 0,
  "published": "Private",
  "usePreview": 0,
  "tags": [
   "sun"
  ],
  "hasliked": 0,
  "parentid": "",
  "parentname": ""
 },
 "renderpass": [
  {
   "inputs": [
    {
     "id": "4sfGRn",
     "filepath": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg",
     "type": "texture",
     "channel": 1,
     "sampler": {
      "filter": "mipmap",
      "wrap": "repeat",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    },
    {
     "id": "4dXGRr",
     "filepath": "/presets/tex00.jpg",
     "type": "keyboard",
     "channel": 0,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    }
   ],
   "outputs": [
    {
     "id": "4dfGRr",
     "channel": 0
    }
   ],
   "code": "/*\n * The sun, the earth and the moon by batersy\n * Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n * Contact: seplanely@gmail.com\n */\n\n// update history\n// 22/03/16: Add movement to sun and moon, and moon phase in a month, \n// atmosphere reference on https://www.shadertoy.com/view/tdSXzD\n// 22/03/31: Add simple cloud and repost, \n// reference on https://www.shadertoy.com/view/MdGfzh\n// will keep on updating new things here\n\n// Camera config\nconst float fov = tan(PI / 3.);\nconst float cameraheight = 00.;\n\n// Ray Marching config\nconst int steps = 16;\nconst int stepss = 6;\nconst int stepsCloud = 18;\nconst int stepssCloud = 6;\n\n// sun and moon cycle\nconst float dayTime = 24.;  // how many time in a day\nconst float monthDay = 30.;  // how many days in a month\n// earth latitude, range PI / 2  PI / 2\nfloat latitude = 35. / 180. * PI;\n\n// circle light smoothstep\nfloat sunSmooth = .02;\nfloat moonSmooth = .2;\n// planet size zoom\nfloat sunZoom = 20. / fov;\nfloat moonZoom = 30. / fov;\n\n// cloud config\nconst float cloudCoverage = .6;  //cloud generate quantity\nconst float cloudPadding = .0;  //cloud thickness padding\nconst float segmaMax = .004;  // scattering coefficient in max cloud density\n// 0: Basic scatering/transmittance integration\n// 1: Improved Scattering integration by SebH, see https://www.shadertoy.com/view/XlBSRz\n// 2: Improved Scattering integration with ambient light, see https://www.shadertoy.com/view/MdGfzh\n#define CLOUD_RENDER_TYPE 2\n// 0: fixed step shadow\n// 1: increased step shadow\n#define CLOUD_SHADOW_RENDER_TYPE 1\n\nvec3 sphTexureMap(in vec3 pos, in vec4 sph) {\n    float theta = asin(pos.y / sph.w);\n    float phi = asin(pos.x / (sph.w * cos(theta)));\n    vec2 uv = vec2(phi, theta);\n    uv = (uv + PI / 2.) / PI;\n    uv.x /= 2.;\n    uv.x = mod(uv.x + 0.26, 1.);\n    vec3 col = texture(iChannel1, uv).rgb;\n    return col;\n}\n\nfloat heightGradient(float cloudType, float h) {\n    float center = .1 + cloudType * .4;\n    float range = .05 + cloudType * .35;\n    float solid = .02 + cloudType * .28;\n    float gradient = smoothstep(center - range, center - solid, h);\n    gradient -= smoothstep(center + range, center + solid, h);\n    return clamp(gradient, 0., 1.);\n}\n\nfloat cloudNoise(vec2 p) {\n    float perlin = perlinNoiseFbm2D(p, 2, 4., cloudCoverage);\n    float voronoi = voronoiNoiseFbm2D(p, 2, 12.);\n    float perlinWorley = remap(perlin, voronoi, 1., 0., 1.);\n    float baseShape = perlinWorley;\n#if 0\n    float highFreq =  0.625 * voronoiNoise2D(p, 4.) +\n        \t\t0.250 * voronoiNoise2D(p, 8.) +\n        \t\t0.125 * voronoiNoise2D(p, 16.);\n    baseShape = remap(perlinWorley, -highFreq, 1., 0., 1.);\n#endif\n    return baseShape;\n}\n\nfloat cloudDensity(vec3 p) {\n    vec2 samplePos = p.xz / 10000.;\n    samplePos.x += iTime / 5.;\n    samplePos.y += iTime / 20.;\n    samplePos += clamp((p.z - p.x) / p.y, 0., 1000.);\n    float heightTop = cloudNoise(samplePos) + cloudPadding;\n    float heightBottom = (1.-heightTop) * .2;\n    float baseCloud = 0.;\n    float heightFraction = getHeightFraction(p);\n    if(heightFraction < heightTop && heightFraction > heightBottom) baseCloud = .3;\n    //return density;\n    /*float Rc = Re + cloudHeightTop;\n    float horizon = sqrt(Rc * Rc - Re * Re) * 2.;\n    vec2 samplePos = p.xz / 30000.;\n    samplePos.x += iTime / 50.;\n    samplePos.y += iTime / 200.;\n    vec3 tex = texture(iChannel2, samplePos).rgb;\n    float baseCloud = tex.r;*/\n\n    /*samplePos /= 4.;\n    vec3 tex = texture(iChannel2, samplePos).rgb;\n    float cloudType = tex.g;\n    float heightFraction = getHeightFraction(p);\n    float gradient = heightGradient(cloudType, heightFraction);\n    //baseCloud *= gradient;*/\n    return baseCloud;\n}\n\nfloat cloudEnergy(float opticalDepth) {\n    float beer = exp(-opticalDepth);\n    float powder = .5;\n    //float powder = 1. - beer * beer;\n    return 2. * beer * powder;\n}\n\nvec3 volumetricAtmosphereShadow(in vec3 ro, in vec3 sd) {\n    float opticalDepthLightR = 0., opticalDepthLightM = 0.;\n    float Ls = rayAtmosphereIntersect(ro, sd);\n    if (Ls > 0.) {\n        float dls = Ls / float(stepss);\n        vec3 samplePositionLight = ro + 0.5 * dls * sd;\n        for (int j = 0; j < stepss; ++j) {\n            float heightLight = getHeight(samplePositionLight);\n            opticalDepthLightR += exp(-heightLight / Hr) * dls;\n            opticalDepthLightM += exp(-heightLight / Hm) * dls;\n            samplePositionLight += dls * sd;\n        }\n    }\n    return betaR * opticalDepthLightR + betaM * 1.1 * opticalDepthLightM;\n}\n\nvec3 rayMarchingAtmosphere(vec3 ro, vec3 rd, vec3 sd, float I, out vec3 transmittance) {\n    rd.y = abs(rd.y);\n    transmittance = vec3(1);\n\tfloat L = rayAtmosphereIntersect(ro, rd);\n    float mu = dot(rd, sd); // mu in the paper which is the cosine of the angle between the sun direction and the ray direction \n    float phaseR = 3. / (16. * PI) * (1. + mu * mu);\n    float phaseM = 3. / (8. * PI) * ((1. - g2) * (1. + mu * mu)) / ((2. + g2) * pow(1. + g2 - 2. * g * mu, 1.5));\n    vec3 sumR = vec3(0), sumM = vec3(0); // mie and rayleigh contribution\n    \n\tfloat dl = L / float(steps);\n    vec3 samplePosition = ro + 0.5 * dl * rd;\n\tfor (int i = 0; i < steps; ++i) {\n        float height = getHeight(samplePosition);\n        // compute optical depth for light\n        float hr = exp(-height / Hr) * dl;\n        float hm = exp(-height / Hm) * dl;\n\n        vec3 shadow = exp(-volumetricAtmosphereShadow(samplePosition, sd));\n        transmittance *= exp(-(betaR * hr + betaM * 1.1 * hm));\n        sumR += transmittance * shadow * hr; \n        sumM += transmittance * shadow * hm;\n        samplePosition += dl * rd;\n\t}\n\n\treturn (sumR * betaR * phaseR + sumM * betaM * phaseM) * I;\n}\n\nfloat volumetricShadow(in vec3 ro, in vec3 sd) {\n    float opticalDepthLight = 0.;\n#if CLOUD_SHADOW_RENDER_TYPE==0\n    vec2 intersectPosLight = rayCloudIntersect(ro, sd);\n    float dl = intersectPosLight.y / float(stepssCloud);\n    vec3 pos = ro + 0.5 * dl * sd;\n    for (int i = 0; i < stepssCloud; ++i) {\n        opticalDepthLight += segmaMax * cloudDensity(pos) * dl;\n        pos += dl * sd;\n    }\n#endif\n#if CLOUD_SHADOW_RENDER_TYPE==1\n    float dl = (cloudHeightTop - cloudHeightBottom) / 20.;\n    float d = dl * .5;\n    for(int i=0; i<stepssCloud; ++i) {\n        vec3 pos = ro + sd * d;\n        float norY = clamp(getHeightFraction(pos), 0., 1.);\n        if(norY > 1.) return opticalDepthLight;\n        opticalDepthLight += segmaMax * cloudDensity(pos) * dl;\n        dl *= 1.3;\n        d += dl;\n    }\n#endif\n    return opticalDepthLight;\n}\n\nvec4 rayMarchingCloud(vec3 ro, vec3 rd, vec3 sd, vec3 light) {\n    rd.y = abs(rd.y);\n    vec2 intersectPos = rayCloudIntersect(ro, rd);\n    if(intersectPos.x > cloudMaxDistance) return vec4(0,0,0,1);\n    vec3 scatteredLight = vec3(0);\n    float transmittance = 1.;\n    float mu = dot(rd, sd);\n    float phase = mix(HenyeyGreenstein(mu, cloudForwardScatteringG), \n        HenyeyGreenstein(mu, cloudBackwardScatteringG), cloudScatteringLerp);\n\n\tfloat dl = (intersectPos.y - intersectPos.x) / float(stepsCloud);\n    float h = hash13(rd + fract(iTime) );\n    // prevent from banding\n    intersectPos.x -= dl * h;\n    vec3 samplePosition = ro + (intersectPos.x + 0.5 * dl) * rd;\n\tfor (int i = 0; i < stepsCloud; ++i) {\n        float sigmaS = segmaMax * cloudDensity(samplePosition);\n        if(sigmaS > 0.) {\n            float sigmaE = sigmaS;\n            float tran = cloudEnergy(sigmaE * dl);\n            float shadow = cloudEnergy(volumetricShadow(samplePosition, sd));\n#if CLOUD_RENDER_TYPE==0\n            scatteredLight += light * sigmaS * phase * shadow * transmittance * dl;\n            transmittance *= tran;\n#endif\n#if CLOUD_RENDER_TYPE==1\n            vec3 S = light * sigmaS * phase * shadow;\n            vec3 Sint = S * (1. - tran) / sigmaE;\n            scatteredLight += transmittance * Sint;\n            transmittance *= tran;\n#endif\n#if CLOUD_RENDER_TYPE==2\n            float norY = clamp(getHeightFraction(samplePosition), 0., 1.);\n            vec3 ambientLight = mix( CLOUDS_AMBIENT_COLOR_BOTTOM, CLOUDS_AMBIENT_COLOR_TOP, norY );\n            vec3 S = ambientLight * light.b / Is * sigmaS  + light * sigmaS * phase * shadow;\n            vec3 Sint = S * (1. - tran) / sigmaE;\n            scatteredLight += transmittance * Sint;\n            transmittance *= tran;\n#endif\n        }\n        \n        if(transmittance < cloudMinTransmittance) break;\n        samplePosition += dl * rd;\n\t}\n    \n\treturn vec4(scatteredLight, transmittance);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 p = (2.0*fragCoord.xy-iResolution.xy) / iResolution.y;\n    p.xy *= fov;\n    vec3 color = vec3(0);\n    \n    // camera position, earth center as coordinate center\n\tvec3 ro = vec3(0, cameraheight + Re, 0);\n    // look at position\n    vec3 ta, direction;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    if (mouse.xy == vec2(0)) mouse.xy = vec2(.5);\n    float leftPressed = texelFetch(iChannel0, ivec2(KEY_LEFT,0),0 ).x;\n    float rightPressed = texelFetch(iChannel0, ivec2(KEY_RIGHT,0),0 ).x;\n    float upPressed = texelFetch(iChannel0, ivec2(KEY_UP,0),0 ).x;\n    float downPressed = texelFetch(iChannel0, ivec2(KEY_DOWN,0),0 ).x;\n    if(leftPressed > 0. || mouse.x < .3)\n        direction = taEast;\n    else if(rightPressed > 0. || mouse.x > .7)\n        direction = taWest;\n    else if(upPressed > 0. || mouse.y > .7)\n        direction = taUp;\n    else if(downPressed > 0. || mouse.y < .3)\n        direction = taNorth;\n    else\n        direction = taSouth;\n    ta = ro + direction;\n\n    // primary ray\n    mat3 camera = getCamera(ro, ta);\n    mat3 cameraInverse = transpose(camera);\n    vec3 rd = camera * normalize(vec3(p.xy, -1.));\n    \n    // used to calculate sunlight of cloud\n    vec3 atmosphereTrans;\n    float phaseS = mod(iTime * TWO_PI / dayTime, TWO_PI);\n    // sun direction\n    vec3 sdCenter = vec3(-cos(phaseS), sin(phaseS) * cos(latitude), sin(phaseS) * -sin(latitude));\n    vec3 sdCamera = normalize(sdCenter * Lse - ro);\n    // consider sunlight has different intensity in a day\n    float sunIntensity = Is * (abs(sin(phaseS)) + .0);\n    if(phaseS < PI) color += rayMarchingAtmosphere(ro, rd, sdCamera, sunIntensity, atmosphereTrans);\n    // paint sun\n    vec3 inverseSunPos = cameraInverse * sdCamera;\n    float sunScreenRadius = Rs / disGroundToPlanet(Re, Lse, phaseS) * sunZoom;\n    if(phaseS < PI && sdCamera.y > 0.05 && rd.y > 0.05) {\n        float sunOffset = sunScreenRadius / length(p + inverseSunPos.xy / inverseSunPos.z);\n        color += atmosphereTrans * smoothstep(sunSmooth, 1., sunOffset);\n    }\n\n    // moon direction simplified being opposite to sun\n    float phaseM = mod(phaseS + PI, TWO_PI);\n    vec3 mdCenter = -sdCenter;\n    vec3 mdCamera = normalize(mdCenter * Lem - ro);\n    float moonDay = mod(iTime / dayTime, monthDay);\n    float phaseDifference = moonDay * TWO_PI / monthDay;\n    float moonIntensity = Im * abs(sin(phaseM)) * (1. + sin(phaseDifference));\n    if(phaseM < PI) color += rayMarchingAtmosphere(ro, rd, mdCamera, moonIntensity, atmosphereTrans);\n    vec3 inverseMoonPos = cameraInverse * rd;\n    vec2 inverseMoonPos2D = -inverseMoonPos.xy / inverseMoonPos.z;\n    vec3 inverseMoonPosCenter = cameraInverse * mdCamera;\n    vec2 inverseMoonPosCenter2D = -inverseMoonPosCenter.xy / inverseMoonPosCenter.z;\n\n    // moon phase and shader\n    vec3 moonro = vec3(0);\n    vec2 moonScreenPos = inverseMoonPos2D - inverseMoonPosCenter2D;\n    vec3 moonrd = camera * normalize(vec3(moonScreenPos, -1.));\n    float moonDis = disGroundToPlanet(Re, Lem, phaseM);\n    vec4 moonSphere = vec4(direction * moonDis, Rm * moonZoom);\n    float t = raySphereIntersect(moonro, moonrd, moonSphere);\n    if(phaseM < PI && mdCamera.y > 0.05 && rd.y > 0.05 && t > 0.) {\n        // ray tracing\n        vec3 pos = moonro + t*moonrd;\n        color += (sphTexureMap(pos, moonSphere) + .4);\n        vec3 nor = sphNormal( pos, moonSphere);\n        vec3 msd = vec3(cos(phaseDifference), 0, sin(phaseDifference));\n        float shadow = clamp( dot(nor, msd), 0.0, 1.0 );\n        color *= shadow;\n    }\n    \n    // because a part of atmosphere under the cloud\n    atmosphereTrans = .1 + .9 * atmosphereTrans;\n    if(phaseS < PI && rd.y > 0.) {\n        vec4 cloud = rayMarchingCloud(ro, rd, sdCamera, sunIntensity * atmosphereTrans);\n        color = cloud.rgb + color.rgb * cloud.a;\n    } else if(phaseS > PI && rd.y > 0.) {\n        vec4 cloud = rayMarchingCloud(ro, rd, mdCamera, moonIntensity * atmosphereTrans);\n        color = cloud.rgb + color.rgb * cloud.a;\n    }\n\tfragColor = vec4(pow(color, vec3(1.0/2.2)), 1.);\n}",
   "name": "Image",
   "description": "",
   "type": "image"
  },
  {
   "inputs": [],
   "outputs": [],
   "code": "// Environment\nconst float Re = 6360e3; //planet radius //6360e3 actual 6371km\nconst float Ra = 6380e3; //atmosphere radius //6380e3 troposphere 8 to 14.5km\nconst float Rm = 1738e3;  // moon radius\nconst float Rs = 695500e3;  // sun radius\nconst float Lse = 149600000e3;  // distance from sun to earth\nconst float Lem = 384400e3;  // distance from earth to moon\nconst float Is = 20.; //sun light power, 10.0 is normal\nconst float Im = .5; //moon light power\nconst float g = 0.5; //light concentration .76 //.45 //.6  .45 is normaL\nconst float g2 = g * g;\n\n// cloud\nconst float cloudHeightTop = 40e2;\nconst float cloudHeightBottom = 15e2;\nconst float cloudForwardScatteringG = .8;\nconst float cloudBackwardScatteringG = -.2;\nconst float cloudScatteringLerp = .5;\nconst float cloudMinTransmittance = .1;\nconst float cloudMaxDistance = 30e3;  //max render distance\n#define CLOUDS_AMBIENT_COLOR_TOP (vec3(149., 167., 200.)*1.5/255.)\n#define CLOUDS_AMBIENT_COLOR_BOTTOM (vec3(39., 67., 87.)*1.5/255.)\n\nconst float Hr = 8e3; //Rayleigh scattering top //8e3\nconst float Hm = 1.2e3; //Mie scattering top //1.3e3\n\nvec3 betaM = vec3(21e-6); //normal mie // vec3(21e-6)\n//vec3 bM = vec3(50e-6); //high mie\n\n//Rayleigh scattering (sky color, atmospheric up to 8km)\nvec3 betaR = vec3(3.8e-6, 23.5e-6, 50.1e-6);\n//vec3 betaR = vec3(5.8e-6, 13.5e-6, 33.1e-6); //normal earth\n//vec3 bR = vec3(5.8e-6, 33.1e-6, 13.5e-6); //purple\n//vec3 bR = vec3( 63.5e-6, 13.1e-6, 50.8e-6 ); //green\n//vec3 bR = vec3( 13.5e-6, 23.1e-6, 115.8e-6 ); //yellow\n//vec3 bR = vec3( 5.5e-6, 15.1e-6, 355.8e-6 ); //yeellow\n//vec3 bR = vec3(3.5e-6, 333.1e-6, 235.8e-6 ); //red-purple\n\nconst float PI = 3.14159265358979323846;\nconst float TWO_PI = 6.28318530717958647692;\n\n// keyboard control\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n// East direction\nvec3 taEast = vec3(-1,0,0);\n// West direction\nvec3 taWest = vec3(1,0,0);\n// North direction\nvec3 taNorth = vec3(0,0,1);\n// South direction\nvec3 taSouth = vec3(0,0,-1);\n// Upward direction\nvec3 taUp = vec3(0,1,0);\n\n// noise control\nconst mat2 m2 = mat2(  0.80,  0.60,\n                      -0.60,  0.80 );\nconst float perlinRange = sqrt(2.) / 2.;\nconst float coverage = 1.;\nconst int surround = 2;\n\nmat3 getCamera( in vec3 ro, in vec3 ta) {\n    vec3 cw = normalize(ro - ta);\n    vec3 up = vec3(0,1,0);\n    if(abs(cw) == up)\n        up = vec3(0,0,1);\n    vec3 cu = normalize(cross(up, cw));\n    vec3 cv = normalize(cross(cw, cu));\n    return mat3(cu, cv, cw);\n}\n\nfloat remap(const float originalValue, const float originalMin, const float originalMax, const float newMin, const float newMax) {\n\treturn newMin + (((originalValue - originalMin) / (originalMax - originalMin)) * (newMax - newMin));\n}\n\nfloat HenyeyGreenstein(float costheta, float g) {\n\tconst float k = 0.079577471546;  // 1/(4pi)\n    float g2 = g * g;\n\treturn k*(1.0-g2)/(pow(1.0+g2-2.0*g*costheta, 1.5));\n}\n\nfloat hash(vec2 p) {\n    p  = 100.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return -1.0+2.0*fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat hash13(vec3 p3) {\n    p3  = fract(p3 * 1031.1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat perlinNoise2D( in vec2 p) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash(i + vec2(0.0,0.0)), \n                     hash(i + vec2(1.0,0.0)), u.x),\n                mix( hash(i + vec2(0.0,1.0)), \n                     hash(i + vec2(1.0,1.0)), u.x), u.y);\n}\n\nfloat perlinNoiseFbm2D( vec2 p, const int octaves, float frequency, float coverage ) {\n    p *= frequency;\n    float G = 0.5;\n    float f = 1.0;\n    float a = .5;\n    float t = 0.0;\n\n    for( int i=0; i<octaves; i++ ) {\n        t += a*perlinNoise2D( m2 * f * p);\n        f *= 2.0;\n        a *= G;\n    }\n    float range = -perlinRange + 2. * coverage * perlinRange;\n    t += range;\n    if(t > 0.)\n        t = remap(t, 0., range + perlinRange, 0., 1.);\n    //t = abs(-2. * t + 1.);\n    return t;\n}\n\nfloat voronoiNoise2D(in vec2 x, float frequency) {\n    x *= frequency;\n\tvec2 xi = floor(x);\n\tvec2 xf = fract(x);\n    float m_dist = 1.;\n    for( int x=-surround; x<=surround; x++ ) {\n        for( int y=-surround; y<=surround; y++ ) {\n            // Neighbor place in the grid\n            vec2 neighbor = vec2(float(x),float(y));\n\n            //vec2 point = vec2(abs(perlinNoise2D(xi + neighbor)), hash(xi + neighbor));\n            // Vector between the pixel and the point\n            vec2 diff = neighbor + abs(hash(xi + neighbor)) - xf;\n\n            float dist = length(diff);\n\n            // Keep the closer distance\n            if(dist < m_dist) {\n                m_dist = min(m_dist, dist);\n            }\n        }\n    }\n    return m_dist;\n}\n\nfloat voronoiNoiseFbm2D( vec2 p, const int octaves, float frequency ) {\n    float G = 0.5;\n    float f = 1.0;\n    float a = 0.5;\n    float t = 0.0;\n    float w = 0.0;\n\n    for( int i=0; i<octaves; i++ ) {\n        t += a*voronoiNoise2D( p * f, frequency );\n        f *= 2.0;\n        w += a;\n        a *= G;\n    }\n\n    return t / w;\n}\n\nfloat getHeight(vec3 p) {\n\treturn length(p) - Re;\n}\n\nfloat getHeightFraction(in vec3 p) {\n    float height = length(p) - Re;\n    float height_fraction = (height - cloudHeightBottom) / (cloudHeightTop - cloudHeightBottom);\n    return clamp(height_fraction, 0., 1.);\n}\n\nfloat rayAtmosphereIntersect(in vec3 ro, in vec3 rd) {\n\tfloat b = dot(ro, rd);\n    float d = dot(ro, ro);\n\tfloat c = Ra*Ra - d;\n\tfloat det = sqrt(b * b + c);\n\treturn c / (det + b);\n}\n\nfloat raySphereIntersect(in vec3 ro, in vec3 rd, vec4 sph) {\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n\nvec2 rayCloudIntersect(in vec3 ro, in vec3 rd) {\n\tfloat b = dot(ro, rd);\n    float d = dot(ro, ro);\n    float Rct = Re + cloudHeightTop;\n    float Rcb = Re + cloudHeightBottom;\n    if(d < Rcb * Rcb) {\n        vec2 c = vec2(Rcb*Rcb, Rct*Rct) - d;\n        vec2 det = sqrt(b * b + c);\n        return c / (det + b);\n    } else {\n        float c = Rct*Rct - d;\n        float det = sqrt(b * b + c);\n        return vec2(0, c / (det + b));\n    }\n}\n\nfloat disGroundToPlanet(in float earthRadius, in float orbitRadius, in float angle) {\n    float radio = earthRadius / orbitRadius;\n    return orbitRadius * sqrt(1. + radio * radio - 2. * radio * sin(angle));\n}\n\nvec3 sphNormal( in vec3 pos, in vec4 sph ) {\n    return normalize(pos-sph.xyz);\n}",
   "name": "Common",
   "description": "",
   "type": "common"
  }
 ]
}