--[[--/*
--- Special purpose Fuse to support shader kernel development.
--
-- Based on the work of Chris Ridings (www.chrisridings.com), Bryan Ray (http://www.bryanray.name/wordpress/opencl-fuses-index/),
-- JiPi (https://youtu.be/dbrPWRldmbs), Igor Riđanović (https://youtu.be/p6IeeWr3FOc), and many others.
--

Änderung zum Testen und Debuggen von Shadern, die einen BufferA verwenden und diesen als iChannel0 wieder laden
! Kernelnamen wird nicht mehr mit Fusenamen gebildet ! -> nur einen Inkubator pro Komposition, da es sonst bei Versionsänderungen des DCTL-Codes zur unerwarteten Reaktionen kommen kann

BufferTest: off        -> Inkubator wie im Original, nur kein Fusenamen im Kernelnamen
BufferTest: TestKernel -> Über kernel kann der zu testende Kernel ausgewählt werden         
                          bei der Auswahl von Recursive wird der Ausgang des Buffers als Eingang (iChannel0) wieder geladen, ansonsten Image1
BufferTest: Final      -> Imagekernel nimmt Ausgang des BufferA und gibt diesen als Output aus


Mit BufferTest: TestKernel können die BufferA bis BufferD ausgewählt werden und mit der Checkbox Recursive kann ausgewählt werden, ob der Ausgang wieder in iChannel0 oder die Textur an Image1 angelegt werden soll.  

ToDo: Reset 

*/--]]--
-- ----------------------------------------------------------------------------------------------------------------------------------------

ShaderParameters     = nil
CompatibilityCode    = nil
ConversionShaderID   = ""
ConversionFusename   = ""
ConversionKernelname = ""
ConversionSourcecode = ""

NUM_COLOR_CONTROLS=5
NUM_TINYSLIDER_CONTROLS=4
NUM_SMALLSLIDER_CONTROLS=4

-- ----------------------------------------------------------------------------------------------------------------------------------------

ConversionSourcecode_fallback = [[

__KERNEL__ void IncubatorFallbackKernel(
    __CONSTANTREF__ Params *params,
    __TEXTURE2D__ iChannel0,
    __TEXTURE2D_WRITE__ dst
    )
{
  DEFINE_KERNEL_ITERATORS_XY(x, y);

  if (x >= params->width || y >= params->height)
    return;

  _tex2DVec4Write(dst, x, y, to_float4(1.0f,0.0f,0.0f,0.0f) );
}
]]



-- ----------------------------------------------------------------------------------------------------------------------------------------

FuRegisterClass("ShadertoysIncubator", CT_SourceTool, {
    REGS_Name = "ShadersInc",
	  REGS_Category = "Fuses",
    REGS_OpDescription = "An Incubator for Shadertoys",
	  REGS_OpIconString = "incubus",
    REG_Source_GlobalCtrls = true,
    REG_Source_SizeCtrls = true,
    REG_Source_AspectCtrls = true,
	  REG_TimeVariant = true,
	  REGS_Company = "nmbr73",
	  REGS_URL = "https://nmbr73.github.io/",
	  REG_Version	= 000001,
    REG_Fuse_NoEdit = false,
    REG_Fuse_NoReload = false, -- true,
    })



-------------------------------------------------------------------------------------------------------------------------------------------
-- Print verbose message.
--
-- Use verbose() to print any non-error message just meant to help developing the Incubator.fuse itself.
--
-- @param[type=string] msg The message to output in DaFusions console window.
--
function verbose(msg)
  print(msg)
end



-------------------------------------------------------------------------------------------------------------------------------------------
-- Local structure to manage vaialable source code.
--
-- This table is initialized by getConversions() with filenames, IDs, etc. of the sources found in the
-- repositorie's *'Conversions/'* folder. It is used to proviede these sources i.e. in a ComboBox for
-- selection.
--
-- @table Conversions
-- @field Name Fusename of the conversion.
-- @field Path Full path of the folder the conversion can be found in.
-- @field Filename Full filename (indcluding the ID and '.c' suffix).
-- @field ShadertoyID The ID of the Shadertoy the code originally came from.
-- @field Label Name in human readable form identifying the converson to show in messages, the ComboBox, etc. .
--
Conversions={}



-------------------------------------------------------------------------------------------------------------------------------------------
-- Create a table to initializie in particular `Conversions` with.
--
-- @param[type=string] path Path to where the conversions reside.
-- @return[type=table] conversion information; `{}` if no conversions found
--
function getConversions(path)

  local files={}

  local handle	= bmd.readdir(path.."*.*.c")

  for k, v in pairs(handle) do
    if v.Name and not(v.IsDir) then

      local filename = v.Name
      local fusename, shadertoyid = filename:match('^(.+)%.([^%.]+)%.c$')

      files[k]={
        Name=fusename,
        Path=path,
        Filename=filename,
        ShadertoyID=shadertoyid,
        Label=fusename.." ("..shadertoyid..")",
      }
    end
  end

  return files
end



-------------------------------------------------------------------------------------------------------------------------------------------
-- Callback to initialize the tool.
--
function Create()

  local xtracode=""

  for i=0,NUM_COLOR_CONTROLS-1 do
    xtracode=xtracode.."#define USE_CTRL_COLOR"..i.."(NAME) float4 NAME     = to_float4(params->color["..i.."][0],params->color["..i.."][1],params->color["..i.."][2],params->color["..i.."][3])\n"
  end

  for i=0,NUM_TINYSLIDER_CONTROLS-1 do
    xtracode=xtracode.."#define USE_CTRL_TINYSLIDER"..i.."(NAME,SMIN,SMAX,SDEFAULT) float NAME = params->tinySlider["..i.."]; if (NAME<SMIN) NAME=(SMIN); if (NAME>SMAX) NAME=(SMAX) \n"
  end

  for i=0,NUM_SMALLSLIDER_CONTROLS-1 do
    xtracode=xtracode.."#define USE_CTRL_SMALLSLIDER"..i.."(NAME,SMIN,SMAX,SDEFAULT) float NAME = params->smallSlider["..i.."]; if (NAME<SMIN) NAME=(SMIN); if (NAME>SMAX) NAME=(SMAX) \n"
  end

  verbose("use the folloin defines to connect your controls:\n"..xtracode)

  -- get the list of conversions and read compatibility and params code

  local REPOSITORYPATH=[[  <WILL BE REPLACED BY INSTALL.LUA>  ]]

  verbose("Create: repository used is "..REPOSITORYPATH)

  Conversions=getConversions(REPOSITORYPATH..'Conversions/')

  f = io.open(REPOSITORYPATH..'.clobber/CompatibilityCode.c', "r")

  if not f then
    CompatibilityCode = nil
    print("failed to read compatibility code")
  else
    CompatibilityCode = f:read("*all") .. xtracode
    f:close()
  end

  ShaderParameters=[[

  float iTime;
  float iMouse[4];

  float color[]]..NUM_COLOR_CONTROLS..[[][4];
  float tinySlider[]]..NUM_TINYSLIDER_CONTROLS..[[];
  float smallSlider[]]..NUM_TINYSLIDER_CONTROLS..[[];

  int   width, height;
  int   compOrder;

  int iChannel0_width;
  int iChannel0_height;
  ]]


  print(ShaderParameters)

  -- combo box with all the conversions + a reload button

  local attrs

  attrs={}

  for k,v in pairs(Conversions) do
    verbose("Create: conversion '"..v.Label.."'")
    table.insert(attrs,{ CCS_AddString = v.Label })
  end

  InFileToUseCombo = self:AddInput("Code Fragment", "FragementFileSelection", {
    LINKID_DataType = "Number",
    INPID_InputControl = "ComboControl",
	  INP_DoNotifyChanged = true,
    INP_Default = 0,
    INP_Integer = true,
    attrs
    })

  InReloadCodeButton= self:AddInput("Reload Code", "ReloadCodeFragment",
    { LINKID_DataType = "Text",
      INPID_InputControl = "ButtonControl",
      INP_DoNotifyChanged = true,
      INP_External = false,
    })

  InShadertoyButton=self:AddInput("Show on shadertoy.com", "ShowOnShadertoy", {
    LINKID_DataType = "Text",
    INPID_InputControl = "ButtonControl",
    INP_DoNotifyChanged = false,
    INP_External = false,
    BTNCS_Execute = 'print("does nothing")',
    INP_Disabled=true,
  })

  InFrequency = self:AddInput("Speedup", "speed", {
    LINKID_DataType    = "Number",
    INPID_InputControl = "SliderControl",
    INP_Default        = 1.0,
    INP_MinScale 	     = 0.0,
    INP_MaxScale 	     = 5.0,
    SLCS_LowName       = "stop",
    SLCS_HighName      = "5x",

  })

  self:BeginControlNest("MultiBuffer", "MultiBuffer", true, {})
  --JiPi Multibuffertest

  InBufferATest = self:AddInput("Buffer Test", "BufferATest", {
    LINKID_DataType = "Number",
    INPID_InputControl = "ComboControl",
	  INP_DoNotifyChanged = true,
    INP_Default = 0,
    INP_Integer = true,
    { CCS_AddString  = "Off", },
    { CCS_AddString  = "Test Kernel", },
	  { CCS_AddString  = "Final", },
    CC_LabelPosition = "Horizontal",
    })
  
  InRecursive = self:AddInput("Recursive", "Recursive", {
      LINKID_DataType = "Number",
      INPID_InputControl = "CheckboxControl",
      INP_Default = 0,
      INP_Integer = true,
      IC_Visible = true,
    })
  
  InKerneltoUse = self:AddInput("Kernel", "KernelSelection", {
    LINKID_DataType = "Number",
    INPID_InputControl = "ComboControl",
	  INP_DoNotifyChanged = true,
    INP_Default = 0,
    INP_Integer = true,
    { CCS_AddString  = "Image", },
    { CCS_AddString  = "BufferA", },
	  { CCS_AddString  = "BufferB", },
    { CCS_AddString  = "BufferC", },
	  { CCS_AddString  = "BufferD", },
    CC_LabelPosition = "Horizontal",
    })
    
  self:EndControlNest()

  -- some general controls for data passed to the kernel

  self:BeginControlNest("Common Shader Inputs", "shaderInputs", true, {})

		InShaderInputs_iResolution = self:AddInput("iResolution", "iResolution", {
			LINKID_DataType = "Text",
			INPID_InputControl = "TextEditControl",
			INP_External = false,
			IC_NoLabel = false,
			ICD_Width = 1.0,
			INPS_DefaultText = "-",
			TEC_Lines = 1,
			TEC_Wrap = false,
			TEC_ReadOnly = true,
			TEC_CharLimit = 0,
			TEC_DeferSetInputs = false,

			INP_DoNotifyChanged  = false,
      INP_Disabled = true,
      INP_Passive = true,
		  })

		InShaderInputs_iTime = self:AddInput("iTime", "iTime", {
			LINKID_DataType = "Text",
			INPID_InputControl = "TextEditControl",
			INP_External = false,
			IC_NoLabel = false,
			ICD_Width = 1.0,
			INPS_DefaultText = "-",
			TEC_Lines = 1,
			TEC_Wrap = false,
			TEC_ReadOnly = true,
			TEC_CharLimit = 0,
			TEC_DeferSetInputs = false,

			INP_DoNotifyChanged  = false,
      INP_Disabled = true,
      INP_Passive = true,
			})

		InShaderInputs_iMouse = self:AddInput("iMouse", "iMouse", {
			LINKID_DataType = "Text",
			INPID_InputControl = "TextEditControl",
			INP_External = false,
			IC_NoLabel = false,
			ICD_Width = 1.0,
			INPS_DefaultText = "-",
			TEC_Lines = 1,
			TEC_Wrap = false,
			TEC_ReadOnly = true,
			TEC_CharLimit = 0,
			TEC_DeferSetInputs = false,

			INP_DoNotifyChanged  = false,
      INP_Disabled = true,
      INP_Passive = true,
			})


    InMouseXY = self:AddInput("iMouse.xy", "iMouseXY", {
      LINKID_DataType = "Point",
      INPID_InputControl = "OffsetControl",
      INPID_PreviewControl = "CrosshairControl",
    })

    InMouseZW = self:AddInput("iMouse.zw", "iMouseZW", {
      LINKID_DataType = "Point",
      INPID_InputControl = "OffsetControl",
      INPID_PreviewControl = "CrosshairControl",

      INP_DoNotifyChanged  = false,
      INP_Disabled = true,
      INP_Passive = true,
    })

    InMouseDrag = self:AddInput("Mouse Button Pressed", "click", {
      LINKID_DataType = "Number",
      INPID_InputControl = "CheckboxControl",
      INP_Default = 0,
      INP_MinScale = 0,
      INP_MaxScale = 1,
      IC_Visible = true,
    })

  self:EndControlNest()

  -- some color controls to play with colors in the kernel

  self:BeginControlNest("Color Controls", "Colors", false, {})

    InColor={}

    local rgba = {'Red','Green','Blue','Alpha'}

    for i=0,NUM_COLOR_CONTROLS-1 do
      InColor[i]={}
      for j=0,3 do
        InColor[i][j]=self:AddInput(rgba[j+1], string.lower(string.sub(rgba[j+1],1,1))..i , { ICS_Name = "Color "..i, IC_ControlGroup = i+1, IC_ControlID = j, INP_Default  = 0.5, LINKID_DataType = "Number", INPID_InputControl = "ColorControl", INP_MinScale = 0.0, INP_MaxScale = 1.0, })
      end
    end

    self:EndControlNest()


  -- some sliders controls to play with colors in the kernel

  self:BeginControlNest("Slider Controls", "Sliders", false, {})

  InTinySlider={}

  for i=0,NUM_TINYSLIDER_CONTROLS-1 do
    InTinySlider[i] = self:AddInput("Tiny Slider "..i, "tinyslider"..i, {
      LINKID_DataType    = "Number",
      INPID_InputControl = "SliderControl",
      INP_MinScale 	     = -1.0,
      INP_MaxScale 	     = 1.0,
      INP_Default        = 0.0,
    })
  end

  InSmallSlider={}

  for i=0,NUM_SMALLSLIDER_CONTROLS-1 do
    InSmallSlider[i] = self:AddInput("Small Slider "..i, "smallslider"..i, {
      LINKID_DataType    = "Number",
      INPID_InputControl = "SliderControl",
      INP_MinScale 	     = -10.0,
      INP_MaxScale 	     = 10.0,
      INP_Default        = 0.0,
    })
  end

  self:EndControlNest()



  -- controls for the tool itself, not passed to the kernel

  InRebuildCheckBox = self:AddInput("InRebuildCheckBox", "InRebuildCheckBox", {
    LINKID_DataType = "Number",
    INPID_InputControl = "CheckboxControl",
    INP_Default = 0,
    INP_MinScale = 0,
    INP_MaxScale = 1,
    IC_Visible = false,
  })

  -- InVerboseCheckBox = self:AddInput("VERBOSE", "VerboseCheckbox", {
  --   LINKID_DataType = "Number",
  --   INPID_InputControl = "CheckboxControl",
  --   INP_Default = 1,
  --   INP_MinScale = 0,
  --   INP_MaxScale = 1,
  --   IC_Visible = true,
  -- })




  -- node's inputs and its output

  InChannel0 = self:AddInput(   "iChannel0",  "iChannel0",  { LINKID_DataType = "Image", LINK_Main = 1, INP_Required = false  })
	OutImage   = self:AddOutput(  "Output",     "Output",     { LINKID_DataType = "Image", LINK_Main = 1                        })

end






-------------------------------------------------------------------------------------------------------------------------------------------
-- Callback to render the node.
--
--JiPi_Multifuse
ImgAttrs_Global = {
        { IMG_Channel = "Red", },
        { IMG_Channel = "Green", },
        { IMG_Channel = "Blue", },
        { IMG_Channel = "Alpha", },
        IMG_Width = Width,
        IMG_Height = Height,
  	    IMG_DeferAlloc = false,
        }
Image_Buff_GlobalA = Image(ImgAttrs_Global)


function Process(req)

  local rebuild = false

  if InRebuildCheckBox:GetValue(req).Value == 1 then
    verbose("Process: do rebuild and clear the flag")
    InRebuildCheckBox:SetSource(Number(0),0)
    rebuild=true
  end



  if rebuild then
    ConversionSourcecode  = ""
    local item   = Conversions[InFileToUseCombo:GetValue(req).Value + 1]
    ConversionFusename    = item.Name
    ConversionShaderID    = item.ShadertoyID

    InShadertoyButton:SetAttrs({
      BTNCS_Execute = 'bmd.openurl("https://www.shadertoy.com/view/' .. ConversionShaderID ..'")',
      INP_Disabled=  ConversionShaderID=="TEST" and true or false
      })

    verbose("Process: rebuild code for conversion '"..ConversionFusename.."' ("..ConversionShaderID..")")

    file = io.open(item.Path .. item.Filename,"r")

    if file ~= nil then
      ConversionSourcecode = "\n" .. file:read("*all")
      file:close()
    end


    --JiPi_Multifuse
    if (InBufferATest:GetValue(req).Value > 0) then
      ConversionKernelname = ConversionFusename .. "Kernel"
    else

      -- Für Incubator-Nodes (und nur für diese) müssen die Kernels über verschiedene
      -- Instanzen hinweg unterschieden werden. Die fertige Fuse braucht das nachher aber
      -- nicht mehr - eine Fuse ist halt eine Fuse und die ändert ihren Kernel nicht einfach
      -- so zwischendurch ... da wird dann nachher einfach nichts mehr an den Namen
      -- drangehaengt.

      --ConversionKernelname = ConversionFusename .. "Kernel_" .. self.Name
      ConversionKernelname = ConversionFusename .. "Kernel"

      local count

      ConversionSourcecode, count = string.gsub(ConversionSourcecode,
        "__KERNEL__%s+void%s+"..ConversionFusename.."Kernel%(",
        "__KERNEL__ void "..ConversionKernelname.."("
        )

      -- Vorsicht: Der Test, ob der Kernelname gefunden wurde muss drinbleiben,
      -- weil sonst die kleinste Aenderung im Kernelnamen Fusion auf dem Mac komplett
      -- weghaut. Ist zwar nicht absolut wasserdicht, verhindert aber versehentlich
      -- falsche Namen in 99% der Faelle

      if count ~=1 then
        print("void "..ConversionFusename.."Kernel() found "..count.."x ... remember the Highlander!")
        ConversionSourcecode = ""
      end
    end
  end




  if ConversionSourcecode == ""  then
    print("no shader to render - using some default kernel")
    ConversionSourcecode=ConversionSourcecode_fallback

    -- No need for a '_ShadersIncN' extension across
    -- multiple instances as the fallback kernel code
    -- is always the same.

    ConversionKernelname="IncubatorFallbackKernel"
    ConversionFusename="IncubatorFallback"
    rebuild=true
  end

  if CompatibilityCode==nil or ShaderParameters==nil then
    print("no way this will work")
    return
  end

  if rebuild then
    verbose("Process: '"..ConversionKernelname.."' is now active for "..self.Name)
  end

  -- JiPi Multibuffertest
  -- ev überrpüfen, ob entsprechender Buffer überhaupt vorhanden ist
  --print("KerneltoUse", InKerneltoUse:GetValue(req).Value)

  _ConversionKernelname = ConversionKernelname --Image

  if (InBufferATest:GetValue(req).Value > 0)  then    -- Buffer allgemein testen
    if (InKerneltoUse:GetValue(req).Value == 1) then       -- BufferA
      _ConversionKernelname = string.gsub(ConversionKernelname, ConversionKernelname, ConversionKernelname.."_BufferA") 
    else if (InKerneltoUse:GetValue(req).Value == 2) then  -- BufferB 
      _ConversionKernelname = string.gsub(ConversionKernelname, ConversionKernelname, ConversionKernelname.."_BufferB")     
    else if (InKerneltoUse:GetValue(req).Value == 3) then  -- BufferC 
      _ConversionKernelname = string.gsub(ConversionKernelname, ConversionKernelname, ConversionKernelname.."_BufferC")     
    else if (InKerneltoUse:GetValue(req).Value == 4) then  -- BufferD 
      _ConversionKernelname = string.gsub(ConversionKernelname, ConversionKernelname, ConversionKernelname.."_BufferD")     
    end
    end
    end
    end
  end
--print("Kernelname",_ConversionKernelname)

  local node = DVIPComputeNode(req,
    _ConversionKernelname,
    CompatibilityCode .. ConversionSourcecode,
    "Params",
    ShaderParameters
    )


  local imgattrs = {
    IMG_Document = self.Comp,
    { IMG_Channel = "Red", },
    { IMG_Channel = "Green", },
    { IMG_Channel = "Blue", },
    { IMG_Channel = "Alpha", },
    IMG_Width = Width,
    IMG_Height = Height,
    IMG_XScale = XAspect,
    IMG_YScale = YAspect,
    IMAT_OriginalWidth = realwidth, -- nil !?!
    IMAT_OriginalHeight = realheight, -- nil !?!
    IMG_Quality = not req:IsQuick(),
    IMG_MotionBlurQuality = not req:IsNoMotionBlur(),
    IMG_DeferAlloc = true,
    IMG_ProxyScale = ( (not req:IsStampOnly()) and 1 or nil),
    IMG_Depth = ( (SourceDepth~=0) and SourceDepth or nil   )
  }


  -- Extern Texture or create a new one
  iChannel0 = InChannel0:GetValue(req)

  if (iChannel0 == nil) then
    iChannel0 = Image(imgattrs)
    local p = Pixel({R=0,G=0,B=0,A=0})
    iChannel0:Fill(p)
  end

  local dst = Image {IMG_Like = iChannel0, IMG_DeferAlloc = true}
  local dst2 = Image {IMG_Like = iChannel0, IMG_DeferAlloc = true}


  if req:IsPreCalc() then
    print("precalc")
    local out = Image({IMG_Like = dst, IMG_NoData = true})
    OutImage:Set(req, out)
    return
  end


  -------------- Parameter für DCTL-Code ---------------------
  local framerate = self.Comp:GetPrefs("Comp.FrameFormat.Rate")

  local params = {}

  params = node:GetParamBlock(ShaderParameters)


  local mouse =  nil
  local text  =  nil

  -- iMouse
  mouse  = InMouseXY:GetValue(req)

  params.iMouse[0] = mouse.X
  params.iMouse[1] = mouse.Y
  params.iMouse[2] = 0
  params.iMouse[3] = 0

  if InMouseDrag:GetValue(req).Value == 1 then
    params.iMouse[2] = params.iMouse[0]
    params.iMouse[3] = params.iMouse[1]
  end

  mouse=InMouseZW:GetValue(req)
  if mouse.X ~= params.iMouse[2] or mouse.Y ~= params.iMouse[3] then
    InMouseZW:SetAttrs({INP_Disabled=false})
    InMouseZW:SetSource(Point(params.iMouse[2],params.iMouse[3]),0,0)
    InMouseZW:SetAttrs({INP_Disabled=true})
  end

  params.iMouse[0] = params.iMouse[0] * Width
  params.iMouse[1] = params.iMouse[1] * Height
  params.iMouse[2] = params.iMouse[2] * Width
  params.iMouse[3] = params.iMouse[3] * Height

  text = string.format("{%.1f, %.1f, %.1f, %.1f}", params.iMouse[0], params.iMouse[1],params.iMouse[2],params.iMouse[3])

  if InShaderInputs_iMouse:GetValue(req).Value ~= text then
    InShaderInputs_iMouse:SetAttrs({INP_Disabled=false})
    InShaderInputs_iMouse:SetSource(Text( text ),0,0)
    InShaderInputs_iMouse:SetAttrs({INP_Disabled=true})
  end


  -- iTime
  local frequency = InFrequency:GetValue(req).Value

  params.iTime            = (req.Time / framerate) * frequency;

  text = string.format("(%.0f/%.2ffps)*%.3f= %.4f", req.Time,framerate,frequency,params.iTime)

  if InShaderInputs_iTime:GetValue(req).Value ~= text then
    InShaderInputs_iTime:SetAttrs({INP_Disabled=false})
    InShaderInputs_iTime:SetSource(Text( text ),0,0)
    InShaderInputs_iTime:SetAttrs({INP_Disabled=true})
  end


  -- Colors
  for i=0,NUM_COLOR_CONTROLS-1 do
    for j=0,3 do
      params.color[i][j] = InColor[i][j]:GetValue(req).Value
    end
  end

  -- Sliders
  for i=0,NUM_TINYSLIDER_CONTROLS-1 do
    params.tinySlider[i] = InTinySlider[i]:GetValue(req).Value
  end

  for i=0,NUM_SMALLSLIDER_CONTROLS-1 do
    params.smallSlider[i] = InSmallSlider[i]:GetValue(req).Value
  end


  -- Resolution
  params.width  = dst.Width
  params.height = dst.Height
--params.width            = iChannel0.DataWindow:Width()
--params.height           = iChannel0.DataWindow:Height()

  text = string.format("{%.0f, %.0f}", params.width, params.height )

  if InShaderInputs_iResolution:GetValue(req).Value ~= text then
    InShaderInputs_iResolution:SetAttrs({INP_Disabled=false})
    InShaderInputs_iResolution:SetSource(Text( text ),0,0)
    InShaderInputs_iResolution:SetAttrs({INP_Disabled=true})
  end


  params.compOrder        = iChannel0:IsMask() and 1 or 15
  params.iChannel0_width  = iChannel0.Width
  params.iChannel0_height = iChannel0.Height

  node:SetParamBlock(params)

  node:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR,TEX_ADDRESS_MODE_BORDER, TEX_NORMALIZED_COORDS_TRUE)
  
  --JiPi_Multifuse
  if (InBufferATest:GetValue(req).Value > 0 and InKerneltoUse:GetValue(req).Value == 1 and InRecursive:GetValue(req).Value == 1 ) then
    node:AddInput("iChannel0",Image_Buff_GlobalA)
    --print("----- BufferA-------")
  else
    node:AddInput("iChannel0",iChannel0)
  end
  
	node:AddOutput("dst", dst)

  if rebuild then
    node:ForceRebuild()
  end


  local ok = node:RunSession(req)

	if (not ok) then
		dst = nil
    print("--- Errors ---")
    dump(node:GetErrorLog())
	end

  --JiPi_Multifuse
  Image_Buff_GlobalA = dst --Recursiv Image
  
  if (InBufferATest:GetValue(req).Value == 2) then   -- ImageKernel after BufferA
  
    local nodeI = DVIPComputeNode(req,
          ConversionFusename.."Kernel",          --Image
          CompatibilityCode .. ConversionSourcecode,
          "Params",
          ShaderParameters
          )
    
    nodeI:SetParamBlock(params)
    nodeI:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR,TEX_ADDRESS_MODE_BORDER, TEX_NORMALIZED_COORDS_TRUE)
    
    nodeI:AddInput("iChannel0",Image_Buff_GlobalA)
   	nodeI:AddOutput("dst", dst2)
 
    if rebuild then
      nodeI:ForceRebuild()
    end

    local ok = nodeI:RunSession(req)

    if (not ok) then
      dst2 = nil
      print("--- Errors Imagekernel ---")
      dump(nodeI:GetErrorLog())
    end
    
    dst = dst2
  end

 
  -- Output our result
  OutImage:Set(req,dst)
  collectgarbage();

end



-------------------------------------------------------------------------------------------------------------------------------------------
-- Callback to handle UI control events.
--
function NotifyChanged(inp, param, time)
	if inp ~= nil and param ~= nil then

		if (inp == InReloadCodeButton) then
			if (param.Value == 1) then
        verbose("NotifyChanged: reload button pressend")
        InRebuildCheckBox:SetSource(Number(1),0)
      end
    end

		if (inp == InFileToUseCombo) then
      verbose("NotifyChanged: file to use changed - set flag for a rebuild")
      InRebuildCheckBox:SetSource(Number(1),0)
    end

	end
end
