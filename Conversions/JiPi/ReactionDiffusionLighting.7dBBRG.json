{"Shader":{"ver":"0.1","info":{"id":"7dBBRG","date":"1653684772","viewed":38,"name":"reaction diffusion + lighting","username":"ml","description":"basic reaction diffusion. Move the mouse to change the lighting direction.","likes":3,"published":3,"flags":32,"usePreview":0,"tags":["lighting","reactiondiffusion"],"hasliked":0},"renderpass":[{"inputs":[{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":37,"channel":0}],"code":"vec3 lightColor = vec3(1.);\n\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos(TAU*(c*t+d) );\n}\n\nvec3 palette1(float t){\n    return palette(t, vec3(0.8, 0.5, 0.4), vec3(0.2, 0.4, 0.2), vec3(2.0, 1.0, 1.0), vec3(0.00, 0.25, 0.25));\n}\n\nvec3 palette2(float t){\n    return palette(t, vec3(0.5, 0.5, 0.5), vec3(0.5, 0.5, 0.5), vec3(1.0, 1.0, 1.0), vec3(0.00, 0.33, 0.67));\n}\n\nvec3 palette3(float t){\n    return palette(t, vec3(0.5, 0.5, 0.5), vec3(0.5, 0.5, 0.5), vec3(2.0, 1.0, 0.0), vec3(0.50, 0.20, 0.25));\n}\n\nvec3 palette4(float t){\n    return palette(t, vec3(0.5, 0.5, 0.5), vec3(0.5, 0.5, 0.5), vec3(2.0, 1.0, 0.0), vec3(0.6627, 0.9411, 0.8196));\n}\n\nvec3 palette5(float t){\n     return vec3(1., pow(cos(t*TAU*1.), 2.)*0.8+0.2, pow(cos(t*TAU*0.5), 2.));\n}\n\nvec3 palette6(float t){\n    return vec3(smoothstep(0.55, 0.45, t)*0.8 +0.06);\n}\n\nvec3 getColour(float depth, vec2 uv){\n    \n    return palette6(depth);\n}\n\nfloat getDepth(vec2 uv){\n    vec4 values = texture(iChannel0, uv);\n    float a = values.x;\n    float b = values.y;\n    float depth = a-b;\n    return depth;\n}\n\n\/\/https:\/\/www.shadertoy.com\/view\/XlGBW3\nvec3 getNormal(vec2 uv) {\n    vec3 p = vec3(uv, 0.);\n    vec2 e = vec2(1.\/iResolution.y, 0);\/\/vec2(.0001, 0);\n    float d = getDepth(uv+e.xy);\n\n    vec3 normal = d - vec3(\n        getDepth(uv-e.xy),\n        getDepth(uv-e.yx),\n        -1.\n    );\n    \n    return normalize(normal);\n}\n\nvec3 getLightDir(vec2 uv){\n    vec3 lightPos = vec3(iMouse.xy\/iResolution.xy*1., 0.2);\n\n    vec3 fragPos = vec3(uv, 0.);\n    vec3 lightDir = vec3(lightPos.xy-vec2(0.5, 0.5), 0.5); \n    \/\/vec3 lightDir = lightPos - fragPos;\n    lightDir = normalize(lightDir);\n    return lightDir;\n}\n\n\/\/https:\/\/learnopengl.com\/Lighting\/Basic-Lighting\nvec3 getAmbient(vec2 uv){\n    float ambientStrength = 0.1;\n    vec3 ambient = ambientStrength * lightColor;\n    return ambient;\n}\n\nvec3 getDiffuse(vec2 uv){\n    \n    float diff = dot(getNormal(uv), getLightDir(uv)); \n    \/\/diff = max(diff, 0.);\n    vec3 diffuse = diff * lightColor;\n    return diffuse;\n}\n\nvec3 getSpecular(vec2 uv){\n\n    float specularStrength = 10.;\n\n    \/\/vec3 viewPos = vec3(uv, 1.);\n    \/\/vec3 fragPos = vec3(uv, 0.);\n    \/\/vec3 viewDir = normalize(viewPos - FragPos);\n    vec3 viewDir = vec3(0., 0., 1.);\n    \n    vec3 reflectDir = reflect(-getLightDir(uv), getNormal(uv));  \n    \n    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 256.);\n    \n    vec3 specular = specularStrength * spec * lightColor; \n    \n    return specular;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord\/iResolution.xy*0.4;\n    \/\/uv.x *= iResolution.x\/iResolution.y;\n   \n\n    float depth = getDepth(uv);\n    \n    vec3 normal = getNormal(uv);\n    \n    vec3 cool = normal*depth*0.8+depth*0.7;\n    vec3 c = vec3(length(cool));\n    \n \n    vec3 lightness = getDiffuse(uv) + getAmbient(uv)+ getSpecular(uv);\n    vec3 colour = getColour(depth,uv);\n    \/\/ Output to screen\n    fragColor = vec4(vec3(colour*lightness), 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":257,"channel":0}],"code":"#define D_A 1.\n#define D_B 0.5\n#define F 0.055\n#define K 0.062\n#define T_STEP 0.5\n\n\n\n\nconst float weights[9] = float[9](\n    .05,0.2,.05,\n    0.2, -1., 0.2,\n    .05,0.2,.05\n);\n\nvec4 laplacian(vec2 fragCoord){\n\n    vec4 weightedLevels = vec4(0.);\n    for(int i = 0; i < 9; i++){\n        int dx = i%3-1;\n        int dy = i\/3-1;\n        vec2 uv = (fragCoord + vec2(dx, dy))\/iResolution.xy;\n\n        weightedLevels += weights[i] * texture(iChannel0, uv);\n\n\n    }\n    \n    return weightedLevels;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord\/iResolution.xy;\n    \/\/uv.x *= iResolution.x\/iResolution.y;\n\n    vec4 levels = texture(iChannel0, uv);\n    \n    float a = levels.x;\n    float b = levels.y;\n   \n    vec4 weightedLevels = laplacian(fragCoord);\n    \n    \/\/https:\/\/www.karlsims.com\/rd.html\n    \n    float aChange = (D_A * weightedLevels.x - a * b * b + F * (1.-a))*T_STEP; \n    \n    float bChange = (D_B * weightedLevels.y + a * b * b - (F+K) *b)*T_STEP; \n    \n    float newA = a + aChange;\n    float newB = b + bChange;\n    \n    if(iFrame < 10){\n        newA = 0.5+hash12(uv*100.)*0.8;\n        newB = step(0.5, hash12(floor(uv*50.) + vec2(10., 16.23)));\n    };\n    \n    fragColor = vec4(newA, newB,1.0,1.0);\n\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define TAU 6.28318530718\n\n\/\/  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n","name":"Common","description":"","type":"common"}]}}