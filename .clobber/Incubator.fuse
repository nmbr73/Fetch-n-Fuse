--- Special purpose Fuse to support shader kernel development.
--
-- Based on the work of Chris Ridings (www.chrisridings.com), Bryan Ray (http://www.bryanray.name/wordpress/opencl-fuses-index/),
-- JiPi (https://youtu.be/dbrPWRldmbs), Igor Riđanović (https://youtu.be/p6IeeWr3FOc), and many others.
--




-- ----------------------------------------------------------------------------------------------------------------------------------------

ShaderParameters     = nil
CompatibilityCode    = nil
ConversionShaderID   = ""
ConversionFusename   = ""
ConversionKernelname = ""
ConversionSourcecode = ""



-- ----------------------------------------------------------------------------------------------------------------------------------------

ConversionSourcecode_fallback = [[

__KERNEL__ void IncubatorFallbackKernel(
    __CONSTANTREF__ Params *params,
    __TEXTURE2D__ iChannel0,
    __TEXTURE2D_WRITE__ dst
    )
{
  DEFINE_KERNEL_ITERATORS_XY(x, y);

  if (x >= params->width || y >= params->height)
    return;

  _tex2DVec4Write(dst, x, y, to_float4(1.0f,0.0f,0.0f,0.0f) );
}
]]



-- ----------------------------------------------------------------------------------------------------------------------------------------

FuRegisterClass("ShadertoysIncubator", CT_SourceTool, {
    REGS_Name = "ShadersInc",
	  REGS_Category = "Fuses",
    REGS_OpDescription = "An Incubator for Shadertoys",
	  REGS_OpIconString = "incubus",
    REG_Source_GlobalCtrls = true,
    REG_Source_SizeCtrls = true,
    REG_Source_AspectCtrls = true,
	  REG_TimeVariant = true,
	  REGS_Company = "nmbr73",
	  REGS_URL = "https://nmbr73.github.io/",
	  REG_Version	= 000001,
    REG_Fuse_NoEdit = false,
    REG_Fuse_NoReload = false, -- true,
    })



-------------------------------------------------------------------------------------------------------------------------------------------
-- Print verbose message.
--
-- Use verbose() to print any non-error message just meant to help developing the Incubator.fuse itself.
--
-- @param[type=string] msg The message to output in DaFusions console window.
--
function verbose(msg)
  print(msg)
end



-------------------------------------------------------------------------------------------------------------------------------------------
-- Local structure to manage vaialable source code.
--
-- This table is initialized by getConversions() with filenames, IDs, etc. of the sources found in the
-- repositorie's *'Conversions/'* folder. It is used to proviede these sources i.e. in a ComboBox for
-- selection.
--
-- @table Conversions
-- @field Name Fusename of the conversion.
-- @field Path Full path of the folder the conversion can be found in.
-- @field Filename Full filename (indcluding the ID and '.c' suffix).
-- @field ShadertoyID The ID of the Shadertoy the code originally came from.
-- @field Label Name in human readable form identifying the converson to show in messages, the ComboBox, etc. .
--
Conversions={}



-------------------------------------------------------------------------------------------------------------------------------------------
-- Create a table to initializie in particular `Conversions` with.
--
-- @param[type=string] path Path to where the conversions reside.
-- @return[type=table] conversion information; `{}` if no conversions found
--
function getConversions(path)

  local files={}

  local handle	= bmd.readdir(path.."*.*.c")

  for k, v in pairs(handle) do
    if v.Name and not(v.IsDir) then

      local filename = v.Name
      local fusename, shadertoyid = filename:match('^(.+)%.([^%.]+)%.c$')

      files[k]={
        Name=fusename,
        Path=path,
        Filename=filename,
        ShadertoyID=shadertoyid,
        Label=fusename.." ("..shadertoyid..")",
      }
    end
  end

  return files
end



-------------------------------------------------------------------------------------------------------------------------------------------
-- Callback to initialize the tool.
--
function Create()


  -- get the list of conversions and read compatibility and params code

  local REPOSITORYPATH=[[  <WILL BE REPLACED BY INSTALL.LUA>  ]]

  verbose("Create: repository used is "..REPOSITORYPATH)

  Conversions=getConversions(REPOSITORYPATH..'Conversions/')

  f = io.open(REPOSITORYPATH..'.clobber/CompatibilityCode.c', "r")

  if not f then
    CompatibilityCode = nil
    print("failed to read compatibility code")
  else
    CompatibilityCode = f:read("*all")
    f:close()
  end

  f = io.open(REPOSITORYPATH..'.clobber/ShaderParameters.c', "r")

  if not f then
    ShaderParameters = nil
    print("failed to read shader paramseters code")
  else
    ShaderParameters = f:read("*all")
    f:close()
  end



  -- combo box with all the conversions + a reload button

  local attrs

  attrs={}

  for k,v in pairs(Conversions) do
    verbose("Create: conversion '"..v.Label.."'")
    table.insert(attrs,{ CCS_AddString = v.Label })
  end

  InFileToUseCombo = self:AddInput("Code Fragment", "FragementFileSelection", {
    LINKID_DataType = "Number",
    INPID_InputControl = "ComboControl",
	  INP_DoNotifyChanged = true,
    INP_Default = 0,
    INP_Integer = true,
    attrs
    })

  InReloadCodeButton= self:AddInput("Reload Code", "ReloadCodeFragment",
    { LINKID_DataType = "Text",
      INPID_InputControl = "ButtonControl",
      INP_DoNotifyChanged = true,
      INP_External = false,
    })



  -- some general controls for data passed to the kernel

  self:BeginControlNest("Common Fuse Controls", "CommonFuseControls", true, {})

    InFrequency = self:AddInput("Frequency", "Frequency", {
      LINKID_DataType    = "Number",
      INPID_InputControl = "SliderControl",
      INP_Default        = 1.0,
      INP_MinScale 	     = 0.0,
      INP_MaxScale 	     = 10.0,
    })

    InMouseXY = self:AddInput("Mouse Drag", "MouseXY", {
      LINKID_DataType = "Point",
      INPID_InputControl = "OffsetControl",
      INPID_PreviewControl = "CrosshairControl",
    })

    InMouseZW = self:AddInput("Mouse Click", "MouseZW", {
      LINKID_DataType = "Point",
      INPID_InputControl = "OffsetControl",
      INPID_PreviewControl = "CrosshairControl",
    })

  self:EndControlNest()



  -- some color controls to play with colors in the kernel

  self:BeginControlNest("Some Color", "Colors", false, {})

    InColor={}

    local rgba = {'Red','Green','Blue','Alpha'}

    for i=0,5 do
      InColor[i]={}
      for j=0,3 do
        InColor[i][j]=self:AddInput(rgba[j+1], string.lower(string.sub(rgba[j+1],1,1))..i , { ICS_Name = "Color "..i, IC_ControlGroup = i+1, IC_ControlID = j, INP_Default  = 0.5, LINKID_DataType = "Number", INPID_InputControl = "ColorControl", INP_MinScale = 0.0, INP_MaxScale = 1.0, })
      end
    end


    -- InR0 = self:AddInput("Red",   "r0", { ICS_Name = "Color 0", IC_ControlGroup = 1, IC_ControlID = 0, INP_Default  = 0.5, LINKID_DataType = "Number", INPID_InputControl = "ColorControl", INP_MinScale = 0.0, INP_MaxScale = 1.0, })
    -- InG0 = self:AddInput("Green", "g0", { ICS_Name = "Color 0", IC_ControlGroup = 1, IC_ControlID = 1, INP_Default  = 0.5, LINKID_DataType = "Number", INPID_InputControl = "ColorControl", INP_MinScale = 0.0, INP_MaxScale = 1.0, })
    -- InB0 = self:AddInput("Blue",  "b0", { ICS_Name = "Color 0", IC_ControlGroup = 1, IC_ControlID = 2, INP_Default  = 0.5, LINKID_DataType = "Number", INPID_InputControl = "ColorControl", INP_MinScale = 0.0, INP_MaxScale = 1.0, })
    -- InA0 = self:AddInput("Alpha", "a0", { ICS_Name = "Color 0", IC_ControlGroup = 1, IC_ControlID = 3, INP_Default  = 0.5, LINKID_DataType = "Number", INPID_InputControl = "ColorControl", INP_MinScale = 0.0, INP_MaxScale = 1.0, })

    -- InR1 = self:AddInput("Red",   "r1", { ICS_Name = "Color 1", IC_ControlGroup = 2, IC_ControlID = 0, INP_Default  = 0.5, LINKID_DataType = "Number", INPID_InputControl = "ColorControl", INP_MinScale = 0.0, INP_MaxScale = 1.0, })
    -- InG1 = self:AddInput("Green", "g1", { ICS_Name = "Color 1", IC_ControlGroup = 2, IC_ControlID = 1, INP_Default  = 0.5, LINKID_DataType = "Number", INPID_InputControl = "ColorControl", INP_MinScale = 0.0, INP_MaxScale = 1.0, })
    -- InB1 = self:AddInput("Blue",  "b1", { ICS_Name = "Color 1", IC_ControlGroup = 2, IC_ControlID = 2, INP_Default  = 0.5, LINKID_DataType = "Number", INPID_InputControl = "ColorControl", INP_MinScale = 0.0, INP_MaxScale = 1.0, })
    -- InA1 = self:AddInput("Alpha", "a1", { ICS_Name = "Color 1", IC_ControlGroup = 2, IC_ControlID = 3, INP_Default  = 0.5, LINKID_DataType = "Number", INPID_InputControl = "ColorControl", INP_MinScale = 0.0, INP_MaxScale = 1.0, })

    -- InR2 = self:AddInput("Red",   "r2", { ICS_Name = "Color 2", IC_ControlGroup = 3, IC_ControlID = 0, INP_Default  = 0.5, LINKID_DataType = "Number", INPID_InputControl = "ColorControl", INP_MinScale = 0.0, INP_MaxScale = 1.0, })
    -- InG2 = self:AddInput("Green", "g2", { ICS_Name = "Color 2", IC_ControlGroup = 3, IC_ControlID = 1, INP_Default  = 0.5, LINKID_DataType = "Number", INPID_InputControl = "ColorControl", INP_MinScale = 0.0, INP_MaxScale = 1.0, })
    -- InB2 = self:AddInput("Blue",  "b2", { ICS_Name = "Color 2", IC_ControlGroup = 3, IC_ControlID = 2, INP_Default  = 0.5, LINKID_DataType = "Number", INPID_InputControl = "ColorControl", INP_MinScale = 0.0, INP_MaxScale = 1.0, })
    -- InA2 = self:AddInput("Alpha", "a2", { ICS_Name = "Color 2", IC_ControlGroup = 3, IC_ControlID = 3, INP_Default  = 0.5, LINKID_DataType = "Number", INPID_InputControl = "ColorControl", INP_MinScale = 0.0, INP_MaxScale = 1.0, })

    self:EndControlNest()



  -- controls for the tool itself, not passed to the kernel

  InRebuildCheckBox = self:AddInput("InRebuildCheckBox", "InRebuildCheckBox", {
    LINKID_DataType = "Number",
    INPID_InputControl = "CheckboxControl",
    INP_Default = 0,
    INP_MinScale = 0,
    INP_MaxScale = 1,
    IC_Visible = false,
  })

  -- InVerboseCheckBox = self:AddInput("VERBOSE", "VerboseCheckbox", {
  --   LINKID_DataType = "Number",
  --   INPID_InputControl = "CheckboxControl",
  --   INP_Default = 1,
  --   INP_MinScale = 0,
  --   INP_MaxScale = 1,
  --   IC_Visible = true,
  -- })

  InShadertoyButton=self:AddInput("Show on shadertoy.com", "ShowOnShadertoy", {
    LINKID_DataType = "Text",
    INPID_InputControl = "ButtonControl",
    INP_DoNotifyChanged = false,
    INP_External = false,
    BTNCS_Execute = 'print("does nothing")',
    INP_Disabled=true,
  })



  -- node's inputs and its output

  InChannel0 = self:AddInput(   "iChannel0",  "iChannel0",  { LINKID_DataType = "Image", LINK_Main = 1, INP_Required = false  })
	OutImage   = self:AddOutput(  "Output",     "Output",     { LINKID_DataType = "Image", LINK_Main = 1                        })

end






-------------------------------------------------------------------------------------------------------------------------------------------
-- Callback to render the node.
--
function Process(req)

  local rebuild = false

  if InRebuildCheckBox:GetValue(req).Value == 1 then
    verbose("Process: do rebuild and clear the flag")
    InRebuildCheckBox:SetSource(Number(0),0)
    rebuild=true
  end



  if rebuild then
    ConversionSourcecode  = ""
    local item   = Conversions[InFileToUseCombo:GetValue(req).Value + 1]
    ConversionFusename    = item.Name
    ConversionShaderID    = item.ShadertoyID

    InShadertoyButton:SetAttrs({
      BTNCS_Execute = 'bmd.openurl("https://www.shadertoy.com/view/' .. ConversionShaderID ..'")',
      INP_Disabled=false
      })

    verbose("Process: rebuild code for conversion '"..ConversionFusename.."' ("..ConversionShaderID..")")

    file = io.open(item.Path .. item.Filename,"r")

    if file ~= nil then
      ConversionSourcecode = "\n" .. file:read("*all")
      file:close()
    end



    -- Für Incubator-Nodes (und nur für diese) müssen die Kernels über verschiedene
    -- Instanzen hinweg unterschieden werden. Die fertige Fuse braucht das nachher aber
    -- nicht mehr - eine Fuse ist halt eine Fuse und die ändert ihren Kernel nicht einfach
    -- so zwischendurch ... da wird dann nachher einfach nichts mehr an den Namen
    -- drangehaengt.

    ConversionKernelname = ConversionFusename .. "Kernel_" .. self.Name

    local count

    ConversionSourcecode, count = string.gsub(ConversionSourcecode,
      "__KERNEL__%s+void%s+"..ConversionFusename.."Kernel%(",
      "__KERNEL__ void "..ConversionKernelname.."("
      )

    -- Vorsicht: Der Test, ob der Kernelname gefunden wurde muss drinbleiben,
    -- weil sonst die kleinste Aenderung im Kernelnamen Fusion auf dem Mac komplett
    -- weghaut. Ist zwar nicht absolut wasserdicht, verhindert aber versehentlich
    -- falsche Namen in 99% der Faelle

    if count ~=1 then
      print("void "..ConversionFusename.."Kernel() found "..count.."x ... remember the Highlander!")
      ConversionSourcecode = ""
    end

  end




  if ConversionSourcecode == ""  then
    print("no shader to render - using some default kernel")
    ConversionSourcecode=ConversionSourcecode_fallback

    -- No need for a '_ShadersIncN' extension across
    -- multiple instances as the fallback kernel code
    -- is always the same.

    ConversionKernelname="IncubatorFallbackKernel"
    ConversionFusename="IncubatorFallback"
    rebuild=true
  end

  if CompatibilityCode==nil or ShaderParameters==nil then
    print("no way this will work")
    return
  end

  if rebuild then
    verbose("Process: '"..ConversionKernelname.."' is now active for "..self.Name)
  end

  local node = DVIPComputeNode(req,
    ConversionKernelname,
    CompatibilityCode .. ConversionSourcecode,
    "Params",
    ShaderParameters
    )



  local imgattrs = {
    IMG_Document = self.Comp,
    { IMG_Channel = "Red", },
    { IMG_Channel = "Green", },
    { IMG_Channel = "Blue", },
    { IMG_Channel = "Alpha", },
    IMG_Width = Width,
    IMG_Height = Height,
    IMG_XScale = XAspect,
    IMG_YScale = YAspect,
    IMAT_OriginalWidth = realwidth, -- nil !?!
    IMAT_OriginalHeight = realheight, -- nil !?!
    IMG_Quality = not req:IsQuick(),
    IMG_MotionBlurQuality = not req:IsNoMotionBlur(),
    IMG_DeferAlloc = true,
    IMG_ProxyScale = ( (not req:IsStampOnly()) and 1 or nil),
    IMG_Depth = ( (SourceDepth~=0) and SourceDepth or nil   )
  }



  -- Extern Texture or create a new one
  iChannel0 = InChannel0:GetValue(req)

  if (iChannel0 == nil) then
    iChannel0 = Image(imgattrs)
    local p = Pixel({R=0,G=0,B=0,A=0})
    iChannel0:Fill(p)
  end

  local dst = Image {IMG_Like = iChannel0, IMG_DeferAlloc = true}


  if req:IsPreCalc() then
    print("precalc")
    local out = Image({IMG_Like = dst, IMG_NoData = true})
    OutImage:Set(req, out)
    return
  end

  -------------- Parameter für DCTL-Code ---------------------
  local framerate = self.Comp:GetPrefs("Comp.FrameFormat.Rate")

  local params = {}

  params = node:GetParamBlock(ShaderParameters)


  local mouse =  nil

  params.mouse_x = 0
  params.mouse_y = 0

  mouse  = InMouseXY:GetValue(req)

  if (mouse ~= nil) then
		params.mouse_x = mouse.X * Width
		params.mouse_y = mouse.Y * Height
	end

	params.mouse_z = 0
	params.mouse_w = 0

  mouse  = InMouseZW:GetValue(req)

  if (mouse ~= nil) then
		params.mouse_z = mouse.X * Width
		params.mouse_w = mouse.Y * Height
	end



  params.frequency        = InFrequency:GetValue(req).Value
  params.iTime            = req.Time / framerate

  for i=0,5 do
    for j=0,3 do
      params.color[i][j] = InColor[i][j]:GetValue(req).Value
    end
  end

  params.width  = dst.Width
  params.height = dst.Height
--params.width            = iChannel0.DataWindow:Width()
--params.height           = iChannel0.DataWindow:Height()

  params.compOrder        = iChannel0:IsMask() and 1 or 15
  params.iChannel0_width  = iChannel0.Width
  params.iChannel0_height = iChannel0.Height

  node:SetParamBlock(params)

--node:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR,TEX_ADDRESS_MODE_BORDER, TEX_NORMALIZED_COORDS_TRUE)
  node:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR,TEX_ADDRESS_MODE_BORDER, TEX_NORMALIZED_COORDS_TRUE)
	node:AddInput("iChannel0",iChannel0)
	node:AddOutput("dst", dst)

  if rebuild then
    node:ForceRebuild()
  end

  local ok = node:RunSession(req)

	if (not ok) then
		dst = nil
    print("--- Errors ---")
    dump(node:GetErrorLog())
	end


  -- Output our result
  OutImage:Set(req,dst)
  collectgarbage();

end



-------------------------------------------------------------------------------------------------------------------------------------------
-- Callback to handle UI control events.
--
function NotifyChanged(inp, param, time)
	if inp ~= nil and param ~= nil then

		if (inp == InReloadCodeButton) then
			if (param.Value == 1) then
        verbose("NotifyChanged: reload button pressend")
        InRebuildCheckBox:SetSource(Number(1),0)
      end
    end

		if (inp == InFileToUseCombo) then
      verbose("NotifyChanged: file to use changed - set flag for a rebuild")
      InRebuildCheckBox:SetSource(Number(1),0)
    end

	end
end
