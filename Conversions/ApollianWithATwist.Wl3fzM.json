{"Shader":{"ver":"0.1","info":{"id":"Wl3fzM","date":"1612391093","viewed":3820,"name":"Apollian with a twist","username":"mrange","description":"License CC0: Apollian with a twist\nPlaying around with apollian fractal\n","likes":145,"published":3,"flags":0,"usePreview":0,"tags":["2d","apollian"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"id":37,"channel":0}],"code":"\/\/ License CC0: Apollian with a twist\n\/\/ Playing around with apollian fractal\n\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define L2(x)           dot(x, x)\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PSIN(x)         (0.5+0.5*sin(x))\n\nvec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 \/ 3.0, 1.0 \/ 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat apollian(vec4 p, float s) {\n  float scale = 1.0;\n\n  for(int i=0; i<7; ++i) {\n    p        = -1.0 + 2.0*fract(0.5*p+0.5);\n\n    float r2 = dot(p,p);\n    \n    float k  = s\/r2;\n    p       *= k;\n    scale   *= k;\n  }\n  \n  return abs(p.y)\/scale;\n}\n\nfloat weird(vec2 p) {\n  float z = 4.0;\n  p *= ROT(TIME*0.1);\n  float tm = 0.2*TIME;\n  float r = 0.5;\n  vec4 off = vec4(r*PSIN(tm*sqrt(3.0)), r*PSIN(tm*sqrt(1.5)), r*PSIN(tm*sqrt(2.0)), 0.0);\n  vec4 pp = vec4(p.x, p.y, 0.0, 0.0)+off;\n  pp.w = 0.125*(1.0-tanh(length(pp.xyz)));\n  pp.yz *= ROT(tm);\n  pp.xz *= ROT(tm*sqrt(0.5));\n  pp \/= z;\n  float d = apollian(pp, 1.2);\n  return d*z;\n}\n\nfloat df(vec2 p) {\n  const float zoom = 0.5;\n  p \/= zoom;\n  float d0 = weird(p);\n  return d0*zoom;\n}\n\nvec3 color(vec2 p) {\n  float aa   = 2.0\/RESOLUTION.y;\n  const float lw = 0.0235;\n  const float lh = 1.25;\n\n  const vec3 lp1 = vec3(0.5, lh, 0.5);\n  const vec3 lp2 = vec3(-0.5, lh, 0.5);\n\n  float d = df(p);\n\n  float b = -0.125;\n  float t = 10.0;\n\n  vec3 ro = vec3(0.0, t, 0.0);\n  vec3 pp = vec3(p.x, 0.0, p.y);\n\n  vec3 rd = normalize(pp - ro);\n\n  vec3 ld1 = normalize(lp1 - pp);\n  vec3 ld2 = normalize(lp2 - pp);\n\n  float bt = -(t-b)\/rd.y;\n  \n  vec3 bp   = ro + bt*rd;\n  vec3 srd1 = normalize(lp1-bp);\n  vec3 srd2 = normalize(lp2-bp);\n  float bl21= L2(lp1-bp);\n  float bl22= L2(lp2-bp);\n\n  float st1= (0.0-b)\/srd1.y;\n  float st2= (0.0-b)\/srd2.y;\n  vec3 sp1 = bp + srd1*st1;\n  vec3 sp2 = bp + srd2*st1;\n\n  float bd = df(bp.xz);\n  float sd1= df(sp1.xz);\n  float sd2= df(sp2.xz);\n\n  vec3 col  = vec3(0.0);\n  const float ss =15.0;\n  \n  col       += vec3(1.0, 1.0, 1.0)*(1.0-exp(-ss*(max((sd1+0.0*lw), 0.0))))\/bl21;\n  col       += vec3(0.5)*(1.0-exp(-ss*(max((sd2+0.0*lw), 0.0))))\/bl22;\n  float l   = length(p);\n  float hue = fract(0.75*l-0.3*TIME)+0.3+0.15;\n  float sat = 0.75*tanh(2.0*l);\n  vec3 hsv  = vec3(hue, sat, 1.0);\n  vec3 bcol = hsv2rgb(hsv);\n  col       *= (1.0-tanh(0.75*l))*0.5;\n  col       = mix(col, bcol, smoothstep(-aa, aa, -d));  \n  col       += 0.5*sqrt(bcol.zxy)*(exp(-(10.0+100.0*tanh(l))*max(d, 0.0)));\n\n  return col;\n}\n\nvec3 postProcess(vec3 col, vec2 q)  {\n  col=pow(clamp(col,0.0,1.0),vec3(1.0\/2.2)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  \/\/ contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  \/\/ saturation\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  \/\/ vigneting\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord\/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x\/RESOLUTION.y;\n  \n  vec3 col = color(p);\n  col = postProcess(col, q);\n  \n  fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}}