{"Shader":{"ver":"0.1","info":{"id":"fdGfW1","date":"1658064939","viewed":1157,"name":"HardSurface Sphere [2]","username":"tdhooper","description":"Tiling the sphere with triangle voronoi patterns, polished version of [url]https:\/\/www.shadertoy.com\/view\/fsKBRR[\/url]","likes":65,"published":3,"flags":32,"usePreview":1,"tags":["voronoi","geodesic"],"hasliked":0},"renderpass":[{"inputs":[{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":37,"channel":0}],"code":"\/\/#define SHOW_DATA\n\/\/#define GREEN_BG\n\n#if HW_PERFORMANCE==1\n#define AA 2\n#endif\n\n#define PI 3.14159265359\n#define PHI 1.618033988749895\n\n\/\/ HG_SDF\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n\/\/ Rotate on axis\n\/\/ blackle https:\/\/suricrasia.online\/demoscene\/functions\/\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax,p)*ax, p, cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat unlerp(float low, float high, float value) {\n    return (value - low) \/ (high - low);\n}\n\n\n\/\/ --------------------------------------------------------\n\/\/ Icosahedral domain mirroring\n\/\/ knighty https:\/\/www.shadertoy.com\/view\/MsKGzw\n\/\/ \n\/\/ Also get the face normal, and tangent planes used to\n\/\/ calculate the uv coordinates later.\n\/\/ --------------------------------------------------------\n\n#define PI 3.14159265359\n\nint Type=5;\nvec3 nc;\nvec3 pab;\nvec3 pbc;\nvec3 pca;\n\nvoid init() {\n    float cospin=cos(PI\/float(Type)), scospin=sqrt(0.75-cospin*cospin);\n    nc=vec3(-0.5,-cospin,scospin);\n    pbc=vec3(scospin,0.,0.5);\n    pca=vec3(0.,scospin,cospin);\n    pbc=normalize(pbc);\n    pca=normalize(pca);\n\tpab=vec3(0,0,1);\n    pca *= 0.794654;\n    pab *= 0.850651;\n}\n\nvoid fold(inout vec3 p) {\n\tfor(int i=0;i<Type;i++){\n\t\tp.xy = abs(p.xy);\n        p -= 2. * min(0., dot(p,nc)) * nc;\n\t}\n}\n\n\nfloat vmin(vec3 v) {\n    return min(v.x, min(v.y, v.z));\n}\n\nfloat vmax(vec3 v) {\n    return max(v.x, max(v.y, v.z));\n}\n\nvec2 triTile(vec2 p)\n{ \n    vec2 hx = p * mat2(1,-1.\/1.73, 0,2.\/1.73);\n    vec3 g = vec3(hx, 1.-hx.x-hx.y);\n    vec3 id = floor(g);\n    g = fract(g); \n    if (length(g) > 1.) g = 1. - g;\n    vec3 axis = primaryAxis(g);\n    float y = -(1.\/3. - vmin(g));\n    float x = (vmax((1.-axis.yzx) * g) - vmax((1.-axis) * g)) * cos(1. \/ (PI \/ 3.));\n    return vec2(x,y);\n}\n\n\/\/ --------------------------------------------------------\n\/\/ Modelling\n\/\/ --------------------------------------------------------\n\nstruct Model {\n    float d;\n    vec3 col;\n    vec3 emissive;\n    int id;\n    bool isBound;\n};\n\nfloat smin(float a, float b, float k){\n    float f = clamp(0.5 + 0.5 * ((a - b) \/ k), 0., 1.);\n    return (1. - f) * a + f  * b - f * (1. - f) * k;\n}\n\nfloat smax(float a, float b, float k) {\n    return -smin(-a, -b, k);\n}\n\nfloat cmin(float a, float b, float r) {\n\treturn min(min(a, b), (a - r + b)*sqrt(0.5));\n}\n\nfloat cmax(float a, float b, float r) {\n\treturn max(max(a, b), (a + r + b)*sqrt(0.5));\n}\n\n\nfloat pReflect(inout vec3 p, vec3 planeNormal, float offset, float soft) {\n    float t = dot(p, planeNormal)+offset;\n    float tr = sqrt(t * t + soft);\n    p = p + (-t + tr) * planeNormal;\n    return sign(t);\n}\n\n\nModel map(vec3 p) {\n    p.z*= -1.;\n    p = erot(p, normalize(pca), fract(gTime \/ gDuration \/ gSpeed + .2) * PI * 2. * (1.\/3.));\n\n    float r = 2.;\n\n    vec3 col = normalize(p) * .5 + .5;\n    \n    vec3 face, ab, atob;\n\n    fold(p);\n    \n    pReflect(p, vec3(1,0,0), 0., .0001);\n    pReflect(p, vec3(0,1,0), 0., .0001);\n    pReflect(p, normalize(vec3(-1,-1.6,.615)), 0., .0001);\n    \n    face = pca;\n    atob = pbc - pab;\n    ab = pab;\n    \n    vec3 vv = normalize(face - ab);\n    vec3 uu = normalize(atob);\n    vec3 ww = face;\n    mat3 m = mat3(uu,vv,ww);\n       \n    vec3 pp = p \/ dot(p, face);\n    \n    vec2 uv = (pp * m).xy;\n    \n    col = vec3(uv * vec2(1,-1), 0);\n     \n    float d = length(p) - 2.;\n    \n    vec4 data = texture(iChannel0, uv * vec2(1,-1) * vec2(1,2.));\n    float border = data.r * r * .66;\n    float tile = data.b;\n    int id = int(data.g);\n    float mask = data.a;\n\n    float o = mix(-.25, .0, pow(tile\/2., .5));\n   \n    float ito = ((linearstep(.2, .6 + o, tFract(gTime)) - pow(linearstep(.8 + o, .9 + o, tFract(gTime)), 4.)));\n \n    if (tile == 1.) {\n        ito *= -1.;\n    }\n\n    float inn = mix(.1, .4, tile\/2.);\n    \n    ito *= .06;\n    r += ito;\n       \n    float ws = 1.;\n    float w = mix(.025, .1, mod(tile + 1., 3.) \/ 2.) * ws;\n\n    \n    float d0 = d;\n    \n    vec2 p2 = vec2(border, length(p) - r);\n    d = p2.y;\n    d = smin(d, dot(p2 - vec2(.005,0), normalize(vec2(-2.6,1))), .005);\n    d = smax(d, p2.y - inn * .4, .005);\n\n    if (id == 0) {\n        float ii = mix(.25, .04, tile\/3.);\n        if (tile == 2.) {\n            d = cmax(d, -(abs(border - .2)), .01);\n        }\n    }\n    else\n    {\n       d = smax(d, dot(p2 - vec2(.1, inn * .4), normalize(vec2(1,1))), .005);\n       d = cmin(d, max(d - .01, (abs(border - .1))), .01);\n    }\n    \n    d = max(d, -(border - w \/ 6.));\n        \n    border *= 1.5;\n    inn *= 1.5;\n    \n    col = vec3(.6);\n    \n    if (id == 1 && tile == 1.) {\n        col *= .4;\n    }\n    \n    if (id == 1 && tile == 0.) {\n        col *= .7;\n    }\n    \n    if (id == 1 && tile == 2.) {\n        col *= 1.1;\n    }\n\n    col = mix(col, vec3(.15), (1.-smoothstep(.01 * ws*1.5, .04*ws*1.5, abs(border * 6. - inn))));\n    \n    ito= max(ito, 0.);\n    col = mix(col, vec3(0), smoothstep(r + .025 - ito, r - .025 - ito, length(p)) * step(border, w + .01));\n        \n    col *= clamp(border * 5. + .7, 0., 1.);\n    \n    \n    vec3 emissive = vec3(0);\n    if (tile == 1.) {\n        float l = (1. - clamp(abs(border - .2) * 100., 0., 1.)) * 2.;\n        l += (1. - clamp(abs(border - .2) * 15., 0., 1.)) * .1;\n        emissive += vec3(0,.8,.5) * l;\n        \n        float lt = tFract(gTime - .4);\n        float ramp = 1. - linearstep(.025, .07, lt);\n        ramp += linearstep(.8, .9, lt);\n        ramp *= mix(1., sin(lt * 150.) * .5 + .5, linearstep(1.2, .9, lt));\n        \n        emissive *= ramp;\n    }\n    \n    col *= .95;\n    \n    if (id == 1) {\n        col *= .4;\n    }\n    \n    return Model(d, col, emissive, id, false);\n}\n\nModel mapDebug(vec3 p) {\n    Model m = map(p);\n    return m;\n    \n    float d = -p.z;\n    m.d = max(m.d, -d);\n    d = abs(d) - .01;\n    if (d < m.d) {\n        return Model(d, vec3(0), vec3(0), 9, false);\n    }\n    return m;\n}\n\n\n\/\/ --------------------------------------------------------\n\/\/ Rendering\n\/\/ --------------------------------------------------------\n\nfloat vmul(vec2 v) {\n    return v.x * v.y;\n}\n\n\/\/ compile speed optim from IQ https:\/\/www.shadertoy.com\/view\/Xds3zN\nvec3 calcNormal(vec3 pos){\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).d;\n    }\n    return normalize(n);\n}\n\nmat3 calcLookAtMatrix(vec3 ro, vec3 ta, vec3 up) {\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww,up));\n    vec3 vv = normalize(cross(uu,ww));\n    return mat3(uu, vv, ww);\n}\n\n\/\/ origin sphere intersection\n\/\/ returns entry and exit distances from ray origin\nvec2 iSphere( in vec3 ro, in vec3 rd, float r )\n{\n\tvec3 oc = ro;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - r*r;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return vec2(-1.0);\n\th = sqrt(h);\n\treturn vec2(-b-h, -b+h );\n}\n\nvec3 render( vec2 p )\n{\n\n    vec2 tuv = p;\n    \n    \/\/tuv *= .333;\n    \/\/pR(tuv, PI \/ 12.);\n    vec3 col = (vec3(.8) - p.y * .33) * .65;\n    float w = fwidth(length(p)) \/ 2.;\n\n    #ifndef LOOP\n    float k = 1. \/ length(tuv) * 1.25;\n    tuv = vec2(k, atan(tuv.x\/tuv.y) * 1.101) * 1.;\n    #ifdef LOOP2\n    tuv += vec2(0,1) * fract(gTime \/ gDuration \/ gSpeed + .2) * 1.73;\n    #else\n    tuv += vec2(-.25,.5) * gTime * .25 * .5;\n    #endif\n    tuv = triTile(tuv);\n    vec4 data = texture(iChannel0, tuv * vec2(1,-1) * vec2(1,2.) * 1.43);\n    \n    float lp = length(p) - .05;\n    \n    float ga = smoothstep(.9, 1.1, lp);\n    ga *= smoothstep(1.9, 1.1, lp);\n    ga = .01 * ga - .005;\n\n    float gb = smoothstep(.6, 1., lp);\n    gb *= smoothstep(1.5, 1., lp);\n    gb = .01 * gb - .005;\n    \n\n    float g = smoothstep(ga + w, ga - w, abs(data.x));\n    g += smoothstep(gb + w, gb - w, abs(data.x - .1));\n    \n    col += vec3(0,.8,.5) * g;\n\n    \/\/col = vec3(.03);\n    \n    float e = unlerp(1.7, .95, length(p));\n    e = mix(.2, .00, e);\n    \/\/e = .06;\n    \n    \/\/data.r \/= k;\n\n    float ms = smoothstep(1.8, .9, length(p));\n    col += vec3(1) * step(e, data.r) * .15 * ms;\n    #else\n    col = vec3(.5);\n    #endif\n    \n    #ifdef GREEN_BG\n    col *= vec3(0,.8,.5) * 1.8;\n    #endif\n    \n    \/\/col = mix(col, vec3(1,0,0), clamp(unlerp(1., .75, length(p)), 0., 1.));\n    \n    \n    \/\/return vec3(1) * step(data.x, .01);\n    \n    vec3 camPos = vec3(0,0,9);\n    \n    vec2 im = iMouse.xy \/ iResolution.xy - .5;\n    \n    if (iMouse.x <= 0.)\n    {\n        im = vec2(0);\n    }\n    \n    im += vec2(.66,.3);\n    \n    pR(camPos.yz, (.5 - im.y) * PI \/ 2.);\n    pR(camPos.xz, (.5 - im.x) * PI * 1.5);\n    \n    mat3 camMat = calcLookAtMatrix(camPos, vec3(0), vec3(0,1,0));\n    \n    float focalLength = 3.;\n    vec3 rayDirection = normalize(camMat * vec3(p.xy, focalLength));\n    \n    vec2 bound = iSphere(camPos, rayDirection, 2.3);\n    if (bound.x < 0.) {\n    \treturn col;\n    }\n\n    \n    vec3 rayPosition = camPos;\n    float rayLength = 0.;\n    Model model;\n    float dist = 0.;\n    bool bg = false;\n    float closestPass = 1e12;\n\n    for (int i = 0; i < 100; i++) {\n        rayLength += dist * .9;\n        rayPosition = camPos + rayDirection * rayLength;\n        model = mapDebug(rayPosition);\n        dist = model.d;\n        \n        if ( ! model.isBound) {\n            closestPass = min(closestPass, dist);\n        }\n        \n        if (abs(dist) < .001) {\n        \tbreak;\n        }\n        \n        if (rayLength > 15.) {\n            bg = true;\n            break;\n        }\n    }\n    \n\n    \n    if ( ! bg) {\n        col = model.col;\n        vec3 nor = calcNormal(rayPosition);\n        \n        vec3 lin = vec3(0);\n        \n        vec3 rd = rayDirection;\n        vec3 lig = normalize(vec3(-.1,1,-.1));\n        vec3 hal = normalize(lig - rd );\n\n        float dif, spe;\n\n        dif = clamp(dot(lig, nor) * .75 + .4, 0., 1.);\n        dif += sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 )) * .5;\n        spe = pow(clamp(dot(nor, normalize(lig - rd)), 0., 1.), 100.);\n        spe *= dif;\n        spe *= .04 + .96 * pow(clamp(1. - dot(hal, lig), 0., 1.), 5.);\n        lin += 1.3 * col * dif;\n        lin += 6. * spe;\n        \n        lig = normalize(vec3(.5,-1,.5));\n        hal = normalize(lig - rd );\n        \n        dif = clamp(dot(lig, nor), 0., 1.);        \n        spe = pow(clamp(dot(nor, normalize(lig - rd)), 0., 1.), 100.);\n        spe *= dif;\n        spe *= .04 + .96 * pow(clamp(1. - dot(hal, lig), 0., 1.), 5.);       \n        float m = clamp(dot(lig, normalize(rayPosition)) + 1., 0., 1.) * 1.5;\n        lin += 1. * col * dif * vec3(0,.8,.5) * m;\n        lin += 6. * spe * vec3(0,.8,.5) * m;\n        \n        col = lin;\n                \n        col += model.emissive;\n        \n        if (model.id == 9) {\n           col = vec3(1,.5,.5) * fract(map(rayPosition).d * 20.);\n        }\n    }\n    else\n    {\n        col = mix(col, vec3(.1), smoothstep(.015 + w*2., .015 - w*2., closestPass));\n    }\n    \n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    initTime(iTime);\n\n    #ifdef SHOW_DATA\n        vec4 data = texture(iChannel0, fragCoord.xy \/ iResolution.xy);\n        data.x = fract(data.x * 100.);\n        fragColor = data;\n        return;\n    #endif\n    \n    init();\n    \n    vec2 o = vec2(0);\n    vec3 col = vec3(0);\n\n    \/\/ AA from iq https:\/\/www.shadertoy.com\/view\/3lsSzf\n    #ifdef AA\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n    \to = vec2(float(m),float(n)) \/ float(AA) - 0.5;\n    \tfloat d = 0.5*vmul(sin(mod(fragCoord.xy * vec2(147,131), vec2(PI * 2.))));\n    #endif\n\t\t\n    \tvec2 p = (-iResolution.xy + 2. * (fragCoord + o)) \/ iResolution.y;\n    \tcol += render(p);\n        \n    #ifdef AA\n    }\n    col \/= float(AA*AA);\n    #endif\n    \n    \/\/ colour grading from tropical trevor's scripts\n    \/\/ https:\/\/github.com\/trevorvanhoof\/ColorGrading\n    vec3 uGain = vec3(.0);\n    vec3 uLift = vec3(.2);\n    vec3 uOffset = vec3(-.225);\n    vec3 uGamma = vec3(.3);\n    col = pow(max(vec3(0.0), col * (1.0 + uGain - uLift) + uLift + uOffset), max(vec3(0.0), 1.0 - uGamma));\n    col = pow( col, vec3(1.\/2.2) );\n    \n    fragColor = vec4(col, 0);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":30,"src":"\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":257,"channel":0}],"code":"\n#define PI 3.14159265359\n\nmat3 scaleM(float s) {\n    return mat3(\n        s, 0, 0,\n        0, s, 0,\n        0, 0, 1\n    );\n}\n\nmat3 rotM(float a) {\n    return mat3(\n        cos(a), sin(a), 0,\n        -sin(a), cos(a), 0,\n        0, 0, 1\n    );\n}\n\nmat3 transM(vec2 v) {\n    return mat3(\n        1, 0, v.x,\n        0, 1, v.y,\n        0, 0, 1\n    );\n}\n\nvec2 mul(vec2 p, mat3 m) {\n   return (vec3(p, 1) * m).xy;\n}\n\nvoid calcAngleOffset(float tf, float ts, out float angle, out vec2 offset) {\n    float time = tf + ts;\n    angle = time;\n    offset = vec2(0, time);\n    \n    #ifndef LOOP\n    #ifndef LOOP2\n    return;\n    #endif\n    #endif\n    \n    float to = timeOffset \/ timeGap;\n\n    angle = 0.;\n    if (mod(tf, 3.) == 2.) {\n        angle += mod(tf, 3.) + ts * -2.;\n    } else{\n        angle += mod(tf, 3.) + ts;\n    }\n    angle *= 1.;\n    angle += to;\n\n    vec3 ba = max(vec3(0), mod(vec3(tf + 2., tf + 1., tf), 3.) - 1.);\n    vec3 bb = max(vec3(0), mod(vec3(tf + 3., tf + 2., tf + 1.), 3.) - 1.);\n    vec3 bary = mix(ba, bb, ts);\n    offset = bary.x * vec2(0,0) + bary.y * vec2(-1.,-.3) + bary.z * vec2(.3,-.333);\n\n    offset.y += to;\n}\n\nmat3 gridTransformation(out float scale) {\n    float tf = tFloor(gTime);\n    float ts = easeSnap(linearstep(.3, .8, tFract(gTime)));\n\n    scale = 2.5;\n        \n    float angle;\n    vec2 offset;\n    calcAngleOffset(tf, ts, angle, offset);  \n\n    mat3 m = scaleM(scale);\n    m *= rotM(PI * -.08 * angle);\n    m *= transM(offset * -.78);\n    return m;\n}\n\nmat3 gridTransformation2(out float scale) {\n    float tf = tFloor(gTime);\n    float ts = easeOutBack(linearstep(.6, .9, tFract(gTime)), 1.70158);\n    \n    scale = 3.5;\n   \n    float angle;\n    vec2 offset;\n    calcAngleOffset(tf, ts, angle, offset);  \n\n    mat3 m = scaleM(scale);\n    m *= rotM(PI * -.08 * angle * .5);\n    m *= rotM(PI * 2.\/3.);\n    m *= transM((offset * -0.78 * .5).yx);\n    return m;\n}\n\nfloat effectMask(vec2 uv) {\n    return sin(length(uv) * 12. + 1.) * .5 + .5;\n}\n\n\/\/ --------------------------------------------------------\n\/\/ Triangle Voronoi\n\/\/ tdhooper https:\/\/www.shadertoy.com\/view\/ss3fW4\n\/\/ iq https:\/\/shadertoy.com\/view\/ldl3W8\n\/\/ --------------------------------------------------------\n\nfloat vmax(vec3 v) {\n    return max(v.x, max(v.y, v.z));\n}\n\nconst float s3 = sin(PI \/ 3.);\n\nvec3 sdTriEdges(vec2 p) {\n    return vec3(\n        dot(p, vec2(0,-1)),\n        dot(p, vec2(s3, .5)),\n        dot(p, vec2(-s3, .5))\n    );\n}\n\nfloat sdTri(vec2 p) {\n    vec3 t = sdTriEdges(p);\n    return max(t.x, max(t.y, t.z));\n}\n\nfloat sdTri(vec3 t) {\n    return max(t.x, max(t.y, t.z));\n}\n\nfloat sdBorder(vec3 tbRel, vec2 pt1, vec2 pt2) {\n    \n    vec3 axis = primaryAxis(-tbRel);\n    bool isEdge = axis.x + axis.y + axis.z < 0.;\n\n    vec2 gA = vec2(0,-1);\n    vec2 gB = vec2(s3, .5);\n    vec2 gC = vec2(-s3, .5);\n    \n    vec2 norA = gC * axis.x + gA * axis.y + gB * axis.z;\n    vec2 norB = gB * -axis.x + gC * -axis.y + gA * -axis.z;\n    \n    vec2 dir = gA * axis.x + gB * axis.y + gC * axis.z;\n    vec2 corner = dir * dot(dir, pt1 - pt2) * 2.\/3.;\n        \n    vec2 ca, cb;\n    float side;\n    \n    if (isEdge) {\n        corner = pt2 + corner;\n        ca = corner + max(0., dot(corner, -norB)) * norB;\n        cb = corner + min(0., dot(corner, -norA)) * norA;\n    } else {\n        corner = pt1 - corner;\n        ca = corner + max(0., dot(corner, -norA)) * norA;\n        cb = corner + min(0., dot(corner, -norB)) * norB;\n    }\n    \n    side = step(dot(corner, dir * mat2(0,-1,1,0)), 0.);\n    corner = mix(ca, cb, side);\n    \n    float d = length(corner);\n\n    return d;\n}\n\nvec2 hash2( vec2 p )\n{\n\treturn textureLod( iChannel0, (p+0.5)\/256.0, 0.0 ).xy;\n}\n\nvec2 cellPoint(vec2 n, vec2 f, vec2 cell, bool gaps) {\n    vec2 coord = n + cell;\n    vec2 o = hash2( n + cell );\n    if (gaps && hash2(o.yx * 10.).y > .5) {\n        return vec2(1e12);\n    }\n    #ifdef ANIMATE\n        o = 0.5 + 0.5*sin( time * PI * 2. + 6.2831*o );\n    #endif\t\n    vec2 point = cell + o - f;\n    return point;\n}\n\nvec4 voronoi(vec2 x, bool gaps)\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    \/\/----------------------------------\n    \/\/ first pass: regular voronoi\n    \/\/----------------------------------\n\tvec2 closestCell, closestPoint;\n\n    const int reach = 3;\n\n    float closestDist = 8.0;\n    for( int j = -reach; j <= reach; j++ )\n    for( int i = -reach; i <= reach; i++ )\n    {\n        vec2 cell = vec2(i, j);\n        vec2 point = cellPoint(n, f, cell, gaps);\n        float dist = vmax(sdTriEdges(point));\n\n        if( dist < closestDist )\n        {\n            closestDist = dist;\n            closestPoint = point;\n            closestCell = cell;\n        }\n    }\n\n\n    \/\/----------------------------------\n    \/\/ second pass: distance to borders\n    \/\/----------------------------------\n    closestDist = 8.0;\n    for( int j = -reach-1; j <= reach+1; j++ )\n    for( int i = -reach-1; i <= reach+1; i++ )\n    {\n        vec2 cell = closestCell + vec2(i, j);\n        vec2 point = cellPoint(n, f, cell, gaps);\n\n        vec3 triEdges = sdTriEdges(closestPoint - point);\n        float dist = vmax(triEdges);\n\n        if( dist > 0.00001 ) {\n            closestDist = min(closestDist, sdBorder(triEdges, closestPoint, point));\n        }\n    }\n\n    return vec4(closestDist, closestCell + n, 0.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initTime(iTime);\n\n    vec2 uv = fragCoord.xy \/ iResolution.xy;\n    uv *= vec2(1,-1);\n    uv.y \/= 2.;\n    \n    if (uv.x > uv.y * -2.) {\n        fragColor = vec4(0);\n        return;\n    }\n\n    float scl;\n    mat3 m = gridTransformation(scl);\n\n    vec4 v = voronoi(mul(uv, m), false);\n    float d = v.x \/ scl;\n    vec2 localPt = v.yz;\n    vec2 worldPt = mul(localPt, inverse(m));\n    vec2 seed = hash2(localPt);\n    float id = 0.;\n    float tile = mod(localPt.x + localPt.y, 3.);\n\n    if (tile == 0.)\n    {\n        m = gridTransformation2(scl);\n        v = voronoi(mul(uv, m), false);\n        d = min(d, v.x \/ scl);\n        localPt = v.yz;\n        worldPt = mul(localPt, inverse(m));\n        seed = hash2(localPt + seed * 10.);\n        id = 1.;\n        tile = mod(localPt.x + localPt.y, 3.);\n    }\n\n    float mask = effectMask(worldPt);\n    \n    fragColor = vec4(d, id, tile, mask);\n}\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\/\/#define LOOP\n\/\/#define LOOP2\n\n\/\/ skaplun https:\/\/www.shadertoy.com\/view\/7tf3Ws\nfloat easeOutBack(float x, float t) {\n    float c1 = t;\n    float c3 = c1 + 1.;\n\n    return 1. + c3 * pow(x - 1., 3.) + c1 * pow(x - 1., 2.);\n}\n\nfloat easeInOutBack(float x) {\n    float c1 = 1.70158;\n    float c2 = c1 * 1.525;\n\n    return x < .5\n      ? (pow(2. * x, 2.) * ((c2 + 1.) * 2. * x - c2)) \/ 2.\n      : (pow(2. * x - 2., 2.) * ((c2 + 1.) * (x * 2. - 2.) + c2) + 2.) \/ 2.;\n}\n\nfloat easeSnap(float x) {\n    x = pow(x, .75);\n    x = easeInOutBack(x);\n    return x;\n}\n\nfloat linearstep(float a, float b, float t) {\n    return clamp((t - a) \/ (b - a), 0., 1.);\n}\n\n#ifdef LOOP\nfloat timeOffset = (92. + 100.) * (3.\/4.);\nfloat timeGap = 3.;\n#else\n#ifdef LOOP2\n    float timeOffset = (92. + 100.);\n    float timeGap = 4.;\n#else\n    float timeOffset = (92. + 100.);\n    float timeGap = 4.;\n#endif\n#endif\n\nfloat gTime;\nfloat gDuration;\nfloat gSpeed;\n\nvoid initTime(float time) {\n    gTime = time;\n    gSpeed = 1.;\n    gDuration = 14.;\n    \n    #ifdef LOOP\n    gSpeed = 1.5;\n    gDuration = (3. * timeGap) \/ gSpeed; \/\/ 6\n    gTime \/= gDuration;\n    gTime = fract(gTime);\n    gTime *= gDuration;\n    gTime *= gSpeed;\n    gTime += .25;\n    #endif\n    \n    #ifdef LOOP2\n    gSpeed = 1.;\n    gDuration = (3. * timeGap) \/ gSpeed; \/\/ 12\n    gTime \/= gDuration;\n    gTime = fract(gTime);\n    gTime *= gDuration;\n    gTime *= gSpeed;\n    \/\/gTime += .25;\n    #endif\n}\n\nfloat tFloor(float time) {\n    time += timeOffset;\n    time -= timeGap \/ 3.;\n    return floor(time \/ timeGap);\n}\n\nfloat tFract(float time) {\n    time += timeOffset;\n    time -= timeGap \/ 3.;\n    return fract(time \/ timeGap) * timeGap * .5;\n}\n\nvec3 primaryAxis(vec3 p) {\n    vec3 a = abs(p);\n    return (1.-step(a.xyz, a.yzx))*step(a.zxy, a.xyz)*sign(p);\n}","name":"Common","description":"","type":"common"}]}}