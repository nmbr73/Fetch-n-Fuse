{"Shader":{"ver":"0.1","info":{"id":"7dlBRs","date":"1645872734","viewed":68,"name":"spqr: blackle gated domain 8","username":"spqr","description":"a","likes":3,"published":3,"flags":0,"usePreview":0,"tags":["a"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"id":37,"channel":0}],"code":"\/\/CC0 1.0 Universal https:\/\/creativecommons.org\/publicdomain\/zero\/1.0\/\n\/\/To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n\n\/\/returns a vector pointing in the direction of the closest neighbouring cell\n\n#define saturate(a) (clamp((a),0.,1.))\nmat2 rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c,s,-s,c);\n}\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\n\/\/ 3d noise function\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\n\/\/ fbm noise for 2-4 octaves including rotation per octave\nfloat fbm( vec3 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p );\n\tp = m*p*2.02;\n    f += 0.2500*noise( p ); \n\tp = m*p*2.03;\n    f += 0.1250*noise( p );\n\tp = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f\/0.9375;\n}\nfloat box(vec3 p,vec3 s)\n{\n  vec3 d=abs(p)-s;\n  return length(max(d,0.));\n}\n\n\n\nfloat hash(float a, float b) {\n    return fract(sin(a*1.2664745 + b*.9560333 + 3.) * 14958.5453);\n}\n\n\n\nfloat tick (float t){\n    float i = floor(t);\n    float r = fract(t);\n    r = smoothstep(0.,1.,r);\n    r = smoothstep(0.,1.,r);\n    r = smoothstep(0.,1.,r);\n    r = smoothstep(0.,1.,r);\n    \n    return i + r;\n}\n\nfloat tock (float t){\n    float i = floor(t);\n    float r = fract(t);\n    r = smoothstep(0.,1.,r);\n  \n    \n    return i + r;\n}\n\nfloat ball;\n#define MOD3 vec3(.1031,.11369,.13787)\n\n\/\/value noise hash\nfloat hash31(vec3 p3)\n{\n\tp3  = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return -1.0 + 2.0 * fract((p3.x + p3.y) * p3.z);\n}\nvec3 randomdir (float n) {\n    return fract(vec3(5.1283,9.3242,13.8381) * hash(n) * 8421.4242);\n}\nfloat glow = 0.;\nfloat sph(vec3 p,float r) {\n    return length(p) -r ;\n}\nfloat cyl (vec2 p, float r){\n    return length(p) - r;\n}\nfloat map(vec3 p) {\n\n    \/\/geo\n    \n\n    float tt = iTime * .3;\n    vec3 q = p;\n    \n    \/\/ wierd skylights\n    q.yz *= rot(.42);\n    q.xz *= rot(.4);\n  \n    q.xy *= rot(q.z\/50.);\n    q.x += tt * 10.;\n    q.xz = mod( q.xz, 40.) - 20.;\n  \n    float uu = cyl(q.xz,.001);\n    glow += .04\/(.1+pow(uu,1.8));\n    \n    float domain = 1.4;\n  ;\n   \n    \n    vec3 id = floor((p*.1)\/domain);\n     vec3 id2 = floor((p)\/domain);\n    p = mod(p,domain) - domain\/2.;\n    \n    float thresh = fbm(id);\n    \n    float rando = hash31(id2);\n\n\n   \n    vec3 flit = vec3(.04);\n    flit.xz *= rot(rando*5.1+tt*2.3);\n    flit.yz *= rot(rando*4.2+tt*1.4);\n    flit.xy *= rot(rando*3.3+tt*1.1);\n   \n    \/\/vec3 flit = randomdir(hash31(id)) * .2;\n    \n    \n    vec3 jitter = flit * sin((tt*9.1+rando*12.1));\n  \n    \n   \n    \n    \/\/(.5)hash(float(id)) * vec3(.5) * sin(iTime*6.+3.*hash(float(id)));\n    \n    if (  rando *.6< thresh) {\n\n        p = abs(p);\n        if (p.x > p.y) p.xy = p.yx;\n        if (p.y > p.z) p.yz = p.zy;\n        if (p.x > p.y) p.xy = p.yx;\n        p.z -= domain;\n        \/\/return length(p)-1.;\n        \n        float u = box(p + jitter, vec3(.4));\n      \n        return min(uu,u*.5);\n        \n    } else {\n        \/\/return length(p)-1.;\n        float u = box(p + jitter, vec3(.4));\n       \n        return min(uu,u*.5);\n    }\n \n}\n\n\nvec3 norm(vec3 p,vec2 d)\n{\n  return normalize(vec3(\n    map(p+d.yxx)-map(p-d.yxx),\n    map(p+d.xyx)-map(p-d.xyx),\n    map(p+d.xxy)-map(p-d.xxy)\n  ));\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.01);\n    return normalize(map(p) - vec3( map(k[0]),map(k[1]),map(k[2]) ));\n}\n\n\nconst float PI = acos(-1.);\n\nvec3 pixel_color(vec2 uv) {\n   \n  \/\/ nav\n\n    float tt = iTime ;\n    vec3 jump = vec3(0) * tick(tt*.05)*77.2;\n    jump.xz *= rot(tt*.00001);\n  \n    \n    vec3 s = vec3(10.,3.2,7.1)*tt*.18 + jump;\n    vec3 arm = vec3(1,0,0);\n    arm.xz *= rot(sin(tt* .19));\n    arm.yz *= rot(sin(tt*.23));\n    \/\/arm.yx *= rot(sin(tt*.28));\n    \n    vec3 t = s + arm;\n    \n \n \n  \n  vec3 cz=normalize(t-s);\n  vec3 cx=normalize(cross(cz,vec3(0,1,0)));\n  vec3 cy=-normalize(cross(cz,cx));\n  cz -= dot(uv,uv)\/15.;\n  vec3 r=normalize(cx*uv.x+cy*uv.y+cz);\n \n\n    \n    vec3 p = s;\n    bool hit = false;\n  \n    float d;\n    float i;\n    float dd = 0.;\n    \/\/ray marching\n    for ( i = 0.; i < 1500.; i++) {\n        \n        d = map(p);\n        d = abs(d);\n        if ( d < .001) {\n           hit = true;\n           break;\n        }\n        if (dd>10000.) { break;}\n        \n        dd += d;\n        p+=d*r;\n    }\n\n \n \n  \n  vec3 col = vec3(.8, .5, .2);\n  \/\/col = vec3(.1,.1,.2)*1.;\n\n  \n  float ao = pow(1. - i\/500.,6.);\n  col *= ao;\n  col += glow*.6;\n  \n  vec3 light = normalize(vec3(1));\n  vec3 n = norm(p);\n \/\/ if ( dot(light,n) < 0.) { light = -light;}\n  float spec =pow(max(dot(reflect(-light,n),-r),0.),40.) * 10.;\n  col += spec * .1;\n   float diff = max(0., dot(n,light)*.5 +.5);\n   col *= diff;\n  vec3 n2 = norm(p, vec2(0.0, 1E-2 ));\/\/ + 3E-2*.01) );\n  vec3 n1 = norm(p, vec2(0.0, 2.3E-2) );\n\n\n  float edge = saturate(length(n1-n2)\/0.1);\n  \n  if ( edge > 0.01) {\n      col = vec3(0);\n  }\n  \n  \n    \n  if (! hit){\n      col = vec3(0);\n   \n  }\n\n\n\n  return col; \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)\/iResolution.y;\n    fragColor = vec4(0);\n    fragColor += vec4(pixel_color(uv), 1.);\n  \tfragColor.xyz = sqrt(fragColor.xyz\/fragColor.w);\n}\n\n\/*\n  \n  \/\/float uniformity = (sin(iTime*.01)*.5 + .5) * 10. + 5.;\n  float uniformity = 15.;\n  vec3 hue = 1.-sin(p\/uniformity);\n\n  vec3 light =normalize(vec3(60,10,10));\n  if ( dot(light,n) < 0.) { light = -light;}\n\n  float diff = max(0., dot(n,light)*.5 +.5);\n \n  float spec =pow(max(dot(reflect(-light,n),-r),0.),40.) * 10.;\n  vec3 fog = vec3(0);\n \n \/\/ vec3 col = mix(spec * 0.2 + hue * ( diff ),fog, min(fren,.8));\n  vec3 col = mix(spec * 0.2 + hue * ( diff ),fog,.5);\n  \n  col = mix(col,fog,1. - exp(-.000003*dd*dd*dd));\n*\/","name":"Image","description":"","type":"image"}]}}