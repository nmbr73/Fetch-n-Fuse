{"Shader":{"ver":"0.1","info":{"id":"7lsBzl","date":"1651344333","viewed":20,"name":"Shader of Life","username":"Yetman","description":"Yet another implementation of Conway's Game of Life.","likes":4,"published":3,"flags":48,"usePreview":0,"tags":["2d","conway","gameoflife","multipass","automaton"],"hasliked":0},"renderpass":[{"inputs":[{"id":258,"src":"\/media\/previz\/buffer01.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":37,"channel":0}],"code":"\/\/ -------------------------------------------------------------------\n\/\/ Shader of Life: Yet Another Implementation of Conway's Game of Life\n\/\/ -------------------------------------------------------------------\n\n\/\/ Buffer A: (Inputs: iChannel0 <- Buffer A)\n\/\/   Implements of Conway's Game of Life and handles the user input.\n\/\/   To keep thing interesting over time, the liveness of the border cells are drived by a pseudo random function.\n\/\/\n\/\/ Buffer B: (Inputs: iChannel0 <- Buffer A, iChannel1 <- Buffer B)\n\/\/   Keeps track of the energy left behind in each cell.\n\/\/   If the texel's energy is 1.0, it contains a live cell.\n\/\/   If the cell dies, the texel's energy dissipate over time.\n\/\/\n\/\/ Image: (Inputs: iChannel0 <- Buffer B)\n\/\/   Maps the cell energy to a fragment color.\n\n\/\/ -------------------------------------------------------------------\n\n\/\/ User Interactions:\n\/\/  - Hold the mouse button and drag to add live cells\n\/\/  - Press space to kill all the cells.\n\n\/\/ -------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ procedural palette generation: https:\/\/iquilezles.org\/articles\/palettes\/\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.2, 1.3, 1.5);\n    vec3 d = vec3(0.00, 0.10, 0.20);\n    \n    float energy = texelFetch(iChannel0, ivec2(fragCoord), 0).r;\n    vec3 color = a + b * cos(radians(360.0) * (c * energy + d));\n    fragColor.rgb = energy * color;\n    fragColor.a = 1.0;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":33,"src":"\/presets\/tex00.jpg","ctype":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":257,"channel":0}],"code":"\/\/ Random Noise: https:\/\/gist.github.com\/patriciogonzalezvivo\/670c22f3966e662d2f83\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\n\/\/ The probability that a texel at the border (or inside the brush) will be live\n#define EMERGE_PROP 0.25\n#define BRUSH_RADIUS 10.0\n\n#define SPACE_ASCII 32\n#define JUST_PRESSED 1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    \/\/ Press Space to bring the Apocalypse.\n    if(texelFetch(iChannel1, ivec2(SPACE_ASCII, JUST_PRESSED), 0).x != 0.0)\n    {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        return;\n    }\n\n    ivec2 coord = ivec2(fragCoord);\n    ivec2 resolution = ivec2(iResolution.xy);\n    \n    if(\n        coord.y == 0 || coord.y == resolution.y - 1 ||coord.x == 0 || coord.x == resolution.x - 1 ||\n        (iMouse.z > 0.0 && iMouse.w < 0.0 && distance(iMouse.xy, fragCoord) <= BRUSH_RADIUS)\n    ){\n        fragColor = vec4(step(rand(vec2(fragCoord.x + iTime, fragCoord.y - iTime)), EMERGE_PROP));\n        return;\n    }\n    \n    \n    const int NEIGHBOR_COUNT = 8;\n\n    const ivec2 NEIGHBORS[NEIGHBOR_COUNT] = ivec2[NEIGHBOR_COUNT](\n        ivec2(-1, -1), ivec2( 0, -1), ivec2( 1, -1),\n        ivec2(-1,  0),                ivec2( 1,  0),\n        ivec2(-1,  1), ivec2( 0,  1), ivec2( 1,  1)\n    );\n\n    int count = 0;\n    for(int index = 0; index < NEIGHBOR_COUNT; index++)\n    {\n        count += int(texelFetch(iChannel0, coord + NEIGHBORS[index], 0).r != 0.0);\n    }\n\n    bool result = texelFetch(iChannel0, coord, 0).r != 0.0;\n    if(result)\n    { \/\/ Alive\n        if(count < 2 || count > 3) result = false; \/\/ Death due to under- or over-population\n    } \n    else \n    { \/\/ Dead\n        if(count == 3) result = true; \/\/ Birth of a new cell\n    }\n\n    fragColor = vec4(result);\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":258,"src":"\/media\/previz\/buffer01.png","ctype":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":258,"channel":0}],"code":"\/\/ How fast the energy in a texel dissipates after the cell dies\n#define DISSIPATION_RATE 0.01\n\n\/\/ Inputs:\n\/\/  iChannel 0 <- Buffer A ... The Game of Life 2D grid of live cells.\n\/\/  iChannel 1 <- Buffer B ... The Energy left behind by the last live cell that occupied the texel.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 coord = ivec2(fragCoord);\n    fragColor = texelFetch(iChannel0, coord, 0) + (1.0 - DISSIPATION_RATE) * texelFetch(iChannel1, coord, 0);\n    fragColor = min(vec4(1.0), fragColor); \/\/ Clamp the energy value to avoid values > 1.0\n}","name":"Buffer B","description":"","type":"buffer"}]}}