{"Shader":{"ver":"0.1","info":{"id":"4s3fDH","date":"1524863948","viewed":2171,"name":"I Have a Question!","username":"wyatt","description":"Here is my question: \nHow is it that in between the vertex and fragment shader of a graphics program, the hardware is able to rasterize millions of triangles in parallel? \nThis just seems like an impossible task and always feels like magic.","likes":69,"published":3,"flags":0,"usePreview":0,"tags":["triangles","reflections"],"hasliked":0},"renderpass":[{"inputs":[{"id":26,"src":"\/media\/a\/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","ctype":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":37,"channel":0}],"code":"#define pi 3.1415927\n#define phi 1.61803398875\nmat3 rot (vec3 u) {\n\t\tvec3 s = sin(u), c = cos(u);\n\t\tmat3 x = mat3(1,0,0, \t\t0,c.x,s.x, \t\t0,-s.x,c.x);\n\t\tmat3 y = mat3(c.y,0,s.y, \t0,1,0, \t\t\t-s.y,0,c.y);\n\t\tmat3 z = mat3(s.z,c.z,0,\t-c.z,s.z,0,\t\t0,0,1);\n\t\treturn x*y*z;}\nvoid tri (vec3 p, vec3 d, mat3 tr, inout vec4 col, inout float depth, inout vec3 norm) {\n    vec3 n = normalize(cross(tr[1]-tr[0],tr[2]-tr[0]));\n    if (dot(n,-d)<0.) n *= -1.;\n    mat3 nn = mat3(\n    \tnormalize(cross(n,tr[2]-tr[1])),\n    \tnormalize(cross(n,tr[0]-tr[2])),\n    \tnormalize(cross(n,tr[1]-tr[0]))\n    );\n    vec3 w = p - tr[0];\n    float x = -dot(w,n)\/dot(d,n);\n    if (x < 0.) return;\n    vec3 i = p + d*x;\n    vec3 ipol = vec3(dot(nn[0],i-tr[1]),dot(nn[1],i-tr[2]),dot(nn[2],i-tr[0]))\/vec3(dot(nn[0],tr[0]-tr[1]),dot(nn[1],tr[1]-tr[2]),dot(nn[2],tr[2]-tr[0]));\n    vec4 c = vec4(1);\n    c.w *= step(0.,ipol.x);\n    c.w *= step(0.,ipol.y);\n    c.w *= step(0.,ipol.z);\n    if (c.w==0.) return;\n    if (x < depth) {\n        vec3 u = normalize(reflect(p-i,n));\n        c.xyz = texture(iChannel0,u).xyz*abs(u)-1.+smoothstep(0.02,0.025,ipol.x)*smoothstep(0.02,0.025,ipol.y)*smoothstep(0.02,0.025,ipol.z);\n        col=c;\n        depth = x;\n        norm = n;\n    }\n}\nvoid sph (vec3 p, vec3 d, vec4 cr, inout vec4 col, inout float depth, inout vec3 norm) {\n\tvec3 w = p-cr.xyz;\n    float B = 2.*dot(w,d);\n    float C = dot(w,w)-cr.w*cr.w;\n    float dl = B*B-4.*C;\n    if (dl < 0.) return;\n    float x = 0.5*(-B-sqrt(dl));\n    if (x < 0.) return;\n    vec3 i = p + d*x;\n    vec4 c = vec4(1);\n    if (x < depth) {\n        norm = normalize(i-cr.xyz);\n        vec3 r = normalize(reflect(p-i,norm));\n    \tc.xyz = abs(r)*texture(iChannel0,r).xyz;\n    \tcol = c;\n        depth = x;\n        \n    }\t\n}\nvoid scene (inout vec3 p, inout vec3 d, inout vec4 col, float i) {\n\tfloat depth = 1e3;\n    vec3 norm=vec3(0);\n    vec4 c = vec4(0);\n    float t = iTime\/pi;\n    for (int i = 0; i < 4; i++) {\n        tri(p,d,\n            rot(pi*float(i)*vec3(1,0,0)*2.\/4.)*mat3(\n               \t4,0,0,\n                0,4,0,\n                0,0,4\n            )\n        ,c,depth,norm);\n    \ttri(p,d,\n            rot(pi*float(i)*vec3(1,0,0)*2.\/4.)*mat3(\n               \t-4,0,0,\n                0,-4,0,\n                0,0,-4\n            )\n        ,c,depth,norm);\n        tri(p,d,\n            rot(vec3(t,0,0)+pi*float(i)*vec3(1,0,0)*2.\/4.)*mat3(\n               \t1,0,0,\n                0,1,0,\n                0,0,1\n            )\n        ,c,depth,norm);\n        tri(p,d,\n            rot(vec3(t,0,0)+pi*float(i)*vec3(1,0,0)*2.\/4.)*mat3(\n               \t-1,0,0,\n                0,-1,0,\n                0,0,-1\n            )\n        ,c,depth,norm);\n        \n        sph (p,d,vec4(sin(t+float(i)),cos(t+float(i)),sin(phi*t+float(i*i)),.2), c, depth, norm);\n    } \n    p = p + d*depth;\n    d = reflect(d,norm);\n    p += 0.0001*d;\n    col += 0.6*c\/(1.+0.3*i);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ((fragCoord)\/iResolution.xy*2.-1.)*iResolution.xy\/iResolution.yy;\n\tmat3 m = rot(vec3(1,2,3)*0.1*iTime);\n    vec3 p = m*vec3(0,0,-2);\n    vec3 d = m*normalize(vec3(uv,2));\n    \n    vec4 col = vec4(0,0,0,0);\n    \n    for (int i = 0; i < 10; i++) scene (p,d,col,float(i));\n    \n    \n    fragColor = col;\n}","name":"Image","description":"","type":"image"}]}}