{"Shader":{"ver":"0.1","info":{"id":"NtcyDn","date":"1659531971","viewed":547,"name":"Wednesday messing around","username":"mrange","description":"CC0: Wednesday messing around\nTinkered a bit with an earlier shader\nThought while similar it turned out distinct enough to share\n","likes":43,"published":3,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"id":37,"channel":0}],"code":"\/\/ CC0: Wednesday messing around\n\/\/ Tinkered a bit with an earlier shader\n\/\/ Thought while similar it turned out distinct enough to share\n\n#define COLORBURN\n#define SKYDOME\n#define PERIOD        10.0\n\n#define PI            3.141592654\n#define ROT(a)        mat2(cos(a), sin(a), -sin(a), cos(a))\n\nconst int   bars     = 7;\nconst mat2  trans    = ROT(PI\/9.0);\nconst float twist    = 1.0;\nconst float dist     = 0.5;\nconst float rounding = 0.125;\n\nconst float raymarchFactor = 0.8;\n\n#define TAU         (2.0*PI)\n#define TIME        iTime\n#define RESOLUTION  iResolution\n\n#define MAX_RAY_LENGTH  15.0\n#define MAX_RAY_MARCHES 70\n#define TOLERANCE       0.001\n#define NORM_OFF        0.005\n\nint g_hit     = 0;\nint g_period  = 0;\n\n\/\/ License: WTFPL, author: sam hocevar, found: https:\/\/stackoverflow.com\/a\/17897228\/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 \/ 3.0, 1.0 \/ 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n\/\/ License: WTFPL, author: sam hocevar, found: https:\/\/stackoverflow.com\/a\/17897228\/418488\n\/\/  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nvec3 band_color(float ny) {\n  vec3 hsv = vec3(0.0);\n  float ramp = 1.0\/abs(ny);\n  if (abs(ny) < 4.0) {\n    hsv = vec3(0.0, 0.0, 0.);\n  } else if (ny > 0.0) {\n    hsv = vec3(0.88, 2.5*ramp,0.8);\n  } else {\n    hsv = vec3(0.53, 4.0*ramp, 0.8);\n  }\n\n  return hsv2rgb(hsv);\n}\n\n\/\/ License: MIT, author: Inigo Quilez, found: https:\/\/iquilezles.org\/www\/articles\/distfunctions2d\/distfunctions2d.htm\nfloat box(vec2 p, vec2 b, vec4 r) {\n  r.xy = (p.x>0.0)?r.xy : r.zw;\n  r.x  = (p.y>0.0)?r.x  : r.y;\n  vec2 q = abs(p)-b+r.x;\n  return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\nfloat fadeIn(float x) {\n  return mix(-0.1, 1.0, smoothstep(-0.9, -0.5, -cos(-0.1*x+TAU*TIME\/PERIOD)));\n}\n\nfloat df_bars1(vec3 p) {\n  p.y += dist*sin(0.5*p.x+0.5*p.z+TIME);\n  vec2 bp = p.zy;\n  \n  float d = 1E6;\n\n  float bs = 0.25*fadeIn(p.x);\n  vec2 bsz = vec2(bs);\n  vec4 brd = vec4(bs*rounding);\n\n  for (int i = 0; i < bars; ++i) {\n    float ii = float(i);\n    vec2 pp = bp;\n    float a = -TIME+0.5*ii;\n    float b = ii+p.x-2.0*TIME;\n    pp.y += sin(a);\n    mat2 rot = ROT(-PI\/4.0*cos(a+twist*b));\n    pp.x -= bsz.x*sqrt(2.0)*ii; \n    pp *= rot;\n    float dd = box(pp, bsz, brd);\n    if (dd < d) {\n      g_hit = i;\n      d = dd;\n    }\n  }\n  \n  return d; \n}\n\nfloat df_bars2(vec3 p) {\n  p.y += 0.5*dist*sin(-0.9*p.x+TIME);\n  vec2 p2 = p.yz;\n  p2 *= ROT(TIME+p.x);  \n  vec2 s2 = sign(p2);\n  p2 = abs(p2);\n  p2 -= 0.3;\n  g_hit = 3+int(s2.y+2.0*s2.x)-1;\n  float bs = 0.25*fadeIn(p.x);\n  vec2 bsz = vec2(bs);\n  vec4 brd = vec4(bs*rounding);\n  return length(p2)-bs;\n}\n\nfloat df_bars3(vec3 p) {\n  const float r = 0.25;\n  p.y += 0.5*dist*sin(-0.9*p.x+TIME);\n  mat2 rot = ROT(TIME+p.x);\n  vec2 p2 = p.yz;\n  vec2 s2 = vec2(0.0);\n\n  p2 *= rot;\n  s2 += 2.0*sign(p2);\n  p2 = abs(p2);\n  p2 -= 2.0*r;\n\n  p2 *= rot;\n  s2 += 1.0*sign(p2);\n  p2 = abs(p2);\n  p2 -= 1.0*r;\n\n  g_hit = 3+int(s2.y+2.0*s2.x)-1;\n\n  float bs = (0.9*r)*fadeIn(p.x);\n  vec2 bsz = vec2(bs);\n  vec4 brd = vec4(bs*rounding);\n  float d0 = length(p2)-bs;\n  float d1 = box(p2, bsz, brd);\n  float d = d0;\n  return d;\n}\n\nfloat df_bars4(vec3 p) {\n  p.y += 0.5*dist*sin(-0.9*p.x+TIME);\n  vec2 p2 = p.yz;\n  p2 *= ROT(TIME+p.x);  \n  vec2 s2 = sign(p2);\n  p2 = abs(p2);\n  p2 -= 0.3;\n  g_hit = 3+int(s2.y+2.0*s2.x)-1;\n\n  float bs = 0.25*fadeIn(p.x);\n\n  vec2 bsz = vec2(bs);\n  vec4 brd = vec4(bs*rounding);\n  return box(p2, bsz, brd);\n}\n\nfloat df(vec3 p) {\n  p.xy *= trans;\n  switch(g_period) {\n  case 0:\n    return df_bars1(p);\n  case 1:\n    return df_bars2(p);\n  case 2:\n    return df_bars3(p);\n  case 3:\n    return df_bars4(p);\n  default:\n    return length(p) - 0.5;\n  }\n}\n\nfloat rayMarch(vec3 ro, vec3 rd, float ti) {\n  float t = ti;\n  int i = 0;\n  vec2 dti = vec2(1e10,0.0);\n  for (i = 0; i < MAX_RAY_MARCHES; i++) {\n    float d = df(ro + rd*t);\n    if (d < TOLERANCE || t > MAX_RAY_LENGTH) break;\n    if (d<dti.x) { dti=vec2(d,t); }\n    t += raymarchFactor*d;\n  }\n  if(i==MAX_RAY_MARCHES) { t=dti.y; }\n  return t;\n}\n\nvec3 normal(vec3 pos) {\n  vec2  eps = vec2(NORM_OFF,0.0);\n  vec3 nor;\n  nor.x = df(pos+eps.xyy) - df(pos-eps.xyy);\n  nor.y = df(pos+eps.yxy) - df(pos-eps.yxy);\n  nor.z = df(pos+eps.yyx) - df(pos-eps.yyx);\n  return normalize(nor);\n}\n\nconst vec3 lightPos = vec3(2.0, 3.0, -5.0); \nconst vec3 lightCol = vec3(HSV2RGB(vec3(0.53, 0.5, 1.0)));\nconst vec3 overCol  = vec3(HSV2RGB(vec3(0.88, 0.25, 0.8)));\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  vec3  ld    = normalize(lightPos - ro);\n  float dif   = max(dot(ld, rd), 0.0);\n\n  vec3  col   = vec3(0.0);\n\n  if ((rd.y > abs(rd.x)*1.0) && (rd.y > abs(rd.z*0.25))) { \n    col = 2.0*overCol*rd.y;\n  }\n  float rb = length(max(abs(rd.xz\/max(0.0,rd.y))-vec2(0.9, 4.0),0.0))-0.1;\n\n  col += overCol*pow(clamp(1.0 - rb*0.5, 0.0, 1.0), 6.0);\n  col += lightCol*pow(dif, 8.0);\n  col += 4.0*lightCol*pow(dif, 40.0);\n  return col;\n}\n\nvec3 effect(vec2 p) {\n  vec3 ro = vec3(0.0, 0.0, -5.0);\n  vec3 la = vec3(0.0, 0.0, 0.0);\n  vec3 ww = normalize(la-ro);\n  vec3 uu = normalize(cross(vec3(0.0,1.0,0.0), ww ));\n  vec3 vv = normalize(cross(ww,uu));\n  const float fov = 3.0;\n  vec3 rd = normalize(-p.x*uu + p.y*vv + fov*ww );\n\n  g_hit = -1;\n  float t = rayMarch(ro, rd, 3.0);\n  int hit = g_hit;\n  \n  vec3 col = vec3(1.0);\n  vec3 bcol = band_color(-4.0*float(hit-(bars-1)\/2));\n  bcol *= bcol;\n  if (t < MAX_RAY_LENGTH) {\n    vec3 p = ro + rd*t;\n    vec3 n = normal(p);\n    vec3 r = reflect(rd, n);\n    vec3 ld= normalize(lightPos-p);\n  \n    float dif = max(dot(ld, n), 0.0);\n    col = bcol*mix(0.5, 1.0, dif);\n#ifdef SKYDOME    \n    vec3 rs= skyColor(p, r);\n    float fre = 1.0+dot(rd, n);\n    fre *= fre;\n    float rf  = mix(0.05, 1.0, fre);\n    col += rf*rs;\n    \/\/ Just some fine-tuning, don't judge me\n    col += smoothstep(0.5, 1.0, fre)*max(n.y, 0.0);\n#else   \n    float spe = pow(max(dot(ld, r), 0.0), 30.0);\n    col += spe;\n#endif    \n  }\n  \n  return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord\/RESOLUTION.xy;\n  vec2 p  = -1. + 2. * q;\n  p.x     *= RESOLUTION.x\/RESOLUTION.y;\n  g_period = int(mod(1.0+floor(TIME\/PERIOD), 4.0));\n\n  vec3 col  = effect(p);\n#if defined(COLORBURN)  \n  col -= vec3(0.2, 0.3, 0.2);\n#endif  \n  col = clamp(col, 0.0, 1.0);\n  col = sqrt(col);\n  fragColor = vec4(col, 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}}