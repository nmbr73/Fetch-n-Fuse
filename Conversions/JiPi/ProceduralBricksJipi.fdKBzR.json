{
 "ver": "0.1",
 "info": {
  "id": "fdKBzR",
  "date": "0",
  "viewed": 0,
  "name": "Procedural Bricks JiPi",
  "description": "I'll try to refactor this someday",
  "likes": 0,
  "published": "Private",
  "usePreview": 0,
  "tags": [
   "procedural",
   "texture"
  ],
  "hasliked": 0,
  "parentid": "NdtBRB",
  "parentname": "Procedural Bricks"
 },
 "renderpass": [
  {
   "inputs": [],
   "outputs": [
    {
     "id": "4dfGRr",
     "channel": 0
    }
   ],
   "code": "#define PI 3.1415926535\n#define SQRT2 1.4142135624\n\n#define CAM_FOV_DEG 45.0\nconst float CAM_DIST = 1.0/tan(CAM_FOV_DEG * 0.5 * PI / 180.0);\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n\nfloat lerp(float a, float b, float t) {\n    t = saturate(t);\n    return (1.0-t)*a + t*b;\n}\n\nvec3 lerp(vec3 a, vec3 b, float t) {\n    t = saturate(t);\n    return (1.0-t)*a + t*b;\n}\n\nbool intersectXYPlane(vec3 org, vec3 dir, inout float dist) {\n    const float epsilon = 1e-6;\n    vec3 normal = vec3(0.0, 0.0, 1.0);\n\n    float denom = dot(-normal, dir); \n    if (denom > epsilon) { \n        dist = dot(-org, -normal) / denom; \n        return (dist >= 0.0); \n    } \n \n    return false; \n}\n\nfloat hash(vec2 p) {\n\treturn 2.0*fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453)-1.0;   \n}\n\nvec2 hash2(vec2 P) {\n \treturn fract(cos(P*mat2(-64.2,71.3,81.4,-29.8))*8321.3); \n}\n\nfloat noise(vec2 p) {\n    vec2 id = floor(p);\n    vec2 u = fract(p);\n    \n    float a = hash(id+vec2(0,0));\n    float b = hash(id+vec2(1,0));\n    float c = hash(id+vec2(0,1));\n    float d = hash(id+vec2(1,1));\n    \n    u = u*u*u*(u*(6.0*u-15.0)+10.0);\n    \n    float k0 = a;\n    float k1 = b-a;\n    float k2 = c-a;\n    float k3 = a-b-c+d;\n    \n    return k0 + k1*u.x + k2*u.y + k3*u.x*u.y;       \n}\n\nfloat fbm(in vec2 p, int octaves) {\n    const float scale_y = 2.0;\n    const float scale_xz = 0.125;\n    const mat2 rot = mat2(0.8, 0.6, -0.6, 0.8);\n    \n    p *= scale_xz;\n\n    float res = 0.0;\n    mat2 M = mat2(1.0);\n    \n    float A = 1.0, a = 1.0;\n    \n    for (int i=1; i<=octaves; i++) {\n        res += A*noise(a*M*p);\n        \n        a *= 2.0;\n        A *= 0.5;\n        M *= rot;\n    }\n    \n    return scale_y*res;\n}\n\nfloat edge_noise(vec2 p, float grid_size) {\n    vec2 q = p - mod(p, vec2(grid_size));\n    \n    vec2 res = vec2(SQRT2*grid_size);\n    \n    vec2 first, second;\n    \n    for (int i=-1; i<=1; i++) {\n        for (int j=-1; j<=1; j++) {\n            vec2 v = q + grid_size * vec2(i,j);\n            vec2 rand = v + grid_size*hash2(v);\n            \n            float d = length(p-rand);\n            \n            if (d < res.y) {\n                res.x = res.y;\n                res.y = d;\n                second = first;\n                first = rand;\n            }\n            \n            else if (d < res.x) {\n                res.x = d;\n                second = rand;\n            }\n        }\n    }\n    \n    float dist = dot(0.5*(first+second) - p, normalize(second-first));\n    \n    return dist/(SQRT2 * grid_size);\n}\n\nfloat stains(vec2 p) {    \n    const float scale = 33.0;\n    float wy = saturate(0.7+0.1*fbm(scale*p, 8));\n    \n    \n    return smoothstep(0.7, 0.75, wy - 0.07);\n}\n\nfloat cracks(vec2 p) {\n    const float scale = 50.0;\n    const vec2 offset = vec2(5.2, 1.3);\n    \n    p += 0.015 * vec2(fbm(scale*p, 5), fbm(scale*(p+offset), 5));\n\n    const float grid_size = 0.04;\n    float we = edge_noise(p, grid_size);\n    we = 1.0 - smoothstep(0.0, 0.06, we);\n    \n    return saturate( (0.44 + fbm(66.0*p, 3)) * we);\n}\n\nvec2 brickCoords(vec2 uv, vec2 dims, float offset) {\n    if (int(floor(uv.y/dims.y)) % 2 == 0)\n        uv += vec2(offset*dims.x, 0.0);\n\n    return dims * mod(uv/dims, 1.0);\n}\n\nfloat brick_id(vec2 uv) {\n    const vec2 dims = vec2(0.3, 0.1);\n    const float offset = 0.5;\n\n    if (int(floor(uv.y/dims.y)) % 2 == 0)\n        uv += vec2(offset*dims.x, 0.0);\n        \n    vec2 ts = floor(uv/dims);\n    return hash(ts);\n}\n\nfloat brickHeightmap(vec2 uv, vec2 dims, float offset, vec2 edge){\n    vec2 ts = brickCoords(uv, dims, offset);\n    \n    float x = smoothstep(0.0, edge.x, ts.x) * smoothstep(dims.x, dims.x-edge.x, ts.x);\n    float y = smoothstep(0.0, edge.y, ts.y) * smoothstep(dims.y, dims.y-edge.y, ts.y);\n    \n    return x*y;\n}\n\n#define MAT_BRICK 0\n#define MAT_MORTAR 1\n\nfloat Heightmap(vec2 uv, inout int mat_id) {\n    //brick params\n    const vec2 dims = vec2(0.3, 0.1);\n    const float offset = 0.5, height = 1.1;\n    const vec2 edge = vec2(0.017);\n    //brick noise params\n    const float scale = 100.0, strength = 0.15;\n    const int octaves = 4;\n    //mortar params\n    const float m_scale = 100.0, m_strength = 0.25, m_base = 0.4;\n    const int m_octaves = 5;\n    \n    float mortar_height = m_base + m_strength * fbm(m_scale*uv, m_octaves);\n    \n    float brick_noise = strength * fbm(scale*uv, octaves);\n    float brick_height = height * brickHeightmap(uv, dims, offset, edge) + brick_noise;\n    brick_height -= 0.1*cracks(uv);\n    \n    if (brick_height > mortar_height) {\n        mat_id = MAT_BRICK;\n        return brick_height;\n    }\n    \n    else {\n        mat_id = MAT_MORTAR;\n        return mortar_height;\n    }\n}\n\nvec3 normal(vec2 uv) {\n    const float smoothness = 0.1;\n    const vec2 h = vec2(0.0, 0.001);\n    int id;\n\n    float dx = Heightmap(uv + h.yx, id) - Heightmap(uv - h.yx, id);\n    float dy = Heightmap(uv + h.xy, id) - Heightmap(uv - h.xy, id);\n             \n    return normalize(vec3(-dx, -dy, smoothness));   \n}\n\nvec3 albedo(vec2 uv) {\n    int id = MAT_BRICK;\n    float height = Heightmap(uv, id);\n    \n    vec3 col = vec3(0.0);\n    \n    if (id == MAT_BRICK) {\n        float darkening = 0.25 * abs(brick_id(uv));\n        col = vec3(0.6, 0.3, 0.1) - vec3(darkening);\n    }\n        \n    else if (id == MAT_MORTAR) {\n        col = vec3(0.70, 0.66, 0.58);\n    }\n    \n    float s = stains(uv);\n    float s2 = stains(uv + vec2(7.25, 3.73));\n    \n    col = lerp(col, s2*vec3(0.22), s2 - 0.25);\n    col = lerp(col,  s*vec3(0.66), s  - 0.25);\n    \n    return col;\n}\n\nfloat light(vec3 pos, vec3 norm, vec3 dir) {\n    vec3 l_pos = vec3(-0.2, -0.2, 1.0);\n    \n    vec3 dif = l_pos - pos;\n    \n    float attenuation = dot(dif, dif);\n    \n    dif = normalize(dif);\n    \n    vec3 R = reflect(dif, norm);\n    float spec = 0.1 * pow(saturate(dot(dir, R)), 5.0);\n    \n    return (spec + saturate(dot(dif, norm)))/attenuation;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n\n    vec3 ray_org = vec3(0.0, 0.0, 1.0);\n    vec3 ray_dir = normalize(vec3(uv, -CAM_DIST));\n    \n    vec3 col = vec3(0.0);\n    \n    float dist = 0.0;\n    if (intersectXYPlane(ray_org, ray_dir, dist)) {\n        vec3 hit = ray_org + dist * ray_dir;\n        \n        vec3 norm = normal(hit.xy);\n        col = albedo(hit.xy) * vec3(light(hit, norm, ray_dir));\n    }\n    \n    fragColor = vec4(col,1.0);\n}",
   "name": "Image",
   "description": "",
   "type": "image"
  }
 ]
}