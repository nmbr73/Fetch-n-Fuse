{
 "ver": "0.1",
 "info": {
  "id": "stsBRS",
  "date": "0",
  "viewed": 0,
  "name": "HAPPY2016 JiPi964",
  "description": "Happy 2016 my fellow shadertoyers! Use the mouse to rotate. Use the defines to change number of particles etc. It needs a pretty beastly GPU. But if you have one, then put fullscreen, and enjoy! ;)",
  "likes": 0,
  "published": "Private",
  "usePreview": 0,
  "tags": [
   "bokeh",
   "fireworks",
   "sparkles",
   "2016",
   "newyears"
  ],
  "hasliked": 0,
  "parentid": "lsd3RX",
  "parentname": "HAPPY 2016!"
 },
 "renderpass": [
  {
   "inputs": [
    {
     "id": "Xsf3Rr",
     "filepath": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg",
     "type": "texture",
     "channel": 1,
     "sampler": {
      "filter": "mipmap",
      "wrap": "repeat",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    },
    {
     "id": "4sf3Rr",
     "filepath": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png",
     "type": "texture",
     "channel": 0,
     "sampler": {
      "filter": "mipmap",
      "wrap": "repeat",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    }
   ],
   "outputs": [],
   "code": "// \"HAPPY 2016!\" by Martijn Steinrucken aka BigWings - 2015\n// countfrolic@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Email:countfrolic@gmail.com Twitter:@The_ArtOfCode\n\n// Use these to change the effect\n\n// if you have a kick ass GPU then double both of these\n#define NUM_SPARKLES 75.\n#define NUM_SUB_SPARKLES 3.\n\n#define SUB_SPARKLE_CHANCE .4\n#define PRIMARY_PARTICLE_COLOR vec3(1., 0.8, 0.5)\n#define SECONDARY_PARTICLE_COLOR vec3(1., 0.5, 0.3)\n#define MOTION_BLUR_AMOUNT 0.04\n#define SLOW_MOTION_SPEED .05\n#define SLOWMO_CYCLE_DURATION 20.\n#define NORMAL_MOTION_SPEED .9\n#define DOF vec2(1., 1.5)\n#define MIN_CAM_DISTANCE 1.5\n#define MAX_CAM_DISTANCE 7.\n\n\n\n\nfloat CAMERA_DISTANCE;\n\n\n#define PI 3.1415\n#define S(x,y,z) smoothstep(x,y,z)\n#define B(x,y,z,w) S(x-z, x+z, w)*S(y+z, y-z, w)\n#define saturate(x) clamp(x,0.,1.)\nfloat dist2(vec2 P0, vec2 P1) { vec2 D=P1-P0; return dot(D,D); }\nfloat DistSqr(vec3 a, vec3 b) { vec3 D=a-b; return dot(D, D); } \n\nconst vec3 up = vec3(0.,1.,0.);\nconst float pi = 3.141592653589793238;\nconst float twopi = 6.283185307179586;\n\nvec4 Noise401( vec4 x ) { return fract(sin(x)*5346.1764); }\nvec4 Noise4( vec4 x ) { return fract(sin(x)*5346.1764)*2. - 1.; }\nfloat Noise101( float x ) { return fract(sin(x)*5346.1764); }\n\n#define MOD3 vec3(.1031,.11369,.13787)\n//  3 out, 1 in... DAVE HOSKINS\nvec3 hash31(float p) {\n   vec3 p3 = fract(vec3(p) * MOD3);\n   p3 += dot(p3, p3.yzx + 19.19);\n   return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\nfloat hash12(vec2 p){\n\tvec3 p3  = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nstruct ray {\n    vec3 o;\n    vec3 d;\n};\nray e;\t\t\t\t// the eye ray\n\nstruct camera {\n    vec3 p;\t\t\t// the position of the camera\n    vec3 forward;\t// the camera forward vector\n    vec3 left;\t\t// the camera left vector\n    vec3 up;\t\t// the camera up vector\n\t\n    vec3 center;\t// the center of the screen, in world coords\n    vec3 i;\t\t\t// where the current ray intersects the screen, in world coords\n    ray ray;\t\t// the current ray: from cam pos, through current uv projected on screen\n    vec3 lookAt;\t// the lookat point\n    float zoom;\t\t// the zoom factor\n};\ncamera cam;\n\nmat4 CamToWorldMatrix(camera c) {\n\tvec3 x = c.left;\n    vec3 y = c.up;\n    vec3 z = c.forward;\n    vec3 p = c.p;\n    \n    return mat4( \n        x.x, x.y, x.z, 0.,\n        y.x, y.y, y.z, 0.,\n        z.x, z.y, z.z, 0.,\n        p.x, p.y, p.z, 1.\n    );\n}\nmat4 WorldToCamMatrix(camera c) {\n\tvec3 x = c.left;\n    vec3 y = c.up;\n    vec3 z = c.forward;\n    vec3 p = c.p;\n    \n   return mat4( \n        x.x, y.x, z.x, -dot(x, p),\n        x.y, y.y, z.y, -dot(y, p),\n        x.z, y.z, z.z, -dot(z, p),\n         0.,  0.,  0.,          0.\n    );\n}\n\nvoid CameraSetup(vec2 uv, vec3 position, vec3 lookAt, float zoom) {\n\t\n    cam.p = position;\n    cam.lookAt = lookAt;\n    cam.forward = normalize(cam.lookAt-cam.p);\n    cam.left = cross(up, cam.forward);\n    cam.up = cross(cam.forward, cam.left);\n    cam.zoom = zoom;\n    \n    cam.center = cam.p+cam.forward*cam.zoom;\n    cam.i = cam.center+cam.left*uv.x+cam.up*uv.y;\n    \n    cam.ray.o = cam.p;\t\t\t\t\t\t// ray origin = camera position\n    cam.ray.d = normalize(cam.i-cam.p);\t// ray direction is the vector from the cam pos through the point on the imaginary screen\n}\n\nfloat within(vec2 v, float t) {\n\treturn (t-v.x) / (v.y-v.x);\n}\n\n\nvec4 tex3D( in vec3 pos, in vec3 normal, sampler2D sampler ) {\n    // by reinder. This is clever as two hamsters feeding three hamsters.\n    \n\treturn \ttexture( sampler, pos.yz )*abs(normal.x)+ \n\t\t\ttexture( sampler, pos.xz )*abs(normal.y)+ \n\t\t\ttexture( sampler, pos.xy )*abs(normal.z);\n}\n\n// DE functions from IQ\n// https://www.shadertoy.com/view/Xds3zN\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ) {\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nvec4 map( in vec3 p) {\n    // returns a vec3 with x = distance, y = bump, z = mat transition w = mat id\n    \n    float t = iTime*.1;\n    vec2 fryInterval = vec2(2., 2.2);\n    float transition = saturate(within(fryInterval, p.y));\n    transition = smoothstep(0., 1., transition);\n    \n    vec3 pos = p*3.;\n    pos.y -= t;\n    \n    vec3 normal = normalize(vec3(p.x, 0., p.z));\n    \n    float newBump = tex3D(pos, normal, iChannel1).x*.003;\n    float burnedBump = tex3D(pos, normal, iChannel0).x*.05;\n    \n    float bump = mix(newBump, burnedBump, transition);\n    \n    float d = sdCapsule(p+bump*normal, vec3(0., -10., 0.), vec3(0., 10., 0.), .1);\n    \n    return vec4(d, bump, transition, 2.);\n}\n\nvec4 castRay( in vec3 ro, in vec3 rd ) {\n    // returns a distance and a material id\n    \n    float dmin = 1.0;\n    float dmax = 20.0;\n    \n\tfloat precis = 0.002;\n    float d = dmin;\n    float m = -1.0;\n    float b = 0.;\n    float t = 0.;\n    for( int i=0; i<50; i++ )\n    {\n\t    vec4 res = map( ro+rd*d );\n        if( res.x<precis || d>dmax ) break;\n        d += res.x;\n        b = res.y;\n        t = res.z;\n\t    m = res.w;\n    }\n\n    if( d>dmax ) m=-1.0;\n    return vec4( d, b, t, m );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor ) {\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n\nvec3 ClosestPoint(ray r, vec3 p) {\n    // returns the closest point on ray r to point p\n    return r.o + max(0., dot(p-r.o, r.d))*r.d;\n}\n\nvec4 render( in vec3 ro, in vec3 rd, out float d ) {\n    // outputs a color\n    \n    vec3 col = vec3(0.);\n    vec4 res = castRay(ro,rd);\n    d = res.x;\t// distance\n    float b = res.y;\t// bump\n    float t = res.z;\t// transition\n\tfloat m = res.w;\t// mat id\n    if( m>0.5 )\n    {\n        vec3 pos = ro + d*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = vec3(0.05,0.08,0.10)+mix(.35, .1, t);\n\n        // lighitng        \n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        \n        float fade = saturate(within(vec2(2., 3.), pos.y));\n        fade = smoothstep(0., 1., fade);\n        fade = mix(80., 0., fade);\n        vec3 afterGlow = pow(abs(b)*fade,2.) * vec3(1., .1, .02)*2.;\n        float whiteGlow = B(2.18, 2.45, .05, pos.y+b*10.);\n\n\t\tvec3 lin = vec3(0.0);\n        lin += amb;\n        lin += dif;\n        \n\t\tcol = col*lin;\n        \n        col += afterGlow;\n\t\tcol += whiteGlow;\n    }\n\n\treturn vec4( saturate(col), saturate(m) );\n}\n\nfloat SineWave(vec2 pos, float phase, float frequency, float amplitude, float offset, float thickness, float glow) {\n\t\t// returns a sine wave band\n    \t// takes a position from -pi,-pi to pi, pi\n\t\t\t\t\n    float dist = abs(pos.y-(sin(pos.x*frequency+phase)*amplitude-offset));  // distance to a sine wave\n    return smoothstep(thickness+glow, thickness, dist);\n}\n\nvec3 background(ray r) {\n\tfloat x = atan(r.d.x, r.d.z);\t\t// from -pi to pi\t\n\tfloat y = pi*0.5-acos(r.d.y);  \t\t// from -1/2pi to 1/2pi\t\t\n    \n    float t = iTime;\n    \n\tfloat band1 = SineWave(vec2(x, y), 0., 3., .25, 0., 0.001, .5);\n    \n    return  mix(vec3(.3, .02, 0.03), vec3(0.), band1);\n}\n\n\nvec3 sparkle(ray r, vec3 p, float size, vec3 color) {\n\tfloat camDist = length(cam.p-p);\n    float focus = smoothstep(DOF.y, DOF.x, abs(camDist-CAMERA_DISTANCE));\n    \n    vec3 closestPoint = ClosestPoint(r, p);\n    float dist = DistSqr(closestPoint, p)*10000.;\n   \n    size = mix(size*5., size, focus);\n    float brightness = size/dist;\n    brightness = clamp(brightness,0., 10.);\n    \n    float bokeh = smoothstep(.01, .04, brightness)*saturate(dist*.005+.4)*.15;\n    \n    brightness = mix(bokeh, brightness, focus);\n    return color * brightness;\n}\n\nvec3 sparkles(ray r, vec2 uv, float time, float timeFactor, float dist) {\n\tvec3 col = vec3(0.);\n    \n    float n2 = fract(sin(uv.x*123134.2345)*1231.234255);\n    float n3 = fract(sin((n2+uv.y)*234.978)*789.234);\n    \n    float motionBlur = (n3-.5)*timeFactor*MOTION_BLUR_AMOUNT;\n    \n    for(float i=0.; i<NUM_SPARKLES; i++) {\t\t\t\t\t\n    \tfloat t = time+(i/NUM_SPARKLES) + motionBlur;\n        float ft = floor(t);\n        t -= ft;\n        vec3 n = hash31(i+ft*123.324);\t\t\t// per particle noise / per cycle noise\n        \n        \n        vec3 pStart = vec3(0., 2.1+n.y*.15, 0.);\n        pStart.y -= t*t*.6;\t// gravity\n        pStart.y += t;\t\t// account for slow scroll down the stick\n        \n        vec3 pEnd = pStart + (n-.5) * vec3(1., .6, 1.)*4.;\n        vec3 p = mix(pStart, pEnd, t);\n       \t\n        if(length(p-cam.p)<dist) {\n            float size = mix(10., .5, smoothstep(0., .2, t)); // in the first 20% it gets smaller very fast\n            size *= smoothstep(1., .2, t);\t\t\t\t\t// in the remaining 80% it slowly fades out\n\n            if(t>n.z && abs(n.z-.55)<SUB_SPARKLE_CHANCE) {\n                for(float x=0.; x<NUM_SUB_SPARKLES; x++) {\n                    vec3 ns = hash31(x+i);\t\t\t// per particle noise\n                    vec3 sStart = mix(pStart, pEnd, n.z);\n                    vec3 sEnd = sStart + (ns-.5) *2.;\n                    float st = saturate(within(vec2(n.z, 1.), t));\n                    vec3 sp = mix(sStart, sEnd, st);\n\n                    size = mix(10., 0.5, smoothstep(0., .1, st));\t// explosion in the first 10%\n                    size *= smoothstep(1., .9, st);\t\t\t\t\t// fade over the next 90%\n\n                    col += sparkle(r, sp, size, SECONDARY_PARTICLE_COLOR);\n                }\n            } else\n                 col += sparkle(r, p, size, PRIMARY_PARTICLE_COLOR);\n        }\n    }\n    \n    return col;\n}\n\nvec3 Rainbow(vec3 c) {\n\t\n    float t=iTime;\n    \n    //float avg = (c.r+c.g+c.b)/3.;\n    //c = avg + (c-avg)*sin(vec3(0., .333, .666)+t);\n    \n    c += sin(vec3(.4, .3, .3)*t + vec3(1.1244,3.43215,6.435))*vec3(.4, .1, .5);\n    \n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.xy) - 0.5;\n   \tuv.y *= iResolution.y/iResolution.x;\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n\tfloat t = iTime;\n    float timeFactor = fract(t/SLOWMO_CYCLE_DURATION)>.5 ? SLOW_MOTION_SPEED : NORMAL_MOTION_SPEED;\n    t *= timeFactor;\n    \n    float turn = -m.x*pi*2.+iTime*.1;\n    float s = sin(turn);\n    float c = cos(turn);\n    mat3 rot = mat3(\t  c,  0., s,\n                   \t\t  0., 1., 0.,\n                   \t\t  s,  0., -c);\n    \n    CAMERA_DISTANCE = mix(MIN_CAM_DISTANCE, MAX_CAM_DISTANCE, sin(iTime*.0765)*.5+.5);\n    vec3 pos = vec3(0., 0.4, -CAMERA_DISTANCE)*rot;\n   \t\n    CameraSetup(uv, pos, vec3(0., 2.3, 0.), 1.);\n    \n    vec3 bg = background(cam.ray);\n    float dist;\t\t\t\t\t\t\t\t\t\t// the distance of the current pixel from the camera\n    vec4 stick = render(cam.ray.o, cam.ray.d, dist);\n    dist += .08; // add some distance to make sure particles render on top of the stick when they first come to life\n    \n    vec3 col = mix(bg, stick.rgb, stick.a);\t// composite stick onto bg\n    \n    col += sparkles(cam.ray, uv, t, timeFactor, dist);\n    \n    col = Rainbow(col);\n    \n    fragColor = vec4(col, .1);\n}",
   "name": "Image",
   "description": "",
   "type": "image"
  }
 ]
}