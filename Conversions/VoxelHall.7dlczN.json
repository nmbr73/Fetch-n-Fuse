{
 "ver": "0.1",
 "info": {
  "id": "7dlczN",
  "date": "0",
  "viewed": 0,
  "name": "Fork Voxel Hall JiPi 925",
  "description": "Forked from Shane's Voxel Corridor. Please check out the original if you haven't already.\nI remove the texture and added a surface color with a time gradient (looked better to me than just changing the ambient light color).",
  "likes": 0,
  "published": "Private",
  "usePreview": 0,
  "tags": [
   "tunnel",
   "raymarch",
   "voxel",
   "brick",
   "corridor",
   "passage"
  ],
  "hasliked": 0,
  "parentid": "fsXczN",
  "parentname": "Voxel Hall Colors"
 },
 "renderpass": [
  {
   "inputs": [
    {
     "id": "XsBSR3",
     "filepath": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png",
     "type": "texture",
     "channel": 0,
     "sampler": {
      "filter": "mipmap",
      "wrap": "repeat",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    }
   ],
   "outputs": [
    {
     "id": "4dfGRr",
     "channel": 0
    }
   ],
   "code": "/*\n    Voxel Hall Colors\n    \n    Forked from Shane's Voxel Corridor.\n    I remove the texture and added a surface color with a time gradient.\n    Changing the ambient light's color would have been more \"correct\" but I liked\n    the way this looks.\n    I also experimented a bit with different bumpmap textures, and settled on just using \n    the original procedural bricks.\n\n    Original author's comments below.\n    --------------\n    \n\tVoxel Corridor\n\t--------------\n\n\tI love the voxel aesthetic, so after looking at some of Akohdr's examples, I went on a bit \n\tof a voxel trip and put this simple scene together... Although, \"scene\" would  be putting \n\tit loosely. :)\n\n\tQuasi-discreet distance calculations sound simple enough to perform in theory, but are just \n\tplain fiddly to code, so I was very thankful to have fb39ca4's, IQ's, Reinder's, and everyone \n\telses voxel examples to refer to.\n\n\tThe code is pretty straight forward. I tried my best to write it in such way that enables\n\tsomeone to plug in any normal distance function and have it render the voxelized version.\n\n\tMainly based on the following:\n\n\tVoxel Ambient Occlusion - fb39ca4\n    https://www.shadertoy.com/view/ldl3DS\n\n\tMinecraft - Reinder\n    https://www.shadertoy.com/view/4ds3WS\n\n\tOther examples:\n\tRounded Voxels - IQ\n    https://www.shadertoy.com/view/4djGWR\n\n\tSampler - w23\n\thttps://www.shadertoy.com/view/MlfGRM\n\n\tText In Space - akohdr\n\thttps://www.shadertoy.com/view/4d3SWB\n\n*/\n\n#define PI 3.14159265\n#define FAR 60.\n\n// 2x2 matrix rotation. Note the absence of \"cos.\" It's there, but in disguise, and comes courtesy\n// of Fabrice Neyret's \"ouside the box\" thinking. :)\nmat2 rot2( float a ){ vec2 v = sin(vec2(1.570796, 0) + a);\treturn mat2(v, -v.y, v.x); }\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n  \n    n = max(abs(n), 0.001);//n = max((abs(n) - 0.2)*7., 0.001); //  etc.\n    n /= (n.x + n.y + n.z ); \n\tp = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    return p*p;\n}\n\n// The path is a 2D sinusoid that varies over time, depending upon the frequencies, and amplitudes.\nvec2 path(in float z){ \n    //return vec2(0); // Straight.\n    float a = sin(z * 0.11);\n    float b = cos(z * 0.14);\n    return vec2(a*4. -b*1.5, b*1.7 + a*1.5); \n}\n\n/*\n// Alternate distance field -- Twisted planes. \nfloat map(vec3 p){\n    \n     // You may need to reposition the light to work in with the shadows, but for\n     // now, I'm repositioning the scene up a bit.\n     p.y -= .75;\n     p.xy -= path(p.z); // Move the scene around a sinusoidal path.\n     p.xy = rot2(p.z/8.)*p.xy; // Twist it about XY with respect to distance.\n    \n     float n = dot(sin(p*1. + sin(p.yzx*.5 + iTime*.0)), vec3(.25)); // Sinusoidal layer.\n     \n     return 4. - abs(p.y) + n; // Warped double planes, \"abs(p.y),\" plus surface layers.\n \n}\n*/\n\n// Standard perturbed tunnel function.\n//\nfloat map(vec3 p){\n     \n     // Offset the tunnel about the XY plane as we traverse Z.\n     p.xy -= path(p.z);\n    \n     // Standard tunnel. Comment out the above first.\n     float n = 5. - length(p.xy*vec2(1, .8));\n    \n     // Square tunnel. Almost redundant in a voxel renderer. :)\n     //n = 4. - max(abs(p.x), abs(p.y)); \n     \n     // Tunnel with a floor.\n     return min(p.y + 3., n); //n = min(-abs(p.y) + 3., n);\n \n}\n\n/*\nfloat brickShade(vec2 p){\n    \n    p.x -= step(p.y, 1.)*.5;\n    \n    p = fract(p);\n    \n    return pow(16.*p.x*p.y*(1.-p.x)*(1.-p.y), 0.25);\n    \n}\n*/\n\n// The brick groove pattern. Thrown together too quickly.\n// Needs some tidy up, but it's quick enough for now.\n//\nconst float w2h = 2.; // Width to height ratio.\nconst float mortW = 0.05; // Morter width.\n\nfloat brickMorter(vec2 p){\n\t\n    p.x -= step(1., p.y)*.5;\n    \n    p = abs(fract(p + vec2(0, .5)) - .5)*2.;\n    \n    // Smooth grooves. Better for bump mapping.\n    return smoothstep(0., mortW, p.x)*smoothstep(0., mortW*w2h, p.y);\n    \n}\n\nfloat brick(vec2 p){\n    \n\tp = fract(p*vec2(0.5/w2h, 0.5))*2.;\n\n    return brickMorter(p);\n}\n\n\n// Surface bump function. Cheap, but with decent visual impact.\nfloat bumpSurf3D( in vec3 p, in vec3 n){\n\n    n = abs(n);\n    \n    if (n.x>0.5) p.xy = p.zy;\n    else if (n.y>0.5) p.xy = p.zx;\n    \n    return brick(p.xy);\n    \n}\n\n// Standard function-based bump mapping function.\nvec3 doBumpMap(in vec3 p, in vec3 nor, float bumpfactor){\n    \n    const vec2 e = vec2(0.001, 0);\n    float ref = bumpSurf3D(p, nor);                 \n    vec3 grad = (vec3(bumpSurf3D(p - e.xyy, nor),\n                      bumpSurf3D(p - e.yxy, nor),\n                      bumpSurf3D(p - e.yyx, nor) )-ref)/e.x;                     \n          \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + grad*bumpfactor );\n\t\n}\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n    \n}\n\n\n// This is just a slightly modified version of fb39ca4's code, with some\n// elements from IQ and Reinder's examples. They all work the same way:\n// Obtain the current voxel, then test the distance field for a hit. If\n// the ray has moved into the voxelized isosurface, break. Otherwise, move\n// to the next voxel. That involves a bit of decision making - due to the\n// nature of voxel boundaries - and the \"mask,\" \"side,\" etc, variable are\n// an evolution of that. If you're not familiar with the process, it's \n// pretty straight forward, and there are a lot of examples on Shadertoy, \n// plus a lot more articles online.\n//\nvec3 voxelTrace(vec3 ro, vec3 rd, out vec3 mask){\n    \n    vec3 p = floor(ro) + .5;\n\n\tvec3 dRd = 1./abs(rd); // 1./max(abs(rd), vec3(.0001));\n\trd = sign(rd);\n    vec3 side = dRd*(rd * (p - ro) + 0.5);\n    \n    mask = vec3(0);\n\t\n\tfor (int i = 0; i < 64; i++) {\n\t\t\n        if (map(p)<0.) break;\n        \n        // Note that I've put in the messy reverse step to accomodate\n        // the \"less than or equals\" logic, rather than just the \"less than.\"\n        // Without it, annoying seam lines can appear... Feel free to correct\n        // me on that, if my logic isn't up to par. It often isn't. :)\n        mask = step(side, side.yzx)*(1.-step(side.zxy, side));\n\t\tside += mask*dRd;\n\t\tp += mask * rd;\n\t}\n    \n    return p;    \n}\n\n\n///////////\n//\n// This is a trimmed down version of fb39ca4's voxel ambient occlusion code with some \n// minor tweaks and adjustments here and there. The idea behind voxelized AO is simple. \n// The execution, not so much. :) So damn fiddly. Thankfully, fb39ca4, IQ, and a few \n// others have done all the hard work, so it's just a case of convincing yourself that \n// it works and using it.\n//\n// Refer to: Voxel Ambient Occlusion - fb39ca4\n// https://www.shadertoy.com/view/ldl3DS\n//\nvec4 voxelAO(vec3 p, vec3 d1, vec3 d2) {\n   \n    // Take the four side and corner readings... at the correct positions...\n    // That's the annoying bit that I'm glad others have worked out. :)\n\tvec4 side = vec4(map(p + d1), map(p + d2), map(p - d1), map(p - d2));\n\tvec4 corner = vec4(map(p + d1 + d2), map(p - d1 + d2), map(p - d1 - d2), map(p + d1 - d2));\n\t\n    // Quantize them. It's either occluded, or it's not, so to speak.\n    side = step(side, vec4(0));\n    corner = step(corner, vec4(0));\n    \n    // Use the side and corner values to produce a more honed in value... kind of.\n    return 1. - (side + side.yzwx + max(corner, side*side.yzwx))/3.;    \n\t\n}\n\nfloat calcVoxAO(vec3 vp, vec3 sp, vec3 rd, vec3 mask) {\n    \n    // Obtain four AO values at the appropriate quantized positions.\n\tvec4 vAO = voxelAO(vp - sign(rd)*mask, mask.zxy, mask.yzx);\n    \n    // Use the fractional voxel postion and and the proximate AO values\n    // to return the interpolated AO value for the surface position.\n    sp = fract(sp);\n    vec2 uv = sp.yz*mask.x + sp.zx*mask.y + sp.xy*mask.z;\n    return mix(mix(vAO.z, vAO.w, uv.x), mix(vAO.y, vAO.x, uv.x), uv.y);\n\n}\n///////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\t\n\t// Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 camPos = vec3(0., 0.5, iTime*8.); // Camera position, doubling as the ray origin.\n\tvec3 lookAt = camPos + vec3(0.0, 0.0, 0.25);  // \"Look At\" position.\n\n \n    // Light positioning. \n \tvec3 lightPos = camPos + vec3(0, 2.5, 8);// Put it a bit in front of the camera.\n\n\t// Using the Z-value to perturb the XY-plane.\n\t// Sending the camera, \"look at,\" and two light vectors down the tunnel. The \"path\" function is \n\t// synchronized with the distance function. Change to \"path2\" to traverse the other tunnel.\n\tlookAt.xy += path(lookAt.z);\n\tcamPos.xy += path(camPos.z);\n\tlightPos.xy += path(lightPos.z);\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = PI/2.; // FOV - Field of view.\n    vec3 forward = normalize(lookAt-camPos);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x )); \n    vec3 up = cross(forward, right);\n\n    // rd - Ray direction.\n    vec3 rd = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);\n    \n    //vec3 rd = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);\n    //rd = normalize(vec3(rd.xy, rd.z - dot(rd.xy, rd.xy)*.25));    \n    \n    // Swiveling the camera about the XY-plane (from left to right) when turning corners.\n    // Naturally, it's synchronized with the path in some kind of way.\n\trd.xy = rot2( path(lookAt.z).x/24. )*rd.xy;\n\n    // Raymarch the voxel grid.\n    vec3 mask;\n\tvec3 vPos = voxelTrace(camPos, rd, mask);\n\t\n    // Using the voxel position to determine the distance from the camera to the hit point.\n    // I'm assuming IQ is responsible for this clean piece of logic.\n\tvec3 tCube = (vPos-camPos - .5*sign(rd))/rd;\n    float t = max(max(tCube.x, tCube.y), tCube.z);\n    \n\t\n    // Initialize the scene color.\n    vec3 sceneCol = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t<FAR){\n\t\n   \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = camPos + rd*t;\n        \n        // Voxel normal.\n        vec3 sn = -(mask * sign( rd ));\n        \n        // Sometimes, it's necessary to save a copy of the unbumped normal.\n        vec3 snNoBump = sn;\n        \n        // I try to avoid it, but it's possible to do a texture bump and a function-based\n        // bump in succession. It's also possible to roll them into one, but I wanted\n        // the separation... Can't remember why, but it's more readable anyway.\n        //\n        // Texture scale factor.\n        const float tSize0 = 1./4.;\n        // Texture-based bump mapping.\n\t    //sn = doBumpMap(iChannel0, sp*tSize0, sn, 0.02);\n\n        // Function based bump mapping. Comment it out to see the under layer. It's pretty\n        // comparable to regular beveled Voronoi... Close enough, anyway.\n        sn = doBumpMap(sp, sn, .15);\n        \n       \n\t    // Ambient occlusion.\n\t    float ao = calcVoxAO(vPos, sp, rd, mask) ;//calculateAO(sp, sn);//*.75 + .25;\n\n        \n    \t// Light direction vectors.\n\t    vec3 ld = lightPos-sp;\n\n        // Distance from respective lights to the surface point.\n\t    float lDist = max(length(ld), 0.001);\n    \t\n    \t// Normalize the light direction vectors.\n\t    ld /= lDist;\n\t    \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + lDist*.2 + lDist*0.1); // + distlpsp*distlpsp*0.025\n    \t\n    \t// Ambient light.\n\t    float ambience = 0.25;\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.0);\n   \t\n    \t// Specular lighting.\n\t    float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 32.);\n \n        // Object texturing.\n        vec3 tint;\n        //tint = vec3(.94, .38, .57); // rose\n        //tint = vec3(1, .6, 1.); // lavender\n        //tint = vec3(.5); // greyscale\n        //tint =  .7 + .5*cos(6.28318*(vec3(1.,0.1,0.4)*iTime*.25 + vec3(0.5,0.15,0.25))) ;\n        tint = .7 + .5*cos(6.28318*(vec3(2.0,1.,0.)*iTime*.25 + vec3(.5,.2,.25)));\n        vec3 texCol = tint + step(abs(snNoBump.y), .5);\n\n    \t// Combining the above terms to produce the final color. It was based more on acheiving a\n        // certain aesthetic than science.\n        sceneCol = texCol*(diff + ambience) + vec3(1., 1., 1.) *spec;\n        \n\n\t    // Shading.  \n        sceneCol *= ao;\n\t}\n       \n    // Blend in a bit of logic-defying fog for atmospheric effect. :)\n    sceneCol = mix(sceneCol, vec3(.08, .16, .34), smoothstep(0., .95, t/FAR)); // exp(-.002*t*t), etc.\n\n    // Clamp and present the badly gamma corrected pixel to the screen.\n\tfragColor = vec4(sqrt(clamp(sceneCol, 0., 1.)), 1.0);\n\t\n}",
   "name": "Image",
   "description": "",
   "type": "image"
  }
 ]
}