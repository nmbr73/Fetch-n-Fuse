{"Shader":{"ver":"0.1","info":{"id":"tlyXzG","date":"1582991165","viewed":548,"name":"Cubemap Face Unwrap","username":"spalmer","description":"A debugging tool, visual aid, some helper functions for managing cubemap uvw and face indices.  Hope it's useful.","likes":11,"published":3,"flags":0,"usePreview":0,"tags":["cubemap","unwrap"],"hasliked":0},"renderpass":[{"inputs":[{"id":22,"src":"\/media\/a\/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","ctype":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":24,"src":"\/media\/a\/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","ctype":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":25,"src":"\/media\/a\/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","ctype":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":26,"src":"\/media\/a\/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","ctype":"cubemap","channel":3,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":37,"channel":0}],"code":"\/\/ I expect someone has done this better, faster, cheaper somewhere\n\/\/ and I wouldn't mind seeing how, but I didn't see any other\n\/\/ examples of such cubemap face debugging tool here on the site,\n\/\/ so I took the first thing I got working and made a toy out of it.\n\/\/ Hopefully someone will find it useful.  I'd appreciate any tips.\n\/\/ heck I probably got the face id's wrong or uv's backward or upside down.\n\n\/\/ Hey!  I did find something related, finally:  https:\/\/shadertoy.com\/view\/3l2SDR\n\/\/ Fabrice has some coordinate conversion code:  https:\/\/shadertoy.com\/view\/WdlGRr\n\/\/ Wunkolo has some stuff here I hope to grok:   https:\/\/shadertoy.com\/view\/wltXDl\n\n#define CUBEMAP iChannel1 \/\/ pick a channel\n\n\nvoid mainImage(out vec4 c, vec2 p)\n{\n    vec2 R = iResolution.xy\n        , q = (p + p - R)\/R.y;\n    c.rgb = Unwrap(CUBEMAP, q * .755).rgb;\n\/\/    c.rgb = pow(c.rgb, vec3(1.\/2.2)); \/\/ gamma (disable for texture cube sources, or fix those on load)\n    c.a = 1.;\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\/\/ these I just threw together over in https:\/\/shadertoy.com\/view\/wtVSDw\n\/\/ but they seem to work, or at least seem to be inverses of each other.\n\nint CubeFaceOfDir(vec3 d) \/\/ just the face id\n{\n    vec3 a = abs(d);\n    int f = a.x >= a.y ? (a.x >= a.z ? 0 : 2) : (a.y >= a.z ? 1 : 2);\n    int i = f + f;\n    if (d[f] < 0.) ++i;\n    return i;\n}\n\/\/ takes normalized direction vector, returns uv in c.xy and face id in c.z\nvec3 DirToCubeFace(vec3 d)\n{\n    int i = CubeFaceOfDir(d)\n    , f = i >> 1;\n    vec2 uv;\n    switch (f) {\n        case 0: uv = d.yz; break;\n        case 1: uv = d.xz; break;\n        case 2: uv = d.xy; break;\n    }\n    uv \/= abs(d[f]); \/\/ project\n    if ((i&1) != 0) \/\/ negative faces are odd indices\n        uv.x = -uv.x; \/\/ flip u\n    return vec3(uv, float(i));\n}\n\/\/ takes uv in c.xy and face id in c.z, returns unnormalized direction vector\nvec3 CubeFaceToDir(vec3 c)\n{\n    int i = int(c.z); \n    vec3 d = vec3(c.xy, 1. - 2. * float(i & 1));\n    d.x *= d.z; \/\/ only unflip u \n    switch (i >> 1) { \/\/ f\n        case 0: d = d.zxy; break;\n        case 1: d = d.xzy; break;\n        case 2: d = d.xyz; break;\n    }\n    return d; \/\/ needs normalized probably but texture() doesn't mind.\n}\n\n\/\/ just for debugging so probably broken and imprecise.\n\/\/ in fact it's a big ol' kludge atm.  what a mess!  I'll try to improve it as I get time.\nvec4 Unwrap(samplerCube ch, vec2 q)\n{\n    vec2 uv = q * .5 + .5;\n    uv *= 4.;\n    uv -= vec2(.0,.5);\n    int i = -1;\n    if (uv.y >= 1. && uv.y < 2.) {\n        int f = int(floor(uv.x));\n        if (f >= 0 && f < 2) i = 3*f + 1;\n     \telse if (f >= 2 && f < 4) i = 5*f - 10;\n        if (f == 2) uv = vec2(uv.y, -uv.x); \/\/ maybe rotate, different directions\n        else if (f == 0) uv = vec2(-uv.y, uv.x);\n    } else {\n\t\tif (int(uv.x) == 1) {\n        \tif (uv.y >= 0. && uv.y < 1.) { i = 3; uv.x = 0.-uv.x; }\n        \telse if (uv.y >= 2. && uv.y < 3.) { i = 2; uv.y = 0.-uv.y; }\n    \t}\n    }\n\tif (!(i >= 0)) return vec4(vec3(.7),1);\n    uv = fract(uv);\n    vec3 d = CubeFaceToDir(vec3(uv * 2. - 1., float(i)));\n\/\/    d = CubeFaceToDir(DirToCubeFace(d)); \/\/ ensure can convert back&forth flawlessly\n\/\/    d = CubeFaceToDir(DirToCubeFace(d));\n    vec4 c = textureLod(ch, d, 0.);\n    \/\/c.rgb = pow(c.rgb, vec3(2.2)); \/\/ gamma correction - skipping as it cancels out here\n    return c;\n} \/\/ result in srgb gamma atm\n\n","name":"Common","description":"","type":"common"}]}}