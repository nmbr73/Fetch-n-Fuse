{"Shader":{"ver":"0.1","info":{"id":"XttcWM","date":"1532951013","viewed":898,"name":"Per-pixel particle structure","username":"emh","description":"Per-pixel particle data structure. Voronoi based on random graph construction and traversal. Will reinitialize on switch to full screen. Some random forces of various types applied + wave equation. High velocity particles are blue.","likes":12,"published":3,"flags":32,"usePreview":0,"tags":["pixel","particles","data","structure"],"hasliked":0},"renderpass":[{"inputs":[{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":258,"src":"\/media\/previz\/buffer01.png","ctype":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":259,"src":"\/media\/previz\/buffer02.png","ctype":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":37,"channel":0}],"code":"\/\/ Public Domain. By Eivind Magnus Hvidevold 30.07.2018.\n\n\/\/ Description:\n\/\/ Per-pixel particle data structure.\n\/\/ Voronoi based on random graph construction and traversal.\n\/\/ Will reinitialize on switch to full screen.\n\/\/ Some random forces of various types applied + wave equation.\n\/\/ High velocity particles are blue.\n\n\/\/ Buf A: Particle positions: xy pos, zw old pos\n\/\/ Buf B: Particle neighbour indices: x, y, z, w indexes neighbour in direction of each corner, respectively\n\/\/ Buf C: x: Nearest particle to pixel position\n\n\/\/ Inspired by https:\/\/www.shadertoy.com\/view\/XsjyRm .\n\/\/ See also https:\/\/www.shadertoy.com\/view\/4dGSDR for Efficient splatting.\n\nbool debug(out vec4 fragColor, in vec2 fragCoord) {\n    int frame = 0;\n    vec3 color = vec3(0.0);\n    vec2 uv = fragCoord \/ iResolution.xy;\n    for (int i = 1; i < 100; i++) {\n        vec2 iv = vec2(ivec2(i \/ 10, i % 10));\n        \n        vec2 pos = texelFetch(iChannel0, ivec2(iv), 0).xy;\n        \n        ivec2 particleCoord = ivec2(iv);\n        \n        ivec4 closest = ivec4(texelFetch(iChannel1, particleCoord, 0));\n        \n        vec2 vnext = vec2(particleCoord);\n        vec2 pos2 = getParticle(iResolution, iChannel0, iFrame, closest.x).xy;\n        vec2 pos3 = getParticle(iResolution, iChannel0, iFrame, closest.y).xy;\n        vec2 pos4 = getParticle(iResolution, iChannel0, iFrame, closest.z).xy;\n        vec2 pos5 = getParticle(iResolution, iChannel0, iFrame, closest.w).xy;\n        \n        \/\/ color = vec3(0.0);\n        if (int(closest.x) != -1) color += drawLine(uv, pos, pos2);\n        if (int(closest.y) != -1) color += drawLine(uv, pos, pos3);\n        if (int(closest.z) != -1) color += drawLine(uv, pos, pos4);\n        if (int(closest.w) != -1) color += drawLine(uv, pos, pos5);\n    }\n\t  \n    fragColor = vec4(color, 1.0);\n    return true;\n}\n\nvec3 vmul(float v) {\n    float r = 0.5;\/\/ + pow(v, 0.1);\n    float g = 0.5;\n    float b = 0.5;\n    float r2 = 0.0;\n    float g2 = 0.0;\n    float b2 = 0.1;\n    float vv = v > 0.002 ? 1.0 : 0.0;\n    vv = smoothstep(0.0, 0.004, v);\n    return mix(vec3(r, g, b), vec3(r2, g2, b2), vv);\n}\n\nvoid mainImage2(out vec4 fragColor, in vec2 fragCoord, in vec2 uv) {\n    \/*\n\tif (debug(fragColor, fragCoord)) {\n        return;\n    }\n\t*\/\n    \n    vec4 near = texelFetch(iChannel2, ivec2(fragCoord), 0);\n    vec2 iv = vec2(fragCoord) + near.yz;\n    int nextIndex = int(near.x);\n    \n    if (nextIndex == -1) {\n        fragColor.r = 1.0;\n        return;\n    }\n\t\n    \/\/int nextIndex = serializeUV(iFrame, getRandomParticlePos(iResolution, iChannel0, iv, frame, i));\n    vec2 closestPos = getParticle(iResolution, iChannel0, iFrame, nextIndex).xy;\n    \n    vec3 color = vec3(0.0);\n    vec3 colorBase = vec3(1.0);\n    float mind = distance(uv, closestPos);\n    float oldmind = 0.0;\n    \/\/float vmul = 1000.0;\n    \n    if (mind <= md) {\n        \/\/fragColor = vec4(1.0);\n    }\n    \/\/fragColor = vec4(float(i) \/ float(iter * iter));\n    \/\/return;\n    \/\/fragColor = vec4(mind \/ md * 0.01);\n    \/\/return;\n    const int iter2 = iter * iter;\n    int seen[iter2];\n    for (int i = 0; i < iter2; i++) {\n        seen[i] = -1;\n    }\n    int stack[iter2];\n    for (int i = 0; i < iter2; i++) {\n        stack[i] = -1;\n    }\n    \n    int oldIndex = nextIndex;\n    int closestIndex = nextIndex;\n    int stackPointer = 0;\n    stack[0] = nextIndex;\n    for (int i = 0; i < 1; i++) {\n    \/\/for (int i = 0; i < iter2 * iter2; i++) {\n    \/\/for (int i = 0; i < 100; i++) {\n        nextIndex = stack[stackPointer];\n        ivec4 closest = ivec4(getParticle(iResolution, iChannel1, iFrame, nextIndex));\n        seen[i] = nextIndex;\n        \n        vec2 pos2 = getParticle(iResolution, iChannel0, iFrame, closest.x).xy;\n        vec2 pos3 = getParticle(iResolution, iChannel0, iFrame, closest.y).xy;\n        vec2 pos4 = getParticle(iResolution, iChannel0, iFrame, closest.z).xy;\n        vec2 pos5 = getParticle(iResolution, iChannel0, iFrame, closest.w).xy;\n        \n        vec2 pos = closestPos;\n        \/\/ color = vec3(0.0);\n        \n        \n        if (nextIndex != -1) {\n            vec4 closest = getParticle(iResolution, iChannel0, iFrame, nextIndex);\n            vec2 v = closest.xy - closest.zw;\n            colorBase = vmul(length(v));\n        }\n        \n        bool lines = LINES;\n        if (lines && length(pos2) > 0.0) {\n            color += colorBase * drawLine(uv, pos, pos2);\n            color += colorBase * drawLine(uv, pos, pos3);\n            color += colorBase * drawLine(uv, pos, pos4);\n            color += colorBase * drawLine(uv, pos, pos5);\n        }\n        \n        {\n            vec2 cmp = uv;\n            \n            bool seenX = false;\n            bool seenY = false;\n            bool seenZ = false;\n            bool seenW = false;\n            for (int j = 0; j <= i && j <= iter2; j++) {\n                seenX = seenX || (seen[j] == closest.x);\n                seenY = seenY || (seen[j] == closest.y);\n                seenZ = seenZ || (seen[j] == closest.z);\n                seenW = seenW || (seen[j] == closest.w);\n            }\n            \n            float d2 = MAX_DIST;\n            if (!seenX && closest.x != -1) {\n            \tnextIndex = closest.x;\n            \tclosestPos = pos2;\n                d2 = distance(uv, closestPos);\n            }\n            if (!seenY && closest.y != -1 && distance(uv, pos3) < d2) {\n                nextIndex = closest.y;\n            \tclosestPos = pos3;\n                d2 = distance(uv, closestPos);\n            }\n            if (!seenZ && closest.z != -1 && distance(uv, pos4) < d2) {\n                nextIndex = closest.z;\n            \tclosestPos = pos4;\n                d2 = distance(uv, closestPos);\n            }\n            if (!seenW && closest.w != -1 && distance(uv, pos5) < d2) {\n                nextIndex = closest.w;\n            \tclosestPos = pos5;\n                d2 = distance(uv, closestPos);\n            }\n        }\n        \n        if (nextIndex == oldIndex) {\n            stackPointer = stackPointer > 0 ? stackPointer - 1 : 0;\n        } else {\n            stackPointer++;\n            stack[stackPointer] = nextIndex;\n        }\n        \n        float d = distance(uv, closestPos);\n        if (d < mind) {\n            mind = d;\n            closestIndex = nextIndex;\n            \/\/ accumulative glow\n            color += 0.1 * colorBase;\n            if (mind <= md) {\n            \tcolor += colorBase;\n            }\n        }\n        oldmind = mind;\n        oldIndex = nextIndex;\n    }\n    \n    \/\/colorBase = vec3(1.0, 1.0, 1.0);\n    \n    colorBase = vec3(1.0, 1.0, 1.0);\n    if (closestIndex != -1) {\n        vec4 closest = getParticle(iResolution, iChannel0, iFrame, closestIndex);\n        vec2 v = closest.xy - closest.zw;\n        colorBase = vmul(length(v));\n    }\n    \n    \/*\n    if (closestIndex > 0 && length(uv) < 0.5) {\n        colorBase.r = hash(uvec2(closestIndex+0, 0));\n        colorBase.g = hash(uvec2(closestIndex+1, 0));\n        colorBase.b = hash(uvec2(closestIndex+2, 0));\n    }*\/\n    \/\/color += colorBase * max(0.0, 1.0 - mind \/ md * 0.5);\n    \/\/color += colorBase * max(0.0, 1000000000.0 * pow(abs(mind - 0.1), 10.0));\n    if (mind <= md) {\n        \/\/color += vec3(1.0 - mind \/ md * 0.5);\n        \/\/color = vec3(1.0);\n    \tcolor += colorBase;\n    }\n    \/\/color = clamp(color, 0.0, 1.0);\n    \/\/fragColor = texelFetch(iChannel2, ivec2(fragCoord), 0) * 0.9 + vec4(color, 1.0);\n    \/\/color *= 10.0;\n    fragColor += vec4(color, 1.0);\n    \/\/fragColor = vec4(mind \/ md * 0.1);\n    \n    \/\/fragColor = texelFetch(iChannel2, ivec2(fragCoord), 0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    int dd = iter;\n    vec2 uv = dnpos(fragCoord \/ iResolution.xy);\n    for (int dx = -dd; dx <= dd; dx++) {\n        for (int dy = -dd; dy <= dd; dy++) {\n            vec2 fc = vec2(fragCoord) + 10.0 * vec2(dx, dy);\n            fc = clamp(fc, vec2(0.0), iResolution.xy - vec2(dd));\n            mainImage2(fragColor, fc, uv);\n        }\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":258,"src":"\/media\/previz\/buffer01.png","ctype":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":257,"channel":0}],"code":"vec2 getContribution(in vec3 iResolution, in sampler2D iChannel0, in int frame, in int index, in vec2 pos) {\n    vec2 pos2 = getParticle(iResolution, iChannel1, iFrame, index).xy;\n    vec2 v = pos2 - pos;\n    vec2 va = pos2 - vec2(0.0);\n    float d = length(v);\n    float d2 = d + 1.0;\n    float dva = length(va);\n    float dva2 = dva + 1.0;\n    \n    float k = 0.001;\n    vec2 spring = (d < k * 2.0) ? 0.1 * v \/ abs(k - d) : vec2(0.0);\n    vec2 test = d < 0.1 ? 0.0001 * v \/ (d * d2) : vec2(0.0);\n    vec2 gravity = d < 0.1 ? 0.001 * v \/ (d2 * d2) : vec2(0.0);\n    vec2 antigravity = 0.000001 * -v \/ (d2 * d2);\n    \n    vec2 downgravity = vec2(0.0, -0.0000001);\n    \n    vec2 center = 0.0001 * -va \/ (dva2 * dva2);\n    vec2 anticenter = 0.00001 * va \/ (dva2 * dva2);\n    \/\/return spring + anticenter; \/\/spring + antigravity;\n    \n    vec2 a = vec2(0.0);\n    int mf = frame % 5;\n    if (mf == 0) {\n        a = spring;\n    } else if (mf == 1) {\n        a = test;\n    } else if (mf == 2) {\n        a = gravity;\n    } else if (mf == 3) {\n        a = antigravity;\n    } else if (mf == 4) {\n        a = anticenter;\n    }\n    \n    a = spring + test + gravity; \/\/ + downgravity;\n    \/\/a  = spring + gravity + anticenter;\n    \/\/a = spring;\n    float ma = 0.0001;\n    a = clamp(a, -ma, ma);\n    \n    return a;\n}\n\nvec2 getWaveContribution(in vec3 iResolution, in sampler2D iChannel0, in int frame, in int index, in vec2 pos) {\n    vec4 pos22 = getParticle(iResolution, iChannel1, iFrame, index);\n    vec2 pos2 = pos22.xy;\n    vec2 oldPos2 = pos22.zw;\n    vec2 v = pos2 - oldPos2;\n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ fragColor = vec4(0.0,0.0,1.0,1.0);\n    \/\/if (fragCoord.y > 0.1) return;\n    vec2 uv = fragCoord \/ iResolution.xy;\n    if (iFrame == 0 || texelFetch(iChannel1, ivec2(iResolution.xy) - ivec2(1.0), 0).xy == vec2(0.0)) {\n        vec2 pos = dnpos(vec2(rand(fragCoord), rand(-fragCoord.yx)));\n        vec2 oldPos = pos;\n        fragColor = vec4(pos, oldPos);\n    } else {\n        vec4 old = texelFetch(iChannel1, ivec2(fragCoord), 0);\n        vec2 oldPos = old.zw;\n        vec2 pos = old.xy;\n        vec2 v = pos - oldPos;\n        \n        vec2 a = vec2(0.0);\n        \n        ivec4 neighbourClosest = ivec4(texelFetch(iChannel2, ivec2(fragCoord), 0));\n\n        a += getContribution(iResolution, iChannel1, iFrame, neighbourClosest.x, pos);\n        a += getContribution(iResolution, iChannel1, iFrame, neighbourClosest.y, pos);\n        a += getContribution(iResolution, iChannel1, iFrame, neighbourClosest.z, pos);\n        a += getContribution(iResolution, iChannel1, iFrame, neighbourClosest.w, pos);\n        for (int i = 0; i < forceIter * forceIter; i++) {\n            ivec2 particleUV = getRandomParticlePos(iResolution, iChannel0, fragCoord, iFrame, i);\n            a += getContribution(iResolution, iChannel1, iFrame, serializeUV(iResolution, iFrame, particleUV), pos);\n        }\n        vec2 vw = vec2(0.0);\n        vw += getWaveContribution(iResolution, iChannel1, iFrame, neighbourClosest.x, pos);\n        vw += getWaveContribution(iResolution, iChannel1, iFrame, neighbourClosest.y, pos);\n        vw += getWaveContribution(iResolution, iChannel1, iFrame, neighbourClosest.z, pos);\n        vw += getWaveContribution(iResolution, iChannel1, iFrame, neighbourClosest.w, pos);\n        vw *= 0.25;\n        v += 0.01 * vw;\n        \n        v += a;\n        \/\/ friction\n        v *= 0.99;\n        \n        oldPos = pos;\n        if (pos.x + v.x <= -1.0 || pos.x + v.x >= 1.0) {\n            v.x = -v.x;\n            \/\/v *= 0.5;\n        }\n        if (pos.y + v.y <= -1.0 || pos.y + v.y >= 1.0) {\n            v.y = -v.y;\n            \/\/v *= 0.5;\n        }\n        pos += v;\n        \n        \/*\n        if (length(pos) < 0.01) {\n            pos = vec2(0.5);\n            oldPos = pos;\n        \t\/\/pos = vec2(rand(fragCoord + 1.0), rand(-fragCoord.yx - 1.0));\n        \t\/\/oldPos = pos;\n        }*\/\n        \n        fragColor = vec4(pos, oldPos);\n    }\n    \/\/vec2 uv = fragCoord \/ iResolution.xy * 40.0;\n    \/\/fragColor = vec4(uv, uv);\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":258,"src":"\/media\/previz\/buffer01.png","ctype":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":258,"channel":0}],"code":"#define checkPos checkPos2\n\n\/\/ 4 closest points\nvoid checkPos1(in int i, in vec2 pos, in vec2 pos2, inout vec4 mind, inout ivec4 closest) {\n    float d = distance(pos, pos2);\n    if (d == 0.0) return;\n    \n    if (d < mind.x) {\n        mind.w = mind.z;\n        closest.w = closest.z;\n\n        mind.z = mind.y;\n        closest.z = closest.y;\n\n        mind.y = mind.x;\n        closest.y = closest.x;\n\n        mind.x = d;\n        closest.x = i;\n    } else if (d < mind.y) {\n        mind.w = mind.z;\n        closest.w = closest.z;\n\n        mind.z = mind.y;\n        closest.z = closest.y;\n\n        mind.y = d;\n        closest.y = i;\n    } else if (d < mind.z) {\n        mind.w = mind.z;\n        closest.w = closest.z;\n\n        mind.z = d;\n        closest.z = i;\n    } else if (d < mind.w) {\n        mind.w = d;\n        closest.w = i;\n    }\n}\n\n\/\/ closest points in each corner direction\nvoid checkPos2(in int i, in vec2 pos, in vec2 pos2, inout vec4 mind, inout ivec4 closest) {\n    float d = distance(pos, pos2);\n    if (d == 0.0) return;\n                \n    if (d < mind.x && pos2.x < pos.x && pos2.y < pos.y) {\n        mind.x = d;\n        closest.x = i;\n    }\n    if (d < mind.y && pos2.x > pos.x && pos2.y > pos.y) {\n        mind.y = d;\n        closest.y = i;\n    }\n    if (d < mind.z && pos2.y < pos.y && pos2.x > pos.x) {\n        mind.z = d;\n        closest.z = i;\n    }\n    if (d < mind.w && pos2.y > pos.y && pos2.x < pos.x) {\n        mind.w = d;\n        closest.w = i;\n    }\n}\n\n\/\/ closest points in each direction\nvoid checkPos3(in int i, in vec2 pos, in vec2 pos2, inout vec4 mind, inout ivec4 closest) {\n    float d = distance(pos, pos2);\n    if (d == 0.0) return;\n        \n    if (d < mind.x && pos2.x < pos.x) {\n        mind.x = d;\n        closest.x = i;\n    }\n    if (d < mind.y && pos2.x > pos.x) {\n        mind.y = d;\n        closest.y = i;\n    }\n    if (d < mind.z && pos2.y < pos.y) {\n        mind.z = d;\n        closest.z = i;\n    }\n    if (d < mind.w && pos2.y > pos.y) {\n        mind.w = d;\n        closest.w = i;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 old = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec2 pos = old.xy;\n    int self = int(fragCoord.x);\n    vec4 mind = vec4(MAX_DIST);\n    ivec4 closest = ivec4(-1);\n    int frame = iFrame;\n    if (iFrame > 0) {\n        closest = ivec4(texelFetch(iChannel1, ivec2(fragCoord), 0));\n        \n        int oldFrame = iFrame - 1;\n        \/\/vec2 pos2 = getRandomParticle(iResolution, iChannel0, fragCoord, oldFrame, closest.x).xy;\n        vec2 pos2 = getParticle(iResolution, iChannel0, frame, closest.x).xy;\n        vec2 pos3 = getParticle(iResolution, iChannel0, frame, closest.y).xy;\n        vec2 pos4 = getParticle(iResolution, iChannel0, frame, closest.z).xy;\n        vec2 pos5 = getParticle(iResolution, iChannel0, frame, closest.w).xy;\n        \n        mind.x = closest.x != -1 ? distance(pos, pos2) : MAX_DIST;\n        mind.y = closest.y != -1 ? distance(pos, pos3) : MAX_DIST;\n        mind.z = closest.z != -1 ? distance(pos, pos4) : MAX_DIST;\n        mind.w = closest.w != -1 ? distance(pos, pos5) : MAX_DIST;\n    }\n    for (int i = 0; i < iter * iter; i++) {\n        \/\/ if (i == self) continue;\n        \/\/ivec2 p = ivec2(uvec2(fragCoord) + 1920U*1080U*uint(iFrame));\n        ivec2 particleUV = getRandomParticlePos(iResolution, iChannel0, fragCoord, iFrame, i);\n        vec4 particle = texelFetch(iChannel0, particleUV, 0); \/\/getRandomParticle(iResolution, iChannel0, fragCoord, iFrame, i);\n        vec2 pos2 = particle.xy;\n        int index = serializeUV(iResolution, frame, particleUV);\n        checkPos(index, pos, pos2, mind, closest);\n        \n        {\n            \/\/ivec2 particleUV = getRandomParticlePos(iResolution, iChannel0, fragCoord, iFrame, i);\n        \tivec4 neighbourClosest = ivec4(texelFetch(iChannel1, ivec2(particleUV), 0));\n\n            vec2 pos3 = getParticle(iResolution, iChannel0, frame, neighbourClosest.x).xy;\n            vec2 pos4 = getParticle(iResolution, iChannel0, frame, neighbourClosest.y).xy;\n            vec2 pos5 = getParticle(iResolution, iChannel0, frame, neighbourClosest.z).xy;\n            vec2 pos6 = getParticle(iResolution, iChannel0, frame, neighbourClosest.w).xy;\n            \n            checkPos(neighbourClosest.x, pos, pos3, mind, closest);\n            checkPos(neighbourClosest.y, pos, pos4, mind, closest);\n            checkPos(neighbourClosest.z, pos, pos5, mind, closest);\n            checkPos(neighbourClosest.w, pos, pos6, mind, closest);\n\t\t\t\n        }\n    }\n    \n    fragColor = vec4(closest);\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const int xParticles = 200;\n\/\/#define xParticles min(1000, iResolution.y)\nconst int yParticles = xParticles;\n\/\/#define yParticles (20 + frame % 2)\n\nconst int particles = xParticles * yParticles;\nconst float md = max(0.005, 0.2 \/ float(xParticles)); \/\/ circle radius\n\nconst int iter = 2;\nconst int forceIter = 4;\n\nconst float MAX_DIST = 10.0;\n\nconst bool LINES = true;\n\n\/\/ from https:\/\/gist.github.com\/patriciogonzalezvivo\/670c22f3966e662d2f83\nfloat rand(vec2 n) {\n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\n\/\/ from iq\nfloat hash(uvec2 x) {\n    uvec2 q = 1103515245U * ( (x>>1U) ^ (x.yx   ) );\n    uint  n = 1103515245U * ( (q.x  ) ^ (q.y>>3U) );\n    return float(n) * (1.0\/float(0xffffffffU));\n}\n\n\nivec2 getRandomParticlePos(in vec3 iResolution, in sampler2D iChannel0, in vec2 fragCoord, in int frame, int i) {\n    \/\/uvec2 b = uvec2(i \/ iter - iter \/ 2, i % iter - iter \/ 2);\n    uvec2 b = uvec2(0);\n    uvec2 p1 = uvec2(fragCoord) + b + uvec2(frame, 13 * frame);\n    uvec2 p2 = uvec2(fragCoord.yx) + b + uvec2(29 * frame, frame);\n    float f1 = hash(p1);\n    float f2 = hash(p2);\n    \/\/int xp = min(xParticles, int(iResolution.y));\n    \/\/int yp = min(yParticles, int(iResolution.y)); \/\/ + 10 * (frame % 10 + 1);\n    ivec2 p3 = ivec2(f1 * float(xParticles), f2 * float(yParticles));\n    \/\/p3 = ivec2(fragCoord);\n    \/\/i = (i + frame) % (iter * iter);\n    p3 += ivec2(i \/ iter - iter \/ 2, i % iter - iter \/ 2);\n    \/\/p3 += ivec2(i \/ iter, i % iter);\n    p3.x = abs(p3.x % xParticles);\n    p3.y = abs(p3.y % yParticles);\n    return p3;\n}\n\nint serializeUV(in vec3 iResolution, in int frame, ivec2 uv) {\n    \/\/int yp = min(yParticles, int(iResolution.y));\n    return uv.x * yParticles + uv.y;\n}\n\nivec2 deserializeUV(in vec3 iResolution, in int frame, int index) {\n    \/\/int yp = min(yParticles, int(iResolution.y));\n    return ivec2(index \/ yParticles, index % yParticles);\n}\n\nvec4 getRandomParticle2(in vec3 iResolution, in sampler2D iChannel0, in vec2 fragCoord, in int frame, int i) {\n\treturn texelFetch(iChannel0, getRandomParticlePos(iResolution, iChannel0, fragCoord, frame, i), 0);\n}\n\n\/\/ TODO: rename to getParticleData   \nvec4 getParticle(in vec3 iResolution, in sampler2D iChannel0, in int frame, int index) {\n    ivec2 uv = deserializeUV(iResolution, frame, index);\n    \/\/getRandomParticlePos(iResolution, iChannel0, fragCoord, frame, i)\n\treturn texelFetch(iChannel0, uv, 0);\n}\n\nvec2 npos(vec2 pos) {\n    return (pos + 1.0) \/ 2.0;\n}\n\nvec2 dnpos(vec2 pos) {\n    return (pos - 0.5) * 2.0;\n}\n\n\/\/ from http:\/\/stackoverflow.com\/questions\/15276454\/is-it-possible-to-draw-line-thickness-in-a-fragment-shader\n#define Thickness 0.0005\nfloat drawLine(vec2 uv, vec2 p1, vec2 p2) {\n  float a = abs(distance(p1, uv));\n  float b = abs(distance(p2, uv));\n  float c = abs(distance(p1, p2));\n\n  if ( a >= c || b >=  c ) return 0.0;\n\n  float p = (a + b + c) * 0.5;\n\n  \/\/ median to (p1, p2) vector\n  float h = 2.0 \/ c * sqrt( p * ( p - a) * ( p - b) * ( p - c));\n\n  return mix(1.0, 0.0, smoothstep(0.5 * Thickness, 1.5 * Thickness, h));\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":258,"src":"\/media\/previz\/buffer01.png","ctype":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":259,"src":"\/media\/previz\/buffer02.png","ctype":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":259,"channel":0}],"code":"\nint depthFirst(in int nextIndex, in vec2 closestPos, in vec2 uv, in float mind) {\n    const int iter2 = iter * iter;\n    int seen[iter2];\n    for (int i = 0; i < iter2; i++) {\n        seen[i] = -1;\n    }\n    int stack[iter2];\n    for (int i = 0; i < iter2; i++) {\n        stack[i] = -1;\n    }\n    \n    int oldIndex = nextIndex;\n    int stackPointer = 0;\n    int closestIndex = nextIndex;\n    stack[0] = nextIndex;\n    for (int i = 0; i < iter2; i++) {\n    \/\/for (int i = 0; i < 100; i++) {\n        nextIndex = stack[stackPointer];\n        ivec4 closest = ivec4(getParticle(iResolution, iChannel1, iFrame, nextIndex));\n        seen[i] = nextIndex;\n        \n        vec2 pos2 = getParticle(iResolution, iChannel0, iFrame, closest.x).xy;\n        vec2 pos3 = getParticle(iResolution, iChannel0, iFrame, closest.y).xy;\n        vec2 pos4 = getParticle(iResolution, iChannel0, iFrame, closest.z).xy;\n        vec2 pos5 = getParticle(iResolution, iChannel0, iFrame, closest.w).xy;\n        \n        vec2 pos = closestPos;\n        \n        {\n            vec2 cmp = uv;\n            \n            bool seenX = false;\n            bool seenY = false;\n            bool seenZ = false;\n            bool seenW = false;\n            for (int j = 0; j <= i && j <= iter2; j++) {\n                seenX = seenX || (seen[j] == closest.x);\n                seenY = seenY || (seen[j] == closest.y);\n                seenZ = seenZ || (seen[j] == closest.z);\n                seenW = seenW || (seen[j] == closest.w);\n            }\n            \n            float d2 = MAX_DIST;\n            if (!seenX && closest.x != -1) {\n            \tnextIndex = closest.x;\n            \tclosestPos = pos2;\n                d2 = distance(uv, closestPos);\n            }\n            if (!seenY && closest.y != -1 && distance(uv, pos3) < d2) {\n                nextIndex = closest.y;\n            \tclosestPos = pos3;\n                d2 = distance(uv, closestPos);\n            }\n            if (!seenZ && closest.z != -1 && distance(uv, pos4) < d2) {\n                nextIndex = closest.z;\n            \tclosestPos = pos4;\n                d2 = distance(uv, closestPos);\n            }\n            if (!seenW && closest.w != -1 && distance(uv, pos5) < d2) {\n                nextIndex = closest.w;\n            \tclosestPos = pos5;\n                d2 = distance(uv, closestPos);\n            }\n            \n            \/*\n            if (!seenX && closest.x != -1 && cmp.x < pos.x && cmp.y < pos.y) {\n                nextIndex = closest.x;\n                closestPos = pos2;\n            }\n            if (!seenY && closest.y != -1 && cmp.x > pos.x && cmp.y > pos.y) {\n                nextIndex = closest.y;\n                closestPos = pos3;\n            }\n            if (!seenZ && closest.z != -1 && cmp.y < pos.y && cmp.x > pos.x) {\n                nextIndex = closest.z;\n                closestPos = pos4;\n            }\n            if (!seenW && closest.w != -1 && cmp.y > pos.y && cmp.x < pos.x) {\n                nextIndex = closest.w;\n                closestPos = pos5;\n            }*\/\n        }\n        \n        if (nextIndex == oldIndex) {\n            stackPointer = stackPointer > 0 ? stackPointer - 1 : 0;\n        } else {\n            stackPointer++;\n            stack[stackPointer] = nextIndex;\n        }\n        \n        float d = distance(uv, closestPos);\n        if (d < mind) {\n            mind = d;\n            closestIndex = nextIndex;\n        }\n        oldIndex = nextIndex;\n    }\n    return closestIndex;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = dnpos(fragCoord \/ iResolution.xy);\n    vec3 color = vec3(0.0);\n    \n    float mind = MAX_DIST;\n    int closestIndex = -1;\n    vec2 closestPos = vec2(0.0);\n    \/\/ivec2 next = ivec2(0.0);\n    \/\/next.x = next.x % xParticles;\n    \/\/next.y = next.y % yParticles;\n    \n    int frame = iFrame;\n    \n    if (iFrame > 0) {\n        int dd = 1;\n        for (int dx = -dd; dx <= dd; dx++) {\n            for (int dy = -dd; dy <= dd; dy++) {\n                ivec2 niv = ivec2(fragCoord) + ivec2(dx, dy);\n                int index = int(texelFetch(iChannel2, niv, 0).x);\n                \n                \/\/ivec2 niv = getRandomParticlePos(iResolution, iChannel2, iv, frame, j);\n                \n                if (index == -1) continue;\n                \n                vec2 pos = getParticle(iResolution, iChannel0, iFrame, index).xy;\n                float d = distance(uv, pos);\n                \n                if (d > 0.0 && d < mind) {\n                    mind = d;\n                    closestIndex = index;\n                    closestPos = pos;\n                }\n            }\n        }\n        \/*if (closestIndex != -1) {\n        \treturn;\n        }*\/\n    }\n    \n    for (int i = 0; i < iter * iter; i++) {\n        vec2 iv = fragCoord;\n        int j = i;\n        \/*\n        if (iFrame > 0) {\n            ivec2 niv = getRandomParticlePos(iResolution, iChannel2, iv, frame, j);\n            j = int(texelFetch(iChannel2, niv, 0).x);\n            if (j == -1) continue;\n            \n            vec2 pos = getParticle(iResolution, iChannel0, iFrame, j).xy;\n\n            float d = distance(uv, pos);\n            if (d > 0.0 && d < mind) {\n                mind = d;\n                closestIndex = j;\n                closestPos = pos;\n            }\n        }*\/\n        \n        ivec2 particleCoord = getRandomParticlePos(iResolution, iChannel0, iv, frame, i);\n        vec4 particle = texelFetch(iChannel0, particleCoord, 0);\n        \/\/ getRandomParticle(iResolution, iChannel0, fragCoord, iFrame + i);\n        vec2 pos = particle.xy;\n        \n        float d = distance(uv, pos);\n        if (d > 0.0 && d < mind) {\n            mind = d;\n            closestIndex = i;\n            closestPos = pos;\n        }\n    }\n    \n    fragColor.x = float(depthFirst(closestIndex, closestPos, uv, mind));\n    \n    \/\/fragColor.x = float(closestIndex);\n    \/\/fragColor.x = float(serializeUV(iFrame, getRandomParticlePos(iResolution, iChannel0, fragCoord, iFrame, 0)));\n    \/\/fragColor.x = 0.0;\n    \n    return;\n}","name":"Buf C","description":"","type":"buffer"}]}}