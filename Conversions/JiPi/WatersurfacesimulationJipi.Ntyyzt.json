{
 "ver": "0.1",
 "info": {
  "id": "Ntyyzt",
  "date": "0",
  "viewed": 0,
  "name": "WaterSurfaceSimulation JiPi",
  "description": "A minimalist grid based water simulation that accounts for the dispersion relation of surface gravity waves.\n",
  "likes": 0,
  "published": "Private",
  "usePreview": 0,
  "tags": [
   "wave",
   "simulation",
   "water"
  ],
  "hasliked": 0,
  "parentid": "wl3cDj",
  "parentname": " Water Surface Simulation"
 },
 "renderpass": [
  {
   "inputs": [
    {
     "id": "4dXGRr",
     "filepath": "/presets/tex00.jpg",
     "type": "keyboard",
     "channel": 2,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    },
    {
     "id": "4dXGR8",
     "filepath": "/media/previz/buffer00.png",
     "type": "buffer",
     "channel": 1,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    },
    {
     "id": "4sXGR8",
     "filepath": "/media/previz/buffer02.png",
     "type": "buffer",
     "channel": 0,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    }
   ],
   "outputs": [
    {
     "id": "4dfGRr",
     "channel": 0
    }
   ],
   "code": "\nfloat kern_v(float x) { return 1.0-x*x*(3.0-2.0*abs(x)); }\nfloat kern_d(float x) { float o = abs(x)-1.0; return x*(o*o); }\n\nfloat kern_vD1(float x) { return x*(abs(x)*6.0-6.0); }\nfloat kern_dD1(float x) { return (abs(x)-1.0)*(abs(x)*3.0-1.0); }\n\nfloat kern_vD2(float x) { return abs(x) * 12.0 - 6.0; }\nfloat kern_dD2(float x) { return x * 6.0 + (x > 0.0 ? -4.0 : 4.0); }\n\n\nvec4 kern(vec2 p)\n{\n    return vec4(kern_d(p.x) * kern_v(p.y),\n                kern_v(p.x) * kern_d(p.y),\n                kern_d(p.x) * kern_d(p.y),\n                kern_v(p.x) * kern_v(p.y));\n}\n\nmat4 kern4x4(vec2 p)\n{\n    vec2 v   = vec2(kern_v  (p.x), kern_v  (p.y));\n    vec2 d   = vec2(kern_d  (p.x), kern_d  (p.y));\n    \n    vec2 vD1 = vec2(kern_vD1(p.x), kern_vD1(p.y));\n    vec2 dD1 = vec2(kern_dD1(p.x), kern_dD1(p.y));\n    \n    mat4 m = mat4\n    (\n        /*   kernDx         kernDy         kernDxy          kern    */\n        vec4(dD1.x * v.y  ,  d.x * vD1.y  ,  dD1.x * vD1.y  ,  d.x * v.y),\n        vec4(vD1.x * d.y  ,  v.x * dD1.y  ,  vD1.x * dD1.y  ,  v.x * d.y),\n        vec4(dD1.x * d.y  ,  d.x * dD1.y  ,  dD1.x * dD1.y  ,  d.x * d.y),\n        vec4(vD1.x * v.y  ,  v.x * vD1.y  ,  vD1.x * vD1.y  ,  v.x * v.y)\n    );\n    \n    return m;\n}\n\nvoid kern4x4(vec2 p, out mat4 mA, out mat4 mB)\n{\n    vec2 v   = vec2(kern_v  (p.x), kern_v  (p.y));\n    vec2 d   = vec2(kern_d  (p.x), kern_d  (p.y));\n    \n    vec2 vD1 = vec2(kern_vD1(p.x), kern_vD1(p.y));\n    vec2 dD1 = vec2(kern_dD1(p.x), kern_dD1(p.y));\n    \n    vec2 vD2 = vec2(kern_vD2(p.x), kern_vD2(p.y));\n    vec2 dD2 = vec2(kern_dD2(p.x), kern_dD2(p.y));\n    \n    mA = mat4\n    (\n        /*   kernDx         kernDy         kernDxy          kern    */\n        vec4(dD1.x * v.y  ,  d.x * vD1.y  ,  dD1.x * vD1.y  ,  d.x * v.y),\n        vec4(vD1.x * d.y  ,  v.x * dD1.y  ,  vD1.x * dD1.y  ,  v.x * d.y),\n        vec4(dD1.x * d.y  ,  d.x * dD1.y  ,  dD1.x * dD1.y  ,  d.x * d.y),\n        vec4(vD1.x * v.y  ,  v.x * vD1.y  ,  vD1.x * vD1.y  ,  v.x * v.y)\n    );\n\n    mB = mat4\n    (\n        /*   kernDxx        kernDyy        kernDxxy         kernDxyy    */\n        vec4(dD2.x * v.y  ,  d.x * vD2.y  ,  dD2.x * vD1.y  ,  dD1.x * vD2.y),\n        vec4(vD2.x * d.y  ,  v.x * dD2.y  ,  vD2.x * dD1.y  ,  vD1.x * dD2.y),\n        vec4(dD2.x * d.y  ,  d.x * dD2.y  ,  dD2.x * dD1.y  ,  dD1.x * dD2.y),\n        vec4(vD2.x * v.y  ,  v.x * vD2.y  ,  vD2.x * vD1.y  ,  vD1.x * vD2.y)\n    );\n}\n\n\n// BICUBIC SAMPLING ROUTINES =============================================================================================================\n\n// this is the most basic version which only evaluates the function value\nfloat SampleBicubic(sampler2D channel, vec2 uv)\n{\n    uv -= vec2(0.5);\n    \n    vec2 uvi = floor(uv);\n    vec2 uvf = uv - uvi;\n\n    ivec2 uv0 = ivec2(uvi);\n    \n    float r = 0.0;\n    for(int j = 0; j < 2; ++j)\n    for(int i = 0; i < 2; ++i)\n    {\n        vec4 c = texelFetch(channel, uv0 + ivec2(i, j), 0);\n        \n        vec2 l = uvf;\n        \n        if(i != 0) l.x -= 1.0;\n        if(j != 0) l.y -= 1.0;\n        \n        r += dot(c, kern(l));\n    }\n    \n\treturn r;\n}\n\n// ... this version also outputs derivatives (used here to compute normals)\nvec4 SampleBicubic2(sampler2D channel, vec2 uv)\n{\n    uv -= vec2(0.5);\n    \n    vec2 uvi = floor(uv);\n    vec2 uvf = uv - uvi;\n\n    ivec2 uv0 = ivec2(uvi);\n    \n    vec4 r = vec4(0.0);\n    for(int j = 0; j < 2; ++j)\n    for(int i = 0; i < 2; ++i)\n    {\n        vec4 c = texelFetch(channel, uv0 + ivec2(i, j), 0);\n        \n        vec2 l = uvf;\n        \n        if(i != 0) l.x -= 1.0;\n        if(j != 0) l.y -= 1.0;\n        \n        r += kern4x4(l) * c;\n    }\n    \n    // r = vec4(df/dx, df/dy, ddf/dxy, f)\n\treturn r;\n}\n\n// ... this version also outputs higher order derivatives (only used to debug C2 continuity here)\nvec4 SampleBicubic3(sampler2D channel, vec2 uv, out vec4 d2)\n{\n    uv -= vec2(0.5);\n    \n    vec2 uvi = floor(uv);\n    vec2 uvf = uv - uvi;\n\n    ivec2 uv0 = ivec2(uvi);\n    \n    d2 = vec4(0.0);\n    vec4 r = vec4(0.0);\n    for(int j = 0; j < 2; ++j)\n    for(int i = 0; i < 2; ++i)\n    {\n        vec4 c = texelFetch(channel, uv0 + ivec2(i, j), 0);\n        \n        vec2 l = uvf;\n        \n        if(i != 0) l.x -= 1.0;\n        if(j != 0) l.y -= 1.0;\n        \n        mat4 mA, mB;\n        kern4x4(l, /*out*/ mA, mB);\n        \n        r  += mA * c;\n        d2 += mB * c;\n    }\n    \n    // r  = vec4(  df/dx,   df/dy,  ddf/dxy ,         f)\n    // d2 = vec4(ddf/dxx, ddf/dyy, dddf/dxxy, dddf/dxyy)\n\treturn r;\n}\n\n\n// IMAGE ==========================================================================================================================\n\nfloat ReadKey(int keyCode) {return texelFetch(iChannel2, ivec2(keyCode, 0), 0).x;}\nfloat ReadKeyToggle(int keyCode) {return texelFetch(iChannel2, ivec2(keyCode, 2), 0).x;}\n\nvoid mainImage( out vec4 fragColor, in vec2 uv0 )\n{    \n    #if 0\n    fragColor = texelFetch(iChannel1, ivec2(uv0-0.5), 0);\n    return;\n    #endif\n\n    bool isTerrainAnimated = ReadKeyToggle(KEY_N1) == 0.0;\n\n   #if 1\n    // mini map\n    bool doShowWaveField = ReadKeyToggle(KEY_N3) != 0.0;\n   \n    if(doShowWaveField)\n    if(uv0.x < GridSize && uv0.y < GridSize)\n    {\n        vec3 col = vec3(1.0) - normalize(vec3(texelFetch(iChannel0, ivec2(uv0 - 0.5), 0).xy, .01)).z;\n        \n        float d = EvalTerrainHeight(uv0, isTerrainAnimated ? iTime : 0.0);\n        \n        bool doShowHeightField = ReadKeyToggle(KEY_N4) != 0.0;\n        if(doShowHeightField) col = (texelFetch(iChannel0, ivec2(uv0 - 0.5), 0).www * 1.0 + 0.5);\n        \n        col *= col;\n\n        float l = -min(d, 0.0)*3.;\n        col = mix(vec3(0.125, 0.125, 1.0 ), col, 1.0-(exp2(-(l*2.0 + l*l*1.0))));\n        col = mix(col, vec3(1.0  , 0.0  , 0.25), smoothstep(-0.05, 0.0, d));\n\n        bool isGridWindowSharp = ReadKeyToggle(KEY_N2) != 0.0;\n        if(isGridWindowSharp && (uv0.x == 0.5 || uv0.y == 0.5 || uv0.x == GridSize-0.5 || uv0.y == GridSize-0.5)) col = vec3(0.0, 1.0, 1.0); \n\n        fragColor = vec4(sqrt(clamp01(col.rgb)), 0.0);\n        return;\n    }\n   #endif\n \n    vec3 col;\n    \n    vec2 uv = uv0;\n    vec2 tc = uv0 / iResolution.xx;\n    \n   #if 0\n    if(uv0.x >= iResolution.x*0.5)\n    uv.x -= iResolution.x*0.5;\n   #endif\n    \n    col = vec3(texture(iChannel0, uv0/iResolution.xy*0.125).r);\n    \n    \n    vec2 uv2 = PatchUVfromScreenUV(uv0.xy, iResolution.xy);\n\n    float time = isTerrainAnimated ? iTime : 0.0;\n\n    vec3 V = vec3(0.0, 0.0, 1.0);\n    vec3 L = normalize(vec3(1.0, 1.0, 1.0));\n    vec3 L2 = normalize(vec3(-1.0, -1.0, 2.0));\n    vec3 H = normalize(L + V);\n\n\n    vec3 terrN;\n    {\n        float s = 1.0/128.0;\n        \n        float hx0 = EvalTerrainHeight(uv2 - vec2(s, 0.0), time);\n        float hx1 = EvalTerrainHeight(uv2 + vec2(s, 0.0), time);\n        float hy0 = EvalTerrainHeight(uv2 - vec2(0.0, s), time);\n        float hy1 = EvalTerrainHeight(uv2 + vec2(0.0, s), time);\n        \n        vec2 dxy = vec2(hx1 - hx0, hy1 - hy0) / (2.0 * s);\n        \n        terrN = normalize(vec3(-dxy, 0.03));\n    }\n    \n    vec3 terrCol = clamp01(dot(terrN, L))*(1.0/(1.0+1.0*(1.0-clamp01(dot(terrN, H)))))*vec3(1.0)*0.05;\n\n\n    vec4 d2;\n    vec4 h = SampleBicubic3(iChannel0, uv2, d2);// sample water surface\n    \n    float nscale = 32.0;\n    vec3 N = normalize(vec3(-h.xy * nscale, 1.0));\n    \n    vec3 R = 2.0*dot(V, N)*N - V;\n\n    float ct = clamp01(dot(N, L));\n    float ct2 = dot(N, L) * 0.5 + 0.5;\n    \n    float d = h.w - EvalTerrainHeight(uv2-N.xy*4.0, time);\n    \n    float waterMask = smoothstep(-0.01, 0.01, d);\n    \n    // diffuse\n    float v =  clamp01(ct2+0.15);\n    v = 1.0-v;\n    v = cubic(v);\n    \n    col = exp(-(v * 12.0 + 5.) * vec3(0.05, 0.3, 1.))*1.4;\n    //col *= mix(0.25, 1.0, clamp01(dot(terrN, L)+0.5));\n\n    float l = max(0.0, d);\n    col = mix(terrCol, col, (1.0-exp2(-(l*2.0 + l*l*1.0))));\n    col += vec3(0.0, 0.25, 1.0)*0.1;\n    \n    // specular\n    float c = 1.0 - (dot(R, L)*0.5+0.5);\n    float c2 = 1.0 - (dot(R, L2)*0.5+0.5);\n    float spec = 0.0;\n    spec += smoothstep(0.9, 0.99, dot(R, L))*0.5; \n    float spec0 = spec;\n    spec += smoothstep(0.7, 0.9, dot(R, L))*0.125; \n    spec += smoothstep(0.8, 0.9, dot(R, L2))*0.02; \n    spec += smoothstep(0.95, 0.99, N.z)*0.02; \n    spec += exp2(-32.0*(c))*0.25;\n    \n    col += vec3(1.0) * spec * waterMask;\n    \n    col = GammaEncode(clamp01(col));\n    \n    fragColor = vec4(col, 0.0);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
   "name": "Image",
   "description": "",
   "type": "image"
  },
  {
   "inputs": [],
   "outputs": [],
   "code": "// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n    #define USE_HQ_KERNEL\n     \n    // #define USE_AXISALIGNED_OBSTACLES\n\nconst float GridScale = 100.0;// vertex spacing; 1 -> meters | 100 -> centimeters \n\nconst float GridSize = 256.0;// vertex count per dimension\n\n\n\nfloat TrigNoise(vec3 x, float a, float b)\n{\n    vec4 u = vec4(dot(x, vec3( 1.0, 1.0, 1.0)), \n                  dot(x, vec3( 1.0,-1.0,-1.0)), \n                  dot(x, vec3(-1.0, 1.0,-1.0)),\n                  dot(x, vec3(-1.0,-1.0, 1.0))) * a;\n\n    return dot(sin(x     + cos(u.xyz) * b), \n               cos(x.zxy + sin(u.zwx) * b));\n}\n\nfloat TrigNoise(vec3 x)\n{\n    return TrigNoise(x, 2.0, 1.0);\n}  \n\n\n\nfloat EvalTerrainHeight(vec2 uv, float time)\n{\n    uv -= vec2(GridSize * 0.5);\n    \n  #ifdef USE_AXISALIGNED_OBSTACLES\n    return max(max((-uv.x-64.0), uv.y-64.0), min((uv.x-32.0), -uv.y-8.0)) * 0.02;\n  #endif\n    \n    float w = time * 0.125;\n    //w = 0.0;\n    \n    float terr = -(TrigNoise(vec3(uv * 0.01, w)) + 1.0) * 0.5;\n    \n    return terr;\n}\n\n\nvec2 PatchUVfromScreenUV(vec2 screenUV, vec2 screenResolution)\n{\n    return vec2(GridSize * 0.5) + (screenUV - screenResolution.xy*0.5)/screenResolution.xx * 226.0;\n}\n\n\n/*\n// x: [0, inf], s: (-1, 1] / (soft, hard]\nfloat SoftClip(float x, float s)\n{\n    return (1.0 + x - sqrt(1.0 - 2.0*s*x + x*x)) / (1.0 + s);\n}\n\nvec3 SoftClip(vec3 x, float s)\n{\n    return (1.0 + x - sqrt(1.0 - 2.0*s*x + x*x)) / (1.0 + s);\n}\n\n*/\n\n\n\n\n#define rsqrt inversesqrt\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define If(cond, resT, resF) mix(resF, resT, cond)\n\nconst float Pi = 3.14159265359;\nconst float Pi05 = Pi * 0.5;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\n/* http://keycode.info/ */\n#define KEY_LEFT  37\n#define KEY_UP    38\n#define KEY_RIGHT 39\n#define KEY_DOWN  40\n\n#define KEY_CTRL 17\n#define KEY_SHIFT 16\n#define KEY_SPACE 32 \n#define KEY_A 0x41\n#define KEY_D 0x44\n#define KEY_S 0x53\n#define KEY_W 0x57\n\n#define KEY_N1 49\n#define KEY_N2 50\n#define KEY_N3 51\n#define KEY_N4 52\n#define KEY_N5 53\n#define KEY_N6 54\n#define KEY_N7 55\n#define KEY_N8 56\n\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}\n\nvec2 AngToVec(float ang)\n{\t\n\treturn vec2(cos(ang), sin(ang));\n}\n\n\nvec3 AngToVec(vec2 ang)\n{\n    float sinPhi   = sin(ang.x);\n    float cosPhi   = cos(ang.x);\n    float sinTheta = sin(ang.y);\n    float cosTheta = cos(ang.y);    \n\n    return vec3(cosPhi * cosTheta, \n                         sinTheta, \n                sinPhi * cosTheta); \n}\n\nfloat cubic(float x) {return x*x*(3.-2.*x);}\nvec2  cubic(vec2  x) {return x*x*(3.-2.*x);}\nvec3  cubic(vec3  x) {return x*x*(3.-2.*x);}\nvec4  cubic(vec4  x) {return x*x*(3.-2.*x);}\n\nfloat quintic(float x){ return ((x * 6.0 - 15.0) * x + 10.0) * x*x*x;}\nvec2  quintic(vec2  x){ return ((x * 6.0 - 15.0) * x + 10.0) * x*x*x;}\nvec3  quintic(vec3  x){ return ((x * 6.0 - 15.0) * x + 10.0) * x*x*x;}\nvec4  quintic(vec4  x){ return ((x * 6.0 - 15.0) * x + 10.0) * x*x*x;}\n\n\nuint  asuint2(float x) { return x == 0.0 ? 0u : floatBitsToUint(x); }\nuvec2 asuint2(vec2 x) { return uvec2(asuint2(x.x ), asuint2(x.y)); }\nuvec3 asuint2(vec3 x) { return uvec3(asuint2(x.xy), asuint2(x.z)); }\nuvec4 asuint2(vec4 x) { return uvec4(asuint2(x.xy), asuint2(x.zw)); }\n\nfloat Float01(uint x) { return float(    x ) * (1.0 / 4294967296.0); }\nfloat Float11(uint x) { return float(int(x)) * (1.0 / 2147483648.0); }\n\nvec2 Float01(uvec2 x) { return vec2(      x ) * (1.0 / 4294967296.0); }\nvec2 Float11(uvec2 x) { return vec2(ivec2(x)) * (1.0 / 2147483648.0); }\n\nvec3 Float01(uvec3 x) { return vec3(      x ) * (1.0 / 4294967296.0); }\nvec3 Float11(uvec3 x) { return vec3(ivec3(x)) * (1.0 / 2147483648.0); }\n\nvec4 Float01(uvec4 x) { return vec4(      x ) * (1.0 / 4294967296.0); }\nvec4 Float11(uvec4 x) { return vec4(ivec4(x)) * (1.0 / 2147483648.0); }\n\n// constants rounded to nearest primes\nconst uint rPhi1  = 2654435761u;\n\nconst uint rPhi2a = 3242174893u;\nconst uint rPhi2b = 2447445397u;\n\nconst uint rPhi3a = 3518319149u;\nconst uint rPhi3b = 2882110339u;\nconst uint rPhi3c = 2360945581u;\n\nconst uint rPhi4a = 3679390609u;\nconst uint rPhi4b = 3152041517u;\nconst uint rPhi4c = 2700274807u;\nconst uint rPhi4d = 2313257579u;\n\nconst uvec2 rPhi2 = uvec2(rPhi2a, rPhi2b);\nconst uvec3 rPhi3 = uvec3(rPhi3a, rPhi3b, rPhi3c);\nconst uvec4 rPhi4 = uvec4(rPhi4a, rPhi4b, rPhi4c, rPhi4d);\n\nuint  Roberts(uint  off, uint n) { return off + rPhi1 * n; }\nuvec2 Roberts(uvec2 off, uint n) { return off + rPhi2 * n; }\nuvec3 Roberts(uvec3 off, uint n) { return off + rPhi3 * n; }\nuvec4 Roberts(uvec4 off, uint n) { return off + rPhi4 * n; }\n\n// http://marc-b-reynolds.github.io/math/2016/03/29/weyl_hash.html\nuint WeylHash(uvec2 c) \n{\n    return ((c.x * 0x3504f333u) ^ (c.y * 0xf1bbcdcbu)) * 741103597u; \n}\n\n// low bias version https://nullprogram.com/blog/2018/07/31/\nuint WellonsHash(uint x)\n{\n    x ^= x >> 16u;\n    x *= 0x7feb352dU;\n    x ^= x >> 15u;\n    x *= 0x846ca68bU;\n    x ^= x >> 16u;\n\n    return x;\n}\n\nuvec2 WellonsHash(uvec2 v) { return uvec2(WellonsHash(v.x), WellonsHash(v.y)); }\n\n",
   "name": "Common",
   "description": "",
   "type": "common"
  },
  {
   "inputs": [
    {
     "id": "4dXGRr",
     "filepath": "/presets/tex00.jpg",
     "type": "keyboard",
     "channel": 1,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    },
    {
     "id": "4dXGR8",
     "filepath": "/media/previz/buffer00.png",
     "type": "buffer",
     "channel": 0,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    },
    {
     "id": "XsXGR8",
     "filepath": "/media/previz/buffer01.png",
     "type": "buffer",
     "channel": 2,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    }
   ],
   "outputs": [
    {
     "id": "4dXGR8",
     "channel": 0
    }
   ],
   "code": "// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/* Simulation */\n\nfloat ReadKey(int keyCode) {return texelFetch(iChannel1, ivec2(keyCode, 0), 0).x;}\nfloat ReadKeyToggle(int keyCode) {return texelFetch(iChannel1, ivec2(keyCode, 2), 0).x;}\n\n#define FETCH(uv) texelFetch(iChannel0, uv, 0).r\n#define FETCH2(uv) texelFetch(iChannel2, uv, 0).r\n#define FETCH3(uv) texelFetch(iChannel2, uv, 0)\n\nvoid mainImage( out vec4 col, in vec2 uv0 )\n{\n\n    // =================================================================================== //\n    // program state\n    bool isGrid = uv0.x < GridSize && uv0.y < GridSize;\n    bool isStateColumn = uv0.x == iResolution.x - 0.5;\n    \n    if(!isGrid && !isStateColumn) { discard; }\n\n    ivec2 uv = ivec2(uv0 - 0.5);\n    int stateColumnX = int(iResolution.x - 1.0);\n    \n    float iFrameTest     = texelFetch(iChannel0, ivec2(stateColumnX, 0), 0).x;\n    vec4  iMouseLast     = texelFetch(iChannel0, ivec2(stateColumnX, 1), 0);\n    float iTimeDeltaLast = texelFetch(iChannel0, ivec2(stateColumnX, 2), 0).x;\n\n    bool isInit = float(iFrame) == iFrameTest;\n    if( !isInit)\n    {\n        iTimeDeltaLast = iTimeDelta;\n    }\n    \n    if(isStateColumn)\n    {\n        if(uv.y == 0) col = vec4(float(iFrame) + 1.0, 0.0, 0.0, 0.0);\n        if(uv.y == 1) col = iMouse;\n        if(uv.y == 2) col = vec4(iTimeDelta, 0.0, 0.0, 0.0);\n        \n        return;\n    }\n    \n    if(!isGrid) return;\n    // =================================================================================== //\n\n    col = vec4(0.0);\n    \n    vec2 h12 = texelFetch(iChannel0, uv, 0).xy;\n\n    bool isTerrainAnimated = ReadKeyToggle(KEY_N1) == 0.0;\n    \n    float terrH = EvalTerrainHeight(uv0, isTerrainAnimated ? iTime : 0.0);\n    float mask = smoothstep(0.0, -0.05, terrH);\n    float D = clamp01(-terrH);\n    float lD2 = clamp01(-terrH-1.0);\n    \n   \n#ifdef USE_HQ_KERNEL\n\n    // 30 tabs version (vertical pass; horizontal pass in Buffer B)\n    float lowp3[4] = float[4](5.0/16.0, 15.0/64.0, 3.0/32.0, 1.0/64.0);   \n    float lowp7[8] = float[8](429.0/2048.0, 3003.0/16384.0, 1001.0/8192.0, 1001.0/16384.0, 91.0/4096.0, 91.0/16384.0, 7.0/8192.0, 1.0/16384.0);   \n    float lapl7[8] = float[8](3.22, -1.9335988099476562, 0.4384577800334821, -0.1637450351359609, 0.07015324480535713, -0.02963974593026339, 0.010609595665007715, -0.0022370294899667453);   \n\n    float lowpass3  = 0.0;\n    float lowpass7  = 0.0;\n    float laplacian = 0.0;\n    \n    for(int y = -7; y <= 7; ++y)\n    {\n        vec3 f = FETCH3(uv + ivec2(0, y)).xyz;\n    \n        int i = abs(y);\n\n        lowpass3  += f.x * (i < 4 ? lowp3[i] : 0.0);\n        lowpass7  += f.y * lowp7[i];\n        laplacian += f.z * lapl7[i];\n    }\n\n    vec4 f0 = FETCH3(uv);\n    \n    laplacian += f0.w;\n    \n    float highpass = f0.z - mix(lowpass3, lowpass7, 0.772 * lD2);\n    float halfLaplacian =   mix(highpass, laplacian, 0.19)*1.255;\n\n    float Aa = laplacian;\n    float Ab = halfLaplacian;\n   \n#else\n\n   #if 0\n    // 21 tabs version\n    const int r  = 4;\n    const int r1 = r + 1;\n\n    float kernA[r1] = float[r1](3.14, -1.8488262937460072, 0.3538769077873216, -0.0913000638886917, 0.016249449847377015);\n\n    float kernB[r1*r1] = float[r1*r1](2.269921105564736    , -0.4505893247500618, 0.01789846106075618, -0.01027660288590306, 0.0034772145111404747, \n                                     -0.4505893247500618   , -0.1279900243271159, 0.                 ,  0.                 , 0.                   , \n                                      0.01789846106075618  ,  0.                , 0.                 ,  0.                 , 0.                   , \n                                     -0.01027660288590306  ,  0.                , 0.                 ,  0.                 , 0.                   , \n                                      0.0034772145111404747,  0.                , 0.                 ,  0.                 , 0.                   );  \n   #else\n    // 13 tabs version\n    const int r  = 2;\n    const int r1 = r + 1;\n \n    float kernA[r1] = float[r1](2.85, -1.5792207792207793, 0.15422077922077923);\n \n    float kernB[r1*r1] = float[r1*r1](2.0933782605117255  , -0.32987120049780483, -0.026408964879028916, \n                                     -0.32987120049780483 , -0.1670643997510976 ,  0.0                 ,\n                                     -0.026408964879028916,  0.0                ,  0.0                 );\n   #endif\n     \n      \n    float Aa = 0.0;\n    float Ab = 0.0;\n\n    for(int y = -r; y <= r; ++y)\n    for(int x = -r; x <= r; ++x)\n    {\n        float w = (kernB[abs(x) + abs(y) * r1]);\n\n        if(w == 0.0) continue;\n\n        float f = FETCH(uv + ivec2(x, y));\n\n        Ab += f * w;\n\n        if(y == 0) Aa += f * kernA[abs(x)];                \n        if(x == 0) Aa += f * kernA[abs(y)];                \n    }     \n\n#endif\n\n  #ifndef USE_AXISALIGNED_OBSTACLES\n    // mitigate erroneous simulation behavior along shorelines\n    D = mix(0.25, 1.0, D);\n  #endif\n  \n    float A = mix(Aa, Ab, (D*D) / (2.0/7.0 + 5.0/7.0 * (D*D))) * D;\n    \n   // A = Ab;// deep\n   // A = Aa * 0.5;// shallow\n\n    A *= -9.81*GridScale;\n\n\n    // painting\n    bool isSingleDrop = ReadKey(KEY_SHIFT) != 0.0;\n    \n    if(iMouse.w > 0.0 || (!isSingleDrop && iMouse.z > 0.0 || (iMouse.x != iMouseLast.x && iMouse.y != iMouseLast.y)))\n    {\n        vec2 c = PatchUVfromScreenUV(iMouse.xy, iResolution.xy);\n        \n        vec2 vec = (uv0 - c);\n  \n        if(!isSingleDrop)\n        if(iMouseLast.z > 0.0 || iMouseLast.w > 0.0)\n        {\n            vec2 c2 = PatchUVfromScreenUV(iMouseLast.xy, iResolution.xy);\n            \n            vec = uv0 - (c2 + (c-c2)*clamp01(dot(c-c2, uv0-c2)/dot(c-c2,c-c2)));\n        }\n  \n        float v = exp2(-dot(vec, vec) * 1.0);\n        h12 = mix(h12, vec2(0.75), v);\n    }\n    \n    if(iFrame == 0) h12 = vec2(0.0);\n\n    // rain drops\n    if(ReadKeyToggle(KEY_N5) == 0.0)\n    if(WellonsHash(uint(iFrame)) < 100000000u)\n    {\n        vec2 c = Float01(WellonsHash(uint(iFrame) * uvec2(3242174893u, 2447445397u) + 3u)) * GridSize;\n        vec2 vec = (uv0 - c);\n    \n        float v = exp2(-dot(vec, vec) * 1.0);\n        h12 = mix(h12, vec2(0.75), v);\n    }\n\n    float dt = 0.016667;\n    float dt2 =  dt * dt;\n\n    float h0 = 0.0;\n    float h1 = h12.x;\n    float h2 = h12.y;\n\n#if 1\n    // Verlet integration\n    h0 = (2.0 * h1 - h2) + A * dt2;\n\n#else\n\n    // ...damped version\n    float a = 1.0/2.0;\n    float adt = a * dt;\n    \n    h0 = (((2.0 + adt) * h1 - h2) + A * dt2) / (1.0 + adt);\n\n#endif\n\n    vec2 h01 = vec2(h0, h1);\n\n    // exponential state buffer smoothing\n    float beta = 2.0;\n    h01 = mix(h01, h12, 1.0-exp2(-dt*beta));\n\n    // mask out obstacles\n    h01 *= mask;\n\n    // grid windowing\n    bool isGridWindowed = ReadKeyToggle(KEY_N2) == 0.0;\n    if(isGridWindowed)\n    {\n        float r = 32.0;\n\n        vec2 u = min((vec2(GridSize*0.5) - abs(uv0 - vec2(GridSize*0.5))) / r, vec2(1.0));\n\n        u = 1.0 - u;\n        u *= u;\n        u *= u;\n        u = 1.0 - u;\n\n        float s = u.x*u.y;\n\n        h01 *= mix(0.75, 1.0, s);        \n    }\n    \n    if(ReadKey(KEY_SPACE) != 0.0) { h01 *= 0.95; } \n    \n    col = vec4(h01, 0.0, 0.0);\n}\n\n\n\n\n\n\n\n\n\n",
   "name": "Buffer A",
   "description": "",
   "type": "buffer"
  },
  {
   "inputs": [
    {
     "id": "4dXGR8",
     "filepath": "/media/previz/buffer00.png",
     "type": "buffer",
     "channel": 0,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    }
   ],
   "outputs": [
    {
     "id": "XsXGR8",
     "channel": 0
    }
   ],
   "code": "// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/* horizontal pass of hq deep water kernel */\n\n#define FETCH(uv) texelFetch(iChannel0, uv, 0).r\n\nvoid mainImage(out vec4 col, in vec2 uv0)\n{\n  #ifndef USE_HQ_KERNEL\n    discard; return;\n  #endif\n  \n    bool isGrid = uv0.x < GridSize && uv0.y < GridSize;\n\n    if(!isGrid) return;\n\n    ivec2 uv = ivec2(uv0 - 0.5);\n    \n    float lowp3[4] = float[4](5.0/16.0, 15.0/64.0, 3.0/32.0, 1.0/64.0);   \n    float lowp7[8] = float[8](429.0/2048.0, 3003.0/16384.0, 1001.0/8192.0, 1001.0/16384.0, 91.0/4096.0, 91.0/16384.0, 7.0/8192.0, 1.0/16384.0);   \n    float lapl7[8] = float[8](3.22, -1.9335988099476562, 0.4384577800334821, -0.1637450351359609, 0.07015324480535713, -0.02963974593026339, 0.010609595665007715, -0.0022370294899667453);   \n\n    float lowpass3  = 0.0;\n    float lowpass7  = 0.0;\n    float laplacian = 0.0;\n    \n    for(int x = -7; x <= 7; ++x)\n    {\n        float f = FETCH(uv + ivec2(x, 0));\n    \n        int i = abs(x);\n\n        lowpass3  += f * (i < 4 ? lowp3[i] : 0.0);\n        lowpass7  += f * lowp7[i];\n        laplacian += f * lapl7[i];\n    }\n\n    float f0 = FETCH(uv);\n    \n    col = vec4(lowpass3, lowpass7, f0, laplacian);\n}",
   "name": "Buffer B",
   "description": "",
   "type": "buffer"
  },
  {
   "inputs": [
    {
     "id": "4dXGR8",
     "filepath": "/media/previz/buffer00.png",
     "type": "buffer",
     "channel": 0,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    }
   ],
   "outputs": [
    {
     "id": "4sXGR8",
     "channel": 0
    }
   ],
   "code": "// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/*\n    pre-filter pass (prepares height field for rendering)\n    https://www.shadertoy.com/view/WtsBDH (\"Bicubic C2 cont. Interpolation\")\n*/\n\n#define FETCH(uv) (texelFetch(iChannel0, uv, 0).r)\n\nvoid mainImage( out vec4 fragColor, in vec2 uv0 )\n{    \n    if(uv0.x > GridSize || uv0.y > GridSize) return;\n\n    ivec2 uv = ivec2(uv0 - 0.5);\n    \n    vec4 col = vec4(0.0);\n    \n    // ======================================================= GENERALIZED CUBIC BSPLINE =======================================================\n    \n    float kernD0[3];\n    float kernD1[3];\n    \n    kernD0[0] = 2.0/3.0; kernD0[1] = 1.0/6.0; kernD0[2] = 0.0;\n    kernD1[0] =     0.0; kernD1[1] =    -0.5; kernD1[2] = 0.0;\n    \n    float sw;// side lobes weight\n\n    sw = 0.0;// cubic BSpline\n    \n   #if 0\n   \n    sw = 0.25;// similar to 1/3 but less ringing\n    \n   #elif 0\n   \n    sw = 1.0/3.0;// kernD0[0] == 1\n    \n   #elif 0\n    \n    sw = 0.186605;// max abs derivative == 1\n    \n   #elif 0\n    \n    sw = 1.0/6.0;// maximaly flat pass band\n    \n   #elif 1\n    \n    sw = -0.25;// spectrum falls off to 0 at Nyquist frequency\n    \n   #endif\n    \n    // add a pair of side lobes:\n    kernD0[0] += 1.0 * sw; kernD0[1] += -1.0/3.0 * sw; kernD0[2] += -1.0/6.0 * sw;\n    \t                   kernD1[1] += -1.0     * sw; kernD1[2] +=  0.5     * sw;\n    \n    int r = sw == 0.0 ? 1 : 2;\n    for(int j = -r; j <= r; ++j)\n    for(int i = -r; i <= r; ++i)\n    {\n    \tfloat f = FETCH(uv + ivec2(i, j));\n        \n        int x = abs(i);\n        int y = abs(j);\n        \n        float kAx = kernD0[x];\n        float kAy = kernD0[y];\n        \n        float kBx = kernD1[x] * (i > 0 ? -1.0 : 1.0);\n        float kBy = kernD1[y] * (j > 0 ? -1.0 : 1.0);\n        \n        col += f * vec4(kBx * kAy, \n                        kAx * kBy, \n                        kBx * kBy,\n                        kAx * kAy);\n    }\n    \n    // col = vec4(df/dx, df/dy, d^2f/dxy, f)\n    fragColor = col;\n}\n\n",
   "name": "Buffer C",
   "description": "",
   "type": "buffer"
  }
 ]
}