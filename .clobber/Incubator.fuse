--- Special purpose Fuse to support shader kernel development.
--
-- Based on the work of Chris Ridings (www.chrisridings.com), Bryan Ray (http://www.bryanray.name/wordpress/opencl-fuses-index/),
-- JiPi (https://youtu.be/dbrPWRldmbs), Igor Riđanović (https://youtu.be/p6IeeWr3FOc), and many others.
--




-- ----------------------------------------------------------------------------------------------------------------------------------------

ShaderParameters     = nil
CompatibilityCode    = nil
ConversionShaderID   = ""
ConversionFusename   = ""
ConversionKernelname = ""
ConversionSourcecode = ""

NUM_COLOR_CONTROLS=5
NUM_TINYSLIDER_CONTROLS=3
NUM_SMALLSLIDER_CONTROLS=3

-- ----------------------------------------------------------------------------------------------------------------------------------------

ConversionSourcecode_fallback = [[

__KERNEL__ void IncubatorFallbackKernel(
    __CONSTANTREF__ Params *params,
    __TEXTURE2D__ iChannel0,
    __TEXTURE2D_WRITE__ dst
    )
{
  DEFINE_KERNEL_ITERATORS_XY(x, y);

  if (x >= params->width || y >= params->height)
    return;

  _tex2DVec4Write(dst, x, y, to_float4(1.0f,0.0f,0.0f,0.0f) );
}
]]



-- ----------------------------------------------------------------------------------------------------------------------------------------

FuRegisterClass("ShadertoysIncubator", CT_SourceTool, {
    REGS_Name = "ShadersInc",
	  REGS_Category = "Fuses",
    REGS_OpDescription = "An Incubator for Shadertoys",
	  REGS_OpIconString = "incubus",
    REG_Source_GlobalCtrls = true,
    REG_Source_SizeCtrls = true,
    REG_Source_AspectCtrls = true,
	  REG_TimeVariant = true,
	  REGS_Company = "nmbr73",
	  REGS_URL = "https://nmbr73.github.io/",
	  REG_Version	= 000001,
    REG_Fuse_NoEdit = false,
    REG_Fuse_NoReload = false, -- true,
    })



-------------------------------------------------------------------------------------------------------------------------------------------
-- Print verbose message.
--
-- Use verbose() to print any non-error message just meant to help developing the Incubator.fuse itself.
--
-- @param[type=string] msg The message to output in DaFusions console window.
--
function verbose(msg)
  print(msg)
end



-------------------------------------------------------------------------------------------------------------------------------------------
-- Local structure to manage vaialable source code.
--
-- This table is initialized by getConversions() with filenames, IDs, etc. of the sources found in the
-- repositorie's *'Conversions/'* folder. It is used to proviede these sources i.e. in a ComboBox for
-- selection.
--
-- @table Conversions
-- @field Name Fusename of the conversion.
-- @field Path Full path of the folder the conversion can be found in.
-- @field Filename Full filename (indcluding the ID and '.c' suffix).
-- @field ShadertoyID The ID of the Shadertoy the code originally came from.
-- @field Label Name in human readable form identifying the converson to show in messages, the ComboBox, etc. .
--
Conversions={}



-------------------------------------------------------------------------------------------------------------------------------------------
-- Create a table to initializie in particular `Conversions` with.
--
-- @param[type=string] path Path to where the conversions reside.
-- @return[type=table] conversion information; `{}` if no conversions found
--
function getConversions(path)

  local files={}

  local handle	= bmd.readdir(path.."*.*.c")

  for k, v in pairs(handle) do
    if v.Name and not(v.IsDir) then

      local filename = v.Name
      local fusename, shadertoyid = filename:match('^(.+)%.([^%.]+)%.c$')

      files[k]={
        Name=fusename,
        Path=path,
        Filename=filename,
        ShadertoyID=shadertoyid,
        Label=fusename.." ("..shadertoyid..")",
      }
    end
  end

  return files
end



-------------------------------------------------------------------------------------------------------------------------------------------
-- Callback to initialize the tool.
--
function Create()

  local xtracode=""

  for i=0,NUM_COLOR_CONTROLS-1 do
    xtracode=xtracode.."#define USE_CTRL_COLOR"..i.."(NAME) float4 NAME     = to_float4(params->color["..i.."][0],params->color["..i.."][1],params->color["..i.."][2],params->color["..i.."][3])\n"
  end

  for i=0,NUM_TINYSLIDER_CONTROLS-1 do
    xtracode=xtracode.."#define USE_CTRL_TINYSLIDER"..i.."(NAME,SMIN,SMAX,SDEFAULT) float NAME = params->tinySlider["..i.."]; if (NAME<SMIN) NAME=(SMIN); if (NAME>SMAX) NAME=(SMAX) \n"
  end

  verbose("use the folloin defines to connect your controls:\n"..xtracode)

  -- get the list of conversions and read compatibility and params code

  local REPOSITORYPATH=[[  <WILL BE REPLACED BY INSTALL.LUA>  ]]

  verbose("Create: repository used is "..REPOSITORYPATH)

  Conversions=getConversions(REPOSITORYPATH..'Conversions/')

  f = io.open(REPOSITORYPATH..'.clobber/CompatibilityCode.c', "r")

  if not f then
    CompatibilityCode = nil
    print("failed to read compatibility code")
  else
    CompatibilityCode = f:read("*all") .. xtracode
    f:close()
  end

  ShaderParameters=[[

  float iTime;
  float iMouse[4];

  float color[]]..NUM_COLOR_CONTROLS..[[][4];
  float tinySlider[]]..NUM_TINYSLIDER_CONTROLS..[[];

  int   width, height;
  int   compOrder;

  int iChannel0_width;
  int iChannel0_height;
  ]]


  print(ShaderParameters)

  -- combo box with all the conversions + a reload button

  local attrs

  attrs={}

  for k,v in pairs(Conversions) do
    verbose("Create: conversion '"..v.Label.."'")
    table.insert(attrs,{ CCS_AddString = v.Label })
  end

  InFileToUseCombo = self:AddInput("Code Fragment", "FragementFileSelection", {
    LINKID_DataType = "Number",
    INPID_InputControl = "ComboControl",
	  INP_DoNotifyChanged = true,
    INP_Default = 0,
    INP_Integer = true,
    attrs
    })

  InReloadCodeButton= self:AddInput("Reload Code", "ReloadCodeFragment",
    { LINKID_DataType = "Text",
      INPID_InputControl = "ButtonControl",
      INP_DoNotifyChanged = true,
      INP_External = false,
    })

  InShadertoyButton=self:AddInput("Show on shadertoy.com", "ShowOnShadertoy", {
    LINKID_DataType = "Text",
    INPID_InputControl = "ButtonControl",
    INP_DoNotifyChanged = false,
    INP_External = false,
    BTNCS_Execute = 'print("does nothing")',
    INP_Disabled=true,
  })

  InFrequency = self:AddInput("Speedup", "speed", {
    LINKID_DataType    = "Number",
    INPID_InputControl = "SliderControl",
    INP_Default        = 1.0,
    INP_MinScale 	     = 0.0,
    INP_MaxScale 	     = 5.0,
    SLCS_LowName       = "stop",
    SLCS_HighName      = "5x",

  })


  -- some general controls for data passed to the kernel

  self:BeginControlNest("Common Shader Inputs", "shaderInputs", true, {})


		InShaderInputs_iTime = self:AddInput("iTime", "iTime", {
			LINKID_DataType = "Text",
			INPID_InputControl = "TextEditControl",
			INP_DoNotifyChanged  = false,
			INP_External = false,
			IC_NoLabel = false,
			ICD_Width = 1.0,
			INPS_DefaultText = "-",
			TEC_Lines = 1,
			TEC_Wrap = false,
			TEC_ReadOnly = true,
			TEC_CharLimit = 0,
			TEC_DeferSetInputs = false,
      INP_Disabled = true,
			})


    InMouseXY = self:AddInput("iMouse.xy", "iMouseXY", {
      LINKID_DataType = "Point",
      INPID_InputControl = "OffsetControl",
      INPID_PreviewControl = "CrosshairControl",
    })

    InMouseZW = self:AddInput("iMouse.zw", "iMouseZW", {
      LINKID_DataType = "Point",
      INPID_InputControl = "OffsetControl",
      INPID_PreviewControl = "CrosshairControl",
      INP_Integer = true,
      INP_Disabled = true,
    })

    InMouseDrag = self:AddInput("Mouse Button Pressed", "click", {
      LINKID_DataType = "Number",
      INPID_InputControl = "CheckboxControl",
      INP_Default = 0,
      INP_MinScale = 0,
      INP_MaxScale = 1,
      IC_Visible = true,
    })



  self:EndControlNest()



  -- some color controls to play with colors in the kernel

  self:BeginControlNest("Color Controls", "Colors", false, {})

    InColor={}

    local rgba = {'Red','Green','Blue','Alpha'}

    for i=0,NUM_COLOR_CONTROLS-1 do
      InColor[i]={}
      for j=0,3 do
        InColor[i][j]=self:AddInput(rgba[j+1], string.lower(string.sub(rgba[j+1],1,1))..i , { ICS_Name = "Color "..i, IC_ControlGroup = i+1, IC_ControlID = j, INP_Default  = 0.5, LINKID_DataType = "Number", INPID_InputControl = "ColorControl", INP_MinScale = 0.0, INP_MaxScale = 1.0, })
      end
    end

    self:EndControlNest()


  -- some sliders controls to play with colors in the kernel

  self:BeginControlNest("Slider Controls", "Sliders", false, {})

  InTinySlider={}

  for i=0,NUM_TINYSLIDER_CONTROLS-1 do
    InTinySlider[i] = self:AddInput("Tiny Slider "..i, "slider"..i, {
      LINKID_DataType    = "Number",
      INPID_InputControl = "SliderControl",
      INP_MinScale 	     = 0.0,
      INP_MaxScale 	     = 1.0,
    })
  end

  self:EndControlNest()



  -- controls for the tool itself, not passed to the kernel

  InRebuildCheckBox = self:AddInput("InRebuildCheckBox", "InRebuildCheckBox", {
    LINKID_DataType = "Number",
    INPID_InputControl = "CheckboxControl",
    INP_Default = 0,
    INP_MinScale = 0,
    INP_MaxScale = 1,
    IC_Visible = false,
  })

  -- InVerboseCheckBox = self:AddInput("VERBOSE", "VerboseCheckbox", {
  --   LINKID_DataType = "Number",
  --   INPID_InputControl = "CheckboxControl",
  --   INP_Default = 1,
  --   INP_MinScale = 0,
  --   INP_MaxScale = 1,
  --   IC_Visible = true,
  -- })




  -- node's inputs and its output

  InChannel0 = self:AddInput(   "iChannel0",  "iChannel0",  { LINKID_DataType = "Image", LINK_Main = 1, INP_Required = false  })
	OutImage   = self:AddOutput(  "Output",     "Output",     { LINKID_DataType = "Image", LINK_Main = 1                        })

end






-------------------------------------------------------------------------------------------------------------------------------------------
-- Callback to render the node.
--
function Process(req)

  local rebuild = false

  if InRebuildCheckBox:GetValue(req).Value == 1 then
    verbose("Process: do rebuild and clear the flag")
    InRebuildCheckBox:SetSource(Number(0),0)
    rebuild=true
  end



  if rebuild then
    ConversionSourcecode  = ""
    local item   = Conversions[InFileToUseCombo:GetValue(req).Value + 1]
    ConversionFusename    = item.Name
    ConversionShaderID    = item.ShadertoyID

    InShadertoyButton:SetAttrs({
      BTNCS_Execute = 'bmd.openurl("https://www.shadertoy.com/view/' .. ConversionShaderID ..'")',
      INP_Disabled=false
      })

    verbose("Process: rebuild code for conversion '"..ConversionFusename.."' ("..ConversionShaderID..")")

    file = io.open(item.Path .. item.Filename,"r")

    if file ~= nil then
      ConversionSourcecode = "\n" .. file:read("*all")
      file:close()
    end



    -- Für Incubator-Nodes (und nur für diese) müssen die Kernels über verschiedene
    -- Instanzen hinweg unterschieden werden. Die fertige Fuse braucht das nachher aber
    -- nicht mehr - eine Fuse ist halt eine Fuse und die ändert ihren Kernel nicht einfach
    -- so zwischendurch ... da wird dann nachher einfach nichts mehr an den Namen
    -- drangehaengt.

    ConversionKernelname = ConversionFusename .. "Kernel_" .. self.Name

    local count

    ConversionSourcecode, count = string.gsub(ConversionSourcecode,
      "__KERNEL__%s+void%s+"..ConversionFusename.."Kernel%(",
      "__KERNEL__ void "..ConversionKernelname.."("
      )

    -- Vorsicht: Der Test, ob der Kernelname gefunden wurde muss drinbleiben,
    -- weil sonst die kleinste Aenderung im Kernelnamen Fusion auf dem Mac komplett
    -- weghaut. Ist zwar nicht absolut wasserdicht, verhindert aber versehentlich
    -- falsche Namen in 99% der Faelle

    if count ~=1 then
      print("void "..ConversionFusename.."Kernel() found "..count.."x ... remember the Highlander!")
      ConversionSourcecode = ""
    end

  end




  if ConversionSourcecode == ""  then
    print("no shader to render - using some default kernel")
    ConversionSourcecode=ConversionSourcecode_fallback

    -- No need for a '_ShadersIncN' extension across
    -- multiple instances as the fallback kernel code
    -- is always the same.

    ConversionKernelname="IncubatorFallbackKernel"
    ConversionFusename="IncubatorFallback"
    rebuild=true
  end

  if CompatibilityCode==nil or ShaderParameters==nil then
    print("no way this will work")
    return
  end

  if rebuild then
    verbose("Process: '"..ConversionKernelname.."' is now active for "..self.Name)
  end

  local node = DVIPComputeNode(req,
    ConversionKernelname,
    CompatibilityCode .. ConversionSourcecode,
    "Params",
    ShaderParameters
    )



  local imgattrs = {
    IMG_Document = self.Comp,
    { IMG_Channel = "Red", },
    { IMG_Channel = "Green", },
    { IMG_Channel = "Blue", },
    { IMG_Channel = "Alpha", },
    IMG_Width = Width,
    IMG_Height = Height,
    IMG_XScale = XAspect,
    IMG_YScale = YAspect,
    IMAT_OriginalWidth = realwidth, -- nil !?!
    IMAT_OriginalHeight = realheight, -- nil !?!
    IMG_Quality = not req:IsQuick(),
    IMG_MotionBlurQuality = not req:IsNoMotionBlur(),
    IMG_DeferAlloc = true,
    IMG_ProxyScale = ( (not req:IsStampOnly()) and 1 or nil),
    IMG_Depth = ( (SourceDepth~=0) and SourceDepth or nil   )
  }



  -- Extern Texture or create a new one
  iChannel0 = InChannel0:GetValue(req)

  if (iChannel0 == nil) then
    iChannel0 = Image(imgattrs)
    local p = Pixel({R=0,G=0,B=0,A=0})
    iChannel0:Fill(p)
  end

  local dst = Image {IMG_Like = iChannel0, IMG_DeferAlloc = true}


  if req:IsPreCalc() then
    print("precalc")
    local out = Image({IMG_Like = dst, IMG_NoData = true})
    OutImage:Set(req, out)
    return
  end


  -------------- Parameter für DCTL-Code ---------------------
  local framerate = self.Comp:GetPrefs("Comp.FrameFormat.Rate")

  local params = {}

  params = node:GetParamBlock(ShaderParameters)


  local mouse =  nil

  mouse  = InMouseXY:GetValue(req)

  params.iMouse[0] = mouse.X -- * Width
  params.iMouse[1] = mouse.Y -- * Height
  params.iMouse[3] = 0
  params.iMouse[4] = 0

  if InMouseDrag:GetValue(req).Value == 1 then
    params.iMouse[3] = params.iMouse[0]
    params.iMouse[4] = params.iMouse[1]
  end


  mouse=InMouseZW:GetValue(req)
  if mouse.X ~= params.iMouse[3] or mouse.Y ~= params.iMouse[4] then
    InMouseZW:SetAttrs({INP_Disabled=false})
    InMouseZW:SetSource(Point(params.iMouse[3],params.iMouse[4]),0,0)
    InMouseZW:SetAttrs({INP_Disabled=true})
  end


  local frequency = InFrequency:GetValue(req).Value

  params.iTime            = (req.Time / framerate) * frequency;

  local txt= string.format("%.4f", params.iTime)
  if InShaderInputs_iTime:GetValue(req).Value ~= txt then
    InShaderInputs_iTime:SetAttrs({INP_Disabled=false})
    InShaderInputs_iTime:SetSource(Text( string.format("%.4f", params.iTime) ),0,0)
    InShaderInputs_iTime:SetAttrs({INP_Disabled=true})
  end



  for i=0,NUM_COLOR_CONTROLS-1 do
    for j=0,3 do
      params.color[i][j] = InColor[i][j]:GetValue(req).Value
    end
  end

  for i=0,NUM_TINYSLIDER_CONTROLS-1 do
    params.tinySlider[i] = InTinySlider[i]:GetValue(req).Value
  end


  params.width  = dst.Width
  params.height = dst.Height
--params.width            = iChannel0.DataWindow:Width()
--params.height           = iChannel0.DataWindow:Height()

  params.compOrder        = iChannel0:IsMask() and 1 or 15
  params.iChannel0_width  = iChannel0.Width
  params.iChannel0_height = iChannel0.Height

  node:SetParamBlock(params)

--node:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR,TEX_ADDRESS_MODE_BORDER, TEX_NORMALIZED_COORDS_TRUE)
  node:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR,TEX_ADDRESS_MODE_BORDER, TEX_NORMALIZED_COORDS_TRUE)
	node:AddInput("iChannel0",iChannel0)
	node:AddOutput("dst", dst)

  if rebuild then
    node:ForceRebuild()
  end






  local ok = node:RunSession(req)

	if (not ok) then
		dst = nil
    print("--- Errors ---")
    dump(node:GetErrorLog())
	end


  -- Output our result
  OutImage:Set(req,dst)
  collectgarbage();

end



-------------------------------------------------------------------------------------------------------------------------------------------
-- Callback to handle UI control events.
--
function NotifyChanged(inp, param, time)
	if inp ~= nil and param ~= nil then

		if (inp == InReloadCodeButton) then
			if (param.Value == 1) then
        verbose("NotifyChanged: reload button pressend")
        InRebuildCheckBox:SetSource(Number(1),0)
      end
    end

		if (inp == InFileToUseCombo) then
      verbose("NotifyChanged: file to use changed - set flag for a rebuild")
      InRebuildCheckBox:SetSource(Number(1),0)
    end

	end
end
