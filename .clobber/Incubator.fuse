--[[--

Some experiments based on the work of
Chris Ridings (www.chrisridings.com), Bryan Ray (http://www.bryanray.name/wordpress/opencl-fuses-index/),
JiPi (https://youtu.be/dbrPWRldmbs), Igor Riđanović (https://youtu.be/p6IeeWr3FOc), and many others.

V0.1 Kernelnamen angepaßt

--]]--



ShaderParameters = nil
CompatibilityCode = nil


ConversionSourcecode_fallback = [[

__KERNEL__ void IncubatorFallbackKernel(
    __CONSTANTREF__ Params *params,
    __TEXTURE2D__ iChannel0,
    __TEXTURE2D_WRITE__ dst
    )
{
  DEFINE_KERNEL_ITERATORS_XY(x, y);

  if (x >= params->width || y >= params->height)
    return;

  _tex2DVec4Write(dst, x, y, to_float4(1.0f,0.0f,0.0f,0.0f) );
}
]]


FuRegisterClass("ShadertoysIncubator", CT_SourceTool, {
    REGS_Name = "ShadersInc",
	  REGS_Category = "Fuses",
    REGS_OpDescription = "An Incubator for Shadertoys",
	  REGS_OpIconString = "incubus",
    REG_Source_GlobalCtrls = true,
    REG_Source_SizeCtrls = true,
    REG_Source_AspectCtrls = true,
	  REG_TimeVariant = true,
	  REGS_Company = "nmbr73",
	  REGS_URL = "https://nmbr73.github.io/",
	  REG_Version	= 000001,
    REG_Fuse_NoEdit = false,
    REG_Fuse_NoReload = false, -- true,
    })



function verbose(msg)
  print(msg)
end




Conversions={}

function getConversions(path)

  local files={}

  local handle	= bmd.readdir(path.."Conversions/*.*.c")

  for k, v in pairs(handle) do
    if v.Name and not(v.IsDir) then

      local filename = v.Name
      local fusename, shadertoyid = filename:match('^(.+)%.([^%.]+)%.c$')

      files[k]={
        Name=fusename,
        Path=path.."Conversions/",
        Filename=filename,
        ShadertoyID=shadertoyid,
        Label=fusename.." ("..shadertoyid..")",
      }
    end
  end

  return files
end


local ConversionShaderID  =  ""


function Create()

  local REPOSITORYPATH=""

  verbose("Create: repo in "..REPOSITORYPATH)

  Conversions=getConversions(REPOSITORYPATH)

  f = io.open(REPOSITORYPATH..'.clobber/CompatibilityCode.c', "r")

  if not f then
    CompatibilityCode = nil
    print("failed to read compat code")
  else
    CompatibilityCode = f:read("*all")
    f:close()
  end

  f = io.open(REPOSITORYPATH..'.clobber/ShaderParameters.c', "r")

  if not f then
    ShaderParameters = nil
    print("failed to read shader params code")
  else
    ShaderParameters = f:read("*all")
    f:close()
  end






  local attrs

  attrs={}

  for k,v in pairs(Conversions) do
    verbose("Create: conversion '"..v.Label.."'")
    table.insert(attrs,{ CCS_AddString = v.Label })
  end

  InFileToUseCombo = self:AddInput("Code Fragment", "FragementFileSelection", {
    LINKID_DataType = "Number",
    INPID_InputControl = "ComboControl",
	  INP_DoNotifyChanged = true,
    INP_Default = 0,
    INP_Integer = true,
    attrs
    })

  InReloadCodeButton= self:AddInput("Reload Code", "ReloadCodeFragment",
    { LINKID_DataType = "Text",
      INPID_InputControl = "ButtonControl",
      INP_DoNotifyChanged = true,
      INP_External = false,
    })

  self:BeginControlNest("Common Fuse Controls", "CommonFuseControls", true, {})


    InFrequency = self:AddInput("Frequency", "Frequency", {
      LINKID_DataType    = "Number",
      INPID_InputControl = "SliderControl",
      INP_Default        = 1.0,
      INP_MinScale 	     = 0.0,
      INP_MaxScale 	     = 10.0,
    })

    InMouseXY = self:AddInput("Mouse Drag", "MouseXY", {
      LINKID_DataType = "Point",
      INPID_InputControl = "OffsetControl",
      INPID_PreviewControl = "CrosshairControl",
    })

    InMouseZW = self:AddInput("Mouse Click", "MouseZW", {
      LINKID_DataType = "Point",
      INPID_InputControl = "OffsetControl",
      INPID_PreviewControl = "CrosshairControl",
    })

  self:EndControlNest()


  self:BeginControlNest("Some Color", "Colors", false, {})

    InR0 = self:AddInput("Red",   "r0", { ICS_Name = "Color 0", IC_ControlGroup = 1, IC_ControlID = 0, INP_Default  = 0.5, LINKID_DataType = "Number", INPID_InputControl = "ColorControl", INP_MinScale = 0.0, INP_MaxScale = 1.0, })
    InG0 = self:AddInput("Green", "g0", { ICS_Name = "Color 0", IC_ControlGroup = 1, IC_ControlID = 1, INP_Default  = 0.5, LINKID_DataType = "Number", INPID_InputControl = "ColorControl", INP_MinScale = 0.0, INP_MaxScale = 1.0, })
    InB0 = self:AddInput("Blue",  "b0", { ICS_Name = "Color 0", IC_ControlGroup = 1, IC_ControlID = 2, INP_Default  = 0.5, LINKID_DataType = "Number", INPID_InputControl = "ColorControl", INP_MinScale = 0.0, INP_MaxScale = 1.0, })
    InA0 = self:AddInput("Alpha", "a0", { ICS_Name = "Color 0", IC_ControlGroup = 1, IC_ControlID = 3, INP_Default  = 0.5, LINKID_DataType = "Number", INPID_InputControl = "ColorControl", INP_MinScale = 0.0, INP_MaxScale = 1.0, })

    InR1 = self:AddInput("Red",   "r1", { ICS_Name = "Color 1", IC_ControlGroup = 2, IC_ControlID = 0, INP_Default  = 0.5, LINKID_DataType = "Number", INPID_InputControl = "ColorControl", INP_MinScale = 0.0, INP_MaxScale = 1.0, })
    InG1 = self:AddInput("Green", "g1", { ICS_Name = "Color 1", IC_ControlGroup = 2, IC_ControlID = 1, INP_Default  = 0.5, LINKID_DataType = "Number", INPID_InputControl = "ColorControl", INP_MinScale = 0.0, INP_MaxScale = 1.0, })
    InB1 = self:AddInput("Blue",  "b1", { ICS_Name = "Color 1", IC_ControlGroup = 2, IC_ControlID = 2, INP_Default  = 0.5, LINKID_DataType = "Number", INPID_InputControl = "ColorControl", INP_MinScale = 0.0, INP_MaxScale = 1.0, })
    InA1 = self:AddInput("Alpha", "a1", { ICS_Name = "Color 1", IC_ControlGroup = 2, IC_ControlID = 3, INP_Default  = 0.5, LINKID_DataType = "Number", INPID_InputControl = "ColorControl", INP_MinScale = 0.0, INP_MaxScale = 1.0, })

  self:EndControlNest()


	InChannel0 = self:AddInput("iChannel0", "iChannel0", { LINKID_DataType = "Image", LINK_Main = 1, INP_Required = false })
	OutImage = self:AddOutput("Output", "Output", { LINKID_DataType = "Image", LINK_Main = 1 }) -- , INP_Required = false })


  InRebuildCheckBox = self:AddInput("InRebuildCheckBox", "InRebuildCheckBox", {
    LINKID_DataType = "Number",
    INPID_InputControl = "CheckboxControl",
    INP_Default = 0,
    INP_MinScale = 0,
    INP_MaxScale = 1,
    IC_Visible = false,
  })

  -- InVerboseCheckBox = self:AddInput("VERBOSE", "VerboseCheckbox", {
  --   LINKID_DataType = "Number",
  --   INPID_InputControl = "CheckboxControl",
  --   INP_Default = 1,
  --   INP_MinScale = 0,
  --   INP_MaxScale = 1,
  --   IC_Visible = true,
  -- })

  InShadertoyButton=self:AddInput("Show on shadertoy.com", "ShowOnShadertoy", {
    LINKID_DataType = "Text",
    INPID_InputControl = "ButtonControl",
    INP_DoNotifyChanged = false,
    INP_External = false,
    BTNCS_Execute = 'print("does nothing")',
    INP_Disabled=true,
  })

end




local ConversionFusename   = ""
local ConversionKernelname = ""
local ConversionSourcecode = ""

function Process(req)

  local rebuild = false

  if InRebuildCheckBox:GetValue(req).Value == 1 then
    verbose("Process: do rebuild and clear the flag")
    rebuild=true
    InRebuildCheckBox:SetSource(Number(0),0)
  end



  if rebuild then
    ConversionSourcecode  = ""
    local item   = Conversions[InFileToUseCombo:GetValue(req).Value + 1]
    ConversionFusename    = item.Name
    ConversionShaderID    = item.ShadertoyID

    InShadertoyButton:SetAttrs({
      BTNCS_Execute = 'bmd.openurl("https://www.shadertoy.com/view/' .. ConversionShaderID ..'")',
      INP_Disabled=false
      })

    verbose("Process: rebuild code for conversion '"..ConversionFusename.."' ("..ConversionShaderID..")")

    file = io.open(item.Path .. item.Filename,"r")

    if file ~= nil then
      ConversionSourcecode = "\n" .. file:read("*all")
      file:close()
    end



    -- Für Incubator-Nodes (und nur für diese) müssen die Kernels über verschiedene
    -- Instanzen hinweg unterschieden werden. Die fertige Fuse braucht das nachher aber
    -- nicht mehr - eine Fuse ist halt eine Fuse und die ändert ihren Kernel nicht einfach
    -- so zwischendurch ... da wird dann nachher einfach nichts mehr an den Namen
    -- drangehaengt.

    ConversionKernelname = ConversionFusename .. "Kernel_" .. self.Name

    local count

    ConversionSourcecode, count = string.gsub(ConversionSourcecode,
      "__KERNEL__%s+void%s+"..ConversionFusename.."Kernel%(",
      "__KERNEL__ void "..ConversionKernelname.."("
      )

    -- Vorsicht: Der Test, ob der Kernelname gefunden wurde muss drinbleiben,
    -- weil sonst die kleinste Aenderung im Kernelnamen Fusion auf dem Mac komplett
    -- weghaut. Ist zwar nicht absolut wasserdicht, verhindert aber versehentlich
    -- falsche Namen in 99% der Faelle

    if count ~=1 then
      print("there definitely is a problem with the kernel name")
      ConversionSourcecode = ""
    end

  end




  if ConversionSourcecode == ""  then
    print("no shader to render - using some default kernel")
    ConversionSourcecode=ConversionSourcecode_fallback

    -- No need for a '_ShadersIncN' extension across
    -- multiple instances as the fallback kernel code
    -- is always the same.

    ConversionKernelname="IncubatorFallbackKernel"
    ConversionFusename="IncubatorFallback"
    rebuild=true
  end

  if CompatibilityCode==nil or ShaderParameters==nil then
    print("no way this will work")
    return
  end

  if rebuild then
    verbose("Process: '"..ConversionKernelname.."' is now active for "..self.Name)
  end

  local node = DVIPComputeNode(req,
    ConversionKernelname,
    CompatibilityCode .. ConversionSourcecode,
    "Params",
    ShaderParameters
    )



  local imgattrs = {
    IMG_Document = self.Comp,
    { IMG_Channel = "Red", },
    { IMG_Channel = "Green", },
    { IMG_Channel = "Blue", },
    { IMG_Channel = "Alpha", },
    IMG_Width = Width,
    IMG_Height = Height,
    IMG_XScale = XAspect,
    IMG_YScale = YAspect,
    IMAT_OriginalWidth = realwidth, -- nil !?!
    IMAT_OriginalHeight = realheight, -- nil !?!
    IMG_Quality = not req:IsQuick(),
    IMG_MotionBlurQuality = not req:IsNoMotionBlur(),
    IMG_DeferAlloc = true,
    IMG_ProxyScale = ( (not req:IsStampOnly()) and 1 or nil),
    IMG_Depth = ( (SourceDepth~=0) and SourceDepth or nil   )
  }



  -- Extern Texture or create a new one
  iChannel0 = InChannel0:GetValue(req)

  if (iChannel0 == nil) then
    iChannel0 = Image(imgattrs)
    local p = Pixel({R=0,G=0,B=0,A=0})
    iChannel0:Fill(p)
  end

  local dst = Image {IMG_Like = iChannel0, IMG_DeferAlloc = true}


  if req:IsPreCalc() then
    print("precalc")
    local out = Image({IMG_Like = dst, IMG_NoData = true})
    OutImage:Set(req, out)
    return
  end

  local framerate = self.Comp:GetPrefs("Comp.FrameFormat.Rate")

  local params = {}

  params = node:GetParamBlock(ShaderParameters)


  local mouse =  nil

  params.mouse_x = 0
  params.mouse_y = 0

  mouse  = InMouseXY:GetValue(req)

  if (mouse ~= nil) then
		params.mouse_x = mouse.X * Width
		params.mouse_y = mouse.Y * Height
	end

	params.mouse_z = 0
	params.mouse_w = 0

  mouse  = InMouseZW:GetValue(req)

  if (mouse ~= nil) then
		params.mouse_z = mouse.X * Width
		params.mouse_w = mouse.Y * Height
	end



  params.frequency        = InFrequency:GetValue(req).Value
  params.iTime            = req.Time / framerate

  params.r0 = InR0:GetValue(req).Value; params.g0 = InG0:GetValue(req).Value; params.b0 = InB0:GetValue(req).Value; params.a0 = InA0:GetValue(req).Value
  params.r1 = InR1:GetValue(req).Value; params.g1 = InG1:GetValue(req).Value; params.b1 = InB1:GetValue(req).Value; params.a1 = InA1:GetValue(req).Value

  params.width  = dst.Width
  params.height = dst.Height
--params.width            = iChannel0.DataWindow:Width()
--params.height           = iChannel0.DataWindow:Height()

  params.compOrder        = iChannel0:IsMask() and 1 or 15
  params.iChannel0_width  = iChannel0.Width
  params.iChannel0_height = iChannel0.Height

  node:SetParamBlock(params)

--node:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR,TEX_ADDRESS_MODE_BORDER, TEX_NORMALIZED_COORDS_TRUE)
	node:AddInput("iChannel0",iChannel0)
	node:AddOutput("dst", dst)

  if rebuild then
    node:ForceRebuild()
  end

  local ok = node:RunSession(req)

	if (not ok) then
		dst = nil
    print("--- Errors ---")
    dump(node:GetErrorLog())
	end


  -- Output our result
  OutImage:Set(req,dst)
  collectgarbage();

end


function NotifyChanged(inp, param, time)
	if inp ~= nil and param ~= nil then

		if (inp == InReloadCodeButton) then
			if (param.Value == 1) then
        verbose("NotifyChanged: reload button pressend")
        InRebuildCheckBox:SetSource(Number(1),0)
      end
    end

		if (inp == InFileToUseCombo) then
      verbose("NotifyChanged: file to use changed - set flag for a rebuild")
      InRebuildCheckBox:SetSource(Number(1),0)
    end

	end
end
