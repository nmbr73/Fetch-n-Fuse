{"Shader":{"ver":"0.1","info":{"id":"NslGRN","date":"1615641551","viewed":49681,"name":"Cube lines","username":"morimea","description":"Art shader.\n\nCineshader support [url]https:\/\/cineshader.com\/view\/NslGRN[\/url]\n\nThis shader as Desktop wallpaper in linux:\n[b]for KDE[\/b] [url]https:\/\/store.kde.org\/p\/1505365[\/url]\n[b]for Gnome[\/b] [url]https:\/\/www.gnome-look.org\/p\/1505898\/[\/url]","likes":422,"published":3,"flags":0,"usePreview":1,"tags":["3d","intersection","art","cineshader"],"hasliked":0},"renderpass":[{"inputs":[{"id":5,"src":"\/media\/a\/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":37,"channel":0}],"code":"\/\/ Created by Danil (2021+) https:\/\/twitter.com\/AruGL\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\/\/ self https:\/\/www.shadertoy.com\/view\/NslGRN\n\n\n\/\/ --defines for \"DESKTOP WALLPAPERS\" that use this shader--\n\/\/ comment or uncomment every define to make it work (add or remove \"\/\/\" before #define)\n\n\n\/\/ this shadertoy use ALPHA, NO_ALPHA set alpha to 1, BG_ALPHA set background as alpha\n\/\/ iChannel0 used as background if alpha ignored by wallpaper-app\n\/\/#define NO_ALPHA\n\/\/#define BG_ALPHA\n\/\/#define SHADOW_ALPHA\n\/\/#define ONLY_BOX\n\n\n\/\/ save PERFORMANCE by disabling shadow (about 2x less GPU usage)\n\/\/#define NO_SHADOW\n\n\n\/\/ static CAMERA position, 0.49 on top, 0.001 horizontal\n\/\/#define CAMERA_POS 0.049\n\n\n\/\/ speed of ROTATION\n#define ROTATION_SPEED 0.8999\n\n\n\/\/ static SHAPE form, default 0.5\n\/\/#define STATIC_SHAPE 0.15\n\n\n\/\/ static SCALE far\/close to camera, 2.0 is default, exampe 0.5 or 10.0\n\/\/#define CAMERA_FAR 0.1\n\n\n\/\/ ANIMATION shape change\n\/\/#define ANIM_SHAPE\n\n\n\/\/ ANIMATION color change\n\/\/#define ANIM_COLOR\n\n\n\/\/ custom COLOR, and change those const values\n\/\/#define USE_COLOR\nconst vec3 color_blue=vec3(0.5,0.65,0.8);\nconst vec3 color_red=vec3(0.99,0.2,0.1);\n\n\n\/\/ use 4xMSAA for cube only (set 2-4-etc level os MSAA)\n\/\/#define AA_CUBE 4\n\n\n\n\/\/ --shader code--\n\n\/\/ Layers sorted and support transparency and self-intersection-transparency\n\/\/ Antialiasing is only dFd. (with some dFd fixes around edges)\n\n\/\/ using iq's intersectors: http:\/\/iquilezles.org\/www\/articles\/intersectors\/intersectors.htm\n\/\/ using https:\/\/www.shadertoy.com\/view\/ltKBzG\n\/\/ using https:\/\/www.shadertoy.com\/view\/tsVXzh\n\/\/ using https:\/\/www.shadertoy.com\/view\/WlffDn\n\/\/ using https:\/\/www.shadertoy.com\/view\/WslGz4\n\n#define tshift 53.\n\n\/\/ reflect back side\n\/\/#define backside_refl\n\n\/\/ Camera with mouse\n#define MOUSE_control\n\n\/\/ min(iFrame,0) does not speedup compilation in ANGLE\n#define ANGLE_loops 0\n\n\n\/\/ this shader discover Nvidia bug with arrays https:\/\/www.shadertoy.com\/view\/NslGR4\n\/\/ use DEBUG with BUG, BUG trigger that bug and one layer will be white on Nvidia in OpenGL\n\/\/#define DEBUG\n\/\/#define BUG\n\n#define FDIST 0.7\n#define PI 3.1415926\n#define GROUNDSPACING 0.5\n#define GROUNDGRID 0.05\n#define BOXDIMS vec3(0.75, 0.75, 1.25)\n\n#define IOR 1.33\n\nmat3 rotx(float a){float s = sin(a);float c = cos(a);return mat3(vec3(1.0, 0.0, 0.0), vec3(0.0, c, s), vec3(0.0, -s, c));  }\nmat3 roty(float a){float s = sin(a);float c = cos(a);return mat3(vec3(c, 0.0, s), vec3(0.0, 1.0, 0.0), vec3(-s, 0.0, c));}\nmat3 rotz(float a){float s = sin(a);float c = cos(a);return mat3(vec3(c, s, 0.0), vec3(-s, c, 0.0), vec3(0.0, 0.0, 1.0 ));}\n\nvec3 fcos(vec3 x) {\n    vec3 w = fwidth(x);\n    \/\/if((length(w)==0.))return vec3(0.); \/\/ dFd fix2\n    \/\/w*=0.; \/\/test\n    float lw=length(w);\n    if((lw==0.)||isnan(lw)||isinf(lw)){vec3 tc=vec3(0.); for(int i=0;i<8;i++)tc+=cos(x+x*float(i-4)*(0.01*400.\/iResolution.y));return tc\/8.;}\n    \n    return cos(x) * smoothstep(3.14 * 2.0, 0.0, w);\n}\n\n\/\/ rename to fcos\nvec3 fcos2( vec3 x){return cos(x);}\n\nvec3 getColor(vec3 p)\n{\n    \/\/ dFd fix, dFd broken on borders, but it fix only top level dFd, self intersection has border\n    \/\/if (length(p) > 0.99)return vec3(0.);\n    p = abs(p);\n\n    p *= 01.25;\n    p = 0.5 * p \/ dot(p, p);\n#ifdef ANIM_COLOR\n    p+=0.072*iTime;\n#endif\n\n    float t = (0.13) * length(p);\n    vec3 col = vec3(0.3, 0.4, 0.5);\n    col += 0.12 * fcos(6.28318 * t * 1.0 + vec3(0.0, 0.8, 1.1));\n    col += 0.11 * fcos(6.28318 * t * 3.1 + vec3(0.3, 0.4, 0.1));\n    col += 0.10 * fcos(6.28318 * t * 5.1 + vec3(0.1, 0.7, 1.1));\n    col += 0.10 * fcos(6.28318 * t * 17.1 + vec3(0.2, 0.6, 0.7));\n    col += 0.10 * fcos(6.28318 * t * 31.1 + vec3(0.1, 0.6, 0.7));\n    col += 0.10 * fcos(6.28318 * t * 65.1 + vec3(0.0, 0.5, 0.8));\n    col += 0.10 * fcos(6.28318 * t * 115.1 + vec3(0.1, 0.4, 0.7));\n    col += 0.10 * fcos(6.28318 * t * 265.1 + vec3(1.1, 1.4, 2.7));\n    col = clamp(col, 0., 1.);\n \n    return col;\n}\n\nvoid calcColor(vec3 ro, vec3 rd, vec3 nor, float d, float len, int idx, bool si, float td, out vec4 colx,\n               out vec4 colsi)\n{\n\n    vec3 pos = (ro + rd * d);\n#ifdef DEBUG\n    float a = 1. - smoothstep(len - 0.15, len + 0.00001, length(pos));\n    if (idx == 0)colx = vec4(1., 0., 0., a);\n    if (idx == 1)colx = vec4(0., 1., 0., a);\n    if (idx == 2)colx = vec4(0., 0., 1., a);\n    if (si)\n    {\n        pos = (ro + rd * td);\n        float ta = 1. - smoothstep(len - 0.15, len + 0.00001, length(pos));\n        if (idx == 0)colsi = vec4(1., 0., 0., ta);\n        if (idx == 1)colsi = vec4(0., 1., 0., ta);\n        if (idx == 2)colsi = vec4(0., 0., 1., ta);\n    }\n#else\n    float a = 1. - smoothstep(len - 0.15*0.5, len + 0.00001, length(pos));\n    \/\/a=1.;\n    vec3 col = getColor(pos);\n    colx = vec4(col, a);\n    if (si)\n    {\n        pos = (ro + rd * td);\n        float ta = 1. - smoothstep(len - 0.15*0.5, len + 0.00001, length(pos));\n        \/\/ta=1.;\n        col = getColor(pos);\n        colsi = vec4(col, ta);\n    }\n#endif\n}\n\n\/\/ xSI is self intersect data, fade to fix dFd on edges\nbool iBilinearPatch(in vec3 ro, in vec3 rd, in vec4 ps, in vec4 ph, in float sz, out float t, out vec3 norm,\n                    out bool si, out float tsi, out vec3 normsi, out float fade, out float fadesi)\n{\n    vec3 va = vec3(0.0, 0.0, ph.x + ph.w - ph.y - ph.z);\n    vec3 vb = vec3(0.0, ps.w - ps.y, ph.z - ph.x);\n    vec3 vc = vec3(ps.z - ps.x, 0.0, ph.y - ph.x);\n    vec3 vd = vec3(ps.xy, ph.x);\n    t = -1.;\n    tsi = -1.;\n    si = false;\n    fade = 1.;\n    fadesi = 1.;\n    norm=vec3(0.,1.,0.);normsi=vec3(0.,1.,0.);\n\n    float tmp = 1.0 \/ (vb.y * vc.x);\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n    float d = va.z * tmp;\n    float e = 0.0;\n    float f = 0.0;\n    float g = (vc.z * vb.y - vd.y * va.z) * tmp;\n    float h = (vb.z * vc.x - va.z * vd.x) * tmp;\n    float i = -1.0;\n    float j = (vd.x * vd.y * va.z + vd.z * vb.y * vc.x) * tmp - (vd.y * vb.z * vc.x + vd.x * vc.z * vb.y) * tmp;\n\n    float p = dot(vec3(a, b, c), rd.xzy * rd.xzy) + dot(vec3(d, e, f), rd.xzy * rd.zyx);\n    float q = dot(vec3(2.0, 2.0, 2.0) * ro.xzy * rd.xyz, vec3(a, b, c)) + dot(ro.xzz * rd.zxy, vec3(d, d, e)) +\n              dot(ro.yyx * rd.zxy, vec3(e, f, f)) + dot(vec3(g, h, i), rd.xzy);\n    float r =\n        dot(vec3(a, b, c), ro.xzy * ro.xzy) + dot(vec3(d, e, f), ro.xzy * ro.zyx) + dot(vec3(g, h, i), ro.xzy) + j;\n\n    if (abs(p) < 0.000001)\n    {\n        float tt = -r \/ q;\n        if (tt <= 0.)\n            return false;\n        t = tt;\n        \/\/ normal\n\n        vec3 pos = ro + t * rd;\n        if(length(pos)>sz)return false;\n        vec3 grad =\n            vec3(2.0) * pos.xzy * vec3(a, b, c) + pos.zxz * vec3(d, d, e) + pos.yyx * vec3(f, e, f) + vec3(g, h, i);\n        norm = -normalize(grad);\n        return true;\n    }\n    else\n    {\n        float sq = q * q - 4.0 * p * r;\n        if (sq < 0.0)\n        {\n            return false;\n        }\n        else\n        {\n            float s = sqrt(sq);\n            float t0 = (-q + s) \/ (2.0 * p);\n            float t1 = (-q - s) \/ (2.0 * p);\n            float tt1 = min(t0 < 0.0 ? t1 : t0, t1 < 0.0 ? t0 : t1);\n            float tt2 = max(t0 > 0.0 ? t1 : t0, t1 > 0.0 ? t0 : t1);\n            float tt0 = tt1;\n            if (tt0 <= 0.)\n                return false;\n            vec3 pos = ro + tt0 * rd;\n            \/\/ black border on end of circle and self intersection with alpha come because dFd\n            \/\/ uncomment this to see or rename fcos2 to fcos\n            \/\/sz+=0.3; \n            bool ru = step(sz, length(pos)) > 0.5;\n            if (ru)\n            {\n                tt0 = tt2;\n                pos = ro + tt0 * rd;\n            }\n            if (tt0 <= 0.)\n                return false;\n            bool ru2 = step(sz, length(pos)) > 0.5;\n            if (ru2)\n                return false;\n\n            \/\/ self intersect\n            if ((tt2 > 0.) && ((!ru)) && !(step(sz, length(ro + tt2 * rd)) > 0.5))\n            {\n                si = true;\n                fadesi=s;\n                tsi = tt2;\n                vec3 tpos = ro + tsi * rd;\n                \/\/ normal\n                vec3 tgrad = vec3(2.0) * tpos.xzy * vec3(a, b, c) + tpos.zxz * vec3(d, d, e) +\n                             tpos.yyx * vec3(f, e, f) + vec3(g, h, i);\n                normsi = -normalize(tgrad);\n            }\n            \n            fade=s;\n            t = tt0;\n            \/\/ normal\n            vec3 grad =\n                vec3(2.0) * pos.xzy * vec3(a, b, c) + pos.zxz * vec3(d, d, e) + pos.yyx * vec3(f, e, f) + vec3(g, h, i);\n            norm = -normalize(grad);\n\n            return true;\n        }\n    }\n}\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nfloat segShadow( in vec3 ro, in vec3 rd, in vec3 pa, float sh )\n{\n    float dm = dot(rd.yz,rd.yz);\n    float k1 = (ro.x-pa.x)*dm;\n    float k2 = (ro.x+pa.x)*dm;\n    vec2  k5 = (ro.yz+pa.yz)*dm;\n    float k3 = dot(ro.yz+pa.yz,rd.yz);\n    vec2  k4 = (pa.yz+pa.yz)*rd.yz;\n    vec2  k6 = (pa.yz+pa.yz)*dm;\n    \n    for( int i=0; i<4 + ANGLE_loops; i++ )\n    {\n        vec2  s = vec2(i&1,i>>1);\n        float t = dot(s,k4) - k3;\n        \n        if( t>0.0 )\n        sh = min(sh,dot2(vec3(clamp(-rd.x*t,k1,k2),k5-k6*s)+rd*t)\/(t*t));\n    }\n    return sh;\n}\n\nfloat boxSoftShadow( in vec3 ro, in vec3 rd, in vec3 rad, in float sk ) \n{\n    rd += 0.0001 * (1.0 - abs(sign(rd)));\n\tvec3 rdd = rd;\n\tvec3 roo = ro;\n\n    vec3 m = 1.0\/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if( tN<tF && tF>0.0) return 0.0;\n    \n    float sh = 1.0;\n    sh = segShadow( roo.xyz, rdd.xyz, rad.xyz, sh );\n    sh = segShadow( roo.yzx, rdd.yzx, rad.yzx, sh );\n    sh = segShadow( roo.zxy, rdd.zxy, rad.zxy, sh );\n    sh = clamp(sk*sqrt(sh),0.0,1.0);\n    return sh*sh*(3.0-2.0*sh);\n}\n\nfloat box(in vec3 ro, in vec3 rd, in vec3 r, out vec3 nn, bool entering)\n{\n    rd += 0.0001 * (1.0 - abs(sign(rd)));\n    vec3 dr = 1.0 \/ rd;\n    vec3 n = ro * dr;\n    vec3 k = r * abs(dr);\n\n    vec3 pin = -k - n;\n    vec3 pout = k - n;\n    float tin = max(pin.x, max(pin.y, pin.z));\n    float tout = min(pout.x, min(pout.y, pout.z));\n    if (tin > tout)\n        return -1.;\n    if (entering)\n    {\n        nn = -sign(rd) * step(pin.zxy, pin.xyz) * step(pin.yzx, pin.xyz);\n    }\n    else\n    {\n        nn = sign(rd) * step(pout.xyz, pout.zxy) * step(pout.xyz, pout.yzx);\n    }\n    return entering ? tin : tout;\n}\n\nvec3 bgcol(in vec3 rd)\n{\n    return mix(vec3(0.01), vec3(0.336, 0.458, .668), 1. - pow(abs(rd.z+0.25), 1.3));\n}\n\nvec3 background(in vec3 ro, in vec3 rd , vec3 l_dir, out float alpha)\n{\n#ifdef ONLY_BOX\nalpha=0.;\nreturn vec3(0.01);\n#endif\n    float t = (-BOXDIMS.z - ro.z) \/ rd.z;\n    alpha=0.;\n    vec3 bgc = bgcol(rd);\n    if (t < 0.)\n        return bgc;\n    vec2 uv = ro.xy + t * rd.xy;\n#ifdef NO_SHADOW\n    float shad=1.;\n#else\n    float shad = boxSoftShadow((ro + t * rd), normalize(l_dir+vec3(0.,0.,1.))*rotz(PI*0.65) , BOXDIMS, 1.5);\n#endif\n    float aofac = smoothstep(-0.95, .75, length(abs(uv) - min(abs(uv), vec2(0.45))));\n    aofac = min(aofac,smoothstep(-0.65, 1., shad));\n    float lght=max(dot(normalize(ro + t * rd+vec3(0.,-0.,-5.)), normalize(l_dir-vec3(0.,0.,1.))*rotz(PI*0.65)), 0.0);\n    vec3 col = mix(vec3(0.4), vec3(.71,.772,0.895), lght*lght* aofac+ 0.05) * aofac;\n    alpha=1.-smoothstep(7.,10.,length(uv));\n#ifdef SHADOW_ALPHA\n    \/\/alpha=clamp(alpha*max(lght*lght*0.95,(1.-aofac)*1.25),0.,1.);\n    alpha=clamp(alpha*(1.-aofac)*1.25,0.,1.);\n#endif\n    return mix(col*length(col)*0.8,bgc,smoothstep(7.,10.,length(uv)));\n}\n\n#define swap(a,b) tv=a;a=b;b=tv\n\nvec4 insides(vec3 ro, vec3 rd, vec3 nor_c, vec3 l_dir, out float tout)\n{\n    tout = -1.;\n    vec3 trd=rd;\n\n    vec3 col = vec3(0.);\n\n    float pi = 3.1415926;\n\n    if (abs(nor_c.x) > 0.5)\n    {\n        rd = rd.xzy * nor_c.x;\n        ro = ro.xzy * nor_c.x;\n    }\n    else if (abs(nor_c.z) > 0.5)\n    {\n        l_dir *= roty(pi);\n        rd = rd.yxz * nor_c.z;\n        ro = ro.yxz * nor_c.z;\n    }\n    else if (abs(nor_c.y) > 0.5)\n    {\n        l_dir *= rotz(-pi * 0.5);\n        rd = rd * nor_c.y;\n        ro = ro * nor_c.y;\n    }\n\n#ifdef ANIM_SHAPE\n    float curvature = (0.001+1.5-1.5*smoothstep(0.,8.5,mod((iTime+tshift)*0.44,20.))*(1.-smoothstep(10.,18.5,mod((iTime+tshift)*0.44,20.))));\n    \/\/ curvature(to not const above) make compilation on Angle 15+ sec\n#else\n#ifdef STATIC_SHAPE\n    const float curvature = STATIC_SHAPE;\n#else\n    const float curvature = .5;\n#endif\n#endif\n    float bil_size = 1.;\n    vec4 ps = vec4(-bil_size, -bil_size, bil_size, bil_size) * curvature;\n    vec4 ph = vec4(-bil_size, bil_size, bil_size, -bil_size) * curvature;\n    \n    vec4 [3]colx=vec4[3](vec4(0.),vec4(0.),vec4(0.));\n    vec3 [3]dx=vec3[3](vec3(-1.),vec3(-1.),vec3(-1.));\n    vec4 [3]colxsi=vec4[3](vec4(0.),vec4(0.),vec4(0.));\n    int [3]order=int[3](0,1,2);\n\n    for (int i = 0; i < 3 + ANGLE_loops; i++)\n    {\n        if (abs(nor_c.x) > 0.5)\n        {\n            ro *= rotz(-pi * (1. \/ float(3)));\n            rd *= rotz(-pi * (1. \/ float(3)));\n        }\n        else if (abs(nor_c.z) > 0.5)\n        {\n            ro *= rotz(pi * (1. \/ float(3)));\n            rd *= rotz(pi * (1. \/ float(3)));\n        }\n        else if (abs(nor_c.y) > 0.5)\n        {\n            ro *= rotx(pi * (1. \/ float(3)));\n            rd *= rotx(pi * (1. \/ float(3)));\n        }\n        vec3 normnew;\n        float tnew;\n        bool si;\n        float tsi;\n        vec3 normsi;\n        float fade;\n        float fadesi;\n\n        if (iBilinearPatch(ro, rd, ps, ph, bil_size, tnew, normnew, si, tsi, normsi, fade, fadesi))\n        {\n            if (tnew > 0.)\n            {\n                vec4 tcol, tcolsi;\n                calcColor(ro, rd, normnew, tnew, bil_size, i, si, tsi, tcol, tcolsi);\n                if (tcol.a > 0.0)\n                {\n                    {\n                        vec3 tvalx = vec3(tnew, float(si), tsi);\n                        dx[i]=tvalx;\n                    }\n#ifdef DEBUG\n                    colx[i]=tcol;\n                    if (si)colxsi[i]=tcolsi;\n#else\n\n                    float dif = clamp(dot(normnew, l_dir), 0.0, 1.0);\n                    float amb = clamp(0.5 + 0.5 * dot(normnew, l_dir), 0.0, 1.0);\n\n                    {\n#ifdef USE_COLOR\n                        vec3 shad = 0.57 * color_blue * amb + 1.5*color_blue.bgr * dif;\n                        const vec3 tcr = color_red;\n#else\n                        vec3 shad = vec3(0.32, 0.43, 0.54) * amb + vec3(1.0, 0.9, 0.7) * dif;\n                        const vec3 tcr = vec3(1.,0.21,0.11);\n#endif\n                        float ta = clamp(length(tcol.rgb),0.,1.);\n                        tcol=clamp(tcol*tcol*2.,0.,1.);\n                        vec4 tvalx =\n                            vec4((tcol.rgb*shad*1.4 + 3.*(tcr*tcol.rgb)*clamp(1.-(amb+dif),0.,1.)), min(tcol.a,ta));\n                        tvalx.rgb=clamp(2.*tvalx.rgb*tvalx.rgb,0.,1.);\n                        tvalx*=(min(fade*5.,1.));\n                        colx[i]=tvalx;\n                    }\n                    if (si)\n                    {\n                        dif = clamp(dot(normsi, l_dir), 0.0, 1.0);\n                        amb = clamp(0.5 + 0.5 * dot(normsi, l_dir), 0.0, 1.0);\n                        {\n#ifdef USE_COLOR\n                            vec3 shad = 0.57 * color_blue * amb + 1.5*color_blue.bgr * dif;\n                            const vec3 tcr = color_red;\n#else\n                            vec3 shad = vec3(0.32, 0.43, 0.54) * amb + vec3(1.0, 0.9, 0.7) * dif;\n                            const vec3 tcr = vec3(1.,0.21,0.11);\n#endif\n                            float ta = clamp(length(tcolsi.rgb),0.,1.);\n                            tcolsi=clamp(tcolsi*tcolsi*2.,0.,1.);\n                            vec4 tvalx =\n                                vec4(tcolsi.rgb * shad + 3.*(tcr*tcolsi.rgb)*clamp(1.-(amb+dif),0.,1.), min(tcolsi.a,ta));\n                            tvalx.rgb=clamp(2.*tvalx.rgb*tvalx.rgb,0.,1.);\n                            tvalx.rgb*=(min(fadesi*5.,1.));\n                            colxsi[i]=tvalx;\n                        }\n                    }\n#endif\n                }\n            }\n        }\n    }\n    \/\/ transparency logic and layers sorting \n    float a = 1.;\n    if (dx[0].x < dx[1].x){{vec3 swap(dx[0], dx[1]);}{int swap(order[0], order[1]);}}\n    if (dx[1].x < dx[2].x){{vec3 swap(dx[1], dx[2]);}{int swap(order[1], order[2]);}}\n    if (dx[0].x < dx[1].x){{vec3 swap(dx[0], dx[1]);}{int swap(order[0], order[1]);}}\n\n    tout = max(max(dx[0].x, dx[1].x), dx[2].x);\n\n    if (dx[0].y < 0.5)\n    {\n        a=colx[order[0]].a;\n    }\n\n#if !(defined(DEBUG)&&defined(BUG))\n    \n    \/\/ self intersection\n    bool [3] rul= bool[3](\n        ((dx[0].y > 0.5) && (dx[1].x <= 0.)),\n        ((dx[1].y > 0.5) && (dx[0].x > dx[1].z)),\n        ((dx[2].y > 0.5) && (dx[1].x > dx[2].z))\n    );\n    for(int k=0;k<3;k++){\n        if(rul[k]){\n            vec4 tcolxsi = vec4(0.);\n            tcolxsi=colxsi[order[k]];\n            vec4 tcolx = vec4(0.);\n            tcolx=colx[order[k]];\n\n            vec4 tvalx = mix(tcolxsi, tcolx, tcolx.a);\n            colx[order[k]]=tvalx;\n\n            vec4 tvalx2 = mix(vec4(0.), tvalx, max(tcolx.a, tcolxsi.a));\n            colx[order[k]]=tvalx2;\n        }\n    }\n\n#endif\n\n    float a1 = (dx[1].y < 0.5) ? colx[order[1]].a : ((dx[1].z > dx[0].x) ? colx[order[1]].a : 1.);\n    float a2 = (dx[2].y < 0.5) ? colx[order[2]].a : ((dx[2].z > dx[1].x) ? colx[order[2]].a : 1.);\n    col = mix(mix(colx[order[0]].rgb, colx[order[1]].rgb, a1), colx[order[2]].rgb, a2);\n    a = max(max(a, a1), a2);\n    return vec4(col, a);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float osc = 0.5;\n    vec3 l_dir = normalize(vec3(0., 1., 0.));\n    l_dir *= rotz(0.5);\n    float mouseY = 1.0 * 0.5 * PI;\n#ifdef MOUSE_control\n    mouseY = (1.0 - 1.15 * iMouse.y \/ iResolution.y) * 0.5 * PI;\n    if(iMouse.y < 1.)\n#endif\n#ifdef CAMERA_POS\n    mouseY = PI*CAMERA_POS;\n#else\n    mouseY = PI*0.49 - smoothstep(0.,8.5,mod((iTime+tshift)*0.33,25.))*(1.-smoothstep(14.,24.0,mod((iTime+tshift)*0.33,25.))) * 0.55 * PI;\n#endif\n#ifdef ROTATION_SPEED\n    float mouseX = -2.*PI-0.25*(iTime*ROTATION_SPEED+tshift);\n#else\n    float mouseX = -2.*PI-0.25*(iTime+tshift);\n#endif\n#ifdef MOUSE_control\n    mouseX+=-(iMouse.x \/ iResolution.x) * 2. * PI;\n#endif\n    \n#ifdef CAMERA_FAR\n    vec3 eye = (2. + CAMERA_FAR) * vec3(cos(mouseX) * cos(mouseY), sin(mouseX) * cos(mouseY), sin(mouseY));\n#else\n    vec3 eye = 4. * vec3(cos(mouseX) * cos(mouseY), sin(mouseX) * cos(mouseY), sin(mouseY));\n#endif\n    vec3 w = normalize(-eye);\n    vec3 up = vec3(0., 0., 1.);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = cross(u, w);\n\n    vec4 tot=vec4(0.);\n#ifdef AA_CUBE\n    const int AA = AA_CUBE;\n    vec3 incol_once=vec3(0.);\n    bool in_once=false;\n    vec4 incolbg_once=vec4(0.);\n    bool bg_in_once=false;\n    vec4 outcolbg_once=vec4(0.);\n    bool bg_out_once=false;\n    for( int mx=0; mx<AA; mx++ )\n    for( int nx=0; nx<AA; nx++ )\n    {\n    vec2 o = vec2(mod(float(mx+AA\/2),float(AA)),mod(float(nx+AA\/2),float(AA))) \/ float(AA) - 0.5;\n    vec2 uv = (fragCoord + o - 0.5 * iResolution.xy) \/ iResolution.x;\n#else\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) \/ iResolution.x;\n#endif\n    vec3 rd = normalize(w * FDIST + uv.x * u + uv.y * v);\n\n    vec3 ni;\n    float t = box(eye, rd, BOXDIMS, ni, true);\n    vec3 ro = eye + t * rd;\n    vec2 coords = ro.xy * ni.z\/BOXDIMS.xy + ro.yz * ni.x\/BOXDIMS.yz + ro.zx * ni.y\/BOXDIMS.zx;\n    float fadeborders = (1.-smoothstep(0.915,1.05,abs(coords.x)))*(1.-smoothstep(0.915,1.05,abs(coords.y)));\n\n    if (t > 0.)\n    {\n        float ang = -iTime * 0.33;\n        vec3 col = vec3(0.);\n#ifdef AA_CUBE\n        if(in_once)col=incol_once;\n        else{\n        in_once=true;\n#endif\n        float R0 = (IOR - 1.) \/ (IOR + 1.);\n        R0 *= R0;\n\n        vec2 theta = vec2(0.);\n        vec3 n = vec3(cos(theta.x) * sin(theta.y), sin(theta.x) * sin(theta.y), cos(theta.y));\n\n        vec3 nr = n.zxy * ni.x + n.yzx * ni.y + n.xyz * ni.z;\n        vec3 rdr = reflect(rd, nr);\n        float talpha;\n        vec3 reflcol = background(ro, rdr, l_dir,talpha);\n\n        vec3 rd2 = refract(rd, nr, 1. \/ IOR);\n\n        float accum = 1.;\n        vec3 no2 = ni;\n        vec3 ro_refr = ro;\n\n        vec4 [2] colo = vec4[2](vec4(0.),vec4(0.));\n\n        for (int j = 0; j < 2 + ANGLE_loops; j++)\n        {\n            float tb;\n            vec2 coords2 = ro_refr.xy * no2.z + ro_refr.yz * no2.x + ro_refr.zx * no2.y;\n            vec3 eye2 = vec3(coords2, -1.);\n            vec3 rd2trans = rd2.yzx * no2.x + rd2.zxy * no2.y + rd2.xyz * no2.z;\n\n            rd2trans.z = -rd2trans.z;\n            vec4 internalcol = insides(eye2, rd2trans, no2, l_dir, tb);\n            if (tb > 0.)\n            {\n                internalcol.rgb *= accum;\n                colo[j]=internalcol;\n            }\n\n            if ((tb <= 0.) || (internalcol.a < 1.))\n            {\n                float tout = box(ro_refr, rd2, BOXDIMS, no2, false);\n                no2 = n.zyx * no2.x + n.xzy * no2.y + n.yxz * no2.z;\n                vec3 rout = ro_refr + tout * rd2;\n                vec3 rdout = refract(rd2, -no2, IOR);\n                float fresnel2 = R0 + (1. - R0) * pow(1. - dot(rdout, no2), 1.3);\n                rd2 = reflect(rd2, -no2);\n\n#ifdef backside_refl\n                if((dot(rdout, no2))>0.5){fresnel2=1.;}\n#endif\n                ro_refr = rout;\n                ro_refr.z = max(ro_refr.z, -0.999);\n\n                accum *= fresnel2;\n            }\n        }\n        float fresnel = R0 + (1. - R0) * pow(1. - dot(-rd, nr), 5.);\n        col = mix(mix(colo[1].rgb * colo[1].a, colo[0].rgb, colo[0].a)*fadeborders, reflcol, pow(fresnel, 1.5));\n        col=clamp(col,0.,1.);\n#ifdef AA_CUBE\n        }\n        incol_once=col;\n        if(!bg_in_once){\n        bg_in_once=true;\n        float alpha;\n        incolbg_once = vec4(background(eye, rd, l_dir, alpha), 0.15);\n#if defined(BG_ALPHA)||defined(ONLY_BOX)||defined(SHADOW_ALPHA)\n        incolbg_once.w = alpha;\n#endif\n        }\n#endif\n        \n        float cineshader_alpha = 0.;\n        cineshader_alpha = clamp(0.15*dot(eye,ro),0.,1.);\n        vec4 tcolx = vec4(col, cineshader_alpha);\n#if defined(BG_ALPHA)||defined(ONLY_BOX)||defined(SHADOW_ALPHA)\n        tcolx.w = 1.;\n#endif\n        tot += tcolx;\n    }\n    else\n    {\n        vec4 tcolx = vec4(0.);\n#ifdef AA_CUBE\n        if(!bg_out_once){\n        bg_out_once=true;\n#endif\n        float alpha;\n        tcolx = vec4(background(eye, rd, l_dir, alpha), 0.15);\n#if defined(BG_ALPHA)||defined(ONLY_BOX)||defined(SHADOW_ALPHA)\n        tcolx.w = alpha;\n#endif\n#ifdef AA_CUBE\n        outcolbg_once=tcolx;\n        }else tcolx=max(outcolbg_once,incolbg_once);\n#endif\n        tot += tcolx;\n    }\n#ifdef AA_CUBE\n    }\n    tot \/= float(AA*AA);\n#endif\n    fragColor = tot;\n#ifdef NO_ALPHA\n    fragColor.w = 1.;\n#endif\n    fragColor.rgb=clamp(fragColor.rgb,0.,1.);\n#if defined(BG_ALPHA)||defined(ONLY_BOX)||defined(SHADOW_ALPHA)\n    fragColor.rgb=fragColor.rgb*fragColor.w+texture(iChannel0, fragCoord\/iResolution.xy).rgb*(1.-fragColor.w);\n#endif\n    \/\/fragColor=vec4(fragColor.w);\n}\n","name":"Image","description":"","type":"image"}]}}