{"Shader":{"ver":"0.1","info":{"id":"Dsl3Rn","date":"1665556959","viewed":12,"name":"Neural Cellular Automaton Worms","username":"fenix","description":"I just watched this video and was inspired to create this shader.\n\n     https:\/\/www.youtube.com\/watch?v=3H79ZcBuw4M\n\nI have no idea how this works, but in my defence neither does the guy who made the video (or so he says).","likes":2,"published":3,"flags":48,"usePreview":0,"tags":["cellular","worms","neural","atomaton","atomata"],"hasliked":0},"renderpass":[{"inputs":[{"id":258,"src":"\/media\/previz\/buffer01.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":37,"channel":0}],"code":"\/\/ ---------------------------------------------------------------------------------------\n\/\/\tCreated by fenix in 2022\n\/\/\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\/\/\n\/\/ I just watched this video and was inspired to create this shader.\n\/\/\n\/\/     https:\/\/www.youtube.com\/watch?v=3H79ZcBuw4M\n\/\/\n\/\/ I have no idea how this works, but in my defence neither does the guy who made the video\n\/\/ (or so he says). Neural Cellular Atomaton is a pretty fancy name for essentially a \n\/\/ continuous (non-binary) CA. You can experiment with this automata (and others) at:\n\/\/\n\/\/     https:\/\/neuralpatterns.io\/\n\/\/\n\/\/ Other than porting to shadertoy, all I did was fancy up the rendering a little bit.\n\/\/\n\/\/ Buffer A computes the neural cellular atomaton\n\/\/ Buffer B performs temporal blur of buffer A\n\/\/ Image computes gradient, applies lighting and color\n\/\/\n\/\/ ---------------------------------------------------------------------------------------\n\nvec2 grad(vec2 fragCoord, float d)\n{\n    vec2 delta = vec2(d, 0);\n    return vec2(texture(iChannel0, fragCoord\/iResolution.xy + delta.xy).x -\n        texture(iChannel0, fragCoord\/iResolution.xy - delta.xy).x,\n        texture(iChannel0, fragCoord\/iResolution.xy + delta.yx).x -\n        texture(iChannel0, fragCoord\/iResolution.xy - delta.yx).x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 g = grad(fragCoord, 1.\/iResolution.y);\n    vec3 norm = normalize(vec3(g, 1.));\n    float value = texelFetch(iChannel0, ivec2(fragCoord), 0).r;\n    vec3 color = mix(vec3(0.3,0.3,.5), vec3(1, .2, .2), smoothstep(0., 0.1, value));\n    fragColor = vec4(color * dot(norm, normalize(vec3(1,-1,1))), 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":33,"src":"\/presets\/tex00.jpg","ctype":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":257,"channel":0}],"code":"vec3 kernel[] = vec3[]( vec3( 0.68, -0.9,   0.68),\n                        vec3(-0.9,  -0.66, -0.9),\n                        vec3( 0.68, -0.9,   0.68) );\n                        \nfloat convolve(vec2 fragCoord)\n{\n    float a = 0.;\n    for (int i = 0; i < 3; ++i)\n    {\n        for (int j = 0; j < 3; ++j)\n        {\n            a += texelFetch(iChannel0, ivec2(fragCoord) + ivec2(i - 1, j - 1), 0).x * kernel[i][j];\n        }\n    }\n    return a;\n}\n\n\/\/ inverse gaussian\nfloat activation(float x)\n{\n    return -1. \/ pow(2., (0.6 * pow(x, 2.))) + 1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 state = texelFetch(iChannel0, ivec2(0), 0);\n    \n    if (ivec2(fragCoord) == ivec2(0))\n    {\n        if (iFrame == 0 || abs(state.x) != iResolution.x * iResolution.y || keyDown(KEY_SPACE))\n        {\n            state.x = -iResolution.x * iResolution.y;\n        }\n        else\n        {\n            state.x = abs(state.x);\n        }\n        \n        fragColor = state;\n        return;\n    }\n    \n    if (iFrame == 0 || state.x < 0. ||\n        (iMouse.z > 0. && distance(iMouse.xy, fragCoord) < 0.1*iResolution.y))\n    {\n        fragColor = vec4(hash(int(fragCoord.x * fragCoord.y + iDate.x) + iFrame));\n        return;\n    }\n        \n    fragColor = vec4(activation(convolve(fragCoord)));\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\/\/hashing noise by IQ\nfloat hash( int k )\n{\n    uint n = uint(k);\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SPACE 32\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":258,"src":"\/media\/previz\/buffer01.png","ctype":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":258,"channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0) * 0.1 + texelFetch(iChannel1, ivec2(fragCoord), 0) * 0.9;\n    \n    if (iFrame == 0) fragColor = vec4(0);\n}","name":"Buffer B","description":"","type":"buffer"}]}}