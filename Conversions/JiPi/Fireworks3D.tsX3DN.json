{"Shader":{"ver":"0.1","info":{"id":"tsX3DN","date":"1546265346","viewed":990,"name":"Fireworks 3d","username":"dr2","description":"Simple 3d fireworks - happy new year","likes":12,"published":3,"flags":0,"usePreview":0,"tags":["explosion","fireworks","fibonacci"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"id":37,"channel":0}],"code":"\/\/ \"Fireworks 3d\" by dr2 - 2018\n\/\/ License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n\/\/ Simple 3d fireworks - happy new year\n\nvec2 Rot2D (vec2 q, float a);\nvec3 HsvToRgb (vec3 c);\nfloat Hashff (float p);\nfloat Hashfv3 (vec3 p);\nfloat Noisefv3 (vec3 p);\n\nfloat tCur, dstFar;\nconst float pi = 3.14159, phi = 1.618034;\n\nvec2 BallHit (vec3 ro, vec3 rd, vec3 p, float s)\n{\n  vec3 v;\n  float dbIn, dbOut, b, d;\n  v = ro - p;\n  b = dot (rd, v);\n  d = b * b + s * s - dot (v, v);\n  dbIn = dstFar;\n  dbOut = dstFar;\n  if (d > 0.) {\n    d = sqrt (d);\n    dbIn = - b - d;\n    dbOut = - b + d;\n  }\n  return vec2 (dbIn, dbOut);\n}\n\nvec4 SphFib (vec3 v, float n)\n{   \/\/ Keinert et al's inverse spherical Fibonacci mapping\n  vec4 b;\n  vec3 vf, vfMin;\n  vec2 ff, c;\n  float fk, ddMin, dd, a, z, ni;\n  ni = 1. \/ n;\n  fk = pow (phi, max (2., floor (log (n * pi * sqrt (5.) * dot (v.xy, v.xy)) \/\n     log (phi + 1.)))) \/ sqrt (5.);\n  ff = vec2 (floor (fk + 0.5), floor (fk * phi + 0.5));\n  b = vec4 (ff * ni, pi * (fract ((ff + 1.) * phi) - (phi - 1.)));\n  c = floor ((0.5 * mat2 (b.y, - b.x, b.w, - b.z) \/ (b.y * b.z - b.x * b.w)) *\n     vec2 (atan (v.y, v.x), v.z - (1. - ni)));\n  ddMin = 4.1;\n  for (int j = 0; j < 4; j ++) {\n    a = dot (ff, vec2 (j - 2 * (j \/ 2), j \/ 2) + c);\n    z = 1. - (2. * a + 1.) * ni;\n    vf = vec3 (sin (2. * pi * fract (phi * a) + vec2 (0.5 * pi, 0.)) * sqrt (1. - z * z), z);\n    dd = dot (vf - v, vf - v);\n    if (dd < ddMin) {\n      ddMin = dd;\n      vfMin = vf;\n    }\n  }\n  return vec4 (sqrt (ddMin), vfMin);\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  vec3 col, rds, mDir, vn;\n  float mRad, bs, ts, f;\n  rd.xz = Rot2D (rd.xz, 0.001 * tCur);\n  mDir = normalize (vec3 (0., 1., 1.));\n  mRad = 0.02;\n  col = vec3 (0.02, 0.02, 0.04) + vec3 (0.06, 0.04, 0.02) *\n     pow (clamp (dot (rd, mDir), 0., 1.), 16.);\n  bs = dot (rd, mDir);\n  ts = bs * bs - dot (mDir, mDir) + mRad * mRad;\n  if (ts > 0.) {\n    ts = bs - sqrt (ts);\n    if (ts > 0.) {\n      vn = normalize ((ts * rd - mDir) \/ mRad);\n      col += 0.8 * vec3 (1., 0.9, 0.5) * clamp (dot (vec3 (-0.77, 0.4, 0.5), vn) *\n         (1. - 0.3 * Noisefv3 (4. * vn)), 0., 1.);\n    }\n    col *= 1.3;\n  } else {\n    rds = floor (2000. * rd);\n    rds = 0.00015 * rds + 0.1 * Noisefv3 (0.0005 * rds.yzx);\n    for (int j = 0; j < 19; j ++) rds = abs (rds) \/ dot (rds, rds) - 0.9;\n    col += 0.5 * smoothstep (0.01, 0.04, rd.y) * vec3 (0.8, 0.8, 0.6) *\n       min (1., 0.5e-3 * pow (min (6., length (rds)), 5.));\n  }\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 f4;\n  vec3 col, bPos;\n  vec2 dSph;\n  float nCyc, tCyc, iFib, phs, hm, hr, h, s, r, a;\n  bool isBg;\n  tCyc = 3.;\n  nCyc = floor (tCur \/ tCyc) + 1.;\n  hm = 0.2 * max (Hashff (17. * nCyc) - 0.2, 0.);\n  hr = 0.8 * min (2. * Hashff (27. * nCyc), 1.);\n  iFib = 500. + floor (6000. * Hashff (37. * nCyc));\n  col = SkyCol (ro, rd);\n  isBg = true;\n  for (float k = 0.; k < 40.; k ++) {\n    phs = fract (tCur \/ tCyc) - 0.005 * k;\n    bPos = vec3 (0., 0., 0.);\n    if (phs > 0.1) {\n      a = smoothstep (0.1, 0.15, phs) - 0.7 * smoothstep (0.3, 1., phs);\n      h = hm + hr * max (phs - 0.2, 0.);\n      dSph = BallHit (ro, rd, bPos, 0.5 + 8.5 * sqrt (phs - 0.1));\n      if (dSph.x < dstFar) {\n        if (k == 0.) col = mix (col, vec3 (1., 1., 0.), 0.03 * a);\n        r = 0.015 * (0.5 + 0.5 * a);\n        ro += dSph.x * rd;\n        f4 = SphFib (normalize (ro), iFib);\n        s = Hashfv3 (73. * f4.yzw + 87. * nCyc);\n        if (s > 0.5 && f4.x < r * s) {\n          col = mix (col, HsvToRgb (vec3 (h, 1., a)), a);\n          isBg = false;\n        } else {\n          ro += (dSph.y - dSph.x) * rd;\n          f4 = SphFib (normalize (ro), iFib);\n          s = Hashfv3 (73. * f4.yzw + 87. * nCyc);\n          if (s > 0.5 && f4.x < r * s) {\n            col = mix (col, HsvToRgb (vec3 (h, 1., 0.7 * a)), a);\n            isBg = false;\n          }\n        }\n      }\n      if (! isBg) break;\n    }\n  }\n  return clamp (col, 0., 1.);\n}\n\n#define AA  1   \/\/ optional antialiasing\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy \/ canvas - 1.;\n  uv.x *= canvas.x \/ canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy \/ canvas - 0.5;\n  az = -0.1 * pi;\n  el = 0.2 * pi;\n  if (mPtr.z > 0.) {\n    az += 0.5 * pi * mPtr.x;\n    el += 0.2 * pi * mPtr.y;\n  } else {\n    az += 0.001 * pi * tCur;\n  }\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  ro = vuMat * vec3 (0., 0., -40.);\n  dstFar = 100.;\n  #if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 \/ canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), 4.5));\n    col += (1. \/ naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2.\/3., 1.\/3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nfloat Hashfv3 (vec3 p)\n{\n  return fract (sin (dot (p, vec3 (37., 39., 41.))) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  vec2 e = vec2 (1., 0.);\n  return fract (sin (vec4 (dot (p + e.yyy, cHashVA3), dot (p + e.xyy, cHashVA3),\n     dot (p + e.yxy, cHashVA3), dot (p + e.xxy, cHashVA3))) * cHashM);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n","name":"Image","description":"","type":"image"}]}}