{"Shader":{"ver":"0.1","info":{"id":"7s3BzN","date":"1656133162","viewed":112,"name":"Mudcrack","username":"davidar","description":"A mass-spring network model for procedural surface crack \/ fracture simulation, loosely based on https:\/\/ima.udg.edu\/~lmuguercia\/survey.pdf and inspired by cornusammonis' work on nonlinear springs. Mouseable.","likes":18,"published":3,"flags":32,"usePreview":0,"tags":["simulation","spring","fracture","mass","crack","mud"],"hasliked":0},"renderpass":[{"inputs":[{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":37,"channel":0}],"code":"\/\/ colour reference https:\/\/fineartamerica.com\/featured\/crack-aidong-ning.html\nconst vec4 yellow = vec4(0.96, 0.86, 0.59, 1);\nconst vec4 orange = vec4(0.86, 0.62, 0.45, 1);\nconst vec4 blue = vec4(0.41, 0.46, 0.55, 1);\nconst vec4 black = vec4(0.03, 0.05, 0.09, 1);\nconst vec4 brown = vec4(0.47, 0.26, 0.18, 1);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord \/ iResolution.xy;\n    \n    vec2 displacement = texture(iChannel0, uv).zw;\n    vec3 normal = normalize(vec3(-displacement\/3., 1));\n    float lighting = dot(normal, normalize(vec3(1,1,0)));\n    \n    vec2 gradDisp = vec2(texGradX(iChannel0, uv).z, texGradY(iChannel0, uv).w);\n    float crackMask = length(max(gradDisp, vec2(0)));\n    \n    fragColor = yellow;\n    fragColor = mix(fragColor, orange, smoothstep(-1., 0., lighting));\n    fragColor = mix(fragColor, blue,   smoothstep( 0., 1., lighting));\n    fragColor = mix(fragColor, brown,  smoothstep( 0., .4, crackMask));\n    fragColor = mix(fragColor, black,  smoothstep( .4, .7, crackMask));\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\/* Texture Stencil Library https:\/\/www.shadertoy.com\/view\/ssBczm\n\nThe MIT License\n\nCopyright (c) 2022 David A Roberts <https:\/\/davidar.io\/>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and\/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*\/\n\nvec4 texStencil(sampler2D ch, vec2 uv, float coeff[9]) {\n    vec2 texel = 1. \/ vec2(textureSize(ch, 0));\n    const vec2 stencilOffset[9] = vec2[](\n        vec2(-1, 1), vec2( 0, 1), vec2( 1, 1),\n        vec2(-1, 0), vec2( 0, 0), vec2( 1, 0),\n        vec2(-1,-1), vec2( 0,-1), vec2( 1,-1)\n    );\n    vec4 r = vec4(0);\n    for (int i = 0; i < 9; i++)\n        r += coeff[i] * texture(ch, uv + texel * stencilOffset[i]);\n    return r;\n}\n\n\/\/ Gaussian\/binomial blur\n\/\/ https:\/\/bartwronski.com\/2021\/10\/31\/practical-gaussian-filter-binomial-filter-and-small-sigma-gaussians\/\nvec4 texBlur(sampler2D ch, vec2 uv) {\n    return texStencil(ch, uv, float[](\n        .0625, .125, .0625,\n        .125,  .25,  .125,\n        .0625, .125, .0625\n    ));\n}\n\n\/\/ Laplacian, optimal 9-point stencil\n\/\/ https:\/\/docs.lib.purdue.edu\/cgi\/viewcontent.cgi?article=1928&context=cstech\nvec4 texLapl(sampler2D ch, vec2 uv) {\n    return texStencil(ch, uv, float[](\n        1.,   4., 1.,\n        4., -20., 4.,\n        1.,   4., 1.\n    )) \/ 6.;\n}\n\n\/\/ horizontal gradient (Sobel filter)\nvec4 texGradX(sampler2D ch, vec2 uv) {\n    return texStencil(ch, uv, float[](\n        -1., 0., 1.,\n        -2., 0., 2.,\n        -1., 0., 1.\n    )) \/ 8.;\n}\n\n\/\/ vertical gradient (Sobel filter)\nvec4 texGradY(sampler2D ch, vec2 uv) {\n    return texStencil(ch, uv, float[](\n         1.,  2.,  1.,\n         0.,  0.,  0.,\n        -1., -2., -1.\n    )) \/ 8.;\n}\n\n\n\n\n\n\/* https:\/\/www.shadertoy.com\/view\/XsX3zB\n *\n * The MIT License\n * Copyright \u00a9 2013 Nikita Miropolskiy\n * \n * ( license has been changed from CCA-NC-SA 3.0 to MIT\n *\n *   but thanks for attributing your source code when deriving from this sample \n *   with a following link: https:\/\/www.shadertoy.com\/view\/XsX3zB )\n *\n * ~\n * ~ if you're looking for procedural noise implementation examples you might \n * ~ also want to look at the following shaders:\n * ~ \n * ~ Noise Lab shader by candycat: https:\/\/www.shadertoy.com\/view\/4sc3z2\n * ~\n * ~ Noise shaders by iq:\n * ~     Value    Noise 2D, Derivatives: https:\/\/www.shadertoy.com\/view\/4dXBRH\n * ~     Gradient Noise 2D, Derivatives: https:\/\/www.shadertoy.com\/view\/XdXBRH\n * ~     Value    Noise 3D, Derivatives: https:\/\/www.shadertoy.com\/view\/XsXfRH\n * ~     Gradient Noise 3D, Derivatives: https:\/\/www.shadertoy.com\/view\/4dffRH\n * ~     Value    Noise 2D             : https:\/\/www.shadertoy.com\/view\/lsf3WH\n * ~     Value    Noise 3D             : https:\/\/www.shadertoy.com\/view\/4sfGzS\n * ~     Gradient Noise 2D             : https:\/\/www.shadertoy.com\/view\/XdXGW8\n * ~     Gradient Noise 3D             : https:\/\/www.shadertoy.com\/view\/Xsl3Dl\n * ~     Simplex  Noise 2D             : https:\/\/www.shadertoy.com\/view\/Msf3WH\n * ~     Voronoise: https:\/\/www.shadertoy.com\/view\/Xd23Dh\n * ~ \n *\n *\/\n\n\/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 *\/\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n\/* skew constants for 3d simplex functions *\/\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n\/* 3d simplex noise *\/\nfloat simplex3d(vec3 p) {\n\t \/* 1. find current tetrahedron T and it's four vertices *\/\n\t \/* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices *\/\n\t \/* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*\/\n\t \n\t \/* calculate s and x *\/\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t \/* calculate i1 and i2 *\/\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t \/* x1, x2, x3 *\/\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t \/* 2. find four surflets and store them in d *\/\n\t vec4 w, d;\n\t \n\t \/* calculate surflet weights *\/\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t \/* w fades from 0.6 at the center of the surflet to 0.0 at the margin *\/\n\t w = max(0.6 - w, 0.0);\n\t \n\t \/* calculate surflet components *\/\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t \/* multiply d by w^4 *\/\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t \/* 3. return the sum of the four surflets *\/\n\t return dot(d, vec4(52.0));\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":257,"channel":0}],"code":"\/\/ location of mass in given cell\nvec2 location(vec2 cell) {\n    return cell + texture(iChannel0, cell \/ iResolution.xy).zw;\n}\n\n\/\/ spring fails when stretched too far\nfloat stiffness(float dist, vec2 uv) {\n    return mix(.05, .2, uv.x) * smoothstep(1.4, .6, dist);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord \/ iResolution.xy;\n\n    \/\/ init\n    if (iFrame < 10) {\n        fragColor = vec4(simplex3d(vec3(10.*uv, 1)), simplex3d(vec3(10.*uv, 2)), simplex3d(vec3(10.*uv, 3)), simplex3d(vec3(10.*uv, 4)));\n        return;\n    }\n    \n    \/\/ diffusion of internal stress\n    vec2 stress = texBlur(iChannel0, uv).xy;\n    \n    \/\/ spring forces from neighbouring cells\n    for (int i = -1; i <= 1; i++) for (int j = -1; j <= 1; j++) {\n        if (i == 0 && j == 0) continue;\n        vec2 offset = normalize(vec2(i,j));\n        vec2 disp = location(fragCoord + offset) - location(fragCoord);\n        vec2 force = stiffness(length(disp), uv) * disp; \/\/ Hooke's law\n        stress += force;\n    }\n    \n    \/\/ interaction\n    vec4 m = iMouse;\n    float t = float(iFrame) \/ 200.;\n    if (t < 1.) {\n        m.x = iResolution.x * t;\n        m.y = iResolution.y * (.5 + .25 * sin(10. * t));\n        m.zw = m.xy;\n    }\n    if (m.z > 0.) {\n        vec2 dx = (fragCoord.xy - m.xy) \/ iResolution.y;\n        dx *= 10.;\n        stress += dx * exp(-dot(dx,dx));\n    }\n    \n    \/\/ clamp stress\n    if (length(stress) > 1.) stress = normalize(stress);\n    \n    \/\/ update mass locations\n    vec2 displacement = texBlur(iChannel0, uv).zw; \/\/ diffusion\n    displacement *= 1. - .01 * length(displacement); \/\/ pull towards centre of cell\n    displacement += .1 * stress; \/\/ push by spring forces\n    \n    fragColor = vec4(stress, displacement);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}}