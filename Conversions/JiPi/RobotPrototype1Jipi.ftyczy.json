{
 "ver": "0.1",
 "info": {
  "id": "ftyczy",
  "date": "0",
  "viewed": 0,
  "name": "Robot prototype1 JiPi",
  "description": "Hi! This my first prototype of the robot, his name is Rolik. I made it always look into your mouse cursor, just try it!)\n\nThis is my first work using ray marching, that has so many details. Firstly it was very laggy, but I made some cool optimizations.",
  "likes": 0,
  "published": "Private",
  "usePreview": 0,
  "tags": [
   "cute",
   "mouse",
   "screen",
   "camera",
   "robot",
   "face"
  ],
  "hasliked": 0,
  "parentid": "slVczW",
  "parentname": "Robot prototype 01"
 },
 "renderpass": [
  {
   "inputs": [],
   "outputs": [
    {
     "id": "4dfGRr",
     "channel": 0
    }
   ],
   "code": "#define PI 3.14159265359\n\nvec2 robotAn;\nfloat robotH;\nvec3 robotPos;\nfloat legLength;\n\nmat2 rmatrix(float a)    //Rotation matrix;\n{\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\n\treturn mat2(c, -s, s, c);\n}\n\nvec3 getRayDir(vec3 cameraDir, vec2 coord, float cameraAngle)\n{\n\tcoord.y /= iResolution.x / iResolution.y;\n\tvec3 xAxis = normalize(vec3(-cameraDir.z, 0, cameraDir.x)) * tan(cameraAngle / 2.0);\n\tvec3 yAxis = normalize(cross(cameraDir, xAxis)) * tan(cameraAngle / 2.0) * -1.0;\n\tvec3 result = normalize(cameraDir + xAxis * coord.x + yAxis * coord.y);\n\n\treturn (result);\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdfStruts(vec3 p) //sdf for strut parts\n{\n    vec3 p1;\n    \n    p1 = vec3(p.xy, abs(p.z)) - vec3(0.3, -0.2, 0.16);\n    float strut = length(vec3(p1.x, p1.y - clamp(p1.y, 0.0, 0.40), p1.z)) - 0.02;\n    \n    //--forehead--\n    \n    p1 = vec3(p.xy, abs(p.z)) - vec3(0.03, 0.34, 0.16);\n    \n    p1.xy *= rmatrix(PI / 7.0 + PI / 2.0);\n    \n    strut = min(strut, length(vec3(p1.x, p1.y - clamp(p1.y, 0.0, 0.30), p1.z)) - 0.02);\n    \n    //--upper horizontal---\n    \n    p1 = vec3(p) - vec3(0.03, 0.34, 0.16);\n    \n    p1.zy *= rmatrix(-PI / 2.0);\n    \n    strut = min(strut, length(vec3(p1.x, p1.y - clamp(p1.y, 0.0, 0.32), p1.z)) - 0.02);\n    \n    //--lower horizontal---\n    \n    p1 = vec3(p) - vec3(0.31, 0.21, 0.16);\n    \n    p1.zy *= rmatrix(-PI / 2.0);\n    \n    strut = min(strut, length(vec3(p1.x, p1.y - clamp(p1.y, 0.0, 0.32), p1.z)) - 0.02);\n    \n    //--chin horizontal---\n    \n    p1 = vec3(p) - vec3(0.31, -0.21, 0.16);\n    \n    p1.zy *= rmatrix(-PI / 2.0);\n    \n    strut = min(strut, length(vec3(p1.x, p1.y - clamp(p1.y, 0.0, 0.32), p1.z)) - 0.02);\n    \n    //--chin - spine---\n    \n    p1 = vec3(vec3(p.xy, abs(p.z))) - vec3(0.31, -0.21, 0.16);\n    \n    p1.xy *= rmatrix(-PI / 1.9);\n    \n    strut = min(strut, length(vec3(p1.x, p1.y - clamp(p1.y, 0.0, 0.42), p1.z)) - 0.02);\n    \n    //--spine - back---\n    \n    p1 = vec3(vec3(p.xy, abs(p.z))) - vec3(-0.1086, -0.2446, 0.16);\n    \n    p1.xy *= rmatrix(-PI / 4.9);\n    \n    strut = min(strut, length(vec3(p1.x, p1.y - clamp(p1.y, 0.0, 0.32), p1.z)) - 0.02);\n    \n    //--back - up---\n    \n    p1 = vec3(vec3(p.xy, abs(p.z))) - vec3(-0.3, 0.0118, 0.16);\n    \n    p1.xy *= rmatrix(PI / 10.0);\n    \n    strut = min(strut, length(vec3(p1.x, p1.y - clamp(p1.y, 0.0, 0.34), p1.z)) - 0.02);\n    \n    //--up - front---\n    \n    p1 = vec3(p.xy, abs(p.z)) - vec3(0.03, 0.34, 0.16);\n    \n    p1.xy *= rmatrix(-PI / 2.0);\n    \n    strut = min(strut, length(vec3(p1.x, p1.y - clamp(p1.y, 0.0, 0.22), p1.z)) - 0.02);\n    \n    //--up - back horizontal---\n    \n    p1 = vec3(p) - vec3(0.03 - 0.22, 0.34, 0.16);\n    \n    p1.zy *= rmatrix(-PI / 2.0);\n    \n    strut = min(strut, length(vec3(p1.x, p1.y - clamp(p1.y, 0.0, 0.32), p1.z)) - 0.02);\n    \n    //--back horizontal---\n    \n    p1 = vec3(p) - vec3(-0.3, 0.0118, 0.16);\n    \n    p1.zy *= rmatrix(-PI / 2.0);\n    \n    strut = min(strut, length(vec3(p1.x, p1.y - clamp(p1.y, 0.0, 0.32), p1.z)) - 0.02);\n    \n     //--spine horizontal---\n    \n    p1 = vec3(p) - vec3(-0.1086, -0.2446, 0.16);\n    \n    p1.zy *= rmatrix(-PI / 2.0);\n    \n    strut = min(strut, length(vec3(p1.x, p1.y - clamp(p1.y, 0.0, 0.32), p1.z)) - 0.02);\n    \n    \n    return strut;\n}\n\nvec4 getHead(vec3 p, vec2 a) // sdf for head\n{\n    vec2 uv = vec2(0.0);\n    float mat = 0.0;\n    float t = 1000000.0;\n    \n    vec3 p1;\n    \n    p.xz *= rmatrix(a.x);\n    p.xy *= rmatrix(a.y);\n    \n    if (length(p) > 0.7)  // This \"if\" is an optimization, which increases fps 3 times\n        return vec4(length(p) - 0.6, uv, mat);\n    \n    //--FOREHEAD--\n    \n    p1 = p;\n    \n    p1.xy *= rmatrix(PI / 7.0);\n    p1 -= vec3(0.055, 0.25, 0.0);\n    \n    float forehead = length(max(abs(p1) - vec3(0.145, 0.03, 0.16), vec3(0))) - 0.01;\n    \n    t = min(t, forehead);\n    \n    if (t == forehead)\n    {\n        if (p1.y > 0.0 && abs(p1.x) <= 0.145 && abs(p1.z) <= 0.16)\n        {\n            uv = p1.zx / vec2(-0.145, -0.16) * vec2(1.0, 1.5);\n            mat = 9.0;\n        }\n    }\n    \n    p1 = p;\n    p1.y -= 0.1;\n    \n    forehead = length(max(abs(p1 - vec3(-0.08, 0.16, 0.0)) - vec3(0.1, 0.03, 0.16), vec3(0))) - 0.01;\n   \n    t = min(t, forehead);\n    \n    \n    if (t == forehead)\n        mat = 5.0;\n    \n    //--BASE--\n    \n    float cube = length(max(abs(p - vec3(0.12, -0.05, 0.0)) - vec3(0.18, 0.2, 0.16), vec3(0))) - 0.01;\n       \n    p1 = p;\n    \n    vec2 d = abs(vec2(length(p1.xy), p1.z)) - vec2(0.24, 0.20);\n    \n    float cilinder = min(max(d.x, d.y), 0.0) + length(max(d, vec2(0.0))) - 0.01;\n    \n    t = min(t, cube);\n    t = min(t, cilinder);\n    \n    if (t == cube)\n    {\n        mat = 4.0;\n    }\n    else if (t == cilinder)\n    {\n        mat = 3.0;\n        if (abs(p.z) < 0.16)\n            mat = 4.0;\n    }\n    \n    //--STRUTS--\n    \n    float strut = sdfStruts(p + vec3(0.0, 0.05, 0.0));\n    \n    t = min(t, strut);\n    \n    if (t == strut)\n        mat = 6.0;\n    \n    //--Display--\n    \n    float display = length(max(abs(p - vec3(0.32, -0.05, 0.0)) - vec3(0.01, 0.16, 0.16), vec3(0))) - 0.01;\n   \n    t = min(t, display);\n    \n    if (t == display)\n    {\n        p1 = p - vec3(0.32, -0.05, 0.0)\n        ;\n        if (p1.x > 0.0 && abs(p1.y) <= 0.16 && abs(p1.z) <= 0.16)\n        {\n            mat = 7.0;\n            uv = p1.zy / vec2(0.16);\n        }\n        else\n        {\n            mat = 8.0;\n        }\n    }\n    \n    //--Torus--\n    \n    p1 = vec3(p.xy, abs(p.z)) - vec3(0.0, 0.00, 0.18);\n    \n    vec3 c = normalize(vec3(p1.xy, 0)) * 0.25;\n    float torus = length(p1 - c) - 0.02;\n    \n    t = min(t, torus);\n    \n    \n    if (t == torus)\n        mat = 8.0;\n    \n    //--axels----\n    \n    \n    p1 = p;\n    \n    d = abs(vec2(length(p1.xy), p1.z)) - vec2(0.15, 0.22);\n    float cilinder1 = min(max(d.x, d.y), 0.0) + length(max(d, vec2(0.0))) - 0.01;\n    \n    t = min(t, cilinder1);\n    \n    if (t == cilinder1)\n    {\n        mat = 4.0;\n    }\n    \n    d = abs(vec2(length(p1.xy), p1.z)) - vec2(0.05, 0.3);\n    float cilinder2 = min(max(d.x, d.y), 0.0) + length(max(d, vec2(0.0))) - 0.01;\n    \n    t = min(t, cilinder2);\n    \n    if (t == cilinder2)\n    {\n        mat = 8.0;\n    }\n    \n    float num = 6.0;\n    \n    float sector = round(atan(p1.x, p1.y) / (PI * 2.0 / num));\n    \n    p1.xy *= rmatrix(sector * (PI * 2.0 / num));\n    \n    p1.z = abs(p1.z);\n    \n    float tooths = length(max(abs(p1 - vec3(-0.0, 0.16, 0.18)) - vec3(0.04, 0.03, 0.03), vec3(0))) - 0.01;\n   \n    t = min(t, tooths);\n    \n    \n    if (t == tooths)\n        mat = 4.0;\n    \n    \n\treturn vec4(t, uv, mat);\n}\n\nvec4 getLeg(vec3 p, vec2 an, float k)  // sdf of a leg\n{\n    float t = 1000000.0;\n    vec2 uv = vec2(0.0);\n    float mat = 10.0;\n    \n    vec3 p1;\n    \n    if (length(p.xz) > legLength * 0.7)  // Another optimization\n        return vec4(length(p.xz) - legLength * 0.6, uv, mat);\n    \n    p.xz *= rmatrix(an.x);\n    \n    float l = legLength / 2.0;\n    \n    vec2 a, b, c;\n    \n    a = vec2(0.0, 0.0);\n    \n    b = vec2(-l * sqrt(1.0 - k * k), l * k);\n    \n    c = vec2(0.0, 2.0 * l * k);\n    \n    vec2 r;\n    \n    r = normalize((b - a) * mat2(0.0, -1.0, 1.0, 0.0)) * 0.07;\n    \n    p1 = p;\n    p1.z = abs(p1.z);\n    \n    float leg1 = sdCapsule(p1, vec3(a + r, 0.32), vec3(b + r, 0.2), 0.02);\n    \n    t = leg1;\n    \n    float leg2 = sdCapsule(p1, vec3(a - r, 0.32), vec3(b -r, 0.2), 0.02);\n    \n    t = min(t, leg2);\n    \n    float leg3 = sdCapsule(p1, vec3(b, 0.1), vec3(c, 0.1), 0.04);\n    \n    t = min(t, leg3);\n    \n    p1 = p;\n    p1.z = abs(p1.z);\n    p1 -= vec3(a, 0.32);\n    \n    vec2 d = abs(vec2(length(p1.xy), p1.z)) - vec2(0.1, 0.02);\n    float joinDown = min(max(d.x, d.y), 0.0) + length(max(d, vec2(0.0))) - 0.01;\n    \n    t = min(t, joinDown);\n    \n    p1 = p;\n    p1.z = abs(p1.z);\n    p1 -= vec3(b, 0.22);\n    \n    d = abs(vec2(length(p1.xy), p1.z)) - vec2(0.1, 0.02);\n    float joinMiddle1 = min(max(d.x, d.y), 0.0) + length(max(d, vec2(0.0))) - 0.01;\n    \n    t = min(t, joinMiddle1);\n    \n    p1 = p;\n    p1 -= vec3(b, 0.0);\n    \n    d = abs(vec2(length(p1.xy), p1.z)) - vec2(0.05, 0.2);\n    float joinMiddle2 = min(max(d.x, d.y), 0.0) + length(max(d, vec2(0.0))) - 0.01;\n    \n    t = min(t, joinMiddle2);\n    \n    \n    return vec4(t, uv, mat);\n}\n\nvec4 map(vec3 p) \n{\n    vec2 uv = vec2(0.0);\n    float mat = 0.0;\n    float t = 1000000.0;\n    \n    vec3 p1;\n    \n    //---Background---\n    \n    uv = p.xz;\n    mat = 0.0;\n    \n    float background = p.x - -1.0;\n    \n    t = background;\n    \n    if (t == background)\n    {\n        mat = 11.0;\n        uv  = p.zy / 1.6;\n    }\n    \n    //---Head---\n    \n    \n    vec4 head = getHead(p - robotPos, robotAn);\n    \n    t = min(t, head.x);\n    if (t == head.x)\n    {\n        uv = head.yz;\n        mat = head.w;\n    }\n    \n    //---Leg---\n    \n    vec4 leg = getLeg(p - robotPos, robotAn, robotH);\n    \n    t = min(t, leg.x);\n    if (t == leg.x)\n    {\n        uv = leg.yz;\n        mat = leg.w;\n    }\n    \n    return vec4(t, uv, mat);\n}\n\nvec4 marchRay(vec3 rayOrigin, vec3 rayDir)  //almost classic raymarching\n{\n\tfloat t;\n\tfloat d = 0.0;\n\tfloat e = 0.00001;\n\tfloat maxRange = 10.0;\n\tvec3 pos;\n    vec4 info;\n\n\tfor (t = 0.0; t <= maxRange; t += d)\n\t{\n\t\tpos = rayOrigin + rayDir * t;\n        \n        info = map(pos);\n       \n\t\t\n        d = info.x;\n\n\t\tif (d < e)\n\t\t\tbreak;\n\t}\n\tif (t > maxRange)\n\t\treturn vec4(-1.0);\n    \n    info.x = t;\n\treturn info;\n}\n\nvec3 getNorm(vec3 pos)\n{\n\tvec2 e = vec2(0.001, 0);\n\tfloat tp = map(pos).x;\n\n\tvec3 norm = -normalize(vec3(map(pos - e.xyy).x - tp,\n\t\t\t\t\t\t\t   map(pos - e.yxy).x - tp,\n\t\t\t\t\t\t\t   map(pos - e.yyx).x - tp));\n\treturn (norm);\n}\n\nfloat getEyesAnim(float t)\n{\n    return 1.0 - step(0.02, pow(cos(0.3 * t) * cos(0.5 * t), 16.0));\n}\n\nvec3 getFaceTex(vec2 uv0, float t)\n{\n    vec3 color = vec3(0.2);\n    \n    uv0.x += sin(t * 1.0) * sin (t * 1.5) * 0.016;\n    vec2 uv = round(uv0 * 15.0) / 15.0;\n    //uv = uv0;\n    \n    vec2 eyesSize = vec2(0.3, 0.05 + 0.25 * getEyesAnim(t));\n    float eyes = length((vec2(abs(uv.x), uv.y) - vec2(0.4, 0.2)) / eyesSize);\n    \n    color = mix(vec3(1.0, 0.0, 0.0), color, step(1.0, eyes));\n    \n    vec2 d = abs(uv + vec2(0.0, 0.4)) - vec2(0.3, 0.05);\n    float mouth = length(max(vec2(0.0), d)) + min(max(d.x,d.y), 0.0);\n    \n    color = mix(vec3(1.0, 0.0, 0.0), color, step(0.0, mouth));\n    \n    float b = length(uv0.y - uv.y);\n    \n    color *= vec3(1.0 - b * 20.0);\n    \n    return color;\n}\n\nvec3 getForeheadTex(vec2 uv)\n{\n    vec3 col = vec3(.8);\n    \n    vec2 uv1 = uv - vec2(-0.4, 0.0);\n    \n    vec2 q = uv1 / vec2(0.3, 0.5);\n    \n    float zero = pow(abs(q.x), 3.0) + pow(abs(q.y), 3.0);\n    \n    float zeroSlash = abs(uv1.y - uv1.x * 2.4);\n    \n    col = mix(col, vec3(1.0, 0.8, 0.0), 1.0 - step(0.4, abs(1.0 - zero)));\n    col = mix(col, vec3(1.0, 0.8, 0.0), (1.0 - step(0.1, zeroSlash)) * (1.0 - step(1.0, zero)));\n    \n    uv1 = uv - vec2(0.4, 0.0);\n    \n    float one = length(max(abs(uv1) - vec2(0.01, 0.5), vec2(0.0))) - 0.05;\n    \n    uv1 = uv;\n    \n    uv1 -= vec2(0.28, 0.33);\n    uv1 *= rmatrix(PI / 5.0);\n    \n    one = min(one, length(max(abs(uv1) - vec2(0.01, 0.2), vec2(0.0))) - 0.05);\n    \n    uv1 = uv - vec2(0.4, -0.5);\n    \n    one = min(one, length(max(abs(uv1) - vec2(0.25, 0.01), vec2(0.0))) - 0.05);\n    \n    col = mix(col, vec3(1.0, 0.8, 0.0), 1.0 - step(0.00, one));\n    \n    return (col);\n}\n\nvec3 getColor(vec4 info)\n{\n   float mat = info.w;\n   vec2 uv = info.yz;\n   \n   if (mat == 1.0)\n   {\n       vec3 c1 = vec3(0, 98, 255) / 255.0;\n       vec3 c2 = vec3(255, 21, 0) / 255.0;\n       \n       float k = sin(fract(uv.y + uv.x * 1.0) * PI);\n       \n       vec3 color = mix(c1, c2, k);\n       \n       color *= pow(abs(sin((uv.y + uv.x * 1.0) * PI / 2.0 * 32.0)), 10.0);\n       \n       return (color);\n   }\n   if (mat == 0.0)\n   {\n       vec2 id = floor(uv);\n       if (mod((id.x + id.y), 2.0) == 0.0)\n           return (vec3(0.5));\n       return vec3(1.0);\n   }\n   if (mat == 2.0)\n   {\n       vec2 id = floor(uv);\n       if (mod((id.x + id.y), 2.0) == 0.0)\n           return (vec3(0.5));\n       return vec3(1.0);\n   }\n   if (mat == 3.0)\n       return vec3(245.0, 133.0, 54.0) / vec3(255.0);\n   if (mat == 4.0)\n       return vec3(0.3);\n   if (mat == 5.0)\n       return vec3(0.95);\n   if (mat == 6.0)\n       return vec3(0.2);\n   if (mat == 7.0)\n       return (getFaceTex(uv, iTime * 10.0));\n   if (mat == 8.0)\n       return vec3(0.6);\n   if (mat == 9.0)\n       return getForeheadTex(uv);\n   if (mat == 10.0)\n       return vec3(0.5);\n   if (mat == 11.0)\n   {\n       if (max(abs(uv).x, abs(uv).y) > 1.0)\n           return vec3(1.0);\n       if (max(abs(uv).x, abs(uv).y) > 0.9)\n       {\n           vec3 c1 = vec3(0.1);\n           vec3 c2 = vec3(1.0, 1.0, 0.0);\n           \n           float k = uv.y - uv.x;\n           \n           return mix(c1, c2, step(0.5, fract(k * 10.0)));\n       }\n       return vec3(0.4);\n   }\n   return (vec3(0));\n}\n\nfloat getShadow(vec3 rayOrigin, vec3 rayDir)\n{\n\tfloat t;\n\tfloat d = 0.0;\n\tfloat e = 0.00001;\n\tfloat maxRange = 10.0;\n    vec4 info;\n\tvec3 pos;\n    \n    float res = 1.0;\n\n\tfor (t = 0.0; t <= maxRange; t += d)\n\t{\n\t\tpos = rayOrigin + rayDir * t;\n        info = map(pos);\n\t\td = info.x;\n        res = min(res, d / t * 64.0);\n\t\tif (d < e)\n\t\t\tbreak;\n\t}\n        \n\treturn res;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float d1 = 2.0;\n    float d2 = 1.5;\n    \n    vec3 cameraPos;\n    vec3 cameraDir;\n    \n    vec2 mouseuv = (iMouse.xy - iResolution.xy / 2.0) / iResolution.y * 2.0;\n    \n    cameraPos = vec3(d1, 0.0, 0.0);\n    cameraDir = vec3(-1.0, 0.0, 0.0);\n    \n    vec3 rayDir = getRayDir(cameraDir, (fragCoord.xy / iResolution.xy) * 2.0 - 1.0, PI / 2.0);\n\tvec3 rayOrigin = cameraPos;\n    \n    legLength = 2.0;\n    robotPos = vec3(0.0, mouseuv.y * -0.4, 0.0);\n    robotH = (1.4 - robotPos.y) / legLength;\n    \n    vec3 mousePos = getRayDir(cameraDir, (iMouse.xy / iResolution.xy) * 2.0 - 1.0, PI / 2.0);;\n    \n    vec3 d = (mousePos - robotPos);\n    \n    robotAn = vec2(atan(d.z, d.x) + PI, atan(d.y, d.x) + PI);\n    \n    \n    vec4 info = marchRay(rayOrigin, rayDir);\n\tfloat t = info.x;\n\n\tvec3 color = vec3(0);\n\n\tif (t != -1.0)\n\t{\n\t\tvec3 pos = rayOrigin + rayDir * t;\n\t\tvec3 lightDir = normalize(vec3(2.0, 0.6, -3.0) - pos);\n\t\tvec3 norm = getNorm(pos);\n\t\tfloat l = 1.0;\n        float mat = info.w;\n        \n        color = getColor(info);\n        \n        if (mat != 7.0)\n        {\n            l = 0.3;\n            float st = getShadow(pos + norm * 0.001, lightDir);\n\n            l += max(0.0, dot(lightDir, norm)) * 0.7 * st;\n        }\n\n        color *= l;\n\t}\n\n\tfragColor = vec4(color, 1.0);\n}",
   "name": "Image",
   "description": "",
   "type": "image"
  }
 ]
}