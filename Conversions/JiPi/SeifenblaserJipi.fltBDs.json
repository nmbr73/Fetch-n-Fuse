{
 "ver": "0.1",
 "info": {
  "id": "fltBDs",
  "date": "0",
  "viewed": 0,
  "name": "SeifenblaseR JiPi",
  "description": "Rebuild",
  "likes": 0,
  "published": "Private",
  "usePreview": 0,
  "tags": [
   "bubble"
  ],
  "hasliked": 0,
  "parentid": "",
  "parentname": ""
 },
 "renderpass": [
  {
   "inputs": [
    {
     "id": "XsX3zn",
     "filepath": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png",
     "type": "cubemap",
     "channel": 0,
     "sampler": {
      "filter": "mipmap",
      "wrap": "clamp",
      "vflip": "false",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    }
   ],
   "outputs": [
    {
     "id": "4dfGRr",
     "channel": 0
    }
   ],
   "code": "#define MAX_STEPS 400\n#define MAX_DIST 100.\n#define EPSILON 0.001\n#define PI 3.14159265\n#define COL1 1.\n#define COL2 2.\n#define COL3 3.\n\n\nmat2 rot(float a) {float s = sin(a), c = cos(a);return mat2(c, -s, s, c);}\nfloat opSmoothUnion( float d1, float d2, float k ) {    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );    return mix( d2, d1, h ) - k*h*(1.0-h); }\nfloat opSmoothSubtraction( float d1, float d2, float k ) {    float h = clamp( 0.5 - 0.5*(d1+d2)/k, 0.0, 1.0 );    return mix( d1, -d2, h ) + k*h*(1.0-h); }\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\nfloat snoise(vec2 v) {\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        0.366025403784439,\n                        -0.577350269189626,\n                        0.024390243902439);\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n\n\n\n// ------------------\nvec2 getDist(vec3 p) {\n\n  // p.x+=10.*snoise(p.yz*.03+iTime*.2) * smoothstep(1., 10., length(p));\n  // p.y+=10.*snoise(p.yz*.03+iTime*.2) * smoothstep(1., 10., length(p));\n  // p=fract(p+.5)-.5;\n\n  p.x+=.03*snoise(p.yz*2.3+iTime*.2);\n  // p.z+=amp.z*snoise(p.xy*1.3+iTime*.2);\n  // p.y+=amp.y*snoise(p.xz*1.3+iTime*.2);\n  return vec2((length(p)-.5)*.8, COL1);\n}\n// -----------------\n\n\n\n\n\nvec4 rayMarch(vec3 ro, vec3 rd) {\n\tfloat d = 0.;\n  float info = 0.;\n  float glow = 9999.;\n  int ii=0;\n  for (int i = 0; i < MAX_STEPS; i++) {\n    ii=i;\n  \tvec2 distToClosest = getDist(ro + rd * d);\n    d += abs(distToClosest.x);\n    info = distToClosest.y;\n    glow = min(glow, abs(distToClosest.x));\n    if(abs(distToClosest.x) < EPSILON || d > MAX_DIST) {\n    \tbreak;\n    }\n  }\n  return vec4(d, info, ii, glow);\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(EPSILON, 0.);\n    vec3 n = getDist(p).x - vec3(getDist(p - e.xyy).x,\n                               getDist(p - e.yxy).x,\n                               getDist(p - e.yyx).x);\n\treturn normalize(n);\n}\n\nvec3 getRayDirection (vec3 ro, vec2 uv, vec3 lookAt) {\n    vec3 rd;\n    rd = normalize(vec3(uv - vec2(0, 0.), 1.));\n    vec3 lookTo = lookAt - ro;\n    float horizAngle = acos(dot(lookTo.xz, rd.xz) / length(lookTo.xz) * length(rd.xz));\n    rd.xz *= rot(horizAngle);\n    return rd;\n}\n\nvec3 getRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 p, color,rd,n,ro,ref;\n    vec4 rm;\n    ro=vec3(0,0,1.5);\n    ro.xz*=rot(iTime);\n    float d, info, dtotal=0., steps, marches, glow;\n    rd = getRayDir(uv, ro, vec3(0), 1.);\n    // rm = rayMarch(ro, rd);\n    // d = rm[0];\n    // info = rm[1];\n    // steps = rm[2];\n\n    vec3 light = vec3(50, 50, 50);\n    // n = getNormal(p);\n\n    // making several marches outside and inside\n    // the surface along the ray\n    for (int i = 0; i < 5; i++) {\n      rm = rayMarch(ro, rd);\n      info = rm[1];\n      glow += rm[3];\n      // color+=0.00000002/glow;\n      // marches+=1.;\n      dtotal += d = rm[0];\n      if (dtotal > MAX_DIST) break;\n      \n      p = ro + rd * d;\n      n = getNormal(p);\n      \n      float refK = 7.;\n      ref = reflect(rd, n);\n      color+=refK*texture(iChannel0, ref).xyz;\n      marches+=refK;\n      \n      color+=2.*smoothstep(-.5,1.,dot(ref, rd));\n      color+=2.*smoothstep(.6,1.,dot(ref, rd));\n      \n      vec3 amp = vec3(2.3);\n      n.z+=amp.z*snoise(n.xy*.6+iTime*.05);\n      n.x+=amp.x*snoise(n.yz*.6+iTime*.05);\n      n.y+=amp.y*snoise(n.xz*.6+iTime*.05);\n      color+= n*.5+.5;\n      marches++;\n\n\n      ro = p + rd * 0.05;\n    }\n    color/=marches;\n\n\n\n    // vec3 dirToLight = normalize(light - p);\n    // vec3 rayMarchLight = rayMarch(p + dirToLight * .06, dirToLight);\n    // float distToObstable = rayMarchLight.x;\n    // float distToLight = length(light - p);\n\n\n\n    fragColor = vec4(color,1);\n}",
   "name": "Image",
   "description": "",
   "type": "image"
  }
 ]
}