{"Shader":{"ver":"0.1","info":{"id":"fscSD8","date":"1632996169","viewed":212,"name":"Phawq of Lovely Bubbles","username":"xenn","description":"It appears that I am unable tio have the bubbles leave behind colourful trails like michael does in this video https:\/\/www.youtube.com\/watch?v=nqxVMLVe62U&ab_channel=TheJacksonsVEVO\n\nso I did some other rubbish. as yet unfinished","likes":6,"published":3,"flags":32,"usePreview":0,"tags":["bubbles"],"hasliked":0},"renderpass":[{"inputs":[{"id":258,"src":"\/media\/previz\/buffer01.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":258,"src":"\/media\/previz\/buffer01.png","ctype":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":260,"src":"\/media\/previz\/buffer03.png","ctype":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":37,"channel":0}],"code":"\/\/ Fork of \"Lovely Bubbles Fawq\" by xenn. https:\/\/shadertoy.com\/view\/fddSz7\n\/\/ 2021-09-30 10:00:20\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord \/ iResolution.xy;\n    \n    vec3 ob, nb, a;\n    ob = texture(iChannel0, uv).rgb;\n    nb = texture(iChannel1, uv).rgb;\n    vec3 xb = texture(iChannel2, uv).rgb;\n    xb += (xb * xb) - xb;\n    \n    \/\/a = col * len\n    a = vec3(0.5 * (abs(sin(iTime \/ 3.0))), 0.25, 0.5 * (1.1 * (abs(cos(iTime \/ 3.0))))) * .5;\n\n    fragColor = min(vec4(mix(ob, nb, (a \/ 0.50)), 1.),(xb,1.));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":24,"src":"\/media\/a\/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","ctype":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":257,"channel":0}],"code":"\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#if USE_THIN_FILM_LOOKUP\n    {\n        int segmentCount = 32;\n        int segment = iFrame % segmentCount;\n        int currSegment = int(floor((fragCoord.y * float(segmentCount) \/ iResolution.y)));\n        \n        if ( segment != currSegment )\n        {\n            fragColor = texelFetch( iChannel0, ivec2(fragCoord), 0 );\n            return;\n        }\n    }\n\n    vec2 uv = fragCoord\/iResolution.xy;\n        \n    vec3 result = GetThinFilmColour(uv.x, uv.y);  \n\n    fragColor = vec4(result,1.0);\n#else\n    discard;\n#endif\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define iFeedbackColorShiftZoom 0.058\n\/\/#define iFeedbackColorShiftImpact 0.001\n#define iBlob1ColorPulseSpeed 0.03456\n#define iBlob2ColorPulseSpeed -0.02345\n#define Margins .0\n\n\n\n\n\n\n\n\n\n\n\n\/*\n * Conway Ticket\n * \n * Copyright (C) 2021  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and\/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http:\/\/www.gnu.org\/licenses\/>.\n *\/\n \nivec2 boardSize = ivec2(125),\n    ci = ivec2(1,0);\nvec2 blockSize,\n    xij;\nvec3 c = vec3(1,0,-1);\nfloat stepTimeDelta = .05,\n    pi = 3.14159,\n    fsaa = 144.,\n    bpm = 90.,\n    spb = 60.\/90.,\n    scale,\n    nbeats,\n    stepTime;\n\n\/\/ Creative Commons Attribution-ShareAlike 4.0 International Public License\n\/\/ Created by David Hoskins.\n\/\/ See https:\/\/www.shadertoy.com\/view\/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(p.xyx * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat lfnoise(float y)\n{\n    vec2 t = y*c.xx;\n    vec2 i = floor(t);\n    t = smoothstep(c.yy, c.xx, fract(t));\n    vec2 v1 = vec2(hash12(i), hash12(i+c.xy)),\n    v2 = vec2(hash12(i+c.yx), hash12(i+c.xx));\n    v1 = c.zz+2.*mix(v1, v2, t.y);\n    return mix(v1.x, v1.y, t.x);\n}\n\nfloat m(vec2 x)\n{\n    return max(x.x,x.y);\n}\n\nfloat d210(vec2 x)\n{\n    return min(max(max(max(max(min(max(max(m(abs(vec2(abs(abs(x.x)-.25)-.25, x.y))-vec2(.2)), -m(abs(vec2(x.x+.5, abs(abs(x.y)-.05)-.05))-vec2(.12,.02))), -m(abs(vec2(abs(x.x+.5)-.1, x.y-.05*sign(x.x+.5)))-vec2(.02,.07))), m(abs(vec2(x.x+.5,x.y+.1))-vec2(.08,.04))), -m(abs(vec2(x.x, x.y-.04))-vec2(.02, .08))), -m(abs(vec2(x.x, x.y+.1))-vec2(.02))), -m(abs(vec2(x.x-.5, x.y))-vec2(.08,.12))), -m(abs(vec2(x.x-.5, x.y-.05))-vec2(.12, .07))), m(abs(vec2(x.x-.5, x.y))-vec2(.02, .08)));\n}\n\nfloat dbox3(vec3 x, vec3 b)\n{\n  b = abs(x) - b;\n  return length(max(b,0.))\n         + min(max(b.x,max(b.y,b.z)),0.);\n}\n\nfloat setStateF(ivec2 index, ivec2 where, float oldState, float newState)\n{\n    return all(equal(index, where)) ? newState : oldState;\n}\n\n\/\/ Distance to star\nfloat dstar(vec2 x, float N, vec2 R)\n{\n    float d = pi\/N,\n        p0 = acos(x.x\/length(x)),\n        p = mod(p0, d);\n    vec2 a = mix(R,R.yx,mod(round((p-p0)\/d),2.)),\n    \tp1 = a.x*c.xy,\n        ff = a.y*vec2(cos(d),sin(d))-p1;\n    return dot(length(x)*vec2(cos(p),sin(p))-p1,ff.yx*c.zx)\/length(ff);\n}\n\nfloat dhexagonpattern(vec2 p) \n{\n    vec2 q = vec2(p.x*1.2, p.y + p.x*.6),\n        qi = floor(q),\n        pf = fract(q);\n    float v = mod(qi.x + qi.y, 3.);\n    \n    return dot(step(pf.xy,pf.yx), 1.-pf.yx + step(1.,v)*(pf.x+pf.y-1.) + step(2.,v)*(pf.yx-2.*pf.xy));\n}\n\n\/\/ x: material\n\/\/ y: distance\n\/\/ z: reflectivity\nvec3 add(vec3 a, vec3 b)\n{\n    if(a.y < b.y) return a;\n    return b;\n}\n\nvec3 hsv2rgb(vec3 cc)\n{\n    vec4 K = vec4(1., 2. \/ 3., 1. \/ 3., 3.);\n    vec3 p = abs(fract(cc.xxx + K.xyz) * 6. - K.www);\n    return cc.z * mix(K.xxx, clamp(p - K.xxx, 0., 1.), cc.y);\n}\n\nvec2 rgb2sv(vec3 cc)\n{\n    vec4 K = vec4(0., -1. \/ 3., 2. \/ 3., -1.),\n        p = mix(vec4(cc.bg, K.wz), vec4(cc.gb, K.xy), step(cc.b, cc.g)),\n        q = mix(vec4(p.xyw, cc.r), vec4(cc.r, p.yzx), step(p.x, cc.r));\n    return vec2((q.x - min(q.w, q.y)) \/ (q.x + 1.e-10), q.x);\n}\n\n\n\n#define pi acos(-1.)\n\n\n#define sint(a) (asin(sin(a))*2. - 1.)\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n\/\/#define pmod(p,d) mod(p - (d)*0.5, (d)) - 0.5*(d)\n\nfloat r11(float i){ return fract(sin(i*12.126)*12.6);}\n\n#define xor(a,b,c) min(max((a),-(b)), max((b),-(a) - c)) \n\nfloat ss( float c, float power, float bias){\n    c = clamp(c,-0.,1.);\n    \/\/c = smoothstep(0.,1.,c);\n    \n    c = pow(c,1. + bias);\n    \n    float a = pow( abs(c), power);\n    float b = 1.-pow( abs(c - 1.), power);\n    \n    return mix(a,b,c);\n}\nfloat valueNoise(float i, float p){ return mix(r11(floor(i)),r11(floor(i) + 1.), ss(fract(i), p,0.6));}\n\nfloat valueNoiseStepped(float i, float p, float steps){ return mix(  floor(r11(floor(i))*steps)\/steps, floor(r11(floor(i) + 1.)*steps)\/steps, ss(fract(i), p,0.6));}\n\n\n\/\/ See: https:\/\/www.shadertoy.com\/view\/ls2Bz1\n\/\/ Spectral Colour Schemes\n\/\/ By Alan Zucconi\n\/\/ Website: www.alanzucconi.com\n\/\/ Twitter: @AlanZucconi\n\n\/\/ Example of different spectral colour schemes\n\/\/ to convert visible wavelengths of light (400-700 nm) to RGB colours.\n\n\/\/ The function \"spectral_zucconi6\" provides the best approximation\n\/\/ without including any branching.\n\/\/ Its faster version, \"spectral_zucconi\", is advised for mobile applications.\n\n\n\/\/ Read \"Improving the Rainbow\" for more information\n\/\/ http:\/\/www.alanzucconi.com\/?p=6703\n\n\n\nfloat saturate (float x)\n{\n    return min(1.0, max(0.0,x));\n}\nvec3 saturate (vec3 x)\n{\n    return min(vec3(1.,1.,1.), max(vec3(0.,0.,0.),x));\n}\n\n\/\/ --- Spectral Zucconi --------------------------------------------\n\/\/ By Alan Zucconi\n\/\/ Based on GPU Gems: https:\/\/developer.nvidia.com\/sites\/all\/modules\/custom\/gpugems\/books\/GPUGems\/gpugems_ch08.html\n\/\/ But with values optimised to match as close as possible the visible spectrum\n\/\/ Fits this: https:\/\/commons.wikimedia.org\/wiki\/File:Linear_visible_spectrum.svg\n\/\/ With weighter MSE (RGB weights: 0.3, 0.59, 0.11)\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n\tvec3 y = vec3(1.,1.,1.) - x * x;\n\ty = saturate(y-yoffset);\n\treturn y;\n}\n\n\/\/ --- Spectral Zucconi 6 --------------------------------------------\n\n\/\/ Based on GPU Gems\n\/\/ Optimised by Alan Zucconi\nvec3 spectral_zucconi6 (float x)\n{\n\t\/\/ w: [400, 700]\n\t\/\/ x: [0,   1]\n\n\tconst vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n\tconst vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n\tconst vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n\n\tconst vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n\tconst vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n\tconst vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n\n\treturn\n\t\tbump3y(c1 * (x - x1), y1) +\n\t\tbump3y(c2 * (x - x2), y2) ;\n}\n\n\/\/ Use a lookup texture in Buffer A for thin film interference instead of calculating it at every intersection\n#define USE_THIN_FILM_LOOKUP 0\n\nfloat N_Air = 1.0f;\nfloat N_Water = 1.33f;\n\nfloat PI = 3.141592654;\n\n\/\/ used to prevent loop unrolling\n\/\/ This will be zero but the compiler doesn't know that as iFrame is a uniform\n#define ZERO min(iFrame,0)\n\n\/\/ https:\/\/en.wikipedia.org\/wiki\/Fresnel_equations\nfloat FresnelS(float ni, float nt, float cosi, float cost)\n{\n    return ((nt * cosi) - (ni * cost)) \/ ((nt * cosi) + (ni * cost));\n}\n\nfloat FresnelP(float ni, float nt, float cosi, float cost)\n{\n    return ((ni * cosi) - (nt * cost)) \/ ((ni * cosi) + (nt * cost));\n}\n\nfloat Fresnel(float ni, float nt, float cosi, float cost )\n{    \n    float Rs = FresnelS( ni, nt, cosi, cost );\n    float Rp = FresnelP( ni, nt, cosi, cost );\n\n    return (Rs * Rs + Rp * Rp) * 0.5;\n}\n\nfloat FresnelR0(float ni, float nt)\n{\n    float R0 = (ni-nt) \/ (ni+nt);\n    R0 *= R0;\n    return R0;\n}\n\n\/\/ https:\/\/en.wikipedia.org\/wiki\/Snell%27s_law\nfloat GetCosT( float ni, float nt, float cosi )\n{\n    float n = ni\/nt;\n    float sinT2 = n*n*(1.0-cosi*cosi);\n    \n    \/\/ Total internal reflection\n    if (sinT2 >= 1.0)\n    {\n        return 1.0;\n    } \n\n    float cost = sqrt(1.0 - sinT2);\n    return cost;\n}\n\n\n\/\/ https:\/\/www.shadertoy.com\/view\/4djSRW\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat SmoothNoise3d(vec3 p)\n{\n    vec3 fl = floor(p);\n    vec3 fr = p - fl;\n    \n    vec3 ot = fr*fr*(3.0-2.0*fr);\n    vec3 zt = 1.0f - ot;\n    \n    \n    float result = 0.0f;\n    \n    result += hash13(fl + vec3(0,0,0)) * (zt.x * zt.y * zt.z);\n    result += hash13(fl + vec3(1,0,0)) * (ot.x * zt.y * zt.z);\n\n    result += hash13(fl + vec3(0,1,0)) * (zt.x * ot.y * zt.z);\n    result += hash13(fl + vec3(1,1,0)) * (ot.x * ot.y * zt.z);\n\n    result += hash13(fl + vec3(0,0,1)) * (zt.x * zt.y * ot.z);\n    result += hash13(fl + vec3(1,0,1)) * (ot.x * zt.y * ot.z);\n\n    result += hash13(fl + vec3(0,1,1)) * (zt.x * ot.y * ot.z);\n    result += hash13(fl + vec3(1,1,1)) * (ot.x * ot.y * ot.z);\n\n    return result;\n}\n\nconst mat3 m3 = mat3( 0.00,  0.80,  0.60,\n\t\t\t\t\t-0.80,  0.36, -0.48,\n\t\t\t\t\t-0.60, -0.48,  0.64 );\n\nfloat Noise(vec3 p, float o)\n{\n    float result = 0.0f;\n    float a = 1.0f;\n    float t= 0.0;\n    float f = 0.5;\n    float s= 2.0f;\n    \n    p.x += o;\n    result += SmoothNoise3d(p) * a; t+= a; p = m3 * p * s; a = a * f;\n    p.x += o;\n    result += SmoothNoise3d(p) * a; t+= a; p = m3 * p * s; a = a * f;\n    p.x += o;\n    result += SmoothNoise3d(p) * a; t+= a; p = m3 * p * s; a = a * f;\n    p.x += o;\n    result += SmoothNoise3d(p) * a; t+= a; p = m3 * p * s; a = a * f;\n    result = result \/ t;\n    \n    return result;\n}\n\n\n\n\/\/ Spectrum to xyz approx function from http:\/\/jcgt.org\/published\/0002\/02\/01\/paper.pdf\n\/\/ Inputs:  Wavelength in nanometers\nfloat xFit_1931( float wave )\n{\n    float t1 = (wave-442.0)*((wave<442.0)?0.0624:0.0374),\n          t2 = (wave-599.8)*((wave<599.8)?0.0264:0.0323),\n          t3 = (wave-501.1)*((wave<501.1)?0.0490:0.0382);\n    return 0.362*exp(-0.5*t1*t1) + 1.056*exp(-0.5*t2*t2)- 0.065*exp(-0.5*t3*t3);\n}\nfloat yFit_1931( float wave )\n{\n    float t1 = (wave-568.8)*((wave<568.8)?0.0213:0.0247),\n          t2 = (wave-530.9)*((wave<530.9)?0.0613:0.0322);\n    return 0.821*exp(-0.5*t1*t1) + 0.286*exp(-0.5*t2*t2);\n}\nfloat zFit_1931( float wave )\n{\n    float t1 = (wave-437.0)*((wave<437.0)?0.0845:0.0278),\n          t2 = (wave-459.0)*((wave<459.0)?0.0385:0.0725);\n    return 1.217*exp(-0.5*t1*t1) + 0.681*exp(-0.5*t2*t2);\n}\n\n#define xyzFit_1931(w) vec3( xFit_1931(w), yFit_1931(w), zFit_1931(w) ) \n\nvec3 XYZtosRGB( vec3 XYZ )\n{\n    \/\/ XYZ to sRGB\n    \/\/ http:\/\/www.brucelindbloom.com\/index.html?Eqn_RGB_XYZ_Matrix.html\n   mat3 m = mat3 (\n        3.2404542, -1.5371385, -0.4985314,\n\t\t-0.9692660,  1.8760108,  0.0415560,\n \t\t0.0556434, -0.2040259,  1.0572252 );\n    \n    return XYZ * m;\n}\n\nvec3 WavelengthToXYZ( float f )\n{    \n    return xyzFit_1931( f );    \n}\n\n\n\n\/\/ from  https:\/\/github.com\/amandaghassaei\/SoapFlow\/blob\/main\/python\/Thin%20Film%20Interference.ipynb\nfloat ThinFilmAmplitude( float wavelength, float thickness, float cosi )\n{\n    float ni = N_Air;\n    float nt = N_Water;\n    \n    float cost = GetCosT( ni, nt, cosi );\n\n    \/\/ # The wavelength inside a medium is scaled by the index of refraction.\n    \/\/ wavelength_soap = wavelength \/ n_soap\n    \/\/ wavelength_air = wavelength \/ n_air\n    \/\/ # First calc phase shift of reflection at rear surface, based on film thickness.\n    \/\/ phaseDelta = 2 * thickness \/ math.cos(theta) * 2 * math.pi \/ wavelength_soap  \n    \/\/ # There is an additional path to compute, the segment AJ from:\n    \/\/ # https:\/\/www.glassner.com\/wp-content\/uploads\/2014\/04\/CG-CGA-PDF-00-11-Soap-Bubbles-2-Nov00.pdf\n    \/\/ phaseDelta -= 2 * thickness * math.tan(theta) * math.sin(incidentAngle) * 2 * math.pi \/ wavelength_air\n    \/\/ Simplified to:\n    float phaseDelta = 2.0 * thickness * nt * cost * 2.0 * PI \/ wavelength;\n    \n    \/\/ https:\/\/en.wikipedia.org\/wiki\/Reflection_phase_change\n    if (ni < nt)\n        phaseDelta -= PI;\n    if (ni > nt)\n        phaseDelta += PI;\n\n    float front_refl_amp = Fresnel(cosi, cost, ni, nt);\n    float front_trans_amp = 1.0 - front_refl_amp;\n    float rear_refl_amp = front_trans_amp * Fresnel(cost, cosi, nt, ni);\n    \n    rear_refl_amp \/= front_refl_amp;\n    front_refl_amp = 1.0f;\n        \n    \/\/ http:\/\/scipp.ucsc.edu\/~haber\/ph5B\/addsine.pdf\n    return sqrt(front_refl_amp * front_refl_amp + rear_refl_amp * rear_refl_amp + 2.0 * front_refl_amp * rear_refl_amp * cos(phaseDelta));\n}\n\nvec3 GetThinFilmColour( float cosi, float thicknessN )\n{\n    float thicknessMin = 100.0;\/\/1.0f;\n    float thicknessMax = 1500.0;\/\/2500.0f;\n    \n    float thickness = mix(thicknessMin, thicknessMax, thicknessN);\n\n    vec3 result = vec3(0.0);\n    \n    float t = 0.0;\n    \n    vec3 white = vec3(0.0);\n    \n    for (float wavelength = 380.0; wavelength<=780.0; wavelength += 50.0)\n    {\n        float amplitude = ThinFilmAmplitude( wavelength, thickness, cosi );\n        \n        vec3 XYZ = WavelengthToXYZ( wavelength );\n    \n        white += XYZ;\n    \n        result += XYZ * amplitude;\n        t += 1.0f;\n    }\n\n    result = XYZtosRGB( result );\n      \n    result \/= t;\n    \/\/result \/= white;\n    \/\/result = vec3(1.0);\n    \n    return result;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":22,"src":"\/media\/a\/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","ctype":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":258,"channel":0}],"code":"\/\/ Lovely Bubbles\n\/\/ by @P_Malin\n\/\/ https:\/\/www.shadertoy.com\/view\/Nl2SRc\n\/\/\n\/\/ Some lovely shadertoy bubbles.\n\/\/ I've wanted to implement something with thin film interference for a while.\n\n\n\/\/ CAMERA\n\nvec2 GetWindowCoord( vec2 uv )\n{\n\tvec2 window = uv * 2.0 - 1.0;\n\twindow.x *= iResolution.x \/ iResolution.y;\n\n\treturn window;\t\n}\n\nvec3 GetCameraRayDir( vec2 window, vec3 cameraPos, vec3 cameraTarget, float fov )\n{\n\tvec3 forward = normalize( cameraTarget - cameraPos );\n\tvec3 right = normalize( cross( vec3(0.0, 1.0, 0.0), forward ) );\n\tvec3 up = normalize( cross( forward, right ) );\n\t\t\t\t\t\t\t  \n\tvec3 dir = normalize(window.x * right + window.y * up + forward * fov);\n\n\treturn dir;\n}\n\n\n\/\/ POSTFX\n\nfloat Vignette( vec2 uv, float size )\n{\n    float d = length( (uv - 0.5f) * 2.0f ) \/ length(vec2(1.0));\n    \n    d \/= size;\n    \n    float s = d * d * ( 3.0f - 2.0f * d );\n    \n    float v = mix ( d, s, 0.6f );\n    \n    return max(0.0, 1.0f - v);\n}\n\nvec3 ApplyTonemap( vec3 linearCol )\n{\n\tconst float kExposure = 0.5;\n\t\n    float a = 0.010;\n    float b = 0.132;\n    float c = 0.010;\n    float d = 0.163;\n    float e = 0.101;\n\n    vec3 x = linearCol * kExposure;\n\n    return ( x * ( a * x + b ) ) \/ ( x * ( c * x + d ) + e );    \n}\n\nvec3 ApplyGamma( vec3 linearCol )\n{\n\tconst float kGamma = 2.2;\n\n\treturn pow( linearCol, vec3(1.0\/kGamma) );\t\n}\n\nvec3 ApplyPostFX( vec2 uv, vec3 col )\n{    \n    col *= 1.3;\n\n    col *= 0.1 + 0.9 * Vignette( uv, 1.0 );\n\n    col *= vec3(1.0, 0.95, 0.8); \/\/ warmer\n  \n    col = ApplyTonemap(col);\n\tcol = ApplyGamma(col);\n    \n\treturn col;\n}\n\t\n\n\n\/\/ Scene\n\nfloat speed = 1.0;\n\nfloat BubbleOriginForward( float t )\n{\n    t = t * 30.0;\n    if ( t > 0.0)\n    {\n        t = t \/ (1.0+t\/10.0f);\n\n    }\n    return t + iTime * speed;\n}\n\nfloat BubbleOriginInverse( float r )\n{\n    r = r- iTime * speed;\n    if( r > 0.0)\n    {\n        r = -10.0f * r \/ (r - 10.0f);\n    }\n    r = r \/ 30.0f;\n    return r;\n}\n\nfloat Scene_Distance(vec3 pos)\n{\n\n    vec3 vPos = pos;\n    vPos.x += 3.0;\n\n    float scale = 50.0;\n    \n    vPos \/= scale;\n\n    \/\/ wobble\n    vec3 offset = vec3(0);\n    offset += sin( pos.yzx * 8.91 + iTime * 10.0 ) * 0.001;\n    offset += sin( pos.zxy * 7.89 + iTime * 10.0 ) * 0.001;    \n    offset *= 0.08;\n    \n    float f = BubbleOriginForward( vPos.x );\n    \n    f = floor(f);\n    \n    float minD = 1000000.0;\n    \n    for (float b=-1.0; b<=2.0; b+=1.0)\n    {\n        float p = f + b;\n        vec3 o = vPos;\n        o.x = BubbleOriginInverse( p );\n                \n        o.x -= vPos.x;\n\n         float spreadBlend = 1.0 - clamp( vPos.x * 3.0 + 0.2, 0.0, 1.0);\n         \n         float spread = spreadBlend;\n         \n         spread *= 0.05;\n\n         o.y += sin(p * 123.3456) * spread;\n         o.z += sin(p * 234.5678) * spread;\n         \n         o += offset;\n           \n         float rad = sin( p * 456.8342 ) * 0.5 + 0.5;\n                             \n         float d = length(o) - 0.005f - rad * rad * 0.02f;\n         \n         minD = min( minD, d );\n    }\n    \n     return minD * scale;\n}\n\nvec3 Scene_GetNormal( vec3 pos )\n{\n    const float delta = 0.0001;\n    \n    vec4 samples;\n    for( int i=ZERO; i<=4; i++ )\n    {\n        vec4 offset = vec4(0);\n        offset[i] = delta;\n        samples[i] = Scene_Distance( pos + offset.xyz );\n    }\n    \n    vec3 normal = samples.xyz - samples.www;    \n    return normalize( normal );\n}    \n\nfloat Scene_Trace( vec3 rayOrigin, vec3 rayDir, float minDist, float maxDist, float side )\n{\n\tfloat t = minDist;\n\n    const int kRaymarchMaxIter = 128;\n\tfor(int i=0; i<kRaymarchMaxIter; i++)\n\t{\t\t\n        float epsilon = 0.0001 * t;\n\t\tfloat d = Scene_Distance( rayOrigin + rayDir * t ) * side;\n        if ( abs(d) < epsilon )\n\t\t{\n\t\t\tbreak;\n\t\t}\n                        \n        if ( t > maxDist )\n        {\n\t        t = maxDist + 1.0f;\n            break;\n        }       \n        \n        t += d;        \n\t}\n    \n    return t;\n}\n\nvec3 GetSkyColour( vec3 dir )\n{\n\tvec3 result = vec3(0.0);\n\t\n    vec3 envMap = texture(iChannel1, dir).rgb;\n    envMap = envMap * envMap;\n    float kEnvmapExposure = 0.99999;\n    result = -log2(1.0 - envMap * kEnvmapExposure);\n\n    return result;\t\n}\n\nfloat FilmThickness( vec3 pos )\n{\n    return Noise(pos * 0.3f, iTime * 0.5);\n}\n\nvoid Shade( inout vec3 colour, inout vec3 remaining, vec3 pos, vec3 rayDir, vec3 normal )\n{\n    float NdotV = max( dot(normal, -rayDir), 0.0 );\n\n    float filmThickness = FilmThickness(pos);\n\n    vec3 reflection = GetSkyColour( reflect( rayDir, normal ) );\n    \n#if 1\n    \/\/ Extra highlight\n    vec3 LightColour = vec3(1,.9,.7) * 0.8;\n    vec3 L = normalize(vec3(1.0, 2.0, 0.0));\n    float NdotL = max( dot( normal, L ), 0.0 );\n    float NdotH = max( dot( normal, normalize(L-rayDir) ), 0.0 );\n    reflection += (pow(NdotH,10000.0) * 10000.0) * NdotL * LightColour;\n    \/\/vReflection += (pow(NdotH,1000.0) * 2000.0) * NdotL * LightColour;\n    reflection += (pow(NdotH,100.0) * 200.0) * NdotL * LightColour;\n    reflection += (pow(NdotH,10.0) * 20.0) * NdotL * LightColour;\n#endif     \n     \n    float ni = N_Air;\n    float nt = N_Water;     \n    \n    float cosi = NdotV;\n    float cost = GetCosT( ni, nt, cosi );\n    float fresnelA = Fresnel( ni, nt, cosi, cost );\n    float fresnelB = Fresnel( nt, ni, cost, cosi );\n\n    float fresnelFactor = 1.0f - (1.0f - fresnelA) * (1.0f - fresnelB);\n    \n    vec3 fresnel = vec3(fresnelFactor);\n\n    vec3 thinFilmColour;\n#if USE_THIN_FILM_LOOKUP\n    thinFilmColour = texture(iChannel0, vec2(NdotV, filmThickness) ).rgb;\n#else\n    thinFilmColour = GetThinFilmColour(NdotV, filmThickness);\n#endif\n    fresnel *= thinFilmColour;\n    \n    colour += reflection * fresnel * remaining;\n    remaining *= (1.0f - fresnel);\n\n\n#if 0\n    float fGlassThickness = 0.5;\n    vec3 vGlassColor = vec3(1,0.5, 0.25);\n\n\tfloat fOpticalDepth = fGlassThickness \/ NdotV;\n    vec3 vExtinction = exp2( -fOpticalDepth * (1.0 - vGlassColor) ); \n    remaining *= vExtinction;\n#endif    \n}\n\n\nvec3 GetSceneColour( vec3 rayOrigin, vec3 rayDir )\n{    \n    float kFarClip = 200.0;\n\n\tvec3 colour = vec3(0);\n    vec3 remaining = vec3(1);\n    \n    float side = 1.0;\n    \n    float minDist = 0.0;\n    \n    for( int i=0; i<10; i++ )\n    {\n        float t = Scene_Trace( rayOrigin, rayDir, minDist, kFarClip, side );\n        \n        if ( t>=kFarClip )\n        {\n            break;\n        }\n        \n        minDist = t + 0.1f;\n        \n        vec3 hitPos = rayOrigin + rayDir * t;\n\n        vec3 normal = Scene_GetNormal( hitPos );\n\n        Shade(colour, remaining, hitPos, rayDir, normal * side );\n        \n        side = side * -1.0f;\n    }\n    \n \/\/   colour += GetSkyColour(rayDir) * remaining; \n\t\n\treturn colour;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{        \n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n\n    float heading = 0.3f + sin(iTime * 0.3) * 0.1;\n\n    float elevation = 1.8 + sin(iTime * 0.134) * 0.1;\n    \n    float fov = 2.5 + sin( iTime * 0.234) * 0.5;\n    \n    float cameraDist = 10.0;\n\tvec3 cameraPos = vec3(sin(heading) * sin(-elevation), cos(-elevation), cos(heading) * sin(-elevation)) * cameraDist;\n\tvec3 cameraTarget = vec3(sin(iTime * 0.1542) * 3.0, 0.0, 0.0);\n\n\tvec3 rayOrigin = cameraPos;\n\tvec3 rayDir = GetCameraRayDir( GetWindowCoord(uv), cameraPos, cameraTarget, fov );\n\t\n\tvec3 sceneCol = GetSceneColour( rayOrigin, rayDir );\n\t\n\tvec3 final = ApplyPostFX( uv, sceneCol );\n\t\n\tfragColor = vec4(final, 1.0);\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":258,"src":"\/media\/previz\/buffer01.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":258,"src":"\/media\/previz\/buffer01.png","ctype":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":259,"src":"\/media\/previz\/buffer02.png","ctype":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":260,"src":"\/media\/previz\/buffer03.png","ctype":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":259,"channel":0}],"code":"                                                                                                                                                                                                                                                                                        \/\/ See Image tab for details, also visit:\n\/\/\n\/\/ https:\/\/xemantic.github.io\/shader-web-background\/\n\/\/\n\/\/ In the original shader-web-background these values are provided as uniforms\n\/\/ feel free to play with them and if you will find something prettier than\n\/\/ the equilibrium I established, please send it back to me :)\nconst vec2  iFeedbackZoomCenter       = vec2(0., 0.);\nconst float iFeedbackZoomRate         = .001;\nconst float iFeedbackFadeRate         = .999;\n\/\/const float iFeedbackColorShiftZoom   = .05;\nconst float iFeedbackColorShiftImpact = 0.0015;\nconst vec2  iDrawCenter               = vec2(0., 0.);\nconst float iDrawIntensity            = 2.5;\nconst float iBlobEdgeSmoothing        = .02;\nconst float iBlob1Radius              = .65;\nconst float iBlob1PowFactor           = 20.;\n\/\/const float iBlob1ColorPulseSpeed     = .042;\nconst float iBlob2Radius              = .7;\nconst float iBlob2PowFactor           = 20.;\n\/\/const float iBlob2ColorPulseSpeed     = .0234;\nconst float iBlob2ColorPulseShift     = 0.0;\nconst float iColorShiftOfRadius       =  0.05;\nconst float iFeedbackMouseShiftFactor = .003;\n\n\/*\n  Normally it would be provided by texture parameters, but on Mac\/iOS the texture REPEAT\n  seems to work only for power-of-2 texture sizes.\n *\/\nvec4 repeatedTexture(in sampler2D channel, in vec2 uv) {\n    return texture(channel, mod(uv, 1.));\n}\n\nfloat drawBlob(\n    in vec2 st,\n    in vec2 center,\n    in float radius,\n    in float edgeSmoothing\n) {\n    float dist = length((st - center) \/ radius);\n    return dist * smoothstep(1., 1. - iBlobEdgeSmoothing, dist);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \/\/ in shader-web-background provided as uniforms: start\n    float iMinDimension = min(iResolution.x, iResolution.y);\n    vec2 iScreenRatioHalf =\n        (iResolution.x >= iResolution.y)\n            ? vec2(iResolution.y \/ iResolution.x * .5, .5)\n            : vec2(.5, iResolution.x \/ iResolution.y);\n    vec3 iBlob1Color = spectral_zucconi6(\n        mod(iTime * (iBlob1ColorPulseSpeed \/ -1.5), 1.)\n    );\n    \n    vec3 iBlob2Color = spectral_zucconi6(\n        mod(iTime * (iBlob2ColorPulseSpeed \/ -1.5) + iBlob2ColorPulseShift, 1.)\n    );\n    vec2 iFeedbackShiftVector =\n        (iMouse.x > 0. && iMouse.y > 0.)\n            ? (iMouse.xy * 2. - iResolution.xy) \/ iMinDimension * iFeedbackMouseShiftFactor\n            : vec2(0);\n    \/\/ in shader-web-background provided as uniforms: end\n            \n    \n    vec2 uv = fragCoord \/ iResolution.xy;\n    vec2 st = (fragCoord * 2. - iResolution.xy) \/ iMinDimension;\n\n    vec2  drawDelta = st - iDrawCenter;\n    float drawAngle = atan(drawDelta.x, drawDelta.y);\n    float drawDist = length(drawDelta);\n\nvec3 feedbk = repeatedTexture(iChannel1, uv - st).rgb;\n    vec3 colorShift = repeatedTexture(\n        iChannel0,\n        uv - st * iFeedbackColorShiftZoom * iScreenRatioHalf\n    ).rgb;\n\n    vec2 stShift = vec2(0);\n    stShift += iFeedbackZoomRate * (st - iFeedbackZoomCenter);\n    stShift += (feedbk.bg\/colorShift.gr - .5) * iFeedbackColorShiftImpact;\n    stShift += iFeedbackShiftVector;\n    stShift *= iScreenRatioHalf;\n\n    vec3 prevColor = repeatedTexture(iChannel2, uv - stShift).rgb;\n    prevColor *= iFeedbackFadeRate;\n    \n    vec3 prevColor2 = repeatedTexture(iChannel3, uv - stShift).rgb;\n    prevColor2 *= iFeedbackFadeRate;\n    \n \/\/   prevColor = mix(prevColor, prevColor2, 0.0995);\n    prevColor = min(prevColor, prevColor2);\n\n    vec3 drawColor = vec3(0);\n   \n\n    float radius =\n        1.\n        + (colorShift.r + colorShift.g + colorShift.b) * iColorShiftOfRadius;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob1Radius, iBlobEdgeSmoothing),\n          iBlob1PowFactor\n        ) * iBlob1Color;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob2Radius, iBlobEdgeSmoothing),\n          iBlob2PowFactor\n        ) * iBlob2Color;\n\n    vec3 color = vec3(0);\n    drawColor *= iDrawIntensity;\n    prevColor *= iFeedbackFadeRate;\n    color += prevColor;\n    color += drawColor;\n\n    color = clamp(color, 0., 1.);\n    fragColor = vec4(color, 1.);\n}\n","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":258,"src":"\/media\/previz\/buffer01.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":258,"src":"\/media\/previz\/buffer01.png","ctype":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":260,"src":"\/media\/previz\/buffer03.png","ctype":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":260,"src":"\/media\/previz\/buffer03.png","ctype":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":260,"channel":0}],"code":"\/\/ This buffer is the feedback loop\n\n\/\/ iq noise\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*157.0;\n\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n               mix( hash(n+157.0), hash(n+158.0),f.x),f.y);\n}\n\n\/\/ hue by netgrind(?)\n\nvec3 hue(vec3 color, float shift) {\n\n    const vec3  kRGBToYPrime = vec3 (0.299, 0.587, 0.114);\n    const vec3  kRGBToI     = vec3 (0.596, -0.275, -0.321);\n    const vec3  kRGBToQ     = vec3 (0.212, -0.523, 0.311);\n\n    const vec3  kYIQToR   = vec3 (1.0, 0.956, 0.621);\n    const vec3  kYIQToG   = vec3 (1.0, -0.272, -0.647);\n    const vec3  kYIQToB   = vec3 (1.0, -1.107, 1.704);\n\n    \/\/ Convert to YIQ\n    float   YPrime  = dot (color, kRGBToYPrime);\n    float   I      = dot (color, kRGBToI);\n    float   Q      = dot (color, kRGBToQ);\n\n    \/\/ Calculate the hue and chroma\n    float   hue     = atan (Q, I);\n    float   chroma  = sqrt (I * I + Q * Q);\n\n    \/\/ Make the user's adjustments\n    hue += shift;\n\n    \/\/ Convert back to YIQ\n    Q = chroma * sin (hue);\n    I = chroma * cos (hue);\n\n    \/\/ Convert back to RGB\n    vec3    yIQ   = vec3 (YPrime, I, Q);\n    color.r = dot (yIQ, kYIQToR);\n    color.g = dot (yIQ, kYIQToG);\n    color.b = dot (yIQ, kYIQToB);\n\n    return color;\n}\n\nfloat fractalNoise(vec2 pos) {\n\tfloat n = 0.;\n\tfloat scale = 1. \/ 1.5;\n\tfor (int i = 0; i < 5; i += 1) {\n\t\tn += noise(pos) * scale;\n\t\tscale *= 0.5;\n\t\tpos *= 2.;\n\t}\n\treturn n;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = fragCoord.xy \/ iResolution.xy;\n    \n    \/\/ Convert the uv's to polar coordinates to scale up  \n    vec2 polarUv = (uv * 2.0 - 1.0);\n    float angle = atan(polarUv.y, polarUv.x);\n    \n    \/\/ Scale up the length of the vector by a noise function feeded by the angle and length of the vector\n    float ll = length(polarUv)*0.5 - fractalNoise(vec2(sin(angle*4. + iTime*2.) + length(uv)*10., length(uv)*20. + sin(angle*4.)))*0.005 ;\n    \n    vec3 base = texture(iChannel0, uv).rgb;\n    \n    \/\/ Convert the scaled coordinates back to cartesian\n    vec2 offs = vec2(cos(angle)*ll + 0.5, sin(angle)*ll + 0.5);\n    \n    \/\/ sample the last texture with uv's slightly scaled up\n    vec3 overlay = texture(iChannel1, offs.xy).rgb;\n    \n    \/\/ Since the colors of the iChannel0 are monochrome, set a color channel to zero to do a hue shift\n \/\/   base.b = 0.0;\n    \n    \/\/ Apply a hue shift to the overlaid image so it cascades in the feedback loop\n    overlay = hue(overlay, .5);\n      overlay += (base + base) * (overlay \/ .50);\n    \n    \/\/ Additively blend the colors together\n    vec4 col = vec4(clamp(vec3(0.),vec3(1.),base + overlay*0.99), 1.0);\n    \n   \/\/ col *= (col + col) * (overlay,1.0);\n    \/\/(overlay,1.0);\n    \n    fragColor = col ;\n}","name":"Buffer D","description":"","type":"buffer"}]}}