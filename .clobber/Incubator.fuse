--- Special purpose Fuse to support shader kernel development.
--
-- Based on the work of Chris Ridings (www.chrisridings.com), Bryan Ray (http://www.bryanray.name/wordpress/opencl-fuses-index/),
-- JiPi (https://youtu.be/dbrPWRldmbs), Igor Riđanović (https://youtu.be/p6IeeWr3FOc), and many others.
--

-- Reload Parameter from ConversionSourcecode and Change Name, Min-,Max-,Defaultvalues - unused Parameter will be unvisible
-- 5 Checkboxen und 3 Pointparameter hinzugefügt

PathToRepository = ""

-- ----------------------------------------------------------------------------------------------------------------------------------------

ShaderKernels = nil


function ShaderKernels_resetData()
  ShaderKernels = {
    Current       = 0,
    Main          = 5,
    Quantity      = 0,
    RenderErrors  = false,
    MaxEntries    = 0,
    Entries       = {
      [0] = { ComboName  = "<none>",    InputName  = "",         InfoName = "",        KernelName=nil, Channel = {nil}, },
            { ComboName  = "Buffer A",  InputName  = "Buffer A", InfoName = "A",       KernelName="",  Channel = {nil}, },
            { ComboName  = "Buffer B",  InputName  = "Buffer B", InfoName = "B",       KernelName="",  Channel = {nil}, },
            { ComboName  = "Buffer C",  InputName  = "Buffer C", InfoName = "C",       KernelName="",  Channel = {nil}, },
            { ComboName  = "Buffer D",  InputName  = "Buffer D", InfoName = "D",       KernelName="",  Channel = {nil}, },
            { ComboName  = "Image",     InputName  = "Image",    InfoName = "IMAGE",   KernelName="",  Channel = {nil}, },
            { ComboName  = "=final=",   InputName  = "",         InfoName = "FINAL",   KernelName="FINAL",  Channel = {nil}, },
    },
  }
end


function ShaderKernels_getLabelText()

  local htm = {}

  for i,e in pairs(ShaderKernels.Entries) do
    if e.KernelName ~= nil then
      if e.KernelName ~= "" then
        -- has kernel
        if i == ShaderKernels.Current then
          -- is currently selected kernel
          if not ShaderKernels.RenderErrors then
            -- did successfully render
            table.insert(htm,'<font style="color:#00ff00; ">&nbsp;'.. e.InfoName ..'&nbsp;</font>')
          else
            -- had errors
            table.insert(htm,'<font style="color:#ff0000; ">&nbsp;'.. e.InfoName ..'&nbsp;</font>')
          end
        else
          -- is currently not selected
          table.insert(htm,'<font style="color:#ffffff; ">&nbsp;'.. e.InfoName ..'&nbsp;</font>')
        end
      else
        -- has no kernel
        if i == ShaderKernels.Current then
          -- is currently selected
          table.insert(htm,'<font style="color:#909090; background-color:#900000; ">&nbsp;'.. e.InfoName ..'&nbsp;</font>')
        else
          -- is currently not selected
          table.insert(htm,'<font style="color:#404040; ">&nbsp;'.. e.InfoName ..'&nbsp;</font>')
        end
      end
    end
  end

  return '<center>'..table.concat(htm,'&nbsp;')..'</center>'

end



ShaderParameters        = nil
ShaderParameters_struct = ""
ShaderParameters_init   = ""
CompatibilityCode       = ""
KernelInputCtrlDefines  = nil
ConversionShaderID      = ""
ConversionFusename      = ""
ConversionSourcecode    = ""
PathToUse               = "Root"

NUM_INPUT_CHANNELS      = 5

NUM_COLOR_CONTROLS      = 10
NUM_SLIDER_CONTROLS     = 10
NUM_INTSLIDER_CONTROLS  = 10
NUM_SCREW_CONTROLS      = 5
NUM_BUTTON_CONTROLS     = 5
NUM_CHECKBOX_CONTROLS   = 10
NUM_POINT_CONTROLS      = 10





-- ----------------------------------------------------------------------------------------------------------------------------------------

FuRegisterClass("ShadertoysIncubator", CT_SourceTool, {
    REGS_Name              = "ShadersInc",
	  REGS_Category          = "Fuses",
    REGS_OpDescription     = "An Incubator for Shadertoys",
	  REGS_OpIconString      = "incubus",
    REG_Source_GlobalCtrls = true, 
    REG_Source_SizeCtrls   = true,
    REG_Source_AspectCtrls = true,
    REG_Source_DepthCtrls  = true,
  --REG_OpNoMask           = true,
	  REG_TimeVariant        = true,
    REG_NoPreCalcProcess   = true,  -- call Process for precalc requests (instead of PreCalcProcess)
	  REGS_Company           = "nmbr73",
	  REGS_URL               = "https://nmbr73.github.io/",
	  REG_Version	           = 000001,

    REG_Fuse_NoEdit = false, REG_Fuse_NoReload = false,

    })



-------------------------------------------------------------------------------------------------------------------------------------------
-- Print verbose message.
--
-- Use verbose() to print any non-error message just meant to help developing the Incubator.fuse itself.
--
-- @param[type=string] msg The message to output in DaFusions console window.
--
function verbose(msg)
   --print(msg)
end

function verbose_MB(msg,...)
   --print(msg,...)
end   


-------------------------------------------------------------------------------------------------------------------------------------------
-- Local structure to manage vaialable source code.
--
-- This table is initialized by Conversions_resetData() with filenames, IDs, etc. of the sources found in the
-- repositorie's *'Conversions/'* folder. It is used to proviede these sources i.e. in a ComboBox for
-- selection.
--
-- @table Conversions
-- @field Name Fusename of the conversion.
-- @field Path Full path of the folder the conversion can be found in.
-- @field Filename Full filename (indcluding the ID and '.c' suffix).
-- @field ShadertoyID The ID of the Shadertoy the code originally came from.
-- @field Label Name in human readable form identifying the converson to show in messages, the ComboBox, etc. .
--
Conversions={}



-------------------------------------------------------------------------------------------------------------------------------------------
-- Create a table to initializie in particular `Conversions` with.
--
-- @param[type=string] path Path to where the conversions reside.
-- @return[type=table] conversion information; `{}` if no conversions found
--
function Conversions_resetData(path)

  Conversions={}

  local files={}

  local handle	= bmd.readdir(path.."*.*.c")

  for k, v in pairs(handle) do
    -- print(k.." "..v.Name)

    if v.Name and not(v.IsDir) then

      files[k] = v.Name

    end
  end

  table.sort(files) -- grrr, it's case sensitive :-(


  local entries={}

  for k, filename in pairs(files) do
    local fusename, shadertoyid = filename:match('^(.+)%.([^%.]+)%.c$')

    entries[k]={
      Name=fusename,
      Path=path,
      Filename=filename,
      ShadertoyID=shadertoyid,
      Label=fusename.." ("..shadertoyid..")",
    }
  end

  Conversions=entries
end


-------------------------------------------------------------------------------------------------------------------------------------------
function CompatibilityCode_loadFile()

  CompatibilityCode = ""

  f = io.open(PathToRepository..'.clobber/CompatibilityCode.c', "r")
  if not f then
    print("failed to read compatibility code")
  else
    CompatibilityCode = f:read("*all")
    f:close()

    if CompatibilityCode=="" then
      print("no compatibility code?!?")
    end
  end
end


-------------------------------------------------------------------------------------------------------------------------------------------
-- Callback to initialize the tool.
--
function Create()

  local REPOSITORYPATH=[[D:\Zumsel\Dokumente\Github\Fetch-n-Fuse\]]

  PathToRepository=REPOSITORYPATH

  verbose("Create: repository used is "..REPOSITORYPATH)


  -- create defined to connect input contols to kernel

  KernelInputCtrlDefines =""

  for i=0,NUM_COLOR_CONTROLS-1 do
    KernelInputCtrlDefines=KernelInputCtrlDefines.."#define CONNECT_COLOR"..i.."(NAME,DEFAULT_R,DEFAULT_G,DEFAULT_B,DEFAULT_A) "..
      "float4 NAME = to_float4( "..
      "_shaderParameters->ctrlColor["..i.."][0],"..
      "_shaderParameters->ctrlColor["..i.."][1],"..
      "_shaderParameters->ctrlColor["..i.."][2],"..
      "_shaderParameters->ctrlColor["..i.."][3]"..
      ")\n"
  end

  for i=0,NUM_SLIDER_CONTROLS-1 do
    KernelInputCtrlDefines=KernelInputCtrlDefines.."#define CONNECT_SLIDER"..i.."(NAME,SMIN,SMAX,SDEFAULT) float NAME = _shaderParameters->ctrlSlider["..i.."]; if (NAME<SMIN) NAME=(SMIN); if (NAME>SMAX) NAME=(SMAX) \n"
  end


  for i=0,NUM_INTSLIDER_CONTROLS-1 do
    KernelInputCtrlDefines=KernelInputCtrlDefines.."#define CONNECT_INTSLIDER"..i.."(NAME,SMIN,SMAX,SDEFAULT) "..
    "const int NAME = ( "..
    "_shaderParameters->ctrlIntSlider["..i.."] < SMIN ? SMIN : ("..
    "_shaderParameters->ctrlIntSlider["..i.."] > SMAX ? SMAX : _shaderParameters->ctrlIntSlider["..i.."]) )\n"
  end


  for i=0,NUM_SCREW_CONTROLS-1 do
    KernelInputCtrlDefines=KernelInputCtrlDefines.."#define CONNECT_SCREW"..i.."(NAME,SMIN,SMAX,SDEFAULT) float NAME = _shaderParameters->ctrlScrew["..i.."]; if (NAME<SMIN) NAME=(SMIN); if (NAME>SMAX) NAME=(SMAX) \n"
  end


  for i=0,NUM_BUTTON_CONTROLS-1 do
    --KernelInputCtrlDefines=KernelInputCtrlDefines.."#define CONNECT_BUTTON"..i.."(NAME,TYP,BTN1,BTN2,BTN3,BTN4,BTN5) float NAME = _shaderParameters->ctrlButton["..i.."]; \n"
    KernelInputCtrlDefines=KernelInputCtrlDefines.."#if defined(DEVICE_IS_OPENCL) \n#define CONNECT_BUTTON"..i.."(NAME,TYP,BTN1,BTN2,BTN3,BTN4,BTN5) float NAME = _shaderParameters->ctrlButton["..i.."]; \n#else\n #define CONNECT_BUTTON"..i.."(NAME,TYP, ...) float NAME = _shaderParameters->ctrlButton["..i.."]; \n#endif\n"
  end


  for i=0,NUM_CHECKBOX_CONTROLS-1 do
    KernelInputCtrlDefines=KernelInputCtrlDefines.."#define CONNECT_CHECKBOX"..i.."(NAME,SDEFAULT) float NAME = _shaderParameters->ctrlCheckbox["..i.."] \n"
  end


--NUM_POINT_CONTROLS
  for i=0,NUM_POINT_CONTROLS-1 do
    KernelInputCtrlDefines=KernelInputCtrlDefines.."#define CONNECT_POINT"..i.."(NAME,SDEFAULTX,SDEFAULTY) float2 NAME = to_float2(_shaderParameters->ctrlPoint["..i.."][0],_shaderParameters->ctrlPoint["..i.."][1]) \n"
  end




   verbose("use the folling defines to connect your controls:\n"..KernelInputCtrlDefines)

  -- create fallback kernel code

  local channels=""
  for i=0,NUM_INPUT_CHANNELS-1 do
    channels=channels.."__TEXTURE2D__ iChannel"..i..", "
  end



  -- get the list of conversions and read compatibility and params code


  local next_ctrl_group = 1   -- increment every time you used it for a new control group
  local control_page    = nil -- you may want to put a -1 here later to have some main ctrls on the top

  -- Choose the Path
  InPathToUseCombo = self:AddInput("Path", "PathConversion", {
    IC_ControlPage      = control_page ,
    LINKID_DataType     = "Number",
    INPID_InputControl  = "ComboIDControl",
	  --INP_DoNotifyChanged = true,
    INP_Default         = 0,
    INP_Integer         = true,
    {CCS_AddString       = "Root",},
    {CCS_AddString       = "nmbr73",},
    {CCS_AddString       = "JiPi",},
    {CCS_AddString       = "ToDo",},
    {CCS_AddString       = "Defect",},
    {CCS_AddString       = "CheckMetal",},
    {CCS_AddString       = "CheckCuda",},
    {CCS_AddString       = "Archive",},
    })

  InInfoReload = self:AddInput( "------ Path has changed ! ------\n------      Push Reload      ------","InfoReload", {
      LINKID_DataType    = "Text",
      INPID_InputControl = "LabelControl",
      LBLC_MultiLine     = true,
      LBLC_LabelColor    = 2,
      IC_NoReset         = false,
      INP_External       = false,
      INP_Passive        = true,
      --IC_NoLabel       = true,
      ICD_Width          = 1.0,
      IC_Visible         = false,
  })

  
  pathToConversions = REPOSITORYPATH..'Conversions/'


  PathToUse = readAll()
  
  print("PathToUse - Create",PathToUse) --pathToConversions..InPathToUseCombo:GetSource(0).Value..'/')

  
  if (PathToUse ~= "Root") then
      print("Create - NeuerPath: ",pathToConversions..PathToUse..'/')
      pathToConversions = pathToConversions..PathToUse..'/'
  end

  Conversions_resetData(pathToConversions)

  CompatibilityCode_loadFile()

  ShaderParameters=[[

  float iResolution[2];
  float iTime;
  float iMouse[4];
  float iTimeDelta;
  int   iFrame;
  float iChannelTime[]]..NUM_INPUT_CHANNELS..[[];
  float iChannelResolution[]]..NUM_INPUT_CHANNELS..[[][2];
  float iDate[4];
  float iSampleRate;
  int width, height; // you should prefer to use iResolution instead
  int compOrder;


  // do not use the following elements directly
  // they will definitely not exists in the final fuse!

  float ctrlColor[]]..     NUM_COLOR_CONTROLS    ..[[][4];
  float ctrlPoint[]]..     NUM_POINT_CONTROLS    ..[[][2];
  float ctrlSlider[]]..    NUM_SLIDER_CONTROLS   ..[[];
  int   ctrlIntSlider[]].. NUM_INTSLIDER_CONTROLS..[[];
  float ctrlScrew[]]..     NUM_SCREW_CONTROLS    ..[[];
  float ctrlButton[]]..    NUM_BUTTON_CONTROLS   ..[[];
  bool  ctrlCheckbox[]]..  NUM_CHECKBOX_CONTROLS ..[[];

  ]]




  -- combo box with all the conversions + a reload button

  local attrs, attrs2

  attrs={}

  for k,v in pairs(Conversions) do
    verbose("Create: conversion '"..v.Label.."'")
    table.insert(attrs,{ CCS_AddString = v.Label })
  end

  InFileToUseCombo = self:AddInput("Code", "conversion", {
    IC_ControlPage = control_page ,
    LINKID_DataType = "Number",
    INPID_InputControl = "ComboControl",
	  INP_DoNotifyChanged = true,
    INP_Default = 0,
    INP_Integer = true,
    attrs
    })


  ShaderKernels_resetData()

  attrs2={}

  for i,e in pairs(ShaderKernels.Entries) do
    table.insert(attrs2,{ CCS_AddString = e.ComboName })
  end

  ShaderKernels_ComboControl = self:AddInput("Kernel", "kernel", {
    IC_ControlPage = control_page ,
      LINKID_DataType = "Number",
      INPID_InputControl = "ComboControl",
      INP_DoNotifyChanged = true,
      INP_Default = 0,
      INP_Integer = true,
      attrs2
  })

  ShaderKernels_LabelControl = self:AddInput(
    ShaderKernels_getLabelText(),
    "kernelInfo", {
    IC_ControlPage = control_page ,
    LINKID_DataType = "Text",
    INPID_InputControl = "LabelControl",
    INP_External = false,
    INP_Passive = true,
    INP_DoNotifyChanged = false,
    INP_Disabled=false,
  })

  InShadertoyButton=self:AddInput("Show on shadertoy.com", "openShaderInBrowser", {
    IC_ControlPage = control_page ,
    LINKID_DataType = "Text",
    ICD_Width =0.5,
    INPID_InputControl = "ButtonControl",
    INP_DoNotifyChanged = false,
    INP_External = false,
    BTNCS_Execute = 'print("does nothing")',
    INP_Disabled=true,
  })

  InReloadCodeButton= self:AddInput("Reload Code", "reloadConversion", {
    IC_ControlPage = control_page ,
    LINKID_DataType = "Text",
    ICD_Width =0.5,
    INPID_InputControl = "ButtonControl",
    INP_DoNotifyChanged = true,
    INP_External = false,
  })

  InReloadParameterNames= self:AddInput("Reload Parameter Names", "ReloadParameterNames", {
    IC_ControlPage      = control_page ,
    LINKID_DataType     = "Text",
    ICD_Width           = 1.0,
    INPID_InputControl  = "ButtonControl",
    INP_DoNotifyChanged = true,
    INP_External        = false,
  })

  InFrequency = self:AddInput("Speedup", "speed", {
    LINKID_DataType    = "Number",
    INPID_InputControl = "SliderControl",
    INP_Default        = 1.0,
    INP_MinScale 	     = 0.0,
    INP_MaxScale 	     = 5.0,
    SLCS_LowName       = "stop",
    SLCS_HighName      = "5x",
  })


  -- some general controls for data passed to the kernel

  self:BeginControlNest("Common Shader Inputs", "shaderInputs", true, {})

		InShaderInputs_iResolution = self:AddInput("iResolution", "iResolution", {
			LINKID_DataType = "Text",
			INPID_InputControl = "TextEditControl",
			INP_External = false,
			IC_NoLabel = false,
			ICD_Width = 1.0,
			INPS_DefaultText = "-",
			TEC_Lines = 1,
			TEC_Wrap = false,
			TEC_ReadOnly = true,
			TEC_CharLimit = 0,
			TEC_DeferSetInputs = false,

			INP_DoNotifyChanged  = false,
      INP_Disabled = true,
      INP_Passive = true,
		})

		InShaderInputs_iTime = self:AddInput("iTime", "iTime", {
			LINKID_DataType = "Text",
			INPID_InputControl = "TextEditControl",
			INP_External = false,
			IC_NoLabel = false,
			ICD_Width = 1.0,
			INPS_DefaultText = "-",
			TEC_Lines = 1,
			TEC_Wrap = false,
			TEC_ReadOnly = true,
			TEC_CharLimit = 0,
			TEC_DeferSetInputs = false,

			INP_DoNotifyChanged  = false,
      INP_Disabled = true,
      INP_Passive = true,
		})

		InShaderInputs_iMouse = self:AddInput("iMouse", "iMouse", {
			LINKID_DataType = "Text",
			INPID_InputControl = "TextEditControl",
			INP_External = false,
			IC_NoLabel = false,
			ICD_Width = 1.0,
			INPS_DefaultText = "-",
			TEC_Lines = 1,
			TEC_Wrap = false,
			TEC_ReadOnly = true,
			TEC_CharLimit = 0,
			TEC_DeferSetInputs = false,

			INP_DoNotifyChanged  = false,
      INP_Disabled = true,
      INP_Passive = true,
		})



    InMouseXY = self:AddInput("iMouse.xy", "iMouseXY", {
      LINKID_DataType = "Point",
      INPID_InputControl = "OffsetControl",
      INPID_PreviewControl = "CrosshairControl",
    })

    InMouseZW = self:AddInput("iMouse.zw", "iMouseZW", {
      LINKID_DataType = "Point",
      INPID_InputControl = "OffsetControl",
      INPID_PreviewControl = "CrosshairControl",

      INP_DoNotifyChanged  = false,
      INP_Disabled = true,
      INP_Passive = true,
    })

    InMouseDrag = self:AddInput("Mouse Button Pressed", "click", {
      LINKID_DataType = "Number",
      INPID_InputControl = "CheckboxControl",
      INP_Default = 0,
      INP_MinScale = 0,
      INP_MaxScale = 1,
      IC_Visible = true,
    })



  self:EndControlNest()


  self:BeginControlNest("Fuse specific Controls", "Controls", true, {})
  -- some color controls to play with colors in the kernel


    InColor = {}
    InColorName = {}

    local rgba = {'Red','Green','Blue','Alpha'}

    for i=0,NUM_COLOR_CONTROLS-1 do
      InColorName[i] = self:AddInput("color_"..i, "ColorName"..i , {LINKID_DataType    = "Text", INPID_InputControl = "LabelControl", INP_External = false, INP_Passive = true, IC_Visible = true, IC_NoLabel = true, })

      InColor[i] = {}
      for j=0,3 do
        InColor[i][j]=self:AddInput(rgba[j+1], string.lower(string.sub(rgba[j+1],1,1))..i , { ICS_Name = "Color "..i, IC_ControlGroup = next_ctrl_group+i+1, IC_ControlID = j, INP_Default  = 0.5, LINKID_DataType = "Number", INPID_InputControl = "ColorControl", INP_MinScale = 0.0, INP_MaxScale = 1.0, })
      end
    end

    next_ctrl_group = next_ctrl_group + NUM_COLOR_CONTROLS + 1


  InSlider={}

  for i=0,NUM_SLIDER_CONTROLS-1 do
    InSlider[i] = self:AddInput("Slider "..i, "CONNECT_SLIDER"..i, {
      LINKID_DataType    = "Number",
      INPID_InputControl = "SliderControl",
      INP_MinScale 	     = -1.0,
      INP_MaxScale 	     = 1.0,
      INP_Default        = 0.0,
    })
  end


  InIntSlider={}

  for i=0,NUM_INTSLIDER_CONTROLS-1 do
    InIntSlider[i] = self:AddInput("Int Slider "..i, "CONNECT_INTSLIDER"..i, {
      LINKID_DataType    = "Number",
      INPID_InputControl = "SliderControl",
      INP_MinScale 	     = -10,
      INP_MaxScale 	     = 10,
      INP_Default        = 0,
      INP_Integer = true,
    })
  end


  InScrew={}

  for i=0,NUM_SCREW_CONTROLS-1 do
    InScrew[i] = self:AddInput("Screw "..i, "CONNECT_SCREW"..i, {
      LINKID_DataType    = "Number",
      INPID_InputControl = "ScrewControl",
      INP_MinScale 	     = -10,
      INP_MaxScale 	     = 10,
      INP_Default        = 0,
    })
  end


  InButton={}

  for i=0,NUM_BUTTON_CONTROLS-1 do
	InButton[i] = self:AddInput("Button "..i, "CONNECT_BUTTON"..i, {
		LINKID_DataType    = "Number",
		INPID_InputControl = "MultiButtonControl",
		MBTNC_ForceButtons = true,
    --MBTNC_Type         = "Toggle", -- oder weglassen :-)
		MBTNC_ShowName     = false,
		{ MBTNC_AddButton  = "Nothing" },
		MBTNC_StretchToFit = true,
    IC_NoLabel         = true,
		INP_Default        = 0,
    IC_Visible         = true,
	})
  end


  InCheckbox={}

  for i=0,NUM_CHECKBOX_CONTROLS-1 do
    InCheckbox[i] = self:AddInput("Checkbox "..i, "Checkbox"..i, {
      LINKID_DataType     = "Number",
      INPID_InputControl  = "CheckboxControl",
      INP_Integer         = true,
      INP_Default         = 0,
    })
  end


  InPoint={}

  for i=0,NUM_POINT_CONTROLS-1 do
    InPoint[i] = self:AddInput("Point "..i,"CONNECT_POINT"..i, {
      LINKID_DataType       = "Point",
      INPID_InputControl    = "OffsetControl",
      INPID_PreviewControl  = "CrosshairControl",
      PC_Visible            = false,
      INP_DefaultX          = 0.5,
      INP_DefaultY          = 0.5,
    })
  end

  self:EndControlNest()


  -- controls for the tool itself, not passed to the kernel

  InRebuildCheckBox = self:AddInput("InRebuildCheckBox", "InRebuildCheckBox", {
    LINKID_DataType = "Number",
    INPID_InputControl = "CheckboxControl",
    INP_Default = 0,
    INP_MinScale = 0,
    INP_MaxScale = 1,
    IC_Visible = false,
  })


  InRebuildParameterNames = self:AddInput("RebuildParameterNames", "InRebuildParameterNames", {
    LINKID_DataType = "Number",
    INPID_InputControl = "CheckboxControl",
    INP_Default     = 0,
    INP_MinScale    = 0,
    INP_MaxScale    = 1,
    IC_Visible      = false,
  })

  -- InVerboseCheckBox = self:AddInput("VERBOSE", "VerboseCheckbox", {
  --   LINKID_DataType = "Number",
  --   INPID_InputControl = "CheckboxControl",
  --   INP_Default = 1,
  --   INP_MinScale = 0,
  --   INP_MaxScale = 1,
  --   IC_Visible = true,
  -- })

  InDebugImage = self:AddInput("DebugImage", "DebugImage", {
    LINKID_DataType = "Number",
    INPID_InputControl = "ComboControl",
    INP_Default = 0.0,
    INP_Integer = true,
    ICD_Width = 1,
    { CCS_AddString = "BufferA", },
    { CCS_AddString = "BufferB", },
    { CCS_AddString = "BufferC", },
    { CCS_AddString = "BufferD", },
    CC_LabelPosition = "Horizontal",
  })

-- Channels
 self:AddControlPage("Channels")

		InChannelBufferA = self:AddInput("Buffer A", "ChannelBufferA", {
			LINKID_DataType = "Text",
			INPID_InputControl = "TextEditControl",
			INP_DoNotifyChanged  = false,
			INP_External = false,
			--IC_NoLabel = true,
			ICD_Width = 1.0,
			INPS_DefaultText = "Channel0: not used\nChannel1: Buffer B\nChannel1: Abstract 3\nChannel1: Buffer A",
      TEC_Lines = 4,              -- height of text entry (default is 8)
			TEC_Wrap = false,            -- automatic word-wrapping (default is false)
			TEC_ReadOnly = true,        -- default is false (you should also set INP_External = false)
			TEC_CharLimit = 0,	         -- maximum number of allowed characters (default is 0, no limit)
			--TEC_DeferSetInputs = false,  -- call NotifyChanged when focus is lost (default is false, call on every key stroke)
      IC_Visible      = false,
			})
		

SepBufferA = self:AddInput("________________Buffer A__________________", "SepBufferA", {
    LINKID_DataType = "Text",
    INPID_InputControl = "LabelControl",
    IC_NoLabel = true,
    INP_External = false,
    INP_Passive = true,
  })
    
  InChBufferA={}
 
  
  for i=0,3 do  

    InChBufferA[i] = self:AddInput("Channel"..i, "ChBufferA"..i, {
			LINKID_DataType = "Text",
			INPID_InputControl = "TextEditControl",
			INP_External = false,
			--IC_NoLabel = true,
			ICD_Width = 1.0,
			INPS_DefaultText = "Buffer B",
      TEC_Lines = 1,              -- height of text entry (default is 8)
			TEC_ReadOnly = true,        -- default is false (you should also set INP_External = false)
			TEC_CharLimit = 0,	         -- maximum number of allowed characters (default is 0, no limit)
			})
  end
SepBufferB = self:AddInput("________________Buffer B__________________", "SepBufferB", {
    LINKID_DataType = "Text",
    INPID_InputControl = "LabelControl",
    IC_NoLabel = true,
    INP_External = false,
    INP_Passive = true,
  })
    
  InChBufferB={}
  for i=0,3 do
    InChBufferB[i] = self:AddInput("Channel"..i, "ChBufferB"..i, {
			LINKID_DataType = "Text",
			INPID_InputControl = "TextEditControl",
			INP_External = false,
			--IC_NoLabel = true,
			ICD_Width = 1.0,
			INPS_DefaultText = "not used",
      TEC_Lines = 1,              -- height of text entry (default is 8)
			TEC_ReadOnly = true,        -- default is false (you should also set INP_External = false)
			TEC_CharLimit = 0,	         -- maximum number of allowed characters (default is 0, no limit)
			})
  end
SepBufferC = self:AddInput("________________Buffer C__________________", "SepBufferC", {
    LINKID_DataType = "Text",
    INPID_InputControl = "LabelControl",
    IC_NoLabel = true,
    INP_External = false,
    INP_Passive = true,
  })
    
  InChBufferC={}
  for i=0,3 do
    InChBufferC[i] = self:AddInput("Channel"..i, "ChBufferC"..i, {
			LINKID_DataType = "Text",
			INPID_InputControl = "TextEditControl",
			INP_External = false,
			--IC_NoLabel = true,
			ICD_Width = 1.0,
			INPS_DefaultText = "Abstract 3",
      TEC_Lines = 1,              -- height of text entry (default is 8)
			TEC_ReadOnly = true,        -- default is false (you should also set INP_External = false)
			TEC_CharLimit = 0,	         -- maximum number of allowed characters (default is 0, no limit)
			})
  end
SepBufferD = self:AddInput("________________Buffer D__________________", "SepBufferD", {
    LINKID_DataType = "Text",
    INPID_InputControl = "LabelControl",
    IC_NoLabel = true,
    INP_External = false,
    INP_Passive = true,
  })
    
  InChBufferD={}
  for i=0,3 do
    InChBufferD[i] = self:AddInput("Channel"..i, "ChBufferD"..i, {
			LINKID_DataType = "Text",
			INPID_InputControl = "TextEditControl",
			INP_External = false,
			--IC_NoLabel = true,
			ICD_Width = 1.0,
			INPS_DefaultText = "Buffer A",
      TEC_Lines = 1,              -- height of text entry (default is 8)
			TEC_ReadOnly = true,        -- default is false (you should also set INP_External = false)
			TEC_CharLimit = 0,	         -- maximum number of allowed characters (default is 0, no limit)
			})
  end
SepImage = self:AddInput("________________Image__________________", "SepBufferImage", {
    LINKID_DataType = "Text",
    INPID_InputControl = "LabelControl",
    IC_NoLabel = true,
    INP_External = false,
    INP_Passive = true,
  })
    
  InChImage={}
  for i=0,3 do
    InChImage[i] = self:AddInput("Channel"..i, "ChImage"..i, {
			LINKID_DataType = "Text",
			INPID_InputControl = "TextEditControl",
			INP_External = false,
			--IC_NoLabel = true,
			ICD_Width = 1.0,
			INPS_DefaultText = "Buffer D",
      TEC_Lines = 1,              -- height of text entry (default is 8)
			TEC_ReadOnly = true,        -- default is false (you should also set INP_External = false)
			TEC_CharLimit = 0,	         -- maximum number of allowed characters (default is 0, no limit)
			})
  end









-- Fetch-n-Fuse
 self:AddControlPage("F-n-F")

  InSpawnError = self:AddInput("SpawnError", "InSpawnError", {
     LINKID_DataType = "Number",
     INPID_InputControl = "CheckboxControl",
     INP_Default  = 1,
     INP_MinScale = 0,
     INP_MaxScale = 1,
     IC_Visible = false,
   })

Sep1 = self:AddInput("________________FETCH__________________", "Separator1", {
    LINKID_DataType = "Text",
    INPID_InputControl = "LabelControl",
    INP_External = false,
    INP_Passive = true,
  })


		InShaderID = self:AddInput("ShaderID to Fetch", "ShaderID", {
			LINKID_DataType      = "Text",
			INPID_InputControl   = "TextEditControl",
			INP_DoNotifyChanged  = true,
			INP_External         = false,
			--IC_NoLabel         = true,
			ICD_Width            = 1.0,
			--INPS_DefaultText     = devshader,
      TEC_Lines            = 1,            -- height of text entry (default is 8)
			TEC_Wrap             = false,        -- automatic word-wrapping (default is false)
			TEC_ReadOnly         = false,        -- default is false (you should also set INP_External = false)
			TEC_CharLimit        = 6,	           -- maximum number of allowed characters (default is 0, no limit)
			TEC_DeferSetInputs   = true,      -- call NotifyChanged when focus is lost (default is false, call on every key stroke)
			})	

  --Will be customized in Process()
  doFetch_tpl =  [==[ 
    comp:RunScript("PFADfetch.py", { id = "SHADERID", verbose=false, noassets=false}) 
                 ]==]  

 	InFetch = self:AddInput('Fetch Shadertoy', 'InFetch', {
		LINKID_DataType        = 'Number',
		INPID_InputControl     = 'ButtonControl',
		INP_DoNotifyChanged    = false,
    INP_Disabled           = true, --will be enabled in the NotifyChanged 
		INP_External           = false,
		INP_Default            = 0.0,
		ICD_Width              = 1,
		BTNCS_Execute          = doFetch_tpl,
		IC_Visible             = true,
		}) 
  InSemaphoreFetch = self:AddInput( "SemaphoreFetch","SemaphoreFetch", {
    LINKID_DataType     = "Number",
    INPID_InputControl  = "CheckboxControl",
    INP_Integer         = true,
    INP_Default         = 0,
    IC_Visible          = false,
  })


  Sep2 = self:AddInput("_________________FUSE__________________", "Separator2", {
    LINKID_DataType = "Text",
    INPID_InputControl = "LabelControl",
    INP_External = false,
    INP_Passive = true,
  })

      
	InManualID = self:AddInput("Manual ID", "ManualID", {
			LINKID_DataType    = "Number",
			INPID_InputControl = "CheckboxControl",
			INP_Default        = 0,
			INP_MinScale       = 0,
			INP_MaxScale       = 1,
      IC_Visible         = false,
		})	

	InShaderIDFuse = self:AddInput("ShaderID to Fuse", "ShaderIDFuse", {
    IC_ControlPage      = control_page ,
    LINKID_DataType     = "Number",
    INPID_InputControl  = "ComboControl",
	  INP_DoNotifyChanged = true,
    INP_Default         = 0,
    INP_Integer         = true,
    attrs
    })	

  --Will be customized in Process()
  doFuse_tpl =  [==[ 
    comp:RunScript("PFADfuse.py", { id = "SHADERID", pforce=false}) 
                ]==]  


	InFuse = self:AddInput('Fuse a Shadertoy', 'InFuse', {
		LINKID_DataType        = 'Number',
		INPID_InputControl     = 'ButtonControl',
		INP_DoNotifyChanged    = false,
    --INP_Disabled         = true, --will be enabled in the NotifyChanged 
		INP_External           = false,
		INP_Default            = 0.0,
		ICD_Width              = 1,
		BTNCS_Execute          = doFuse,
		IC_Visible             = true,
		}) 
  InSemaphoreFuse = self:AddInput( "SemaphoreFuse","SemaphoreFuse", {
      LINKID_DataType     = "Number",
      INPID_InputControl  = "CheckboxControl",
      INP_Integer         = true,
      INP_Default         = 0,
      IC_Visible          = false,
    })


  InSize = self:AddInput("Size", "Size_Fuse", {
    LINKID_DataType  = "Number",
    INPID_InputControl = "ComboControl",
	  INP_DoNotifyChanged = true,
    INP_Default      = 0,
    INP_Integer      = true,
    ICD_Width        = 1,
  	{ CCS_AddString  = "Default", },
    { CCS_AddString  = "Manually", },
	  { CCS_AddString  = "Image1", },
    { CCS_AddString  = "1920x1080", },
	  { CCS_AddString  = "1200x675", },
	  { CCS_AddString  = "800x450", },
	  { CCS_AddString  = "640x360", },
    CC_LabelPosition = "Horizontal",
	  ICS_ControlPage  = "Image",
  })
	InWidth = self:AddInput("Width", "_Width", {
		LINKID_DataType 	= "Number",
		INPID_InputControl 	= "SliderControl",
		INP_Default 		= 1920,
		INP_Integer     = true,
		INP_MinScale 		= 0,
		INP_MaxScale 		= 4096,
	})
	InHeight = self:AddInput("Height", "_Height", {
		LINKID_DataType 	= "Number",
		INPID_InputControl 	= "SliderControl",
		INP_Default 		= 1080,
		INP_Integer     = true,
		INP_MinScale 		= 0,
		INP_MaxScale 		= 4096,
	})
  InDepth = self:AddInput("Depth_Fuse", "Depth_Fuse", {
    LINKID_DataType  = "Number",
    INPID_InputControl = "ComboControl",
	  INP_DoNotifyChanged = true,
    INP_Default      = 0,
    INP_Integer      = true,
    ICD_Width        = 1,
	  { CCS_AddString  = "Default", },
	  { CCS_AddString  = "int8", },
	  { CCS_AddString  = "int16", },
    { CCS_AddString  = "float16", },
    { CCS_AddString  = "float32", },
    CC_LabelPosition = "Horizontal",
	  ICS_ControlPage  = "Image",
  })
  
  InMyWidth = self:FindInput("Width")
	InMyWidth:SetAttrs({ IC_Visible = false })
	InMyHeight = self:FindInput("Height")
	InMyHeight:SetAttrs({ IC_Visible = false })
	InMyDepth = self:FindInput("Depth")
	InMyDepth:SetAttrs({ IC_Visible = false })



  -- node's inputs and its output
  InChannel = {}
  for i=0,NUM_INPUT_CHANNELS-1 do
    InChannel[i] = self:AddInput(   "iChannel"..i,  "iChannel"..i,  { LINKID_DataType = "Image", LINK_Main = i+1, INP_Required = false  })
  end
  -- InChannel0 = self:AddInput(   "iChannel0",  "iChannel0",  { LINKID_DataType = "Image", LINK_Main = 1, INP_Required = false  })
  OutImage   = self:AddOutput(  "Output",     "Output",     { LINKID_DataType = "Image", LINK_Main = 1                        })

  OutImage2 = self:AddOutput("Output2", "Output2", {
    LINKID_DataType = "Image",
    LINK_Main = 2,
  })
end


InstallPath = [[c:\Users\Zumsel\AppData\Roaming\Blackmagic Design\Fusion\Fuses\]]
---------------------------------- Helperfunctions PathToUse---------------------------------------
function readAll()
 
 
  file = InstallPath.."PathToUse.txt"
  
  local f = io.open(file, "r")
  if not f then
    print("File-Error-Reading: ",f)
    return "root"
  end
  --print("READING*************************************\n ",content)
  local content = f:read("*all")
  local size = f:seek("end")
  
  f:close()
  return content
end


function writeAll(content)
  --file = self.Comp:MapPath(file)
  file = InstallPath.."PathToUse.txt"
  local f = io.open(file, "w")
  if not f then
    print("File-Error-Writing: ",f)
    return
  end
  --print("WRITING*************************************\n ", content)
  f:write(content)
  local size = f:seek("end")
  
  f:close()
  return 0
end


--------------------------------------------------------------------------------------
--  Get the Channels of a Buffer
--

-- Examples
--  // Connect Buffer A 'Texture: RGBA Noise Medium' to iChannel0
--  // Connect Buffer A 'Preset: Keyboard' to iChannel1
--  
--  // Connect Image 'Previsualization: Buffer A' to iChannel0

function GetChannels(ConversionSourcecode, Part, Channels)

  --// Connect Buffer A 'Previsualization: Buffer B' to iChannel0
  local BufferChannel0 = ConversionSourcecode:match(Part.."%s*'[A-Za-z0-9_]*:%s+([%sA-Za-z0-9_]*)'%s*to iChannel0") --OK
  local BufferChannel1 = ConversionSourcecode:match(Part.."%s*'[A-Za-z0-9_]*:%s+([%sA-Za-z0-9_]*)'%s*to iChannel1") --OK
  local BufferChannel2 = ConversionSourcecode:match(Part.."%s*'[A-Za-z0-9_]*:%s+([%sA-Za-z0-9_]*)'%s*to iChannel2") --OK
  local BufferChannel3 = ConversionSourcecode:match(Part.."%s*'[A-Za-z0-9_]*:%s+([%sA-Za-z0-9_]*)'%s*to iChannel3") --OK

--print("\nChannel0: ", BufferChannel0)
--print("Channel1: ", BufferChannel1)
--print("Channel2: ", BufferChannel2)
--print("Channel3: ", BufferChannel3,"\n")

	Channels[0] = BufferChannel0
	Channels[1] = BufferChannel1
	Channels[2] = BufferChannel2
	Channels[3] = BufferChannel3
  -- should be solved more elegantly -> double array
  if(Part == "Buffer A") then
    InChBufferA[0]:SetSource(Text(BufferChannel0),0,0)
    InChBufferA[1]:SetSource(Text(BufferChannel1),0,0)
    InChBufferA[2]:SetSource(Text(BufferChannel2),0,0)
    InChBufferA[3]:SetSource(Text(BufferChannel3),0,0)
  else if(Part == "Buffer B") then
        InChBufferB[0]:SetSource(Text(BufferChannel0),0,0)
        InChBufferB[1]:SetSource(Text(BufferChannel1),0,0)
        InChBufferB[2]:SetSource(Text(BufferChannel2),0,0)
        InChBufferB[3]:SetSource(Text(BufferChannel3),0,0)
       else if(Part == "Buffer C") then
            InChBufferC[0]:SetSource(Text(BufferChannel0),0,0)
            InChBufferC[1]:SetSource(Text(BufferChannel1),0,0)
            InChBufferC[2]:SetSource(Text(BufferChannel2),0,0)
            InChBufferC[3]:SetSource(Text(BufferChannel3),0,0)
            else if(Part == "Buffer D") then
                InChBufferD[0]:SetSource(Text(BufferChannel0),0,0)
                InChBufferD[1]:SetSource(Text(BufferChannel1),0,0)
                InChBufferD[2]:SetSource(Text(BufferChannel2),0,0)
                InChBufferD[3]:SetSource(Text(BufferChannel3),0,0)
                 else if(Part == "Image") then
                    InChImage[0]:SetSource(Text(BufferChannel0),0,0)
                    InChImage[1]:SetSource(Text(BufferChannel1),0,0)
                    InChImage[2]:SetSource(Text(BufferChannel2),0,0)
                    InChImage[3]:SetSource(Text(BufferChannel3),0,0)
                    end                  
                 end     
            end
       end
  end
  
end



-------------------------------------------------------------------------------------------------------------------------------------------
-- Rename the kernel and its parameters.
--
function PatchKernel(ConversionSourcecode,ConversionFusename,Part,NodeName)


  ConversionFusenameExtension=""
  if Part ~= "Image" then
    ConversionFusenameExtension="__"..Part:gsub('%s+','_')
  end

  local ConversionKernelname = ConversionFusename .. "Fuse"..ConversionFusenameExtension.."_" .. NodeName

  local kernel_parameters=ConversionSourcecode:match("__KERNEL__%s+void%s+"..ConversionFusename.."Fuse"..ConversionFusenameExtension.."%s*%(([^%)]*)%)%s*%{")


  if kernel_parameters==nil then
    if Part=="Image" then
      print("kernel for 'Image': ",ConversionFusename," not found!"  )
      
      return "", nil
    end
    return ConversionSourcecode, nil
  end



  local has_param={
    ['iResolution']           = { Type='float2',    Present=false, Code='float2 iResolution = to_float2(_shaderParameters->iResolution[0], _shaderParameters->iResolution[1]);' },
    ['iTime']                 = { Type='float',     Present=false, Code='float iTime = _shaderParameters->iTime;' },
    ['iMouse']                = { Type='float4',    Present=false, Code='float4 iMouse = to_float4(_shaderParameters->iMouse[0],_shaderParameters->iMouse[1],_shaderParameters->iMouse[2],_shaderParameters->iMouse[3]);' },

    ['iTimeDelta']            = { Type='float',     Present=false, Code='float iTimeDelta = _shaderParameters->iTimeDelta;' },
    ['iFrame']                = { Type='int',       Present=false, Code='int iFrame = _shaderParameters->iFrame;' },
    ['iChannelTime']          = { Type='float*',    Present=false, Code='ohoh!'  },
    ['iChannelResolution']    = { Type='float2*',   Present=false, Code='whoops!'  },
    ['iDate']                 = { Type='float4',    Present=false, Code='float4 iDate = to_float4(_shaderParameters->iDate[0],_shaderParameters->iDate[1],_shaderParameters->iDate[2],_shaderParameters->iDate[3]);'},
    ['iSampleRate']           = { Type='float',     Present=false, Code='float iSampleRate = _shaderParameters->iSampleRate;' },

    -- Some special variables not known to shadertoys, but you may want to use
    -- them in a Fuse, so we allow to add them to the kernel's parameters:

    ['width']             = { Type='int', Present=false, Code='int width = _shaderParameters->width;' },
    ['height']            = { Type='int', Present=false, Code='int height = _shaderParameters->height;' },
    ['compOrder']         = { Type='int', Present=false, Code='int width = _shaderParameters->compOrder;' },
    ['x']                 = { Type='int', Present=false, Code='int x = fusion_x;' },
    ['y']                 = { Type='int', Present=false, Code='int y = fusion_y;' },

  }

  -- iChannelResolution[]
  has_param['iChannelResolution']['Code']='float2 iChannelResolution['..NUM_INPUT_CHANNELS..'];\n'
  for i=0,NUM_INPUT_CHANNELS-1 do
    has_param['iChannelResolution']['Code']=has_param['iChannelResolution']['Code']
      .."iChannelResolution["..i.."] = to_float2(_shaderParameters->iChannelResolution["..i.."][0],_shaderParameters->iChannelResolution["..i.."][1]);\n"
  end

  -- iChannelTime[]
  has_param['iChannelTime']['Code']='float iChannelTime['..NUM_INPUT_CHANNELS..'];\n'
  for i=0,NUM_INPUT_CHANNELS-1 do
    has_param['iChannelTime']['Code']=has_param['iChannelTime']['Code']
      .."iChannelTime["..i.."] = _shaderParameters->iChannelTime["..i.."];\n"
  end

  -- iChannel<0..N>
  for i=0,NUM_INPUT_CHANNELS-1 do
    has_param['iChannel'..i]={ Type='sampler2D', Present=false }
  end

  local fragColor_name=nil -- float4
  local fragCoord_name=nil -- float2


  -- ja, okay, jetzt wird's echt bescheuert ...

  local i=-1 -- iteration to allow fragColor and Coord only as the first two parameters

  if kernel_parameters==nil then
    print("no kernel found - unable to determine parameters")
  else
    -- kernel_parameters=kernel_parameters:gsub("^%s*(.-)%s*$", "%1") -- trim
    -- verbose("kernel parameters='"..kernel_parameters.."'")

    for p in kernel_parameters:gmatch('([^,]+)') do

      i=i+1;

      t, n = p:match("^%s*([A-Za-z_][A-Za-z0-9_]*)%s+([A-Za-z_][A-Za-z_0-9]*)%s*$") -- match "type name"
      if t==nil then
        t, n = p:match("^%s*([A-Za-z_][A-Za-z0-9_]*)%s*%*%s*([A-Za-z_][A-Za-z_0-9]*)%s*$") -- match "type * name" (yes, type*name matches, so what)
        if t~=nil then
          t=t..'*'
        else
          t, n = p:match("^%s*([A-Za-z_][A-Za-z0-9_]*)%s+([A-Za-z_][A-Za-z_0-9]*)%s*%[%s*%]%s*$") -- match "type name [ ]"
          if t~=nil then
            t=t..'*'
          end
        end
      end

      if t==nil then
        print("parameter='"..p.."' has bad format")
      else
        verbose("parameter"..i..": type='"..t.."', name='"..n.."'")
        if has_param[n]==nil then
          if i==0 and t=='float4' and fragColor_name==nil then
            fragColor_name=n -- first and only the first parameter can be the color (yes, stupid idea to call that color iDate)
          elseif i<2 and t=='float2' and fragCoord_name==nil then
            fragCoord_name=n -- first or second parameter can be the coord
          else
            print("i don't know '"..t.." "..n.."'")
          end
        else
          if t ~= has_param[n].Type then
            print("bad type '"..t.."' for '"..n.."' ('"..(has_param[n].Type).."' expected)")
          else
            if has_param[n].Present then
              print("multiple occurences of '"..t.." "..n.."'")
            else
              has_param[n].Present=true
            end
          end
        end
      end
    end
  end


  kernel_parameters = "__CONSTANTREF__ ShaderParameters*  _shaderParameters, "
  for i=0,NUM_INPUT_CHANNELS-1 do
    if has_param["iChannel"..i].Present then
      kernel_parameters = kernel_parameters .. " __TEXTURE2D__ iChannel"..i..", "
    else
      kernel_parameters = kernel_parameters .. " __TEXTURE2D__ iChannel"..i..", " -- ausprobieren, ob hier dummy geht!?!
    end
  end
  kernel_parameters = kernel_parameters .. "__TEXTURE2D_WRITE__ _shaderDestinationTexture"


  local variable_declarations = ""

  if fragColor_name ~= nil then
    variable_declarations=variable_declarations.."float4 "..fragColor_name.."=to_float4_s(0.0f);\n"
  end

  if fragCoord_name ~= nil then
    variable_declarations=variable_declarations.."float2 "..fragCoord_name.."=to_float2(fusion_x,fusion_y);\n"
  end


  for n,p in pairs(has_param) do
    if p.Present and p.Code then
      variable_declarations = variable_declarations .. p.Code .. "\n"
    end
  end


  local count

  ConversionSourcecode, count = string.gsub(ConversionSourcecode,
    "__KERNEL__%s+void%s+"..ConversionFusename.."Fuse"..ConversionFusenameExtension.."%s*%([^%)]*%)%s*%{",

    KernelInputCtrlDefines.."\n\n"..
    "__KERNEL__ void "..ConversionKernelname.."("..kernel_parameters..")\n{\n"..
    [[
        DEFINE_KERNEL_ITERATORS_XY(fusion_x, fusion_y);
        if (fusion_x >= _shaderParameters->width || fusion_y >= _shaderParameters->height)
          return;
    ]]
    ..variable_declarations.."\n\n// --------\n\n"
    )

  -- Vorsicht: Der Test, ob der Kernelname gefunden wurde muss drinbleiben,
  -- weil sonst die kleinste Aenderung im Kernelnamen Fusion auf dem Mac komplett
  -- weghaut. Ist zwar nicht absolut wasserdicht, verhindert aber versehentlich
  -- falsche Namen in 99% der Faelle

  if count ~=1 then
    print(ConversionFusename.." kernel found for "..Part.." "..count.."x ... there ".. (count<1 and "must be exactly" or "can be only") .. " one!")
    ConversionSourcecode = ""
    return ConversionSourcecode, nil
  end

  return ConversionSourcecode, ConversionKernelname
end



-------------------------------------------------------------------------------------------------------------------------------------------
-- Rename all kernels and their parameters.
--
function InitializeKernels(ConversionSourcecode,ConversionFusename,NodeName)

  ShaderKernels_resetData()


-- Channel
  local i=0
 
 --print("#################### Multibuffertest ########################\n")

  for i,e in pairs(ShaderKernels.Entries) do
    if e.InputName ~= "" then
      --print("\n-------------------------GetChannelsaufruf: ",i,e.InputName,e.Channel[1])
      GetChannels(ConversionSourcecode,e.InputName,e.Channel)  
    end
  end

  i=0
  local kn

  for i,e in pairs(ShaderKernels.Entries) do
    if e.InputName ~= "" then
      ConversionSourcecode,kn =  PatchKernel(ConversionSourcecode,ConversionFusename,e.InputName,NodeName)
      if kn ~= nil then
        e.KernelName=kn
        ShaderKernels.Quantity=ShaderKernels.Quantity+1
      end
    end
  end

  ConversionSourcecode, count = string.gsub(ConversionSourcecode,
      "(%s+)SetFragmentShaderComputedColor%s*%(%s*",
      "%1_tex2DVec4Write(_shaderDestinationTexture, fusion_x, fusion_y, "
    )

  return ConversionSourcecode
end

---------------------------------------------RebuildParameters--------------------------------------------
function RebuildParameters()

  ShaderParameters_struct = "typedef struct {\n".. ShaderParameters .."\n  // instead you may want to use the following\n  // but only if you really need to\n\n"

  ShaderParameters_init   = [[
  Params _hiddenParams;

  _hiddenParams.iResolution[0] = _shaderParameters->iResolution[0];
  _hiddenParams.iResolution[1] = _shaderParameters->iResolution[1];
  _hiddenParams.iTime = _shaderParameters->iTime;

  // ... init here all the other stuff (TODO!!!)

]]



    --CONNECT_COLOR0(NAME,DEFAULT_R,DEFAULT_G,DEFAULT_B,DEFAULT_A)
    for i=0,NUM_COLOR_CONTROLS-1 do

      -- local name, defRed, defGreen, defBlue, defAlpha = ConversionSourcecode:match("%s+ CONNECT_COLOR"..i.."%(([%a*_*%d*]*)%s*,%s*(%-?%d*%.%d*)f%s*,%s*(%-?%d*%.%d*)f%s*,%s*(%-?%d*%.%d*)f%s*,%s*(%-?%d*%.%d*)f.*$") -- geht
      local name, defRed, defGreen, defBlue, defAlpha = ConversionSourcecode:match("%s+CONNECT_COLOR"..i.."%s*%(([%a_][%w_]*)%s*,%s*(%-?%d+%.%d+)f%s*,%s*(%-?%d+%.%d+)f%s*,%s*(%-?%d+%.%d+)f%s*,%s*(%-?%d+%.%d+)f%s*%)%s*;") -- geht
      --print("#Color0#",name, defRed, defGreen, defBlue, defAlpha)--
      if (name ~= nil) then

        ShaderParameters_struct = ShaderParameters_struct .. "  float "..name.."[4]; // ".."COLOR"..i.."\n"
        ShaderParameters_init   = ShaderParameters_init
          .."  _hiddenParams."..name.."[0] = _shaderParameters->ctrlColor["..i.."][0];\n"
          .."  _hiddenParams."..name.."[1] = _shaderParameters->ctrlColor["..i.."][1];\n"
          .."  _hiddenParams."..name.."[2] = _shaderParameters->ctrlColor["..i.."][2];\n"
          .."  _hiddenParams."..name.."[3] = _shaderParameters->ctrlColor["..i.."][3];\n"

        InColorName[i]:SetAttrs({ IC_Visible = true, LINKS_Name = name })

        InColor[i][0]:SetAttrs({ IC_Visible = true  })
        InColor[i][0]:SetAttrs({INP_Default = tonumber(defRed)})
        InColor[i][0]:SetSource(Number(tonumber(defRed)),0,0)

        InColor[i][1]:SetAttrs({INP_Default = tonumber(defGreen) })
        InColor[i][1]:SetSource(Number(tonumber(defGreen)),0,0)

        InColor[i][2]:SetAttrs({INP_Default = tonumber(defBlue)})
        InColor[i][2]:SetSource(Number(tonumber(defBlue)),0,0)

        InColor[i][3]:SetAttrs({INP_Default = tonumber(defAlpha)})
        InColor[i][3]:SetSource(Number(tonumber(defAlpha)),0,0)
      else
          InColorName[i]:SetAttrs({ IC_Visible = false })
          InColor[i][0]:SetAttrs({ IC_Visible = false })
      end
    end


    --CONNECT_SLIDER0(NAME,SMIN,SMAX,SDEFAULT)
    for i=0,NUM_SLIDER_CONTROLS-1 do

      -- local name, smin, smax, sdef = ConversionSourcecode:match("%s+ CONNECT_SLIDER"..i.."%(([%a*_*%d*]*)%s*,%s*(%-?%d*%.%d*)f%s*,%s*(%-?%d*%.%d*)f%s*,%s*(%-?%d*%.%d*)f%s*.*$") -- geht
      local name, smin, smax, sdef = ConversionSourcecode:match("%s+CONNECT_SLIDER"..i.."%s*%(([%a_][%w_]*)%s*,%s*(%-?%d+%.%d+)f%s*,%s*(%-?%d+%.%d+)f%s*,%s*(%-?%d+%.%d+)f%s*%)%s*;")
      --print("#SLIDER#",name, smin, smax, sdef)

      if (name ~= nil) then

        ShaderParameters_struct = ShaderParameters_struct .. "  float "..name.."; // ".."SLIDER"..i.."\n"
        ShaderParameters_init   = ShaderParameters_init.."  _hiddenParams."..name.." = _shaderParameters->ctrlSlider["..i.."];\n"

        InSlider[i]:SetAttrs({
          IC_Visible    = true,
          LINKS_Name    = name,
          INP_MinScale  = tonumber(smin),
          INP_MaxScale  = tonumber(smax),
          INP_Default   = tonumber(sdef),
        })
        InSlider[i]:SetSource(Number(tonumber(sdef)),0,0)
      else
        InSlider[i]:SetAttrs({ IC_Visible = false })
      end
    end

    --CONNECT_INTSLIDER0(NAME,SMIN,SMAX,SDEFAULT)
    for i=0,NUM_INTSLIDER_CONTROLS-1 do

      -- local name, smin, smax, sdef = ConversionSourcecode:match("%s+ CONNECT_INTSLIDER"..i.."%(([%a*_*%d*]*)%s*,%s*(%-?%d*)%s*,%s*(%-?%d*)%s*,%s*(%-?%d*)%s*.*$") -- geht
      local name, smin, smax, sdef = ConversionSourcecode:match("%s+CONNECT_INTSLIDER"..i.."%s*%(([%a_][%w_]*)%s*,%s*(%-?%d+)%s*,%s*(%-?%d+)%s*,%s*(%-?%d+)%s*%)%s*;")
      --print("#INTSLIDER#",name, smin, smax, sdef) --

      if (name ~= nil) then
        ShaderParameters_struct = ShaderParameters_struct .. "  int "..name.."; // ".."INTSLIDER"..i.."\n"
        ShaderParameters_init   = ShaderParameters_init.."  _hiddenParams."..name.." = _shaderParameters->ctrlIntSlider["..i.."];\n"

        InIntSlider[i]:SetAttrs({
          IC_Visible    = true,
          LINKS_Name    = name,
          INP_MinScale  = tonumber(smin),
          INP_MaxScale  = tonumber(smax),
          INP_Default   = tonumber(sdef),
        })
        InIntSlider[i]:SetSource(Number(tonumber(sdef)),0,0)
      else
        InIntSlider[i]:SetAttrs({ IC_Visible = false })
      end
    end


    --CONNECT_SCREW0(NAME,SMIN,SMAX,SDEFAULT)
    for i=0,NUM_SCREW_CONTROLS-1 do

      -- local name, smin, smax, sdef = ConversionSourcecode:match("%s+ CONNECT_SCREW"..i.."%(([%a*_*%d*]*)%s*,%s*(%-?%d*)%s*,%s*(%-?%d*)%s*,%s*(%-?%d*)%s*.*$") -- geht
      local name, smin, smax, sdef = ConversionSourcecode:match("%s+CONNECT_SCREW"..i.."%s*%(([%a_][%w_]*)%s*,%s*(%-?%d+%.%d+)f%s*,%s*(%-?%d+%.%d+)f%s*,%s*(%-?%d+%.%d+)f%s*%)%s*;")
      --print("#SCREW#",name, smin, smax, sdef) --

      if (name ~= nil) then
        ShaderParameters_struct = ShaderParameters_struct .. "  float "..name.."; // ".."SCREW"..i.."\n"
        ShaderParameters_init   = ShaderParameters_init.."  _hiddenParams."..name.." = _shaderParameters->ctrlScrew["..i.."];\n"

        InScrew[i]:SetAttrs({
          IC_Visible    = true,
          LINKS_Name    = name,
          INP_MinScale  = tonumber(smin),
          INP_MaxScale  = tonumber(smax),
          INP_Default   = tonumber(sdef),
        })
        InScrew[i]:SetSource(Number(tonumber(sdef)),0,0)
      else
        InScrew[i]:SetAttrs({ IC_Visible = false })
      end
    end


    --CONNECT_BUTTON0(NAME,TYP,BTN1,BTN2,BTN3,BTN4,BTN5)
    for i=0,NUM_BUTTON_CONTROLS-1 do

      local name, typ, btn1, btn2, btn3, btn4, btn5 = ConversionSourcecode:match("%s+CONNECT_BUTTON"..i.."%s*%(%s*([%a_][%w_]*)%s*,%s*(%d+)%s*,%s*([%a_]*[%w_]*)%s*[,|%)]*%s*([%a_]*[%w_]*)%s*[,|%)]*%s*([%a_]*[%w_]*)%s*[,|%)]*%s*([%a_]*[%w_]*)%s*[,|%)]*%s*([%a_]*[%w_]*)%s*%)*%s*.*;")
      --print("#Button"..i,name, typ, btn1, btn2, btn3, btn4, btn5 ) --

      if (name ~= nil) then
        ShaderParameters_struct = ShaderParameters_struct .. "  float "..name.."; // ".."Button"..i.."\n"
        ShaderParameters_init   = ShaderParameters_init.."  _hiddenParams."..name.." = _shaderParameters->ctrlButton["..i.."];\n"
        
        InButton[i]:SetAttrs({
          IC_Visible    = true,
          LINKS_Name    = name,
        })

        if (btn1 ~= nil) then InButton[i]:SetAttrs({ MBTNC_AddButton = btn1, }) end
        if (btn2 ~= nil) then InButton[i]:SetAttrs({ MBTNC_AddButton = btn2, }) end
        if (btn3 ~= nil) then InButton[i]:SetAttrs({ MBTNC_AddButton = btn3, }) end
        if (btn4 ~= nil) then InButton[i]:SetAttrs({ MBTNC_AddButton = btn4, }) end
        if (btn5 ~= nil) then InButton[i]:SetAttrs({ MBTNC_AddButton = btn5, }) end
        
        if (tonumber(typ) == 1) then 
          InButton[i]:SetAttrs({ MBTNC_Type = "Toggle", }) 
        end        
          
        
      else
        InButton[i]:SetAttrs({ IC_Visible = false })
      end
    end




    --CONNECT_CHECKBOX0(NAME,SDEFAULT)
    for i=0,NUM_CHECKBOX_CONTROLS-1 do

      --local name, sdef = ConversionSourcecode:match("%s+ CONNECT_CHECKBOX"..i.."%(([%a*_*%d*]*)%s*,%s*(%d*)%s*.*$") -- ev. [0|1] da bool ???
      local name, sdef = ConversionSourcecode:match("%s+CONNECT_CHECKBOX"..i.."%s*%(([%a_][%w_]*)%s*,%s*(%w+)%s*.*$")
      --print("#CHECKBOX#", name, sdef) --

      if sdef~=nil then
        if sdef=='true' or sdef=='1' then
          sdef=1
        elseif sdef=='false' or sdef=='0' then
          sdef=0
        else
          print("invalid default value '".. sdef .."' for checkbox '".. name .."'")
          name=nil
        end
      end

      if (name ~= nil) then

        ShaderParameters_struct = ShaderParameters_struct .. "  bool "..name.."; // ".."CHECKBOX"..i.."\n"
        ShaderParameters_init   = ShaderParameters_init.."  _hiddenParams."..name.." = _shaderParameters->ctrlCheckbox["..i.."];\n"

        InCheckbox[i]:SetAttrs({
          IC_Visible = true,
          LINKS_Name = name,
          INP_Default = tonumber(sdef),
        })
        InCheckbox[i]:SetSource(Number(tonumber(sdef)),0,0)
      else
        InCheckbox[i]:SetAttrs({ IC_Visible = false })
      end
    end

    --CONNECT_POINT0(NAME,SDEFAULT)
    for i=0,NUM_POINT_CONTROLS-1 do

      -- local name, sdefx, sdefy = ConversionSourcecode:match("%s+ CONNECT_POINT"..i.."%(([%a*_*%d*]*)%s*,%s*(%-?%d*%.%d*)f%s*,%s*(%-?%d*%.%d*)f%s*.*$") -- geht
      local name, sdefx, sdefy = ConversionSourcecode:match("%s+CONNECT_POINT"..i.."%s*%(([%a_][%w_]*)%s*,%s*(%-?%d+%.%d+)f%s*,%s*(%-?%d+%.%d+)f%s*%)%s*;")
      --print("#POINT#", name, sdefx, sdefy) --

      if (name ~= nil) then
        ShaderParameters_struct = ShaderParameters_struct .. "  float "..name.."[2]; // ".."POINT"..i.."\n"
        ShaderParameters_init   = ShaderParameters_init
          .."  _hiddenParams."..name.."[0] = _shaderParameters->ctrlPoint["..i.."][0];\n"
          .."  _hiddenParams."..name.."[1] = _shaderParameters->ctrlPoint["..i.."][1];\n"

        InPoint[i]:SetAttrs({
          IC_Visible = true,
          LINKS_Name = name,
          PC_Visible = true,
          INP_DefaultX = tonumber(sdefx),
          INP_DefaultY = tonumber(sdefy),
        })
        InPoint[i]:SetSource(Number(tonumber(sdef)),0,0)
      else
        InPoint[i]:SetAttrs({ IC_Visible = false })
      end
    end

    ShaderParameters_struct = ShaderParameters_struct .. "\n} Params;\n"
    ShaderParameters_init   = ShaderParameters_init .. "  Params* params = &_hiddenParams;\n"

--    print("typedef to simulate the parameters struct would be:\n\n"..ShaderParameters_struct.."\n\n")
--    print("and then something like this would have to be inserted into the kernel:\n\n"..ShaderParameters_init.."\n\n")
--    print("so we'd need the struct declaration right after the Compatibility and straight before the Conversion code (an easy one) and the initialization code should then be placed and the top of the kernel function - then we schould end up with 'params' as we know it ... but no idea if this works - in particular when handing over the pointer to other functions (what is what the whole thing would be needed for)\n\n")
end

---------------------------------------------Add_Inputs for Multibuffer--------------------------------------------
function Add_Inputs(node, iChannel, ImageCnt, e, InCh)

    local imgcnt = 0 -- Fortlaufend Images "auffüllen", die nicht vom Shader definiert wurden
    for i=0,3 do -- iChannel0..3

      if(e.Channel[i] == "Buffer A") then   
        --print("iChannel"..i, "GlobalA")
        node:AddInput("iChannel"..i,Image_Buff_GlobalA)        
      else if(e.Channel[i] == "Buffer B") then   
             --print("iChannel"..i, "GlobalB") 
             node:AddInput("iChannel"..i,Image_Buff_GlobalB)
           else if(e.Channel[i] == "Buffer C") then   
                  --print("iChannel"..i, "GlobalC") 
                  node:AddInput("iChannel"..i,Image_Buff_GlobalC)
                else if(e.Channel[i] == "Buffer D") then
                       --print("iChannel"..i, "GlobalD")
                       node:AddInput("iChannel"..i,Image_Buff_GlobalD)
                     else if(e.Channel[i] ~= nil) then
                            -- Textur Eingänge des Shaders
                            --print("iChannel"..i, "Image"..ImageCnt)
                            node:AddInput("iChannel"..i,iChannel[ImageCnt])
                            
                            -- Anzeige 
                            InCh[i]:SetAttrs({LINKS_Name = "Image"..ImageCnt, LBLC_LabelColor = 2,})
                            ImageCnt = ImageCnt+1
                            if (ImageCnt == 5) then print("Error Multibuffer - zuviele Textureingänge") ImageCnt = 4 end
                          else
                            if (ImageCnt+imgcnt > 4) then print("Multibuffer - Textureingänge überprüfen") imgcnt = 0 end
                            --print("iChannel"..i, "Image"..ImageCnt+imgcnt)
                            node:AddInput("iChannel"..i,iChannel[ImageCnt+imgcnt])
                            imgcnt = imgcnt+1
                          end
                     end      
                end 
           end
      end

    end
    if (ImageCnt+imgcnt > 4) then print("Multibuffer - Textureingänge überprüfen") imgcnt = 0 end
    --print("iChannel4", "Image"..ImageCnt+imgcnt) -- Zusätzlicher Eingang
    node:AddInput("iChannel4",iChannel[ImageCnt+imgcnt])
    
end    


-------------------------------------------------------------------------------------------------------------------------------------------
-- Callback to render the node.
--
ImgAttrs_Global = {
        { IMG_Channel = "Red", },
        { IMG_Channel = "Green", },
        { IMG_Channel = "Blue", },
        { IMG_Channel = "Alpha", },
        IMG_Width = Width,
        IMG_Height = Height,
	      IMG_DeferAlloc = false,
        }

Image_Buff_GlobalA = Image(ImgAttrs_Global)
Image_Buff_GlobalB = Image(ImgAttrs_Global)
Image_Buff_GlobalC = Image(ImgAttrs_Global)
Image_Buff_GlobalD = Image(ImgAttrs_Global)


function Process(req)


	-- Imagesize and Depth
  if (InSize:GetValue(req).Value >= 1) then
		if (InSize:GetValue(req).Value == 2) then
			if (InChannel[0]:GetValue(req) ~= nil) then
			   Width = InChannel[0]:GetValue(req).Width
			   Height = InChannel[0]:GetValue(req).Height
			end
		else
			Width = InWidth:GetValue(req).Value
			Height = InHeight:GetValue(req).Value 
		end
	end	
	if (InDepth:GetValue(req).Value > 0) then
	  if InDepth:GetValue(req).Value == 1 then 
	    SourceDepth = 5 
    else 
	    if InDepth:GetValue(req).Value == 2 then 
	        SourceDepth = 6 
	    else 
	        if InDepth:GetValue(req).Value == 3 then 
 		        SourceDepth = 7 
		    	else
			      SourceDepth = 8
	        end
		  end
	  end
	end
  
        --fusion = eyeon.scriptapp('Fusion', 'localhost')
        --if (fusion) then print("Fusion funktioniert",fusion:GetCurrentComp()) end
        --cmp = fusion:GetCurrentComp()
        --print("VERSUCH1: ",cmp.ActiveTool.Name)
  
  InPathToUseCombo:SetAttrs({INP_DoNotifyChanged = true,})
  --PathToUse = InPathToUseCombo:GetValue(req).Value
  --print("PathToUse - Process",PathToUse)



  if (InSemaphoreFetch:GetValue(req).Value == 1) then
    shaderID = InShaderID:GetValue(req).Value
    
    --Warum auch immer - verstehe wer will    
    PathToRepository_cor =  string.gsub(PathToRepository, '\\', '\\\\')
         
    doFetch = string.gsub(doFetch_tpl, 'PFAD', PathToRepository_cor)
    doFetch = string.gsub(doFetch, 'SHADERID', shaderID)
        
    InFetch:SetAttrs({ BTNCS_Execute = doFetch, }) --Zuweisung notwendig !! Ändern des Strings funktioniert nicht
    verbose("TestFetch",doFetch)

    --print("----------------\n DoFetch-String-Process",doFetch,"\n----------------" )    

    
    InSemaphoreFetch:SetSource(Number(0),0,0) --nur einmal ändern
  end


print("Anzahl Entries: ",table.getn(Conversions))

  if (InSemaphoreFuse:GetValue(req).Value == 1 and table.getn(Conversions) > 0) then
    shaderIDFuse = Conversions[InShaderIDFuse:GetValue(req).Value + 1].ShadertoyID
        
    --Warum auch immer - verstehe wer will    
    PathToRepository_cor =  string.gsub(PathToRepository, '\\', '\\\\')
         
    doFuse = string.gsub(doFuse_tpl, 'PFAD', PathToRepository_cor)
    doFuse = string.gsub(doFuse, 'SHADERID', shaderIDFuse)
        
    InFuse:SetAttrs({ BTNCS_Execute = doFuse, })
 
    --print("----------------\n DoFuse-String-Process",doFuse,"\n----------------" )
    
    InSemaphoreFuse:SetSource(Number(0),0,0)
  end


  local rebuild = false

  ShaderKernels.RenderErrors = false
  ShaderKernels.Current      = ShaderKernels_ComboControl:GetValue(req).Value


  if InRebuildCheckBox:GetValue(req).Value == 1 then
    verbose("Process: do rebuild and clear the flag")
    InRebuildCheckBox:SetSource(Number(0),0)
    rebuild=true
  end


  if (rebuild and table.getn(Conversions) > 0) then
    ConversionSourcecode  = ""
    local item   = Conversions[InFileToUseCombo:GetValue(req).Value + 1]
    ConversionFusename    = item.Name
    ConversionShaderID    = item.ShadertoyID

    InShadertoyButton:SetAttrs({
      BTNCS_Execute = 'bmd.openurl("https://www.shadertoy.com/view/' .. ConversionShaderID ..'")',
      INP_Disabled=  ConversionShaderID=="TEST" and true or false
      })

    verbose("Process: rebuild code for conversion '"..ConversionFusename.."' ("..ConversionShaderID..")")


    f = io.open(PathToRepository..'.clobber/CompatibilityCode.c', "r")

    if (InPathToUseCombo:GetValue(req).Value ~= "Root") then
      -- print("Testpath",item.Path..InPathToUseCombo:GetValue(req).Value..'/')
      --item.Path = item.Path..InPathToUseCombo:GetValue(req).Value..'/'
    end
    
    file = io.open(item.Path .. item.Filename,"r")

    if file ~= nil then
      ConversionSourcecode = "\n" .. file:read("*all")
      file:close()
    end



    -- Für Incubator-Nodes (und nur für diese) müssen die Kernels über verschiedene
    -- Instanzen hinweg unterschieden werden (per self.name). Die fertige Fuse braucht
    -- das nachher aber nicht mehr - eine Fuse ist halt eine Fuse und die ändert ihren
    -- Kernel nicht einfach so zwischendurch ... da wird dann nachher einfach nichts
    -- mehr an den Namen drangehaengt.



    RebuildParameters() --Parameternamen, Min/Max und Defaultwerte aus ConversionCode auslesen und entsprechend Inputs anpassen


    ShaderKernels_resetData()
    ShaderKernels.Current = ShaderKernels_ComboControl:GetValue(req).Value
    CompatibilityCode_loadFile()

    ConversionSourcecode = CompatibilityCode..InitializeKernels(ConversionSourcecode,ConversionFusename,self.Name)
  end


  -- -----------------------


  --JiPi TestButton für Rebuildparameter
  if InRebuildParameterNames:GetValue(req).Value == 1 then
    verbose("Process: Parameter Names")
    InRebuildParameterNames:SetSource(Number(0),0)
    RebuildParameters()
    print("\n###### ConversionCode ######\n",ConversionSourcecode,"\n########################\n")
  end


  local imgattrs = {
    IMG_Document = self.Comp,
    { IMG_Channel = "Red", },
    { IMG_Channel = "Green", },
    { IMG_Channel = "Blue", },
    { IMG_Channel = "Alpha", },
    IMG_Width = Width,
    IMG_Height = Height,
    IMG_XScale = XAspect,
    IMG_YScale = YAspect,
    IMAT_OriginalWidth = realwidth, -- nil !?!
    IMAT_OriginalHeight = realheight, -- nil !?!
    IMG_Quality = not req:IsQuick(),
    IMG_MotionBlurQuality = not req:IsNoMotionBlur(),
    IMG_DeferAlloc = true,
    --IMG_ProxyScale = ( (not req:IsStampOnly()) and 1 or nil),
    --IMG_Depth = ( (SourceDepth~=0) and SourceDepth or nil   )
  }

    if not req:IsStampOnly() then
      imgattrs.IMG_ProxyScale = 1
    end
    if SourceDepth ~= 0 then
      imgattrs.IMG_Depth = SourceDepth
    end





  local dst=Image(imgattrs)
  local p = Pixel({R=0,G=0,B=0,A=0})
  dst:Fill(p)


  local ConversionKernelname = ShaderKernels.Entries[ShaderKernels.Current].KernelName

  if ConversionKernelname==nil or ConversionKernelname=="" then
    ShaderKernels.RenderErrors = true
    ShaderKernels_LabelControl:SetAttrs({LINKS_Name = ShaderKernels_getLabelText()})

    if ConversionKernelname==nil then
      verbose("<none> selected for kernel")
      dst:Fill(Pixel({R=0,G=0,B=0,A=0}))
    else
      print("no kernel for "..ShaderKernels.Entries[ShaderKernels.Current].ComboName)
      print("NAME: ",ConversionKernelname, "\nCODE\n", ConversionSourcecode)
      dst:Fill(Pixel({R=0.5,G=0,B=0,A=0}))
    end
    OutImage:Set(req,dst)
    OutImage2:Set(req, out)
    return
  end

  if rebuild then
    verbose("Process: '"..ConversionKernelname.."' is now active for "..self.Name)
  end



  if ConversionSourcecode == "" or ConversionKernelname == "" or ShaderParameters == nil then
    print("whoops - something went terribly wrong?!?!!")
    ShaderKernels.RenderErrors = true
    ShaderKernels_LabelControl:SetAttrs({LINKS_Name = ShaderKernels_getLabelText()})
    OutImage:Set(req,nil)
    OutImage:Set(req,dst)
    return
  end


  if req:IsPreCalc() then
    --verbose("precalc")
    local out = Image({IMG_Like = dst, IMG_NoData = true})
    OutImage:Set(req, out)
    OutImage2:Set(req,dst)
    ShaderKernels_LabelControl:SetAttrs({LINKS_Name = ShaderKernels_getLabelText()})
    return
  end

-- DCTL-Kernelaufruf

--############################################################################################
--print("\n###### ConversionCode ######\n",ConversionSourcecode,"\n########################\n")


  if(ShaderKernels.Current == 6) then                            -- "=final=" ? 
    if(ShaderKernels.Quantity > 1) then                          -- und Multibuffer ? dann   
      ConversionKernelname = ShaderKernels.Entries[1].KernelName -- Buffer A zuerst
    else
      ConversionKernelname = ShaderKernels.Entries[5].KernelName -- Nur Image vorhanden
    end  
  end
  
  verbose_MB("\n Kernelname:",ConversionKernelname)
  
  
  local node = DVIPComputeNode(req,
    ConversionKernelname,
    ConversionSourcecode,
    "ShaderParameters",
    ShaderParameters
    )

    -- Extern Texture or create a new one
    local iChannel={}
    local Tex={}           -- Signal, ob Textur vorhanden
    for i=0,NUM_INPUT_CHANNELS-1 do
      iChannel[i] = InChannel[i]:GetValue(req)
      Tex[i] = true
      if (iChannel[i] == nil) then
        Tex[i] = false
        iChannel[i] = Image(imgattrs)
        local p = Pixel({R=0,G=0,B=0,A=0})
        iChannel[i]:Fill(p)
      end
    end


--local dst = Image {IMG_Like = iChannel[0], IMG_DeferAlloc = true}
  local dstA = Image {IMG_Like = dst, IMG_DeferAlloc = true}
	local dstB = Image {IMG_Like = dst, IMG_DeferAlloc = true}
	local dstC = Image {IMG_Like = dst, IMG_DeferAlloc = true}
	local dstD = Image {IMG_Like = dst, IMG_DeferAlloc = true}
	local dstI = Image {IMG_Like = dst, IMG_DeferAlloc = true}


  -------------- Parameter für DCTL-Code ---------------------
  local framerate = self.Comp:GetPrefs("Comp.FrameFormat.Rate")

  local params = {}
  params = node:GetParamBlock(ShaderParameters)


  local text  =  nil

  -- iMouse
  local mouse_xy  = InMouseXY:GetValue(req)
  local mouse_zw  = InMouseZW:GetValue(req)
  params.iMouse[0] = mouse_xy.X
  params.iMouse[1] = mouse_xy.Y
  params.iMouse[2] = mouse_zw.X
  params.iMouse[3] = mouse_zw.Y

  -- okay, tut's noch immer nicht - vermutlich muss ich da
  -- mit einem weiteren versteckten feld arbeiten, um mir
  -- die position beim click zu merken

  if InMouseDrag:GetValue(req).Value ~= 0 then
    -- hm, okay ... was mache ich mit einem Mausklick bei Position -1|-1 ?!?
    if params.iMouse[2]==-1 and params.iMouse[3]==-1 then
      params.iMouse[2]=params.iMouse[0]
      params.iMouse[3]=params.iMouse[1]
    end
  else
    params.iMouse[2] = -1
    params.iMouse[3] = -1
  end

  if mouse_zw.X ~= params.iMouse[2] or mouse_zw.Y ~= params.iMouse[3] then
    InMouseZW:SetAttrs({INP_Disabled=false})
    InMouseZW:SetSource(Point(params.iMouse[2],params.iMouse[3]),0,0)
    InMouseZW:SetAttrs({INP_Disabled=true})
  end

  params.iMouse[0] = params.iMouse[0] * Width
  params.iMouse[1] = params.iMouse[1] * Height
  if params.iMouse[2] == -1 and params.iMouse[3] == -1 then
    params.iMouse[2] = 0
    params.iMouse[3] = 0
  else
    params.iMouse[2] = params.iMouse[2] * Width
    params.iMouse[3] = params.iMouse[3] * Height
  end

  text = string.format("{%.1f, %.1f, %.1f, %.1f}", params.iMouse[0], params.iMouse[1],params.iMouse[2],params.iMouse[3])

  if InShaderInputs_iMouse:GetValue(req).Value ~= text then
    InShaderInputs_iMouse:SetAttrs({INP_Disabled=false})
    InShaderInputs_iMouse:SetSource(Text( text ),0,0)
    InShaderInputs_iMouse:SetAttrs({INP_Disabled=true})
  end

  -- iTime
  local frequency = InFrequency:GetValue(req).Value
  params.iTime            = (req.Time / framerate) * frequency;
  text = string.format("(%.0f/%.2ffps)*%.3f= %.4f", req.Time,framerate,frequency,params.iTime)

  if InShaderInputs_iTime:GetValue(req).Value ~= text then
    InShaderInputs_iTime:SetAttrs({INP_Disabled=false})
    InShaderInputs_iTime:SetSource(Text( text ),0,0)
    InShaderInputs_iTime:SetAttrs({INP_Disabled=true})
  end

  -- Colors
  for i=0,NUM_COLOR_CONTROLS-1 do
    for j=0,3 do
      params.ctrlColor[i][j] = InColor[i][j]:GetValue(req).Value
    end
  end

  -- Sliders
  for i=0,NUM_SLIDER_CONTROLS-1 do
    params.ctrlSlider[i] = InSlider[i]:GetValue(req).Value
  end
  for i=0,NUM_INTSLIDER_CONTROLS-1 do
    params.ctrlIntSlider[i] = InIntSlider[i]:GetValue(req).Value
  end
  for i=0,NUM_SCREW_CONTROLS-1 do
    params.ctrlScrew[i] = InScrew[i]:GetValue(req).Value
  end

  -- Buttons
  for i=0,NUM_BUTTON_CONTROLS-1 do
    params.ctrlButton[i] = InButton[i]:GetValue(req).Value
  end

  -- Checkboxes
  for i=0,NUM_CHECKBOX_CONTROLS-1 do
    params.ctrlCheckbox[i] = InCheckbox[i]:GetValue(req).Value
  end

  -- PointControls
  for i=0,NUM_POINT_CONTROLS-1 do
    params.ctrlPoint[i] = {InPoint[i]:GetValue(req).X,InPoint[i]:GetValue(req).Y}
  end

  -- Resolution
  params.width  = dst.Width
  params.height = dst.Height
  params.iResolution[0] = dst.Width
  params.iResolution[1] = dst.Height
  text = string.format("{%.0f, %.0f}", params.iResolution[0], params.iResolution[1] )

  if InShaderInputs_iResolution:GetValue(req).Value ~= text then
    InShaderInputs_iResolution:SetAttrs({INP_Disabled=false})
    InShaderInputs_iResolution:SetSource(Text( text ),0,0)
    InShaderInputs_iResolution:SetAttrs({INP_Disabled=true})
  end

  params.compOrder        = iChannel[0]:IsMask() and 1 or 15

  params.iTimeDelta = 1/framerate
  params.iFrame = req.Time

  for i=0,NUM_INPUT_CHANNELS-1 do
    params.iChannelTime[i] = 0
    params.iChannelResolution[i][0] = iChannel[0].DataWindow:Width()    -- or maybe: iChannel[0].Width
    params.iChannelResolution[i][1] = iChannel[0].DataWindow:Height()   -- or maybe: iChannel[0].Height
  end

  params.iDate[0] = 0
  params.iDate[1] = 0
  params.iDate[2] = 0
  params.iDate[3] = 0

  params.iSampleRate = 44100


  node:SetParamBlock(params)

  node:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR,TEX_ADDRESS_MODE_MIRROR, TEX_NORMALIZED_COORDS_TRUE)
  --node:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR,TEX_ADDRESS_MODE_BORDER, TEX_NORMALIZED_COORDS_TRUE)
  
  ImageCnt = 0 -- Textureingänge des Shaders forlaufend mitzählen ! Achtung mehr als 5 insgesamt nicht möglich 
  
  -- Multibuffer Buffer A ?
  if(ShaderKernels.Current == 6 and ShaderKernels.Quantity > 1) then   -- "=final=" und Multibuffer 

    verbose_MB("\n------Multibuffer Buffer A:",ConversionKernelname)


    Add_Inputs(node, iChannel, ImageCnt, ShaderKernels.Entries[1], InChBufferA )
        
    node:AddOutput("dst", dstA)
    Image_Buff_GlobalA = dstA
  else
    for i=0,NUM_INPUT_CHANNELS-1 do
      node:AddInput("iChannel"..i,iChannel[i])
    end
    node:AddOutput("dst", dst)
  end 

  if rebuild then
    node:ForceRebuild()
  end

  local ok = node:RunSession(req)
	if (not ok) then
    ShaderKernels.RenderErrors = true
		dst = nil
    dump(node:GetErrorLog())
	end

  
  -- Multibuffer Next Buffer: B
  if(ShaderKernels.Current == 6 and ShaderKernels.Quantity > 2) then   -- "=final=" und Multibuffer AB? dann

    ConversionKernelname = ShaderKernels.Entries[2].KernelName --Buffer B starten
 
    verbose_MB("------Multibuffer Buffer B:",ConversionKernelname)
    
    local nodeB = DVIPComputeNode(req,
      ConversionKernelname,
      ConversionSourcecode,
      "ShaderParameters",
      ShaderParameters
      )

    nodeB:SetParamBlock(params)

    nodeB:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR,TEX_ADDRESS_MODE_MIRROR, TEX_NORMALIZED_COORDS_TRUE)
    --node:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR,TEX_ADDRESS_MODE_BORDER, TEX_NORMALIZED_COORDS_TRUE)
    
    Add_Inputs(nodeB, iChannel, ImageCnt, ShaderKernels.Entries[2], InChBufferB)
      
    nodeB:AddOutput("dst", dstB)
    Image_Buff_GlobalB = dstB


    if rebuild then
      nodeB:ForceRebuild()
    end

    local ok = nodeB:RunSession(req)
    if (not ok) then
      ShaderKernels.RenderErrors = true
      dstB = nil
      dump(nodeB:GetErrorLog())
    end
  end

  -- Multibuffer Next Buffer: C
  if(ShaderKernels.Current == 6 and ShaderKernels.Quantity > 3) then   -- "=final=" und Multibuffer AB? dann

    ConversionKernelname = ShaderKernels.Entries[3].KernelName --Buffer C starten
 
    verbose_MB("------Multibuffer Buffer C:",ConversionKernelname)
    
    local nodeC = DVIPComputeNode(req,
      ConversionKernelname,
      ConversionSourcecode,
      "ShaderParameters",
      ShaderParameters
      )

    nodeC:SetParamBlock(params)

    nodeC:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR,TEX_ADDRESS_MODE_MIRROR, TEX_NORMALIZED_COORDS_TRUE)
    --node:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR,TEX_ADDRESS_MODE_BORDER, TEX_NORMALIZED_COORDS_TRUE)
    
    Add_Inputs(nodeC, iChannel, ImageCnt, ShaderKernels.Entries[3], InChBufferC)
      
    nodeC:AddOutput("dst", dstC)
    Image_Buff_GlobalC = dstC


    if rebuild then
      nodeC:ForceRebuild()
    end

    local ok = nodeC:RunSession(req)
    if (not ok) then
      ShaderKernels.RenderErrors = true
      dstC = nil
      dump(nodeC:GetErrorLog())
    end
  end

  -- Multibuffer Next Buffer: D
  if(ShaderKernels.Current == 6 and ShaderKernels.Quantity == 5) then   -- "=final=" und Multibuffer AB? dann

    ConversionKernelname = ShaderKernels.Entries[4].KernelName --Buffer B starten
 
    verbose_MB("------Multibuffer Buffer D:",ConversionKernelname)
    
    local nodeD = DVIPComputeNode(req,
      ConversionKernelname,
      ConversionSourcecode,
      "ShaderParameters",
      ShaderParameters
      )

    nodeD:SetParamBlock(params)

    nodeD:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR,TEX_ADDRESS_MODE_MIRROR, TEX_NORMALIZED_COORDS_TRUE)
    --node:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR,TEX_ADDRESS_MODE_BORDER, TEX_NORMALIZED_COORDS_TRUE)
    
    Add_Inputs(nodeD, iChannel, ImageCnt, ShaderKernels.Entries[4], InChBufferD)
      
    nodeD:AddOutput("dst", dstD)
    Image_Buff_GlobalD = dstD


    if rebuild then
      nodeD:ForceRebuild()
    end

    local ok = nodeD:RunSession(req)
    if (not ok) then
      ShaderKernels.RenderErrors = true
      dstD = nil
      dump(nodeD:GetErrorLog())
    end
  end






-- Multibuffer Final: Image
  if(ShaderKernels.Current == 6 and ShaderKernels.Quantity > 1 ) then   -- "=final=" und Multibuffer? dann

    ConversionKernelname = ShaderKernels.Entries[5].KernelName --Image zum Schluß starten
 
    verbose_MB("------Multibuffer Image:",ConversionKernelname)
    
    local nodeI = DVIPComputeNode(req,
      ConversionKernelname,
      ConversionSourcecode,
      "ShaderParameters",
      ShaderParameters
      )

    nodeI:SetParamBlock(params)

    nodeI:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR,TEX_ADDRESS_MODE_MIRROR, TEX_NORMALIZED_COORDS_TRUE)
    --node:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR,TEX_ADDRESS_MODE_BORDER, TEX_NORMALIZED_COORDS_TRUE)
    
    Add_Inputs(nodeI, iChannel, ImageCnt, ShaderKernels.Entries[5], InChImage)
      
    nodeI:AddOutput("dst", dst)
    
    if rebuild then
      nodeI:ForceRebuild()
    end

    local ok = nodeI:RunSession(req)
    if (not ok) then
      ShaderKernels.RenderErrors = true
      dst = nil
      dump(nodeI:GetErrorLog())
    end
  end



  ShaderKernels_LabelControl:SetAttrs({LINKS_Name = ShaderKernels_getLabelText(),}) -- LBLC_LabelColor = 3,


  --Debugging Image
  OutImage2:Set(req, Image_Buff_GlobalA)
  if(ShaderKernels.Current == 6 and ShaderKernels.Quantity > 1) then 
    InDebugImage:SetAttrs({ IC_Visible = true })
    if (InDebugImage:GetValue(req).Value == 1) then OutImage2:Set(req, Image_Buff_GlobalB) end
    if (InDebugImage:GetValue(req).Value == 2) then OutImage2:Set(req, Image_Buff_GlobalC) end
    if (InDebugImage:GetValue(req).Value == 3) then OutImage2:Set(req, Image_Buff_GlobalD) end
  else
    InDebugImage:SetAttrs({ IC_Visible = false })
  end  


  -- Output our result
  OutImage:Set(req,dst)
  collectgarbage();

end


-------------------------------------------------------------------------------------------------------------------------------------------
-- Callback to handle UI control events.
--
function NotifyChanged(inp, param, time)
	if inp ~= nil and param ~= nil then

		if (inp == InReloadCodeButton) then
			if (param.Value == 1) then
        verbose("NotifyChanged: reload button pressend")
        InRebuildCheckBox:SetSource(Number(1),0)
        return
      end
    end
    
		if (inp == InPathToUseCombo) then
      print("\nPathToUse-Notify: ",param.Value)
    end
    
    if (inp == InPathToUseCombo) then
    
      --print("NotifyChanged-selected: "..param.Value)
      --InSemaphore:SetSource(Number(1),0,0)
      --file = InstallPath.."Test.txt"
      
      print("AlterWert: ", readAll())
      print("NeuerWert",param.Value)
      
      writeAll(param.Value)
      
      InFileToUseCombo:SetSource(Number(0),0) -- Auf den Ersten Eintrag stellen, da sonst bei kleinerer Liste Fehler erzeugt wird

      InInfoReload:SetAttrs({IC_Visible = true})

      -- Verzweifelter Versuch - automatisch ein reload zu bewerkstelligen -> keine Chance - Scripte sind erst nach dem "Create" verfügbar!       
      --if not tool then
        --fusion = eyeon.scriptapp('Fusion', 'localhost')
        --cmp = fusion:GetCurrentComp()
        --print("VERSUCH1: ",fusion.ActiveTool.Name)
        
--	      tool = fusion.ActiveTool
      --end 
        
--      tool.ScriptReload[fu.TIME_UNDEFINED] = 1
--	    print("Fuse Reloaded")
--	    tool.ScriptReload[fu.TIME_UNDEFINED] = 0
        
        
      --InInfoReload:SetAttrs({IC_Visible = true})
    end
    
    
    
    


		if (inp == InFileToUseCombo) then
      verbose("NotifyChanged: file to use changed - set flag for a rebuild")
      InRebuildCheckBox:SetSource(Number(1),0)
      return
    end

    --JiPi
		if (inp == InReloadParameterNames) then
			if (param.Value == 1) then
        verbose("NotifyChanged: reload Parameter Names")
        InRebuildParameterNames:SetSource(Number(1),0)
        return
      end
    end

		if (inp == InShaderID) then
			if (string.len(param.Value) == 6) then 
        InFetch:SetAttrs({INP_Disabled = false})
        InFetch:SetAttrs({LINKS_Name = "Fetch Shadertoy ID "..param.Value})
      else
        InFetch:SetAttrs({INP_Disabled = true})
        InFetch:SetAttrs({LINKS_Name = "Please Enter ID (6 Characters) "})
      end
      
      --print("\n\nNotify ",param.Value,string.len(param.Value), "\n\n")
       InSemaphoreFetch:SetSource(Number(1),0,0)
  	end
    
    if (inp == InShaderIDFuse) then  -- ev Button noch modifizieren
      InSemaphoreFuse:SetSource(Number(1),0,0)
    end  

		if inp == InSize then
		  if param.Value == 1 then
			  InWidth:SetAttrs({ IC_Visible = true })
			  InHeight:SetAttrs({ IC_Visible = true })
		  else
			  InWidth:SetAttrs({ IC_Visible = false })
			  InHeight:SetAttrs({ IC_Visible = false })
		  end
		  
		  if param.Value == 3 then --1920x1080
			  InWidth:SetSource(Number(1920),0,0)
			  InHeight:SetSource(Number(1080),0,0)
		  end
		  if param.Value == 4 then --1200x675
			  InWidth:SetSource(Number(1200),0,0)
			  InHeight:SetSource(Number(675),0,0)
		  end
		  if param.Value == 5 then --800x450
			  InWidth:SetSource(Number(800),0,0)
			  InHeight:SetSource(Number(450),0,0)
		  end
 	    if param.Value == 6 then --640x360
		    InWidth:SetSource(Number(640),0,0)
	   	  InHeight:SetSource(Number(360),0,0)
		  end
		end 

	end
end
