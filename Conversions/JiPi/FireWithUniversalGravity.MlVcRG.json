{"Shader":{"ver":"0.1","info":{"id":"MlVcRG","date":"1543261618","viewed":772,"name":"Fire With Universal Gravity","username":"mathmasterzach","description":"Inspired by https:\/\/www.shadertoy.com\/view\/ll3SWs\nClick and drag to create more particles.\nSorry for the messy code, there are lots of parameters with which to fiddle.\n","likes":31,"published":3,"flags":32,"usePreview":0,"tags":["2d","sdf","fire","particle","gravity","buckets"],"hasliked":0},"renderpass":[{"inputs":[{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":258,"src":"\/media\/previz\/buffer01.png","ctype":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":37,"channel":0}],"code":"#define rMode 0\n\/\/#define rMode 1\n\/\/#define rMode 2\n\/\/#define rMode 3\n\/\/#define rMode 4\n\n#define shadow false\n\/\/#define shadow true\n\n\/\/IMPORTANT. IF IT DOESNT WORK THEN GO TO BUFFER A AND SET THE BUFFER TO CLAMP AND THEN REPEAT\nfloat numPart(vec2 p)\n{\n    float t=0.;\n    float t1=0.;\n    for(float i=-R2;i<=R2;i++){\n    \tfor(float j=-R2;j<=R2;j++){\n            float w=pow(3.0,-length(vec2(i,j)\/R2));\n            if(length(vec2(i,j))>R2){\n            \tcontinue;\n            }\n            if(texture(iChannel0,p+(vec2(j,i)\/iResolution.xy)).x!=-1.){\n            \/\/if(texture(iChannel1,p+(vec2(j,i)\/iResolution.xy)).x>.1){\n                t+=w;\n           \t}\n            t1+=w;\n        }\n    }\n    return t\/t1;\n}\n\nbool hasPart(vec2 p)\n{\n    for(float i=-R2;i<=R2;i++){\n    \tfor(float j=-R2;j<=R2;j++){\n            if(length(vec2(i,j))>R2){\n            \tcontinue;\n            }\n            if(texture(iChannel0,p+(vec2(j,i)\/iResolution.xy))!=vec4(-1.)){\n            \treturn true;\n           \t}\n        }\n    }\n    return false;\n}\n\n\/\/convert HSV to RGB\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0 \/ 3.0, 1.0 \/ 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 bg(vec2 p)\n{\n    return vec3(.5*mod(ceil(p.x) + ceil(p.y), 2.));\n}\n\nvec3 render(vec2 uv, vec2 p){\n    float m=map(p,iTime);\n    if(m<0.){\n        if(m>-10.){\n        \treturn vec3(.5+.4*dot(mapNormal(p,iTime),normalize(vec2(.5,1.))));\n        }else{\n        \treturn vec3(.5);\n        }\n    }else{\n        float mc=1.;\n        if(shadow){\n        \t\/\/mc=1.-(1.\/(.05*m+1.));\n            mc=1.-(1.\/(.1*m+1.));\n        }\n        if(rMode==3||rMode==4){\n            float h=numPart(uv);\n            if(rMode==3){\n            \treturn mc*mix(vec3(0.),hsv2rgb(vec3(h*.5,1.,1.)),clamp(h,0.,1.));\n            }\n           \t\/\/return mc*mix(vec3(0.),hsv2rgb(vec3(h\/20.,1.,1.)),clamp(h*10.,0.,1.));\n            \/\/return vec3(numPart(uv));\n            \/\/return mc*vec3(step(.2,h));\n        }else{\n            float h=texture(iChannel1,uv).x;\n            vec3 sh=vec3(1.\/iResolution.xy,0.);\n            h+=texture(iChannel1,uv+sh.xz).x+texture(iChannel1,uv+sh.zy).x\n                +texture(iChannel1,uv-sh.xz).x+texture(iChannel1,uv-sh.zy).x;\n            h\/=5.;\n            float rs=10.; \/\/good values are 10, 20, 30\n            if(rMode==0){\n                return mc*mix(bg(p*4.),hsv2rgb(vec3(h\/20.,1.,1.)),h);\n            }else if(rMode==1){\n                return mc*mix(vec3(0.),hsv2rgb(vec3(h\/20.,1.,1.)),1.-h);\n            }else if(rMode==2){\n                return mc*mix(vec3(0.),hsv2rgb(vec3((h\/20.)+.6,1.,1.)),h);\n            }\n        }\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord\/iResolution.xy;\n    vec3 c=vec3(render(uv,fragCoord.xy));\n    fragColor = vec4(c,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":257,"channel":0}],"code":"\/\/particle handling\nvec4 getParticle(vec2 p)\n{\n    vec4 mass=vec4(0.,0.,0.,0.);\n    float s=.8;\/\/modify this value. .5 is default. 1. is big; above 1 is interesting ex. 2, 3\n    float nh=.0;\/\/modify this as well. 0. is default.\n    float t=0.;\n    for(float i=-R;i<=R;i++){\n    \tfor(float j=-R;j<=R;j++){\n            vec4 prt = texture(iChannel0,(p+vec2(j,i))\/iResolution.xy);\n            if(prt!=vec4(-1.)){\n                if( abs(prt.x+prt.z-j)<=s && abs(prt.y+prt.w-i)<=s ){\n                    mass+=vec4(prt.x+prt.z-j,prt.y+prt.w-i,prt.z,prt.w);\n                    t++;\n            \t}\n            }\n            \n    \t}\n    }\n    if(t>nh){\n    \treturn mass\/t;\n    }\n    return vec4(-1.);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord\/iResolution.xy;\n    if(iFrame<=5){\n    \tfragColor = vec4(0.);\n    }else{\n        if(length(vec2(fragCoord.x-iMouse.x,fragCoord.y-iMouse.y))<20.&&iMouse.z > 0.){\n            vec2 v=-R*normalize(vec2(fragCoord.x-iMouse.x+3.*sin(iTime*100.),fragCoord.y-iMouse.y+3.*sin(iTime*251.)));\n            fragColor = vec4(0.0,0.0,v);\n        }else{\n        \tvec4 p=getParticle(fragCoord);\n            if(map(fragCoord,iTime)>=-R&&p.x!=-1.){\n                vec2 rez=1.\/iResolution.xy;\n                vec2 n=mapNormal(fragCoord+p.xy,iTime);\n                \/\/gravity\n                vec2 ac=n*.1\/(1.+.001*map(p.xy,iTime));\n                vec2 nv=vec2(clamp(.999*p.z+ac.x,-R,R),clamp(.999*p.w+ac.y,-R,R));\n                if(map(fragCoord+p.xy,iTime)<=0.){\n                    \/\/the normal vector can be made more accurate here by getting the exact collision\n                    p.zw=1.1*reflect(vec2(p.z,p.w),n);\n                    nv=vec2(clamp(p.z,-R,R),clamp(p.w,-R,R));\n                }\n                fragColor = vec4(p.x,p.y,nv);\n            }else{\n                fragColor = vec4(-1.);\n            }\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":258,"src":"\/media\/previz\/buffer01.png","ctype":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":258,"channel":0}],"code":"\/\/trails\nconst float str=.8; \/\/good values are .8,.99,-.1\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord\/iResolution.xy;\n    fragColor = vec4(texture(iChannel1,uv).xyz*str,1.0);\n    if(texture(iChannel0,uv)!=vec4(-1.)){\n    \tfragColor +=1.;\n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\/\/increase R as much as your computer can take. 4-5 is usually sufficient though.\n\/\/setting R to 10 is fun, albeit slow\nconst float R=4.;\nconst float R2=8.;\nmat2 rot2(float a) {\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s,-s, c);\n}\nfloat box(vec2 p,vec2 b)\n{\n    vec2 d = abs(p) - b;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat rotatedBox(vec2 p, vec2 b, float time)\n{\n    vec2 q=p;\n    q.xy*=rot2(time);\n\treturn box(q,b);\n}\nfloat circle(vec2 p,float r)\n{\n\treturn length(p)-r;\n}\nfloat edge(vec2 p)\n{   \n\tfloat d=.5-length(p+vec2(-.5));\n    d=max(d,.3-length(p-vec2(0.)));\n    return d;\n}\nfloat grid(vec2 p)\n{\n\tfloat gS=130.;\n    vec2 q=gS*(fract(p\/gS)-.5);\n    return length(q)-gS\/5.;\n}\nfloat items(vec2 p,float time)\n{\n\tfloat d=box(p-vec2(80.,60.),vec2(40.,20.));\n    d=min(d,circle(p-vec2(230.+40.*sin(time),100.+20.*sin(time)),30.));\n    d=min(d,circle(p-vec2(400.,180.),80.));\n    d=max(d,-circle(p-vec2(400.,180.),40.));\n    d=max(d,-rotatedBox(p-vec2(400.,180.),vec2(90.,20.),time));\n    d=min(d,rotatedBox(p-vec2(135.,115.),vec2(20.,80.),-.7));\n    d=min(d,circle(p-vec2(800.,500.),100.));\n    d=min(d,circle(p-vec2(300.,550.),30.));\n    d=min(d,box(p-vec2(1000.,400.+300.*sin(time*.1)),vec2(50.,20.)));\n    return d;\n}\nfloat map(vec2 p, float time)\n{\n    float d=items(p,time);\n    return d;\n    \n}\nvec2 mapNormal(vec2 p, float t)\n{\n\tvec2 eps = vec2(0.0, 0.001);\n    vec2 normal = normalize(vec2(\n        map(p + eps.yx,t) - map(p - eps.yx,t),\n        map(p + eps.xy,t) - map(p - eps.xy,t)));\n    return normal;\n}","name":"Common","description":"","type":"common"}]}}