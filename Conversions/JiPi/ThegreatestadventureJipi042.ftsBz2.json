{
 "ver": "0.1",
 "info": {
  "id": "ftsBz2",
  "date": "0",
  "viewed": 0,
  "name": "TheGreatestAdventure  JiPi042",
  "description": "My entry for the competition. Pulled an all-nighter to get this done in time.\nThis was made and tested on Windows 10. I hear some people see something different on other systems, sadly, I'm not sure how to fix it.\n\nHope you like it!",
  "likes": 0,
  "published": "Private",
  "usePreview": 0,
  "tags": [
   "life",
   "candle",
   "sh17b"
  ],
  "hasliked": 0,
  "parentid": "MsSBD1",
  "parentname": "[SH17B] - The Greatest Adventure"
 },
 "renderpass": [
  {
   "inputs": [
    {
     "id": "MlSXzz",
     "filepath": "https://soundcloud.com/josephraphael/yann-tiersen-amelie-piano-version-soundtrack?in=user-624915920/sets/yan-tiersen",
     "type": "musicstream",
     "channel": 0,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 0
    }
   ],
   "outputs": [
    {
     "id": "4dfGRr",
     "channel": 0
    }
   ],
   "code": "// The Greatest Adventure by Martijn Steinrucken aka BigWings - 2016\n// Email:countfrolic@gmail.com Twitter:@The_ArtOfCode\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// Song: Yann Tiersen – Comptine d’un autre été - L’après midi\n// https://soundcloud.com/reminiscience/yann-tiersen-comptine-dun-autre-ete-lapres-midi \n//\n// My entry for the 2017 ShaderToy competition\n//\n// I thought I had one more day, luckily I found out in time that I didn't :) Pulled an all-nighter to get this done in time.\n// I didn't have time to optimized and beautify so forgive me for the horrible code.\n// \n// I figured the greatest adventure there is is life itself. \n//\n// https://www.shadertoy.com/view/MsSBD1\n\n#define INVERTMOUSE 1.\n\n#define MAX_STEPS 200\n#define MIN_DISTANCE 0.1\n#define MAX_DISTANCE 4.\n#define RAY_PRECISION 0.0003\n\n#define BG_STEPS 20.\n\n#define S(x,y,z) smoothstep(x,y,z)\n#define L(x, y, z) clamp((z-x)/(y-x), 0., 1.)\n#define B(x,y,z,w) S(x-z, x+z, w)*S(y+z, y-z, w)\n#define sat(x) clamp(x,0.,1.)\n#define SIN(x) sin(x)*.5+.5\n\n#define BOKEH_SIZE .03\n\n#define FLAMECOL vec3(.99, .6, .35)\n#define FLAMEBLUE vec3(.1, .1, 1.)\n#define CANDLECOL  vec3(.2, .5, .2)\n#define CANDLE_HEIGHT 10.\n#define SONG_LENGTH 134.\n#define DEATH_TIME 126.3\n\nconst float halfpi = 1.570796326794896619;\nconst float pi = 3.141592653589793238;\nconst float twopi = 6.283185307179586;\n\nvec2 m; // mouse\n\nvec3 A;\t// 0=birth  1=death  x = 0->1 y = 1->0 z = smoothstep(x)\n\n\nfloat gHeight;\n\nfloat X2(float x) {return x*x;}\nfloat N( float x ) { return fract(sin(x*12.35462)*5346.1764); }\nfloat N2(float x, float y) { return N(x + y*23414.324); }\n\nfloat N21(vec2 t) {return fract(sin((t.x+t.y*10.)*9e2));}\nfloat N31(vec3 t) {return fract(sin((t.x+t.y*10.+ t.z*100.)*9e2));}\nvec4 N14(float t) {return fract(sin(vec4(1., 3., 5., 7.)*9e2));}\n\nfloat LN(float x) {return mix(N(floor(x)), N(floor(x+1.)), fract(x));}\n\nstruct ray {\n    vec3 o;\n    vec3 d;\n};\n\n\n\nstruct de {\n    // data type used to pass the various bits of information used to shade a de object\n\tfloat a;// age\n    float d;\t// distance to the object\n    float fh;\t// flame height\n    float m; \t// material\n    float f;\t// flame\n    float w;\t// distance to wick\n    float fd;\t// distance to flame\n    float b;\t// bump\t\n    \n    float s; // closest flame pass\n    float sd;\n    vec2 uv;\n    \n    // params that only get calculate when marcing is complete\n    vec3 id;\t// cell id\n    vec4 n; \t// cell id based random values\n    vec3 p;\t// the world-space coordinate of the fragment\n    vec3 nor;\t// the world-space normal of the fragment\t\n};\n    \nstruct rc {\n    // data type used to handle a repeated coordinate\n\tvec3 id;\t// holds the floor'ed coordinate of each cell. Used to identify the cell.\n    vec3 h;\t\t// half of the size of the cell\n    vec3 p;\t\t// the repeated coordinate\n};\n\n\nray GetRay(vec2 uv, vec3 p, vec3 lookAt, float zoom) {\n\t\n    vec3 f = normalize(lookAt-p),\n    \t r = cross(vec3(0,1,0), f),\n    \t u = cross(f, r),\n    \t c = p+f*zoom,\n         i = c+r*uv.x+u*uv.y;\t// point in 3d space where cam ray intertsects screen\n    \n    ray cr;\n    \n    cr.o = p;\t\t\t\t\t\t\n    cr.d = normalize(i-p);\t\t// ray dir is vector from cam pos to screen intersect \n\treturn cr;\n}\n\nfloat remap01(float a, float b, float t) { return (t-a)/(b-a); }\nfloat remap(float a, float b, float c, float d, float t) { return sat((b-a)/(t-a)) * (d-c) +c; }\n\nfloat DistLine(vec3 ro, vec3 rd, vec3 p) {\n\treturn length(cross(p-ro, rd));\n}\n\nvec2 within(vec2 uv, vec4 rect) {\n\treturn (uv-rect.xy)/rect.zw;\n}\n\n// DE functions from IQ\n// https://www.shadertoy.com/view/Xds3zN\n\nvec2 smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return vec2(mix( b, a, h ) - k*h*(1.0-h), h);\n}\nvec2 smin2( float a, float b, float k, float z )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    float g = h*h*(3.-2.*h);\n    return vec2(mix( b, a, g ) - k*pow(g*(1.-g), z), g);\n}\n\nvec2 smax( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn vec2(mix( a, b, h ) + k*h*(1.0-h), h);\n}\n\nfloat sdSphere( vec3 p, vec3 pos, float s ) { return length(p-pos)-s; }\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdCylinder( vec3 p, vec2 h ) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCone( vec3 p, vec3 c ) {\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nvec3 Bend( vec3 p, float center, float strength ) {\n    p.y-=center;\n    float c = cos(strength*p.y);\n    float s = sin(strength*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xy,p.z);\n    q.y+=center;\n    return q;\n}\n\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*pi/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\nde fmap( vec3 p, de n ) {\n    // mapping the flame\n     \n    float t = iTime;\n     \n    float y = sat(remap01(.0, CANDLE_HEIGHT, p.y));\n    float h = 1.-y;\n    float a = atan(p.x, p.z);\n    float l = length(p.xz);\n    \n    float baby = S(.025, 0., h);\n    float child = S(.3, .05, h); \t\t\t\t\n    float adult = 1.-child;\n    float adult2 = S(.2, .5, A.x);\n    float death = S(.8, 1., A.z);\n    \n    float height = gHeight+.055+baby*.05-adult2*.04-adult*.02+death*.02;\n   \n    de o;\n    o.m = 1.;\n    \n    p.z *= 1.5;\n    \n    float size = .04-baby*.01+adult2*.04-death*.02;\n    \n    float flame = MAX_DISTANCE;\n    \n    float flameHeight = .2-.1*baby+adult2*.1-death*.2;\n   \n    float smth = .02-baby*.01+adult2*.03-death*.03;\n    \n    float x = adult*.01-adult2*.03+death*.04;\n    float wave = sin(p.y*10.-t*4.);\n    wave *= sin(t);\n    wave *= .01;\n    \n    float baseSize = .7+flameHeight*.4;\n    float start = S(.01, .0, A.x);\n    baseSize *= 1.-start*.5;\n    flameHeight *= 1.-start;\n    \n    float flicker = LN(t+A.x*t);\n    flameHeight *= 1.-flicker*flicker*flicker*A.x*.5;\n    \n    for(float i=0.; i<1.; i+=1./10.) {\n    \tfloat fH = height + i*flameHeight;\n        size = baseSize * mix(.05, .01, i);\n        \n        float fX = x+wave*i*i;\n        flame = smin(flame, sdSphere(p, vec3(fX, fH, .0), size), smth).x;\n    }\n    \n    o.fh = flameHeight;\n    \n    o.d = flame/1.5;\n    return o;\n    \n}\n\nvec4 map( vec3 p ) {\n   \n    float y = sat(remap01(.0, CANDLE_HEIGHT, p.y));\n    float h = 1.-y;\n    float a = atan(p.x, p.z);\n    float l = length(p.xz);\n    \n    float cRadius = mix(.3, .1, S(0., 1., y)); // overall growth in thickness\n    float baby = S(.025, 0., h);\n    float child = S(.3, .05, h); \t\t\t\t\n    float adult = 1.-child;\n    float adult2 = S(.2, .5, A.x);\n    float death = S(.8, 1., A.z);\n    \n    cRadius *= 1.-child*.6;\n    \n    float inside = l/cRadius;\n    float oMask = S(.8, .9, inside);\n    \n    //candle\n    float candle = sdCylinder(p, vec2(cRadius, gHeight));\n    if(baby>0.) {\n    \tfloat topCone = sdCone(p-vec3(0,gHeight+.075,0), vec3(1,cRadius*12.6,.075));\n    \tcandle = min(candle, topCone);\n    }\n    \n    float d = candle-.003*baby;\n    \n    float chamfer = 0.06*adult2;//.1*(1.-baby);\n    float crRadius = cRadius*(.6+adult2*.3)+ (1.-baby)*.015;\n    float crHeight = gHeight+.03*child-.05*adult2+.07*baby;\n    crHeight = gHeight+.05+baby*.06-adult*.02-.02*adult2;\n    float crBlend = .001+adult2*.02+.02*adult;\n    float crater = sdCylinder(p-vec3(0, crHeight+chamfer, 0), vec2(crRadius-chamfer, .05))-chamfer;\n    d = smax(d, -crater, crBlend).x;\n\n    // drips\n    float id = floor(a*40./twopi);\n    float n = N(id);\n    float age = n*n-y;\n    \n    float drips = -abs(sin(a*20.)*sin(p.y*.5+n*pi))*max(0., age);\n    drips = max(0., sin(a*20.));\n    drips *= S(.85, 1., inside);\n    float bump = -max(drips*.7*sin(p.y+n*twopi)-y, 0.);\t// add drips\n    \n    // baby bday candle\n    float x = a+p.y*10.;\n    float bday = pow(abs(sin(x*4.)),8.);\n    float coneMask = S(.9755, .96, y);\n\n    bday = bday*oMask*child*coneMask;\n    d -= bday*.005;\n    \n    // candle getting fucked up toward the bottom\n    vec3 q = p*25.;\n    bump += sin(p.y)*(sin(q.x+sin(q.y+sin(q.z*pi)))+sin(q.x*2.+q.z+q.y))*.5*S(.3, .1, y);\n    bump += sin(sin(p.y*15.)+a*10.)*S(.11, .0, y)*2.;\n    d += bump*.01*oMask;\n    \n    // floor\n   \td = smin(d, p.y, .3).x;\t\n    \n    // wick\n    float wBottom = crHeight-.05-.01*adult2;\n    float wHeight = .08-.01*death-.02*child-baby*.02;\n    float wDiam = .008+adult2*.003-.002*child;\n    float wBlend = (.04+.05*adult)*(1.-baby)+.1*adult2;\n    wBlend = (1.-baby)*.02+.05*adult2-.05*death;\n    float wBend = 10.1*adult2*(1.-death)-5.*adult;\n    vec3 wPos = Bend(p, wBottom, wBend);\n    float wick = sdCapsule(wPos, vec3(0, wBottom, 0), vec3(0, wBottom+wHeight, 0), wDiam);\n    \n    vec3 wUv = wPos*80.*CANDLE_HEIGHT;\n    float wBump = sin(wUv.y*0.2)*sin(wUv.z)*sin(wUv.x);\n    wBump *= sat(remap01(wBottom, wBottom+wHeight, p.y));\n    wBump *= .001+.001*adult2;\n    \n    d = smin2(d, wick-wBump, wBlend, 1.+adult2*3.).x;\n    \n    // floor drips\n    float j = pModPolar(p.xz, 4.);\n    n = N(j);\n    float bottom = sdSphere(p, vec3(1, 0, 0)*.4, .3*(n+.3));\n    bottom = smax(bottom, p.y-.05, .05).x;\n    d = smin(d, bottom, .02).x;\n    \n    //d = candle;\n    \n    return vec4(d, wick, wBottom+wHeight, bump+bday);\n}\n\nde castRay( ray r ) {\n    \n    float t = iTime;\n    float dS;\n    \n    de o;\n    o.d = MIN_DISTANCE;\n    o.w = MAX_DISTANCE;\n    o.m = -1.0;\n    o.n = mix(N14(floor(t)), N14(floor(t+1.)), fract(t));\n    \n    vec4 d;\n    for( int i=0; i<MAX_STEPS; i++ ) {\n        o.p =  r.o+r.d*o.d;\n \n        d = map(o.p);\n        \n        o.w = min(o.w, d.y);\t// keep track of closest wick dist \n        if( d.x<RAY_PRECISION || o.d>MAX_DISTANCE ) break;\n        \n        o.d += d.x;\n    }\n    o.a = d.z;\n    o.b = d.w;\n    \n    if(d.x<RAY_PRECISION) o.m = 1.;\n    \n    \n    // marching the flame\n    de res;\n    \n    o.s = 1000.;\n    o.fd = 0.;\n    float n = 1.;\n    for( int i=0; i<MAX_STEPS; i++ )\n    {\n\t    res = fmap( r.o+r.d*o.fd, o );\n        o.fh = res.fh;\n        if( res.d<RAY_PRECISION || o.fd>MAX_DISTANCE ) break;\n        if(res.d<o.s) {\n            o.s = res.d;\n            o.sd = o.fd;\n        }\n        \n        o.fd += res.d;\n    }\n    \n    if(res.d<RAY_PRECISION)\n        o.f=1.;\n    \n    return o;\n}\n\nvec3 calcNormal( de o )\n{\n\tvec3 eps = vec3( 0.01, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(o.p+eps.xyy).x - map(o.p-eps.xyy).x,\n\t    map(o.p+eps.yxy).x - map(o.p-eps.yxy).x,\n\t    map(o.p+eps.yyx).x - map(o.p-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nvec3 FlameNormal( vec3 p, de n )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    fmap(p+eps.xyy, n).d - fmap(p-eps.xyy, n).d,\n\t    fmap(p+eps.yxy, n).d - fmap(p-eps.yxy, n).d,\n\t    fmap(p+eps.yyx, n).d - fmap(p-eps.yyx, n).d );\n\treturn normalize(nor);\n}\n\nvec3 Background(ray r) {\n    \n    float t = iTime;\n    \n\tfloat x = atan(r.d.x, r.d.z);\n    float y = dot(vec3(0,1,0), r.d);\n    \n    float d = 2.1;\n        \n    vec2 size = vec2(2);\n    vec2 h = size / 2.;\n    \n    float blur = .3;\n    \n    vec3 col = vec3(0);\n    \n    for(float i=0.; i<BG_STEPS; i++) {\n    \tvec3 p = r.o + r.d*d;\n    \t\t\t\t\t\t\n    \tvec2 id = floor(p.xz/size);\t\t\t\t\t\t\t\t// used to give a unique id to each cell\n   \t\tvec3 q = p;\n        q.xz = mod(p.xz, size)-h;\t\t\t\t\t\t\t\t// make grid of flames\n        \n        vec3 cP = vec3(0, N21(id)*CANDLE_HEIGHT, 0);\n        \n        float dRayFlame = DistLine(q, r.d, cP);\t\t\t\t\t\t// closest ray, point dist\n        \n        float dOriFlame = d + length(cP-p);\t\t// approximate distance from ray origin to flame \n        float bSize = dRayFlame/dOriFlame;\n        vec3 flame = FLAMECOL;\n        flame *= S(BOKEH_SIZE, BOKEH_SIZE-BOKEH_SIZE*blur, bSize);\n        \n        flame *= 100.;\n        flame /= (dOriFlame*dOriFlame);\n        float flicker = LN(t+id.x*100.+id.y*345.);\n        //flicker = mix(.3, 1., S(.2, .5, flicker));\n        flame *= 1.-flicker*flicker*.7;\n        col += flame;\n        \n        // step to the next cell\n        vec2 rC = ((2.*step(0., r.d.xz)-1.)*h-q.xz)/r.d.xz;\t\t// ray to cell boundary\n        float dC = min(rC.x, rC.y)+.01;\n        \n        d += dC;\n    }\n    \n    \n    return col;\n}\n\n\nvec3 render( vec2 uv, ray cam ) {\n    \n    float t = iChannelTime[0];\n    \n    vec3 col = vec3(0.);\n    de o = castRay(cam);\n    \n    vec3 n = calcNormal(o);\n    \n    float death2 = S(.9999, .998, A.x);\n    \n    if(o.m==-1.)\n        col = Background(cam)*S(0.25, .45, A.x)*S(1., .8, A.x);//*X2(A.x*A.y)*4.;\n    else if(o.m==1.) {\n    \t\n        float y = sat(remap01(.0, CANDLE_HEIGHT, o.p.y));\n    \tfloat h = 1.-y;\n    \n    \tfloat baby = S(.025, 0., h);\n    \tfloat child = S(.3, .05, h); \t\t\t\t\n    \tfloat adult = 1.-child;\n    \tfloat adult2 = S(.2, .5, A.x);\n    \tfloat death = S(.8, 1., A.z);\n        \n        vec3 sssColor = mix(mix(vec3(1), vec3(1, 0, 0), o.b), CANDLECOL, adult);\n        \n        float cRadius = mix(.3, .1, S(0., 1., y));\n        \n        float l = length(o.p.xz);\n        float inside = l/cRadius;\n        \n        col = vec3(dot(normalize(vec3(1, 1,1)), n)*.5+.5);\n    \n        float height = mix(CANDLE_HEIGHT, .1, A.z);\n\n        // add wick glow\n        y = o.p.y-height;\n        float wickH = y-o.p.x*.4-.02-baby*.15;\n        float wickGlow = S(.009, .025, wickH)*S(.2, .15, inside);\n        \n        vec3 fPos = vec3(0,height,0);\n        fPos.y += .2;\n        fPos -= o.p;\n        float lambert = sat(dot(normalize(fPos), n))/dot(fPos, fPos);\n        lambert *= S(1.0005, .998, A.x);\n        lambert *= 1.-S(.85, .999, A.x)*.75;\n        lambert *= .1;\n        vec3 light = FLAMECOL*lambert;\n\n        col *= S(1.5, 0., length(o.p.xz));\n        col *= .1;\n        col += light*(1.-wickGlow*.7);\n        \n        col += FLAMECOL*FLAMECOL*wickGlow*2.;\n        \n        vec3 r = reflect(cam.d, n);\n        float phong = sat(dot(normalize(fPos), r));\n        phong = pow(phong, 10.);\n        phong *= S(1.5, .8, inside);\n        phong *= S(1.0005, .998, A.x);\n        col += phong*FLAMECOL*o.fh*2.;\n        \n        \n        \n        // add sss\n        float sssHeight = mix(.4, 1., adult)*o.fh;\n        float sss = S(-sssHeight, -.0, y);\n        sss *= inside*S(.3, .1, A.x)*2.+S(.7, .98, inside);\n        sss *= 1.+o.b*.3;\n        sss *= S(1., .9, A.x);\n        col += sss*sssColor;\n        \n        //col = vec3(phong);\n        \n    }\n    \n     if(o.f>0.&&o.fd<o.d) {\n        vec3 p = cam.o+cam.d*o.fd;\n         \n        float y = sat(remap01(.0, CANDLE_HEIGHT, p.y));\n    \tfloat h = 1.-y;\n    \n    \tfloat baby = S(.025, 0., h);\n    \tfloat child = S(.3, .05, h); \t\t\t\t\n    \tfloat adult = 1.-child;\n    \tfloat adult2 = S(.2, .5, A.x);\n    \tfloat death = S(.8, 1., A.z);\n        \n         \n        vec3 n = FlameNormal(p, o);\n        float fresnel = sat(dot(n, -cam.d));\n        float flame = 1.;//fresnel;\n        \n        y = p.y-gHeight;\n       \n        float topFade = S(o.fh, o.fh*.5, y-baby*.13);\n        float bottomFade = S(.0, .1, y);\n        float wickFade = S(.0, .03, o.w)*.8 +.2;\n         \n         float spikes = sin(uv.x*200.+t*15.)*.25;\n         spikes += sin(uv.x*324.-t*5.)*.5;\n         spikes += sin(uv.x*145.+t);\n         spikes *= S(0.1, .6, y);\n         spikes = 1.-spikes;\n         \n        col = mix(col, FLAMECOL*3., bottomFade*wickFade*fresnel*topFade*death2*spikes);\n        \n         float blue = S(.4, -.0, y);\n         blue *= fresnel;//S(.7, .3, fresnel);\n         \n         topFade = S(.1, .0, y);\n         bottomFade = S(-.04, .01, y);\n         wickFade = mix(wickFade, 1., 1.-bottomFade);\n         col += FLAMEBLUE*blue*bottomFade*topFade*wickFade*death2;\n        \n         //col = vec3(spikes);\n    }\n    \n    \n    // add some glow\n    float gw = S(0., .3, A.x);\n    gw *= S(1., .8, A.x);\n    float glow = S(.1*gw, 0., o.s)*.15*gw;\n    glow*=death2;\n    col += glow*FLAMECOL;\n    \n    return col;\n}\n\nvoid mainImage( out vec4 o, in vec2 uv )\n{\n    float t = fract(iTime/SONG_LENGTH)*SONG_LENGTH;\n    \n    uv = (2.*uv - (o.xy=iResolution.xy) ) / o.y ;  \t// -1 <> 1\n   \tm = iMouse.xy/iResolution.xy;\t\t\t\t\t// 0 <> 1\n    \n    float t2 = sat(t/DEATH_TIME);\n    A = vec3(t2, 1.-t2, S(0., 1., t2));\n    //A = vec3(m.y);\n    \n    gHeight = mix(CANDLE_HEIGHT, .1, A.z);\n    \n    float turn = (.1-m.x)*twopi+t*.06;\n    float s = sin(turn);\n    float c = cos(turn);\n    mat3 rotX = mat3(\t  c,  0., s,\n                   \t\t  0., 1., 0.,\n                   \t\t  s,  0., -c);\n    \n    float y = mix(CANDLE_HEIGHT+.1, .1, A.z);\n    //y-=.1;\n    vec3 lookAt = vec3(0., y, 0.);\n    //lookAt.y += S(.2, 0., A.x)*.1;\n    \n    y += A.x*A.x*A.x*A.z*.5;\t\t\t\t\t// raise cam towards the end\n    \n    \n    float dist = .5+A.z+S(.3, 0., A.x)*.25;\n   // dist = .45; //y-=.2;\n    vec3 pos = vec3(0., y, -dist)*rotX;\n   \t\n    ray r = GetRay(uv, pos, lookAt, 2.);\n\n    vec3 col = render(uv, r);\n    \n    o = vec4(col, 1.);\n    \n    \n    o *= S(0., 1., t)*S(SONG_LENGTH, 130., t);\t// fade in/out\n}",
   "name": "Image",
   "description": "",
   "type": "image"
  }
 ]
}