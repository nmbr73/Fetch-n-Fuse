{
 "ver": "0.1",
 "info": {
  "id": "NtyXRR",
  "date": "0",
  "viewed": 0,
  "name": "Fork Pan Tone JiPi 759",
  "description": "A little late for Valentine's Day, but hey.",
  "likes": 0,
  "published": "Private",
  "usePreview": 0,
  "tags": [
   "metaballs",
   "pantone"
  ],
  "hasliked": 0,
  "parentid": "3l3BWj",
  "parentname": "Pan Tone"
 },
 "renderpass": [
  {
   "inputs": [
    {
     "id": "4dfGRn",
     "filepath": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg",
     "type": "texture",
     "channel": 2,
     "sampler": {
      "filter": "mipmap",
      "wrap": "repeat",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    },
    {
     "id": "4dXGR8",
     "filepath": "/media/previz/buffer00.png",
     "type": "buffer",
     "channel": 0,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    },
    {
     "id": "XsXGR8",
     "filepath": "/media/previz/buffer01.png",
     "type": "buffer",
     "channel": 1,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    },
    {
     "id": "4sXGR8",
     "filepath": "/media/previz/buffer02.png",
     "type": "buffer",
     "channel": 3,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    }
   ],
   "outputs": [
    {
     "id": "4dfGRr",
     "channel": 0
    }
   ],
   "code": "float vignette(in vec2 fragCoord)\n{\n    vec3 uvr = xyToUvr(fragCoord, iResolution);\t\t\t\t\n    return mix(1.0, max(0.0, 1.0 - pow(uvr.z * kVignetteScale, kVignetteExponent)), kVignetteStrength);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{       \n\niR = iResolution.xy;\n\n    vec3 rgb = kZero; \n    vec4 texel;\n    #if kApplyBloom == 1\n    {\n        rgb += vec3(bloom(fragCoord, iResolution, ivec2(0, 1), iChannel1).w * kBloomGain);\n        \n        if(kDebugBloom)\n        {\n            fragColor = vec4(rgb, 1.0);\n            return;\n        }\n        \n        //texel = texelFetch(iChannel0, ivec2(fragCoord), 0);\n        texel = texture(iChannel0, (vec2(fragCoord)+0.5)/iR);\n    }\n    #else\n    {\n        texel = renderMetaballs(fragCoord, iResolution, iTime / kTimeStretch, iChannel2);\n    }\n    #endif\n        \n    vec3 bgColour = vec3(0.13);\n    \n    if(kApplyVignette) { bgColour *= vignette(fragCoord); }\n    \n    float alpha = min(0.05, texel.w) / 0.05;\n    rgb += mix(bgColour, texel.rgb, alpha);\n    \n    rgb = clamp(rgb, vec3(0.0), vec3(1.0));\n    \n    \n    \n    fragColor.xyz = rgb;\n    fragColor.w = 1.0;\n}",
   "name": "Image",
   "description": "",
   "type": "image"
  },
  {
   "inputs": [],
   "outputs": [],
   "code": "vec2 iR;\n\n#define kApplyBloom           1\n#define kApplyVignette            true            // Apply vignette as a post-process\n\n#define kBloomGain            10.0             // The strength of the bloom effect \n#define kBloomTint            vec4(1.0)       // The tint applied to the bloom effect\n#define kBloomWidth           0.08             // The width of the bloom effect as a proportion of the buffer width\n#define kBloomHeight          0.08             // The height of the bloom effect as a proportion of the buffer height\n#define kBloomShape           4.0             // The fall-off of the bloom shape. Higher value = steeper fall-off\n#define kBloomDownsample      3              // How much the bloom buffer is downsampled. Higher value = lower quality, but faster\n#define kDebugBloom           false           // Show only the bloom in the final comp\n#define kBloomBurnIn          vec4(0.5)\n\n#define kVignetteStrength         0.5             // The strength of the vignette effect\n#define kVignetteScale            1.2             // The scale of the vignette effect\n#define kVignetteExponent         2.0             // The rate of attenuation of the vignette effect\n\n#define kAA 1\n\n#define kMetaSpeed            0.07\n#define kMetaSpeedVariance    0.5\n#define kMetaSpread           0.008\n#define kMetaAA               3.0\n#define kMetaColourPhase      0.0003\n#define kMetaThreshold        8.0\n#define kMetaDiffusion        0.01\n#define kMetaPulse            true\n\n#define kResolution           0\n#if kResolution == 0\n    #define kNumMetaballs         250\n    #define kMetaCharge           0.0018\n    #define kMetaChargeVariance   0.8\n    #define kMetaChargeExponent   2.0\n    #define kMetaSpreadVariance   0.6\n    #define kMetaSpreadExponent   0.3\n#else\n    #define kNumMetaballs         500\n    #define kMetaCharge           0.0013\n    #define kMetaChargeVariance   0.9\n    #define kMetaChargeExponent   3.0\n    #define kMetaSpreadVariance   0.8\n    #define kMetaSpreadExponent   0.3\n#endif\n\n#define kAnimationCycle       20.0\n#define kOpenTransition       3.0\n#define kCloseTransition      2.0\n#define kTimeStretch          1.0\n#define kTimeDelay            0.0\n#define kTimeStartAt          0.0\n\n#define kPi                    3.14159265359\n#define kTwoPi                 (2.0 * kPi)\n#define kHalfPi                (0.5 * kPi)\n#define kRoot2                 1.41421356237\n#define kFltMax                3.402823466e+38\n#define kIntMax                0x7fffffff\n#define kOne                   vec3(1.0)\n#define kZero                  vec3(0.0)\n#define kPink                  vec3(1.0, 0.0, 0.2)\nfloat toRad(float deg)         { return kTwoPi * deg / 360.0; }\nfloat toDeg(float rad)         { return 360.0 * rad / kTwoPi; }\nfloat sqr(float a)             { return a * a; }\n//int sqr(int a)                 { return a * a; }\nint mod2(int a, int b)         { return ((a % b) + b) % b; }\nfloat length2(vec2 v)          { return dot(v, v); }\nfloat length2(vec3 v)          { return dot(v, v); }\nint sum(ivec2 a)               { return a.x + a.y; }\nfloat luminance(vec3 v)        { return v.x * 0.17691 + v.y * 0.8124 + v.z * 0.01063; }\nfloat mean(vec3 v)             { return v.x / 3.0 + v.y / 3.0 + v.z / 3.0; }\n//vec4 mul4(vec3 a, mat4 m)      { return vec4(a, 1.0) * m; }\n//vec3 mul3(vec3 a, mat4 m)      { return (vec4(a, 1.0) * m).xyz; }\nfloat saturate(float a)        { return clamp(a, 0.0, 1.0); }\nfloat sin01(float a)           { return 0.5 * sin(a) + 0.5; }\nfloat cos01(float a)           { return 0.5 * cos(a) + 0.5; }\n\nivec2 kFragCoord;\nuvec4 rngSeed; \n\n// Maps the input xy texel coordinates to UV [0.0, 1.0] and distance R from center\nvec2 xyToUv(in vec2 xy, in vec3 iResolution)\n{\n    vec2 uv = vec2(xy.x / iResolution.x, xy.y / iResolution.y);\n    uv.x = (uv.x - 0.5) * (iResolution.x / iResolution.y) + 0.5;     \n    return uv;\n}\n\n// Maps the input xy texel coordinates to UV [-1.0, 1.0] and distance R from center\nvec3 xyToUvr(in vec2 xy, in vec3 iResolution)\n{\n    vec2 uv = xyToUv(xy, iResolution);    \n    float x = 2.0 * (uv.x - 0.5);\n    float y = 2.0 * (uv.y - 0.5);\n    \n    return vec3(uv, sqrt(x*x + y*y) / kRoot2);\n}\n\n// Permuted congruential generator from \"Hash Functions for GPU Rendering\" (Jarzynski and Olano)\n// http://jcgt.org/published/0009/03/02/paper.pdf\nuvec4 pcgAdvance()\n{\n    rngSeed = rngSeed * 1664525u + 1013904223u;\n    \n    rngSeed.x += rngSeed.y*rngSeed.w; \n    rngSeed.y += rngSeed.z*rngSeed.x; \n    rngSeed.z += rngSeed.x*rngSeed.y; \n    rngSeed.w += rngSeed.y*rngSeed.z;\n    \n    rngSeed ^= rngSeed >> 16u;\n    \n    rngSeed.x += rngSeed.y*rngSeed.w; \n    rngSeed.y += rngSeed.z*rngSeed.x; \n    rngSeed.z += rngSeed.x*rngSeed.y; \n    rngSeed.w += rngSeed.y*rngSeed.z;\n    \n    return rngSeed;\n}\n\n// Seed the PCG hash function with the current frame multipled by a prime\nvoid pcgInitialise(int frame)\n{    \n    rngSeed = uvec4(20219u, 7243u, 12547u, 28573u) * uint(frame);\n}\n\n// Generates a tuple of canonical random number and uses them to sample an input texture\nvec4 randX(sampler2D sampler)\n{\n    //return texelFetch(sampler, (kFragCoord + ivec2(pcgAdvance() >> 16)) % 1024, 0);\n    return texture(sampler, (vec2((kFragCoord + ivec2(pcgAdvance() >> 16)) % 1024)+0.5)/iR);\n}\n\n// Generates a tuple of canonical random numbers in the range [0, 1]\nvec4 rand()\n{\n    return vec4(pcgAdvance()) / float(0xffffffffu);\n}\n\nvec3 hue(float phi)\n{\n    float phiColour = 6.0 * phi / kTwoPi;\n    int i = int(phiColour);\n    vec3 c0 = vec3(((i + 4) / 3) & 1, ((i + 2) / 3) & 1, ((i + 0) / 3) & 1);\n    vec3 c1 = vec3(((i + 5) / 3) & 1, ((i + 3) / 3) & 1, ((i + 1) / 3) & 1);             \n    return clamp(mix(c0, c1, phiColour - float(i)), kZero, kOne);\n}\n\nvec3 hue(float phi, float saturation, float brightness)\n{\n    vec3 rgb = hue(phi);\n    \n    rgb = mix(vec3(0.5), rgb, saturation);\n    \n    return (brightness < 0.5) ? mix(kZero, rgb, brightness * 2.0) :\n                                mix(rgb, kOne, (brightness - 0.5) * 2.0);\n}\n\nvec2 bezier(vec2 u0, vec2 u1, vec2 u2, vec2 u3, float t)\n{\n    vec2 v0 = mix(u0, u1, t);\n    vec2 v1 = mix(u1, u2, t);\n    vec2 v2 = mix(u2, u3, t);\n    vec2 w0 = mix(v0, v1, t);\n    vec2 w1 = mix(v1, v2, t);\n    \n    return mix(w0, w1, t);    \n}\n\nvec3 metaColour(vec2 t)\n{\n    #define sat 1.3\n    #define light 0.5\n    \n    //t.x = fract(t.x * 10.0);\n    \n    t.x = fract(t.x + 0.01);    \n    \n    //h = (fract(t * 2.0) < 0.5) ? hue(0.0, 0.0, 0.9) : clamp(hue(0.0, 1.2, 0.5), vec3(0.0), vec3(1.0));\n    if(t.x < 0.333) { return hue(kTwoPi * (0.11 + t.y * 0.03), sat, light); }\n    else if(t.x < 0.666) { return hue(kTwoPi * (0.92 + t.y * 0.03), sat, light); }\n    return hue(kTwoPi * (0.55 + t.y * 0.03), sat, light); \n}\n\nvec2 heartPath(float t)\n{\n    vec2 dir = (t < 0.5) ? vec2(1.0, -1.0) : vec2(-1.0, -1.0);\n    if(t >= 0.5) { t = 1.0 - t; }\n    t *= 2.0;\n    \n    if(t < 0.5)\n    {\n        return bezier(vec2(-1.5266667e-6,-24.039329), \n                      vec2(-19.654762,-56.545271), \n                      vec2(-50.316625,-43.202057), \n                      vec2(-50.270832,-19.881592), t * 2.0) * dir;\n    }\n    else\n    {\n        return bezier(vec2(-50.270832,-19.881592), \n                      vec2(-50.270832 + 0.04579,-19.881592 + 23.3204663), \n                      vec2(-50.270832 + 38.50771,-19.881592+31.238355), \n                      vec2(-50.270832+50.22497425,-19.881592+73.193701), (t - 0.5) * 2.0) * dir;\n    }   \n}\n\nvec3 charge(vec4 xi1, vec4 xi2, float time)\n{           \n    vec3 p = kZero;\n    float t = mod(kMetaSpeed * mix(1.0 - kMetaSpeedVariance, 1.0, xi2.x) * time + xi2.y, 1.0);\n    float pulse = 1.0;\n    \n    if(time < kOpenTransition)\n    {\n        float delta = smoothstep(0.0, 1.0, time / kOpenTransition);   \n        pulse = delta;\n        \n        p.z = pow(saturate((delta - (xi2.y * 0.8)) * 5.0), 0.3) * kMetaCharge * mix(1.0 - kMetaChargeVariance, 1.0, pow(xi1.y, kMetaChargeExponent));\n    }\n    else if(kAnimationCycle - time < kCloseTransition)\n    {\n        float delta = 1.0 - (kAnimationCycle - time) / kCloseTransition;        \n        delta = cos(kPi + kPi * delta) * 0.5 + 0.5;\n        pulse = 1.0 - delta;\n        \n        p.y = -pow(delta, 2.0 + xi1.x) * mix(1.0, 2.0, xi1.y);\n        p.z = kMetaCharge * mix(1.0 - kMetaChargeVariance, 1.0, pow(xi1.y, kMetaChargeExponent)) * mix(1.0, 0.5, pow(delta, 2.0));  \n    }\n    else\n    {\n        p.z = kMetaCharge * mix(1.0 - kMetaChargeVariance, 1.0, pow(xi1.y, kMetaChargeExponent));\n    }\n    \n    float d = kMetaSpread * mix(1.0 - kMetaSpreadVariance, 1.0, pow(xi1.y, kMetaSpreadExponent));    \n    if(kMetaPulse) d += kMetaSpread * mix(0.0, max(0.0, sin(time * 5.0)), 0.05 * pulse);\n    p.xy = heartPath(t) * d + vec2(0.0, 0.015) + p.xy;\n \n    return p;\n}\n\nvoid field(in vec2 xy, in float time, vec3 iResolution, out float F, out vec2 delF, out vec3 colour, sampler2D sampler)\n{      \n    pcgInitialise(0);\n    \n    F = 0.0;\n    delF = vec2(0.0);\n    float denom = 0.0;\n    float sumWeights = 0.0;\n    colour = kZero;\n    \n    vec2 aspectRatio = vec2(iResolution.x / iResolution.y, 1.0);\n     \n    for(int i = 0; i < kNumMetaballs; i++)\n    {\n        vec4 xi1 = rand();        \n        vec4 xi2 = rand();\n        vec3 p = charge(xi1, xi2, time);    \n        \n        F += p.z / length2(xy - p.xy);\n        \n        float n = sqr(xy.x - p.x) + sqr(xy.y - p.y);\n        delF.x += -p.z * 2.0 * (xy.x - p.x) / sqr(n);\n        delF.y += -p.z * 2.0 * (xy.y - p.y) / sqr(n);\n        \n        denom += p.z / n;\n        \n        float weight = pow(min(1e5, 1.0 / length2(xy - p.xy)), 2.0);\n        \n        if(weight > 1e-2)\n        {        \n            //vec3 h = texelFetch(sampler, ivec2(i, 0), 0).rgb;\n            vec3 h = texture(sampler, (vec2(i, 0)+0.5)/iResolution.xy).rgb;\n            \n            if(length2(h) == 0.0)\n            {\n                h = metaColour(vec2(xi2.y, xi2.x));\n            }\n       \n            colour += h * weight;\n            sumWeights += weight;\n        }\n    }\n    \n    colour /= sumWeights;    \n    F = 1.0 / sqrt(F) - 1.0 / sqrt(kMetaThreshold);   \n    delF = -0.5 * delF / pow(denom, 1.5);\n}\n\nvec4 renderMetaballs(vec2 fragCoord, vec3 iResolution, float iTime, sampler2D sampler, sampler2D colourMap)\n{                \n    vec2 xy = vec2((fragCoord.x - 0.5 * iResolution.x) / iResolution.y, \n                   (fragCoord.y - 0.5 * iResolution.y) / iResolution.y);\n                   \n    //xy = xy * 0.1 + vec2(0.27, 0.27);\n    //xy = xy * 0.1 - vec2(0.13, 0.13);\n\n    float F;\n    vec2 delF;\n    vec3 colour;\n    field(xy, iTime, iResolution, F, delF, colour, colourMap);   \n    \n    if(kAnimationCycle - iTime < kCloseTransition)\n    {\n        float delta = 1.0 - (kAnimationCycle - iTime) / kCloseTransition;        \n        colour = mix(colour, kZero, saturate(pow(delta * 2.0, 2.0)));\n    }\n\n    float delFLength = length(delF);\n    vec2 delFNorm = delF / ((delFLength > 1.0) ? delFLength : 1.0);\n            \n    delFNorm = delFNorm * 0.5 + vec2(0.5);    \n    \n    float FMax = (kMetaAA / iResolution.x) * length(delF);          \n    if(F < FMax)\n    {        \n        float alpha = min(1.0, (FMax - F) / FMax);\n        float z = pow(min(1.0, -F * 2.5), 0.5);\n        vec3 normal = normalize(vec3(delFNorm * (1.0 - z), z));                \n                \n        float L = pow(luminance(texture(sampler, normal.xy, 0.0).xyz), 2.0);\n        //return vec4(mix(colour, kOne, L), mix(0.05 * alpha, 0.05 + L, clamp(-F, 0.0, 1.0))); \n        return vec4(mix(colour, kOne, L), mix(0.05 * alpha, 0.05 + L, clamp(-F / 0.01, 0.0, 1.0))); \n    }   \n    else\n    {\n        return vec4(0.0);\n    }  \n}\n\n// Seperable bloom function. This filter requires two passes in the horizontal and vertical directions which are combined as a post-process\n// effect after each frame. The accuracy/cost of the effect can be tuned by dialing the kBloomDownsample parameter. \nvec4 bloom(vec2 fragCoord, vec3 iResolution, ivec2 delta, sampler2D renderSampler)\n{        \n    vec2 scaledResolution = vec2(iResolution.x, iResolution.y) / float((delta.x == 1) ? kBloomDownsample : 1);\n   \n    if(fragCoord.x > scaledResolution.x || fragCoord.y > scaledResolution.y) { return vec4(0.0); }\n    \n    float bloomSize = (delta.x == 1) ? kBloomWidth : kBloomHeight;\n    \n    int kKernelWidth = int(bloomSize * max(iResolution.x, iResolution.y) + 0.5) / ((delta.x == 1) ? kBloomDownsample : 1);\n    vec4 sumWeights = vec4(0.0);\n    vec4 sumRgb = vec4(0.0);\n    for(int i = -kKernelWidth; i <= kKernelWidth; i++)\n    {      \n        vec2 xy = vec2(fragCoord.x + float(i * delta.x), fragCoord.y + float(i * delta.y));\n        \n        if(delta.x == 1) { xy *= float(kBloomDownsample); }\n        else { xy /= float(kBloomDownsample); }\n        \n        if(xy.x < 0.0 || xy.x > iResolution.x || xy.y < 0.0 || xy.y > iResolution.y) { continue; }\n            \n        vec4 rgb = texture(renderSampler, xy / iResolution.xy);\n        float d = float(abs(i)) / float(kKernelWidth);\n           \n        vec4 weight = vec4(1.0);\n        if(i != 0)\n        {\n            // Currently using a single weight although this effect can be done per-channel\n            float kernel = pow(max(0.0, (exp(-sqr(d * 4.0)) - 0.0183156) / 0.981684), kBloomShape);            \n            weight = vec4(1.0) * kernel;\n        }\n            \n        sumRgb += ((delta.y == 1) ? rgb : max(vec4(0.0), rgb - kBloomBurnIn)) * weight;         \n        sumWeights += weight;\n    }\n    \n    sumRgb = sumRgb / sumWeights;\n    \n    return (delta.x == 1) ? sumRgb : (sumRgb * kBloomTint);\n}",
   "name": "Common",
   "description": "",
   "type": "common"
  },
  {
   "inputs": [
    {
     "id": "4dfGRn",
     "filepath": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg",
     "type": "texture",
     "channel": 0,
     "sampler": {
      "filter": "mipmap",
      "wrap": "repeat",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    },
    {
     "id": "4sXGR8",
     "filepath": "/media/previz/buffer02.png",
     "type": "buffer",
     "channel": 1,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    }
   ],
   "outputs": [
    {
     "id": "4dXGR8",
     "channel": 0
    }
   ],
   "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    iR = iResolution.xy;\n    \n    kFragCoord = ivec2(fragCoord);\n    \n    float time = mod(max(0.0, iTime - kTimeDelay) / kTimeStretch, kAnimationCycle);\n    if(time > 0.0) { time += kTimeStartAt; }\n    \n    #if kApplyBloom == 1   \n    {\n        fragColor = renderMetaballs(fragCoord, iResolution, time, iChannel0, iChannel1);\n    }\n    #endif\n}",
   "name": "Buffer A",
   "description": "",
   "type": "buffer"
  },
  {
   "inputs": [
    {
     "id": "4dXGR8",
     "filepath": "/media/previz/buffer00.png",
     "type": "buffer",
     "channel": 0,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    }
   ],
   "outputs": [
    {
     "id": "XsXGR8",
     "channel": 0
    }
   ],
   "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\niR = iResolution.xy;\n\n    #if kApplyBloom == 1   \n    {    \n        fragColor = bloom(fragCoord, iResolution, ivec2(1, 0), iChannel0);\n    }\n    #endif\n}",
   "name": "Buffer B",
   "description": "",
   "type": "buffer"
  },
  {
   "inputs": [
    {
     "id": "4sXGR8",
     "filepath": "/media/previz/buffer02.png",
     "type": "buffer",
     "channel": 0,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    }
   ],
   "outputs": [
    {
     "id": "4sXGR8",
     "channel": 0
    }
   ],
   "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\niR = iResolution.xy;\n\n    ivec2 xy = ivec2(fragCoord);\n    \n    float time = mod(max(0.0, iTime - kTimeDelay) / kTimeStretch, kAnimationCycle);\n    \n    if(xy.x == 0 && xy.y == 2) { fragColor = vec4(time); }\n    //float lastTime = texelFetch(iChannel0, ivec2(0, 2), 0).x;\n    float lastTime = texture(iChannel0, (vec2(0, 2)+0.5)/iR).x;\n    \n    if(xy.x >= kNumMetaballs || xy.y >= 2) { return; }\n    \n    int y0 = iFrame % 2;\n    int y1 = (iFrame + 1) % 2;\n    \n    //vec4 texel = texelFetch(iChannel0, xy, 0);\n    vec4 texel = texture(iChannel0, (vec2(xy)+0.5)/iR);\n    \n    if(xy.y == y1) \n    { \n        fragColor = texel; \n        return; \n    }\n        \n    vec2 aspectRatio = vec2(iResolution.x / iResolution.y, 1.0);\n    \n    pcgInitialise(0);\n    \n    vec4 p[kNumMetaballs]; \n    for(int i = 0; i < kNumMetaballs; i++)\n    {\n        vec4 xi1 = rand();        \n        vec4 xi2 = rand();\n        vec3 v = charge(xi1, xi2, time);  \n        \n        p[i] = vec4(v.xy, xi2.y, xi2.x);        \n    }\n    \n    if(time < 1.0 || length2(texel.rgb) == 0.0)\n    {\n        fragColor = vec4(metaColour(p[xy.x].zw), 0.0);\n        return;\n    }\n    \n    /*float delta = 1.0 - (kAnimationCycle - time) / kCloseTransition;\n    if(delta > 0.0)\n    {\n        float delta = cos(kPi + kPi * delta) * 0.5 + 0.5;            \n        fragColor = mix(texelFetch(iChannel0, xy, 0), vec4(metaColour(p[xy.x].zw), 0.0), pow(delta, 3.0));\n        return;\n    } */ \n    \n    float sumWeights = 0.0;        \n    vec3 colour = vec3(0.0);\n    for(int i = 0; i < kNumMetaballs; i++)\n    {               \n        #define kMaxDist 0.1\n        float weight = pow(max(0.0, 1.0 - length(p[xy.x].xy - p[i].xy) / kMaxDist), 1.0); \n\n        //colour += texelFetch(iChannel0, ivec2(i, y1), 0).rgb * weight;\n        colour += texture(iChannel0, (vec2(i, y1)+0.5)/iR).rgb * weight;\n        \n        sumWeights += weight;\n    }\n    \n    colour /= sumWeights;\n    //vec3 thisColour = texelFetch(iChannel0, ivec2(xy.x, y1), 0).rgb;   \n    vec3 thisColour = texture(iChannel0, (vec2(xy.x, y1)+0.5)/iR).rgb;  \n    \n    //thisColour = mix(thisColour, kOne * 0.7, 0.001);\n    fragColor.xyz = mix(thisColour, colour, kMetaDiffusion / kTimeStretch);\n    \n}",
   "name": "Buffer C",
   "description": "",
   "type": "buffer"
  }
 ]
}