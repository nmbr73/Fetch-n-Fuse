{"Shader":{"ver":"0.1","info":{"id":"NssczB","date":"1642312685","viewed":250,"name":"Primordial Soup System","username":"davidar","description":"A continuous version of the [url=https:\/\/nagualdesign.github.io\/]Primordial Particle System[\/url] (also see [url]https:\/\/www.shadertoy.com\/view\/Wdj3zm[\/url]), using reintegration tracking.","likes":14,"published":3,"flags":32,"usePreview":0,"tags":["simulation","fluid","automata","life","cell","particle","ecology","reintegration"],"hasliked":0},"renderpass":[{"inputs":[{"id":258,"src":"\/media\/previz\/buffer01.png","ctype":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":37,"channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = vec4(0,0,0,1);\n    vec2 uv = fragCoord \/ iResolution.xy;\n\n    vec4 data = texture(iChannel0, fragCoord \/ iResolution.xy);\n    particle P = getParticle(data, fragCoord);\n    vec2 vel = P.V;\n\n    fragColor = vec4(pow(clamp(P.M, 0., 1.), .4));\n    fragColor.rgb *= .6 + .6 * cos(3.5*fragColor.x + vec3(0,23,21));\n\n    if(iMouse.z > 0. && length(iMouse.xy - fragCoord) < 10.) fragColor += 0.5;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":258,"src":"\/media\/previz\/buffer01.png","ctype":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":257,"channel":0}],"code":"#define MAX_SPEED 1.9\n#define MAX_FORCE 0.05\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = vec4(0);\n    vec2 uv = fragCoord\/iResolution.xy;\n    if(iFrame < 10) {\n        float q = 2.*PI * hash12(1. + fragCoord);\n        particle P;\n        P.X = fragCoord;\n        P.V = MAX_SPEED * vec2(cos(q), sin(q));\n        P.M = .45 - abs(fragCoord.x\/iResolution.x - 0.5);\n        fragColor = saveParticle(P, fragCoord);\n        return;\n    }\n    \n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    particle P = getParticle(data, fragCoord);\n    vec2 pos = P.X, vel = P.V;\n\n    float r = 0., l = 0.;\n\n    for(int i = -RADIUS; i <= RADIUS; i++) {\n        for(int j = -RADIUS; j <= RADIUS; j++) {\n            vec2 ij = vec2(i,j);\n            if(ij == vec2(0) || length(ij) > float(RADIUS)) continue;\n\n            vec4 data2 = texelFetch(iChannel0, ivec2(mod(fragCoord + ij, iResolution.xy)), 0);\n            particle P2 = getParticle(data2, fragCoord + ij);\n            vec2 pos2 = P2.X;\n            float m = P2.M;\n\n            vec2 d = pos - pos2;\n            float side = dot(vel, vec2(-d.y, d.x));\n            if(side > 0.0)\n                r += m;\n            else\n                l += m;\n        }\n    }\n\n    float angle = atan(vel.y, vel.x);\n    angle += ALPHA + BETA * (r + l) * tanh(r - l);\n    P.V = vec2(cos(angle), sin(angle));\n    fragColor = saveParticle(P, fragCoord);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":258,"channel":0}],"code":"\/\/ reintegration tracking code from https:\/\/www.shadertoy.com\/view\/ttBcWm\n#define Bi(p) ivec2(mod(p,iResolution.xy))\n#define texel(a, p) texelFetch(a, Bi(p), 0)\n\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n#define dt 1.5\n\nvec3 distribution(vec2 x, vec2 p, float K)\n{\n    vec4 aabb0 = vec4(p - 0.5, p + 0.5);\n    vec4 aabb1 = vec4(x - K*0.5, x + K*0.5);\n    vec4 aabbX = vec4(max(aabb0.xy, aabb1.xy), min(aabb0.zw, aabb1.zw));\n    vec2 center = 0.5*(aabbX.xy + aabbX.zw); \/\/center of mass\n    vec2 size = max(aabbX.zw - aabbX.xy, 0.); \/\/only positive\n    float m = size.x*size.y\/(K*K); \/\/relative amount\n    \/\/if any of the dimensions are 0 then the mass is 0\n    return vec3(center, m);\n}\n\n\/\/diffusion and advection basically\nvoid Reintegration(sampler2D ch, inout particle P, vec2 pos)\n{\n    \/\/basically integral over all updated neighbor distributions\n    \/\/that fall inside of this pixel\n    \/\/this makes the tracking conservative\n    range(i, -3, 3) range(j, -3, 3)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n       \n        particle P0 = getParticle(data, tpos);\n       \n        P0.X += P0.V*dt; \/\/integrate position\n\n        vec3 D = distribution(P0.X, pos, DIFFUSION);\n        \/\/the deposited mass into this cell\n        float m = P0.M*D.z;\n        \n        \/\/add weighted by mass\n        P.X += D.xy*m;\n        P.V += P0.V*m;\n        \n        \/\/add mass\n        P.M += m;\n    }\n    \n    \/\/normalization\n    if(P.M != 0.)\n    {\n        P.X \/= P.M;\n        P.V \/= P.M;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    particle P;\n    Reintegration(iChannel0, P, fragCoord);\n    fragColor = saveParticle(P, fragCoord);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define RADIUS 8\n#define DIFFUSION 1.12\n#define MAX_DENSITY 4.\n\n#define ALPHA radians(uv.y < .5 ? 117. :  0.) \/\/ intrinsic turning angle\n#define BETA  radians(uv.y < .5 ?  -4. : 13.) \/\/ reactive turning angle\n\n#define PI 3.14159265359\n\nstruct particle {\n    vec2 X, V;\n    float M;\n};\n\nparticle getParticle(vec4 data, vec2 pos) {\n    particle P;\n    if (data == vec4(0)) return P;\n    P.X = data.xy + pos;\n    P.M = data.z;\n    P.V = vec2(cos(data.w), sin(data.w));\n    return P;\n}\n\nvec4 saveParticle(particle P, vec2 pos) {\n    return vec4(clamp(P.X - pos, -.5, .5), clamp(P.M, 0., MAX_DENSITY), atan(P.V.y, P.V.x));\n}\n\n\/\/ Hash without Sine\n\/\/ Creative Commons Attribution-ShareAlike 4.0 International Public License\n\/\/ Created by David Hoskins.\n\n\/\/ https:\/\/www.shadertoy.com\/view\/4djSRW\n\/\/ Trying to find a Hash function that is the same on ALL systens\n\/\/ and doesn't rely on trigonometry functions that change accuracy \n\/\/ depending on GPU. \n\/\/ New one on the left, sine function on the right.\n\/\/ It appears to be the same speed, but I suppose that depends.\n\n\/\/ * Note. It still goes wrong eventually!\n\/\/ * Try full-screen paused to see details.\n\n\n#define ITERATIONS 4\n\n\n\/\/ *** Change these to suit your range of random numbers..\n\n\/\/ *** Use this for integer stepped ranges, ie Value-Noise\/Perlin noise functions.\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(.1031, .1030, .0973, .1099)\n\n\/\/ For smaller input rangers like audio tick or 0-1 UVs use these...\n\/\/#define HASHSCALE1 443.8975\n\/\/#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n\/\/#define HASHSCALE4 vec3(443.897, 441.423, 437.195, 444.129)\n\n\n\n\/\/----------------------------------------------------------------------------------------\n\/\/  1 out, 1 in...\nfloat hash11(float p)\n{\n        vec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n        vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n        p3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/  2 out, 1 in...\nvec2 hash21(float p)\n{\n        vec3 p3 = fract(vec3(p) * HASHSCALE3);\n        p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/\/  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n        vec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/\/  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n        p3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * HASHSCALE3);\n   p3 += dot(p3, p3.yzx+19.19);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n\/\/----------------------------------------------------------------------------------------\n\/\/\/  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n        vec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/\/  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n        p3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/ 4 out, 1 in...\nvec4 hash41(float p)\n{\n        vec4 p4 = fract(vec4(p) * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/ 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n        vec4 p4 = fract(vec4(p.xyxy) * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/ 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n        vec4 p4 = fract(vec4(p.xyzx)  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/ 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n        p4 = fract(p4  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n","name":"Common","description":"","type":"common"}]}}