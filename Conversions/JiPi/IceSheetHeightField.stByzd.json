{"Shader":{"ver":"0.1","info":{"id":"stByzd","date":"1650107993","viewed":20,"name":"Ice sheet height field","username":"mrange","description":"CC0: Ice sheet height field experimentation\nWas tinkering with using recursive voronoi patterns to\ngenerate something that could pass for ice breaking up\ninto smaller blocks","likes":4,"published":3,"flags":0,"usePreview":0,"tags":["2d","height"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"id":37,"channel":0}],"code":"\/\/ CC0: Ice sheet height field experimentation\n\/\/  Was tinkering with using recursive voronoi patterns to\n\/\/  generate something that could pass for ice breaking up\n\/\/  into smaller blocks\n#define RESOLUTION  iResolution\n#define TIME        iTime\n\n\/\/ License: Unknown, author: Unknown, found: don't remember\nvec2 hash2(vec2 p) {\n  p = vec2(dot (p, vec2 (127.1, 311.7)), dot (p, vec2 (269.5, 183.3)));\n  return fract (sin (p)*43758.5453123);\n}\n\n\/\/ From: https:\/\/www.shadertoy.com\/view\/MsScWz\n\/\/ Originally from: https:\/\/www.shadertoy.com\/view\/ldl3W8\nvec3 voronoi(vec2 x) {\n  vec2 n = floor(x);\n  vec2 f = fract(x);\n\n  vec2 mr;\n  vec2 mp;\n\n  float md = 8.0;\n  for(int j=-1; j<=1; ++j)\n  for(int i=-1; i<=1; ++i) {\n    vec2 g = vec2(float(i),float(j));\n    vec2 o = hash2(n + g);\n    vec2 r = g + o - f;\n    float d = dot(r,r);\n\n    if(d<md) {\n      md = d;\n      mr = r;\n      mp = x+r;\n    }\n  }\n\n  md = 8.0;\n  for(int j=-1; j<=1; ++j)\n  for(int i=-1; i<=1; ++i) {\n    vec2 g = vec2(float(i),float(j));\n    vec2 o = hash2(n + g);\n    vec2 r = g + o - f;\n\n    if(dot(mr-r,mr-r)>0.0001) \/\/ skip the same cell\n      md = min(md, dot(0.5*(mr+r), normalize(r-mr)));\n  }\n\n  return vec3(md, mp);\n}\n\nfloat height(vec2 p) {\n  vec2 vp = p;\n  float vz = 1.0;\n  \n  const float aa = 0.025;\n\n  float gh = 0.0;\n  float hh = 0.0;\n\n  const float hf = 0.025;\n\n  \/\/ Recursive voronois\n  {\n    vec3 c = voronoi(vp);\n    gh = tanh(max(abs(0.35*(c.y-2.0*sin(0.25*c.z)*cos(sqrt(0.1)*c.z)))-0.4, 0.));\n    hh = smoothstep(-aa, aa, c.x-2.0*aa*smoothstep(1.0, 0.75, gh));\n    if (gh > 0.75) {    \n      return hf*tanh(hh+1.0*(gh-0.75));\n    }\n\n    vz *= 0.5;\n    vp = vp * 2.0;\n  }\n\n  {\n    vec3 c = voronoi(vp);\n    hh = hh*smoothstep(-aa, aa, vz*c.x-3.0*aa*smoothstep(1.0, 0.5, gh));\n    if (gh > 0.5) {\n      return 0.75*hf*hh;\n    }\n\n    vz *= 0.5;\n    vp = vp * 2.0;\n  }\n\n  {\n    vec3 c = voronoi(vp);\n    hh = hh*smoothstep(-aa, aa, vz*c.x-2.0*aa*smoothstep(0.9, 0.25, gh));\n    if (gh > 0.25) {\n      return 0.5*hf*hh;\n    }\n\n    vz *= 0.5;\n    vp = vp * 2.0;\n  }\n  \n  return 0.0;\n}\n\nvec3 normal(vec2 p) {\n  vec2 v;\n  vec2 w;\n  vec2 e = vec2(4.0\/RESOLUTION.y, 0);\n  \n  vec3 n;\n  n.x = height(p + e.xy) - height(p - e.xy);\n  n.y = 2.0*e.x;\n  n.z = height(p + e.yx) - height(p - e.yx);\n  \n  return normalize(n);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord\/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x\/RESOLUTION.y;\n  float aa = 2.0\/RESOLUTION.y;\n  \n  float z = mix(0.2, 0.5, smoothstep(-0.5, 0.5, sin(0.5*TIME)));\n\n  vec2 ip = p;\n  ip \/= z;\n  ip.y += 0.5*TIME;\n  float h = height(ip);\n  vec3 n  = normal(ip);\n \n  vec3 ro = vec3(0.0, -1.0, 0.0);\n  vec3 lp = vec3(1.0, -0.95, 1.5);\n  vec3 pp = vec3(p.x, h, p.y);;\n  vec3 rd = normalize(ro-pp);\n  vec3 ld = normalize(pp-lp);\n  vec3 ref= reflect(rd, n);\n  \n  float dif = max(dot(n, ld), 0.0)*tanh(200.0*h);\n  float spe = pow(max(dot(ref, ld), 0.0), 10.0);\n \n  vec3 col = vec3(0.);\n  col += dif;\n  col += spe;\n  \n  \n  fragColor = vec4(col, 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}}