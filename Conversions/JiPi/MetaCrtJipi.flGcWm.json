{
 "ver": "0.1",
 "info": {
  "id": "flGcWm",
  "date": "0",
  "viewed": 0,
  "name": "Meta CRT JiPi",
  "description": "Experiments with CRT screen material with scanlines and RGB elements.\nPost FX include temporal AA, depth of field and motion blur.",
  "likes": 0,
  "published": "Private",
  "usePreview": 0,
  "tags": [
   "motionblur",
   "dof",
   "crt",
   "depthoffield",
   "temporalaa",
   "taa"
  ],
  "hasliked": 0,
  "parentid": "4dlyWX",
  "parentname": "Meta CRT"
 },
 "renderpass": [
  {
   "inputs": [
    {
     "id": "XdfGR8",
     "filepath": "/media/previz/buffer03.png",
     "type": "buffer",
     "channel": 0,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    }
   ],
   "outputs": [
    {
     "id": "4dfGRr",
     "channel": 0
    }
   ],
   "code": "// Meta CRT - @P_Malin\n// https://www.shadertoy.com/view/4dlyWX#\n// In which I add and remove aliasing\n\n// Uncomment different defines in Buf B to run different shaders on TV\n\n// Postprocessing Pass\n// Motion blur, Depth of Field, Vignetting & Tonemap\n\n\n#define ENABLE_DOF\n#define ENABLE_MOTION_BLUR\n\n\n\nvec3 Tonemap( vec3 x )\n{\n#if 0 \n    \n    vec3 luminanceCoeffsBT709 = vec3( 0.2126f, 0.7152f, 0.0722f );\n    float f = dot( x, luminanceCoeffsBT709 );\n    x /= f;        \n    f = 1.0f - exp(-f);    \n    x *= f;    \n    x = mix( x, vec3(f), f*f );\n    \n    return x;\n#else       \n    float a = 0.010;\n    float b = 0.132;\n    float c = 0.010;\n    float d = 0.163;\n    float e = 0.101;\n\n    return ( x * ( a * x + b ) ) / ( x * ( c * x + d ) + e );    \n#endif    \n}\n\n\nfloat GetVignetting( const in vec2 vUV, float fScale, float fPower, float fStrength )\n{\n\tvec2 vOffset = (vUV - 0.5) * sqrt(2.0) * fScale;\n\t\n\tfloat fDist = max( 0.0, 1.0 - length( vOffset ) );\n    \n\tfloat fShade = 1.0 - pow( fDist, fPower );\n    \n    fShade = 1.0 - fShade * fStrength;\n\n\treturn fShade;\n}\n\n\n\n\nfloat GetCoC( float fDistance, float fPlaneInFocus )\n{\n#ifdef ENABLE_DOF    \n\t// http://http.developer.nvidia.com/GPUGems/gpugems_ch23.html\n\n    float fAperture = min(1.0, fPlaneInFocus * fPlaneInFocus * 0.5);\n    float fFocalLength = 0.03;\n    \n\treturn abs(fAperture * (fFocalLength * (fDistance - fPlaneInFocus)) /\n          (fDistance * (fPlaneInFocus - fFocalLength)));  \n#else\n    return 0.0f;\n#endif    \n}\n\n// Depth of field pass\n\n#define BLUR_TAPS 64\nfloat fGolden = 3.141592 * (3.0 - sqrt(5.0));\n\n#define MOD2 vec2(4.438975,3.972973)\n\nfloat Hash( float p ) \n{\n    // https://www.shadertoy.com/view/4djSRW - Dave Hoskins\n\tvec2 p2 = fract(vec2(p) * MOD2);\n    p2 += dot(p2.yx, p2.xy+19.19);\n\treturn fract(p2.x * p2.y);    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    CameraState camCurr;\n\tCam_LoadState( camCurr, iChannel0, ivec2(0) );\n\n    CameraState camPrev;\n\tCam_LoadState( camPrev, iChannel0, ivec2(3,0) );\n    \n\tvec2 vUV = fragCoord.xy / iResolution.xy;\n \t//vUV -= camCurr.vJitter / iResolution.xy;    // TAA has removed jitter\n\n    vec4 vSample = texelFetch( iChannel0, ivec2(fragCoord.xy), 0 ).rgba;\n    \n    int iObjectId;\n    float fDepth = DecodeDepthAndObjectId( vSample.w, iObjectId );\n    \n    vec3 vRayOrigin, vRayDir;\n    \n    Cam_GetCameraRay( vUV, iResolution.xy, camCurr, vRayOrigin, vRayDir );    \n    vec3 vWorldPos = vRayOrigin + vRayDir * fDepth;\n        \n    vec2 vPrevUV = Cam_GetUVFromWindowCoord( Cam_WorldToWindowCoord(vWorldPos, camPrev), iResolution.xy );// - camPrev.vJitter / iResolution.xy;\n        \n\tvec3 vResult = vec3(0.0);\n    \n    float fTot = 0.0;\n    \n    float fPlaneInFocus = camCurr.fPlaneInFocus;\n        \n\tfloat fCoC = GetCoC( fDepth, camCurr.fPlaneInFocus );\n        \n    float r = 1.0;\n    vec2 vangle = vec2(0.0,fCoC); // Start angle\n    \n    float fWeight = max( 0.001, fCoC );    \n    vResult.rgb = vSample.rgb * fWeight;\n    fTot += fWeight;\n    \n#if defined(ENABLE_DOF) || defined(ENABLE_MOTION_BLUR)    \n    float fMotionBlurTaps = float(BLUR_TAPS);\n    \n    float fShutterAngle = 0.5;\n    \n    float f = 0.0;\n    float fIndex = 0.0;\n    for(int i=1; i<BLUR_TAPS; i++)\n    {\n        float fRandomT = Hash( iTime + fIndex + vUV.x + vUV.y * 12.345);\n        float fOrderedT = fIndex / fMotionBlurTaps;\n        \n        float fDofT = fOrderedT;\n        float fMotionT = fRandomT;\n        \n        vec2 vTapUV = vUV;\n        #ifdef ENABLE_MOTION_BLUR\n        vTapUV = mix( vTapUV, vPrevUV, (fMotionT - 0.5) * fShutterAngle );\n        #endif\n                \n        // http://blog.marmakoide.org/?p=1\n        \n        float fTheta = fDofT * fGolden * fMotionBlurTaps;\n        float fRadius = fCoC * sqrt( fDofT * fMotionBlurTaps ) / sqrt( fMotionBlurTaps );        \n        \n        vTapUV += vec2( sin(fTheta), cos(fTheta) ) * fRadius;\n        \n        vec4 vTapSample = textureLod( iChannel0, vTapUV, 0.0 ).rgba;\n\t    //vec4 vTapTexel = texelFetch( iChannel0, ivec2(vTapUV.xy * iResolution.xy), 0 ).rgba;\n        \n        int iTapObjectId;\n        float fTapDepth = DecodeDepthAndObjectId( vTapSample.w, iTapObjectId );\n        \n        if ( fTapDepth > 0.0 )\n        {            \n  \t\t  \tfloat fCurrCoC = GetCoC( fTapDepth, fPlaneInFocus );\n            \n            float fCurrWeight = max( 0.001, fCurrCoC );\n            \n    \t\tvResult += vTapSample.rgb * fCurrWeight;\n        \tfTot += fCurrWeight;\n        }\n        f += 1.0;\n        fIndex += 1.0;\n    }\n#endif    \n    vResult /= fTot;\n    \n\tfragColor = vec4(vResult, 1.0);    \n    \n    float fShade = GetVignetting( vUV, 0.7, 2.0, 1.0 );\n    \n    fragColor.rgb *= fShade;\n    \n    fragColor.rgb = Tonemap( fragColor.rgb );\n    fragColor.a = 1.0;\n}\n",
   "name": "Image",
   "description": "",
   "type": "image"
  },
  {
   "inputs": [
    {
     "id": "4dXGRr",
     "filepath": "/presets/tex00.jpg",
     "type": "keyboard",
     "channel": 1,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    },
    {
     "id": "4dXGR8",
     "filepath": "/media/previz/buffer00.png",
     "type": "buffer",
     "channel": 0,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    }
   ],
   "outputs": [
    {
     "id": "4dXGR8",
     "channel": 0
    }
   ],
   "code": "// Update Logic for Commodore 64 by hubbe\n// https://www.shadertoy.com/view/Xs3XW4\n\n// TODO: break\n\n#define CURSOR 0\n#define STATE 1\n#define MEMORY 2\n\nvec4 old_memory[MEMORY];\nvec4 memory[MEMORY];\n\n#define STATE_READY 0\n#define STATE_PRINT_READY 1\n#define STATE_PRINT_READY_NL 2\n#define STATE_LISTING 3\n#define STATE_RUNNING 4\n#define STATE_BREAK 5\n\n#define LINE_ZERO 30\n#define MAX_LINES 200\n\nfloat vec4pick(int c, vec4 v) {\n    if (c == 0) return v.x;\n    if (c == 1) return v.y;\n    if (c == 2) return v.z;\n    return v.w;\n}\n\nint vec4toint(int c, vec4 v) {\n    c = int(mod(float(c), 8.0));\n    float tmp = vec4pick(c / 2, v);\n    if (c != (c/2) * 2) {\n        return int(mod(tmp, 256.0));\n    } else {\n        return int(tmp) / 256;\n    }\n}\n\nvec4 vec4tochar(int c, vec4 v) {\n    return vec4(vec4toint(c, v), 14/* fg */, 6 /* bg */, 0);\n}\n\n\nvoid init_screen(out vec4 fragColor, int x, int y) {\n    fragColor = vec4(96, 14, 6, 0);\n\n    if(y == 1) {\n        if (x > 3 && x < 35) fragColor.x = 42.0;\n        if (x > 7 && x < 31) fragColor.x = 96.0;\n        x -= 9;\n        vec4 tmp;\n        if (x < 0) return;\n        if (x > 20) return;\n        int n = x / 8;\n        if (n == 0) tmp = vec4(0x030F, 0x0D0D, 0x0F04, 0x0F12);  // COMMODOR\n        if (n == 1) tmp = vec4(0x0560, 0x3634, 0x6002, 0x0113);  // E 64 BAS\n        if (n == 2) tmp = vec4(0x0903, 0x6016, 0x3200, 0x0000);  // IC V2\n        fragColor = vec4tochar(x, tmp);\n    }\n    if (y == 3) {\n        int n = x / 8;\n        vec4 tmp;\n        if (n == 0) tmp = vec4(0x6036, 0x340B, 0x6012, 0x010D); //  64K RAM\n        if (n == 1) tmp = vec4(0x6013, 0x1913, 0x1405, 0x0D60); //  SYSTEM \n        if (n == 2) tmp = vec4(0x6033, 0x3839, 0x3131, 0x6002); //  38911 B\n        if (n == 3) tmp = vec4(0x0113, 0x0903, 0x6002, 0x1914); // ASIC BYT\n        if (n == 4) tmp = vec4(0x0513, 0x6006, 0x1205, 0x0560); // ES FREE\n        fragColor = vec4tochar(x, tmp);\n    }\n}\n\nint key = -1;\nint scroll = 0;\n\nvoid NL() {\n   memory[CURSOR].x = 0.0;\n   memory[CURSOR].y += 1.0;\n   if (memory[CURSOR].y >= 20.0) {\n       scroll += 1;\n       memory[CURSOR].y -= 1.0;\n   }\n}\n\nvoid putc(int c) {\n    key = c;\n    memory[CURSOR].x += 1.0;\n    if (memory[CURSOR].x > 40.0) NL();\n}\n\nint screen_pos(vec4 v) {\n    int x = int(v.x + 0.5);\n    int y = int(v.y + 0.5);\n    return x + y * 40;\n}\n\nvec4 peek(int x, int y) {\n    return texelFetch(iChannel0, ivec2(x, y), 0 );\n}\n\nvec4 peek(int pos) {\n    int y = pos / 40;\n    int x = pos - y * 40;\n    return peek(x, y);\n}\n\nvec4 itoa(int x, int p) {\n\tint c = 96;\n    int len = 1;\n    if (x > 9) len = 2;\n    if (x > 99) len = 3;\n    if (p < len) {\n        int power10 = 1;\n        if (len - p == 2) power10 = 10;\n        if (len - p == 3) power10 = 100;\n        c = 48 + int(mod(float(x / power10), 10.0));        \n    }\n    return vec4(c, 14, 6, 0);\n}\n\nint copy_from;\nint copy_to;\nint copy_length;\n\n#define MSG_SYNTAX_ERROR -1\n#define MSG_READY -2\n#define MSG_ZERO -3\n#define MSG_BREAK -4\n\nvoid copy(int pos, inout vec4 tmp) {\n    int c = pos - copy_to;\n    if (c >= 0 && c < copy_length) {\n        tmp = vec4(0,0,0,0);\n        if (copy_from == MSG_SYNTAX_ERROR) {\n            vec4 ch;\n            if (c / 8 == 0)\n              ch = vec4(0x3F13, 0x190E, 0x1401, 0x1860);  // ?SYNTAX \n            if (c / 8 == 1)\n              ch = vec4(0x6005, 0x1212, 0x0F12, 0x0000);  // ERROR\n            tmp = vec4tochar(c, ch);\n        } else if (copy_from == MSG_READY) {\n            vec4 ch = vec4(0x1205, 0x0104, 0x192E, 0);\n            tmp = vec4tochar(c, ch) ; \n        } else if (copy_from == MSG_ZERO) {\n            tmp = vec4(0);\n        } else if (copy_from == MSG_BREAK) {\n            vec4 ch;\n            if (c < 8)\n              tmp = vec4tochar(c, vec4(0x0212, 0x0501, 0x0B60, 0x090E));  // BREAK IN\n            if (c == 8)\n              tmp = vec4(96, 14, 6, 0);\n            if (c > 8)\n              tmp = itoa(int(memory[STATE].y), c - 9);\n        } else {\n\t        tmp = peek(copy_from + c);\n            if (tmp.x >= 128.0) tmp.x -= 128.0;\n        }\n    }\n}\n\nvoid memcpy(int dst, int src, int len) {\n    copy_from = src;\n    copy_to = dst;\n    copy_length = len;\n}\n\n\nvoid print(int msg, int msg_len) {\n    NL();\n    memcpy(screen_pos(memory[CURSOR]) - 40, msg, msg_len);\n}\n\nvoid list() {\n      memory[STATE].x = float(STATE_LISTING);\n      memory[STATE].y = float(0);\n}\n\nint getchar(int x, int y) {\n    int c = int(peek(x, y).x);\n    if (c > 128) c -= 128;\n    return c;\n}\n\nint getchar(int pos) {\n    int c = int(peek(pos).x);\n    if (c > 128) c -= 128;\n    return c;\n}\n\nvoid skipwhite(inout int pos) {\n    int c = getchar(pos);\n    if (c == 96) pos = pos + 1;    \n    c = getchar(pos);\n    if (c == 96) pos = pos + 1;    \n    c = getchar(pos);\n    if (c == 96) pos = pos + 1;    \n}\n\nbool strtod(inout int pos, inout int value) {\n  skipwhite(pos);\n  int c = getchar(pos);\n  int num = c - 48;\n  if (num < 0 || num > 9) return false;\n  value = num;\n  pos = pos + 1;\n  c = getchar(pos);\n  num = c - 48;\n  if (num < 0 || num > 9) return true;\n  value = value * 10 + num;\n  pos = pos + 1;\n  c = getchar(pos);\n  num = c - 48;\n  if (num < 0 || num > 9) return true;\n  value = value * 10 + num;\n  return true;  \n}\n\nvoid skipnum(inout int pos) {\n    int value;\n    strtod(pos, value);\n}\n\nvoid parse(int pos) {\n    skipwhite(pos);\n    int c1 = getchar(pos);\n    int c2 = getchar(pos + 1);\n    int c3 = getchar(pos + 2);\n    int c4 = getchar(pos + 3);\n    if (c1 == 12 && c2 == 9 && c3 == 19 && c4 == 20) { // list\n        list();\n        \n    } else if (c1 == 18 && c2 == 21 && c3 == 14) { // run\n        memory[STATE].x = float(STATE_RUNNING);\n        int line = 0;\n        int p = pos + 3;\n        strtod(p, line);\n        memory[STATE].y = float(line);\n    } else if (c1 == 7 && c2 == 15 && c3 == 20 && c2 == 15) { // goto\n        memory[STATE].x = float(STATE_RUNNING);\n        int line = 0;\n        int p = pos + 4;\n        strtod(p, line);\n        memory[STATE].y = float(line);\n    } else if (c1 == 16 && c2 == 18 && c3 == 9 && c4 == 14) {\n        // print\n        NL();\n        int p = pos + 7;\n        int len = 0;\n        for (int l = 0; l < 33; l++) {\n            if (len == 0 && int(peek(p + l).x) == 34)\n                len = l;\n        }\n        \n        memcpy(screen_pos(memory[CURSOR]) - 40, pos + 7, len);\n    } else if (c1 == 96 && c2 == 96 && c3 == 96 && c4 == 96) {\n        // Do nothing\n    } else {\n        int value = 0;\n        int p = pos;\n        if (strtod(p, value)) {\n            if (getchar(p) == 96 && getchar(p+1) == 96 && getchar(p+2) == 96) {\n\t\t\t\tmemcpy((LINE_ZERO + value) * 40, MSG_ZERO, 10);\n            } else {\n\t          memcpy((LINE_ZERO + value) * 40, pos, 40);\n            }\n        } else {\n          NL();\n          NL();\n          // ?SYNTAX ERROR\n          memcpy(screen_pos(memory[CURSOR]) - 40, MSG_SYNTAX_ERROR, 14);\n          memory[STATE].x = float(STATE_PRINT_READY);\n        }\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    copy_length = 0;\n\tint x = int(fragCoord.x);\n    int y = int(fragCoord.y);\n    if (x > 40 && y > 25) discard;\n    \n    if (iFrame < 3) {\n    \tmemory[CURSOR] = vec4(0, 5, 0, 0);\n        memory[STATE].x = float(STATE_PRINT_READY);\n    } else {\n\t    for (int i = 0; i < MEMORY; i++) {\n    \t\tmemory[i] = peek(i + 40, 0);\n            old_memory[i] = memory[i];\n   \t\t}\n    } \n\n    fragColor = peek(x, y);\n\n    if (memory[STATE].x == float(STATE_LISTING)) {\n        int line = int(memory[STATE].y);\n        memory[STATE].x = float(STATE_PRINT_READY_NL);\n        \n        for (int i = 0; i < 50; i++) {\n            if (getchar(0, LINE_ZERO + line + i) != 0) {\n                memory[STATE].x = float(STATE_LISTING);\n                memory[STATE].y = float(line + i + 1);\n                NL();\n                memcpy(screen_pos(memory[CURSOR]) - 40, 40 * (LINE_ZERO + line + i), 40);\n                break;\n            }\n        }\n    } else if (memory[STATE].x == float(STATE_RUNNING)) {\n        bool esc = texture(iChannel1, vec2(27.5 / 256.0, 0.5/3.0)).x > 0.5;\n        if (esc) {\n            NL();\n            memory[STATE].x = float(STATE_BREAK);\n        } else {\n           \tint line = int(memory[STATE].y);\n\t        memory[STATE].x = float(STATE_PRINT_READY_NL);\n        \n    \t    for (int i = 0; i < 50; i++) {\n        \t    if (getchar(0, LINE_ZERO + line + i) != 0) {\n            \t    memory[STATE].x = float(STATE_RUNNING);\n                \tmemory[STATE].y = float(line + i + 1);\n    \t            int pos = 40 * (LINE_ZERO + line + i);\n\t                skipnum(pos);\n        \t        parse(pos);\n            \t    break;\n        \t    }\n     \t   }\n        }\n    } else if (memory[STATE].x == float(STATE_BREAK)) {\n  \t\tmemory[STATE].x = float(STATE_PRINT_READY);\n        print(MSG_BREAK, 12);\n    } else if (memory[STATE].x == float(STATE_PRINT_READY)) {\n  \t\tmemory[STATE].x = float(STATE_READY);\n        print(MSG_READY, 6);\n    } else if (memory[STATE].x == float(STATE_PRINT_READY_NL)) {\n  \t\tmemory[STATE].x = float(STATE_READY);\n        NL();\n        print(MSG_READY, 6);\n    } else {\n \t   bool shift = texture(iChannel1, vec2(16.5 / 256.0, 0.5/3.0)).x > 0.5;\n\n    \tfor (int key = 0; key < 64; key++) {\n        \tfloat key_val = texture(iChannel1, vec2((float(key) + 32.5)/256.0, 0.5)).x;\n\t        if (key_val > 0.6) {\n    \t        if (key > 32)\n        \t        putc(key - 32 + (shift ? 64 : 0));\n            \telse if (key == 0)\n                \tputc(96);\n\t            else if (key >= 16)\n    \t            putc(key + 32 + (shift ? -16 : 0));\n        \t}\n \t   }\n    \n  \t  if (texture(iChannel1, vec2(13.5/256.0, 0.5)).x > 0.6) {\n          int y = int(memory[CURSOR].y);\n    \t    NL();\n     \t   parse(y * 40);\n  \t      // Enter\n  \t  }\n        if (texture(iChannel1, vec2(8.5/256.0, 0.5)).x > 0.6) {\n            int x = int(memory[CURSOR].x);\n            if (x > 0) {\n                x = x - 1;\n                int p = screen_pos(memory[CURSOR]);\n                memcpy(p - 1, p, 40 - x);\n                memory[CURSOR].x = float(x);\n            }\n        }\n    }\n     \n    if (x >= 0 && x < 40 && y >=0 && y < 20) {\n      if (iFrame < 2) {\n        init_screen(fragColor, x, y);\n        return;\n      }\n      fragColor = peek(x, y + scroll);\n      int sp = x + y * 40;\n      \n      if (sp + 40 * scroll == screen_pos(old_memory[CURSOR])) {\n          fragColor.x = mod(fragColor.x, 128.0);\n          if (key != -1)\n          {\n              fragColor.x = float(key);\n          }\n      }\n\n      if (sp == screen_pos(memory[CURSOR])) {\n          if (fract(iTime) > 0.5) {\n            fragColor.x += 128.0;\n         }\n      }\n      copy(sp, fragColor);\n      return;\n    }\n    copy(x + y * 40, fragColor);\n    if (x >= 0 && x < 40 && y >= 20 && y <= 25) {\n       fragColor = vec4(96, 14, 6, 0);\n    }\n    if (y == 0) {\n \t\tfor (int i = 0; i < MEMORY; i++) {\n \t    \tif (i + 40 == x) {\n\t\t\t\tfragColor = memory[i];\n            \treturn;\n          \t}\n        }\n    }\n}",
   "name": "Buffer A",
   "description": "",
   "type": "buffer"
  },
  {
   "inputs": [
    {
     "id": "XsfGRn",
     "filepath": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg",
     "type": "texture",
     "channel": 2,
     "sampler": {
      "filter": "mipmap",
      "wrap": "repeat",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    },
    {
     "id": "4dXGRr",
     "filepath": "/presets/tex00.jpg",
     "type": "keyboard",
     "channel": 1,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    },
    {
     "id": "4dXGR8",
     "filepath": "/media/previz/buffer00.png",
     "type": "buffer",
     "channel": 0,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    }
   ],
   "outputs": [
    {
     "id": "XsXGR8",
     "channel": 0
    }
   ],
   "code": "// Meta CRT - @P_Malin\n// https://www.shadertoy.com/view/4dlyWX#\n// In which I add and remove aliasing\n\n// Screen image rendering\n\n\n// https://www.shadertoy.com/view/lslGDn\n#define SHADERTOY\n\n// Commodore 64 by hubbe\n// https://www.shadertoy.com/view/Xs3XW4\n//#define C64\n\n// https://www.shadertoy.com/view/lsl3Rn\n//#define SPECTRUM\n\n// https://www.shadertoy.com/view/MdsGzr\n//#define ELITE\n\n// https://www.shadertoy.com/view/4lG3Wz\n//#define MANDELBROT\n\n#ifdef ELITE\n\n/////////////////////////////////////\n// Settings\n\n#define EMULATE_8BIT\n\n#ifdef EMULATE_8BIT\n\t#define LIMIT_FRAMERATE\n\t//#define SCANLINE_EFFECT\n\t#define NON_AA_LINES\n\t#define LOW_RESOLUTION\n\t#define XOR_PIXELS\n#endif\n\n#ifndef NON_AA_LINES\n#ifdef XOR_PIXELS\n#undef XOR_PIXELS\n#endif\n#endif\n\nfloat kFramesPerSecond = 7.5;\n\n#ifdef LOW_RESOLUTION\nvec2 kWindowResolution = vec2(256.0, 192.0);\n#else\nvec2 kWindowResolution = iResolution.xy;\n#endif\n\nfloat kAALineWidth = 1.0;\n\n/////////////////////////////////////\n// Time\n\nfloat GetSceneTime()\n{\n\t#ifdef LIMIT_FRAMERATE\n\t\treturn (floor(iTime * kFramesPerSecond) / kFramesPerSecond);\n\t#else\n\t\treturn iTime;\n\t#endif\n}\n\n/////////////////////////////////////\n// Line Rasterization\n\n#ifdef NON_AA_LINES\nfloat RasterizeLine(const in vec2 vPixel, const in vec2 vA, const in vec2 vB)\n{\n\t// vPixel is the centre of the pixel to be rasterized\n\t\n\tvec2 vAB = vB - vA;\t\n\tvec2 vAbsAB = abs(vAB);\n\tfloat fGradientSelect = step(vAbsAB.y, vAbsAB.x);\n\n\tvec2 vAP = vPixel - vA;\n\n\tfloat fAB = mix(vAB.y, vAB.x, fGradientSelect);\n\tfloat fAP = mix(vAP.y, vAP.x, fGradientSelect);\n\t\n\t// figure out the co-ordinates we intersect the vPixelCentre x or y axis\n\tfloat t = fAP / fAB;\t\n\tvec2 vIntersection = vA + (vB - vA) * t;\n\tvec2 vIntersectionDist = abs(vIntersection - vPixel);\n\t\n\tvec2 vResult = step(vIntersectionDist, vec2(0.5));\n\n\t// mask out parts of the line beyond the beginning or end\n\tfloat fClipSpan = step(t, 1.0) * step(0.0, t);\t\n\t\n\t// select the x or y axis result based on the gradient of the line\n\treturn mix(vResult.x, vResult.y, fGradientSelect) * fClipSpan;\n}\n#else\nfloat RasterizeLine(const in vec2 vPixel, const in vec2 vA, const in vec2 vB)\n{\n\t// AA version based on distance to line\n\t\n\t// vPixel is the co-ordinate within the pixel to be rasterized\n\t\n\tvec2 vAB = vB - vA;\t\n\tvec2 vAP = vPixel - vA;\n\t\n\tvec2 vDir = normalize(vAB);\n\tfloat fLength = length(vAB);\n\t\n\tfloat t = clamp(dot(vDir, vAP), 0.0, fLength);\n\tvec2 vClosest = vA + t * vDir;\n\t\n\tfloat fDistToClosest = 1.0 - (length(vClosest - vPixel) / kAALineWidth);\n\n\tfloat i =  clamp(fDistToClosest, 0.0, 1.0);\n\t\n\treturn sqrt(i);\n}\n#endif\n\n/////////////////////////////////////\n// Matrix Fun\n\nmat4 SetRotTrans( vec3 r, vec3 t )\n{\n    float a = sin(r.x); float b = cos(r.x); \n    float c = sin(r.y); float d = cos(r.y); \n    float e = sin(r.z); float f = cos(r.z); \n\n    float ac = a*c;\n    float bc = b*c;\n\n    return mat4( d*f,      d*e,       -c, 0.0,\n                 ac*f-b*e, ac*e+b*f, a*d, 0.0,\n                 bc*f+a*e, bc*e-a*f, b*d, 0.0,\n                 t.x,      t.y,      t.z, 1.0 );\n}\n\nmat4 SetProjection( float d )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, d,\n\t\t\t\t 0.0, 0.0, 0.0, 0.0 );\n}\n\nmat4 SetWindow( vec2 s, vec2 t )\n{\n    return mat4( s.x, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, s.y, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t t.x, t.y, 0.0, 1.0 );\n}\n\n/////////////////////////////////////\n// Window Border Setup\n\nconst vec2 kWindowMin = vec2(0.1, 0.1);\nconst vec2 kWindowMax = vec2(0.9, 0.9);\nconst vec2 kWindowRange = kWindowMax - kWindowMin;\n\nvec2 ScreenUvToWindowPixel(vec2 vUv)\n{\n\t#ifdef LOW_RESOLUTION\n\t\tvUv = ((vUv - kWindowMin) / kWindowRange);\n\t#endif\n\treturn vUv * kWindowResolution;\n}\n\nfloat IsPixelInWindow(vec2 vPixel)\n{\n\tvec2 vResult = step(vPixel, kWindowResolution)\n\t\t\t\t* step(vec2(0.0), vPixel);\n\treturn min(vResult.x, vResult.y);\n}\n\n/////////////////////////////\n\nconst int kVertexCount = 30;\nvec3 kVertices[kVertexCount];\n\nvoid SetupVertices()\n{\n\tkVertices[0] = vec3(40, 0.0, 95);\n    kVertices[1] = vec3(-40, 0.0, 95);\n    kVertices[2] = vec3(00, 32.5, 30);\n    kVertices[3] = vec3(-150,-3.8,-10);\n    kVertices[4] = vec3(150,-3.8,-10);\n    kVertices[5] = vec3(-110, 20,-50);\n    kVertices[6] = vec3(110, 20,-50);\n    kVertices[7] = vec3(160,-10,-50);\n    kVertices[8] = vec3(-160,-10,-50);\n    kVertices[9] = vec3(0, 32.5,-50);\n    kVertices[10] = vec3(-40,-30,-50);\n    kVertices[11] = vec3(40,-30,-50);\n    kVertices[12] = vec3(-45, 10,-50);\n    kVertices[13] = vec3(-10, 15,-50);\n    kVertices[14] = vec3( 10, 15,-50);\n    kVertices[15] = vec3(45, 10,-50);      \n    kVertices[16] = vec3(45,-15,-50);\n    kVertices[17] = vec3(10,-20,-50);\n    kVertices[18] = vec3(-10,-20,-50);\n    kVertices[19] = vec3(-45,-15,-50);\n    kVertices[20] = vec3(-2,-2, 95);\n    kVertices[21] = vec3(-2,-2, 112.5);\n    kVertices[22] = vec3(-100,-7.5,-50);\n    kVertices[23] = vec3(-100, 7.5,-50);\n    kVertices[24] = vec3(-110, 0,-50);\n    kVertices[25] = vec3( 100, 7.5,-50);\n    kVertices[26] = vec3( 110, 0,-50);\n    kVertices[27] = vec3( 100,-7.5,-50);\n    kVertices[28] = vec3(  0,0, 95);\n    kVertices[29] = vec3(  0,0, 112.5);    \n}\n\nfloat BackfaceCull(vec2 A, vec2 B, vec2 C)\n{\n\tvec2 AB = B - A;\n\tvec2 AC = C - A;\n\tfloat c = AB.x * AC.y - AB.y * AC.x;\n\treturn step(c, 0.0);\n}\n\nfloat Accumulate( const float x, const float y )\n{\n#ifdef XOR_PIXELS\n\treturn x + y;\n#else\n\treturn max(x, y);\n#endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\t// get window pixel co-ordinates for centre of current pixel\n\tvec2 vWindowPixelCords = ScreenUvToWindowPixel(uv);\n\tvec2 vPixel = floor(vWindowPixelCords) + 0.5;\n\t\n\t// Setup Transform\n\tmat4 mTransform;\n\n\t{\n\t\tvec3 vRot = vec3(0.1, 0.2, 0.3) * GetSceneTime();\n\t\t\n\t\t/*if(iMouse.z > 0.0)\n\t\t{\n\t\t\tvec2 vUnitMouse = iMouse.xy / iResolution.xy;\n\t\t\tvRot= vec3(vUnitMouse.yx * vec2(1.0, 1.0) + vec2(1.5, 0.5), 0.0) * 3.14159 * 2.0;\n\t\t}*/\n\t\t\n\t\tvec3 vTrans = vec3(0.0, 0.0, 350.0);\n\t\tmat4 mRotTrans = SetRotTrans( vRot, vTrans );\n\t\tmat4 mProjection = SetProjection( 1.0 );\n\t\tmat4 mWindow = SetWindow( vec2(1.0, iResolution.x/iResolution.y) * kWindowResolution, vec2(0.5) * kWindowResolution );\n\t\n\t\tmTransform = mWindow * mProjection * mRotTrans;\n\t}\n\n\t// Transform Vertices to Window Pixel Co-ordinates\n\tSetupVertices();\n\t\n\tvec2 vScrVtx[kVertexCount];\n\tfor(int i=0; i<kVertexCount; i++)\n\t{\n\t\tvec4 vhPos = mTransform * vec4(kVertices[i], 1.0);\n\t\tvScrVtx[i] = vhPos.xy / vhPos.w;\n\t}\n\n\t// Cull Faces\n\tconst int kFaceCount = 14;\n\tfloat fFaceVisible[kFaceCount];\n\t\n\t// hull \n\tfFaceVisible[0] = BackfaceCull( vScrVtx[2], vScrVtx[1], vScrVtx[0] );\n\tfFaceVisible[1] = BackfaceCull( vScrVtx[0], vScrVtx[1], vScrVtx[10] );\n\tfFaceVisible[2] = BackfaceCull( vScrVtx[6], vScrVtx[2], vScrVtx[0] );\n\tfFaceVisible[3] = BackfaceCull( vScrVtx[0], vScrVtx[4], vScrVtx[6] );\n\tfFaceVisible[4] = BackfaceCull( vScrVtx[0], vScrVtx[11], vScrVtx[7] );\n\tfFaceVisible[5] = BackfaceCull( vScrVtx[1], vScrVtx[2], vScrVtx[5] );\n\n\tfFaceVisible[6] = BackfaceCull( vScrVtx[5], vScrVtx[3], vScrVtx[1] );\n\tfFaceVisible[7] = BackfaceCull( vScrVtx[1], vScrVtx[3], vScrVtx[8] );\n\tfFaceVisible[8] = BackfaceCull( vScrVtx[5], vScrVtx[2], vScrVtx[9] );\n\tfFaceVisible[9] = BackfaceCull( vScrVtx[2], vScrVtx[6], vScrVtx[9] );\n\tfFaceVisible[10] = BackfaceCull( vScrVtx[5], vScrVtx[8], vScrVtx[3] );\n\tfFaceVisible[11] = BackfaceCull( vScrVtx[7], vScrVtx[6], vScrVtx[4] );\n\tfFaceVisible[12] = BackfaceCull( vScrVtx[9], vScrVtx[6], vScrVtx[7] );\n\t\n\t// engines - all culled together\n\tfFaceVisible[13] = BackfaceCull( vScrVtx[14], vScrVtx[15], vScrVtx[16] );\n\n\t// Draw Lines\n\t\n\tfloat fResult = 0.0;\n\t\n\tfResult = Accumulate(fResult, RasterizeLine( vPixel, vScrVtx[0], vScrVtx[2]) * max(fFaceVisible[0], fFaceVisible[2]));\n\tfResult = Accumulate(fResult, RasterizeLine( vPixel, vScrVtx[0], vScrVtx[4]) * max(fFaceVisible[3], fFaceVisible[4]));\n\tfResult = Accumulate(fResult, RasterizeLine( vPixel, vScrVtx[0], vScrVtx[6]) * max(fFaceVisible[2], fFaceVisible[3]));\n\tfResult = Accumulate(fResult, RasterizeLine( vPixel, vScrVtx[1], vScrVtx[0]) * max(fFaceVisible[0], fFaceVisible[1]));\n\tfResult = Accumulate(fResult, RasterizeLine( vPixel, vScrVtx[1], vScrVtx[10]) * max(fFaceVisible[1], fFaceVisible[7]));\n\tfResult = Accumulate(fResult, RasterizeLine( vPixel, vScrVtx[2], vScrVtx[1]) * max(fFaceVisible[0], fFaceVisible[5]));\n\tfResult = Accumulate(fResult, RasterizeLine( vPixel, vScrVtx[2], vScrVtx[5]) * max(fFaceVisible[5], fFaceVisible[8]));\n\tfResult = Accumulate(fResult, RasterizeLine( vPixel, vScrVtx[2], vScrVtx[9]) * max(fFaceVisible[8], fFaceVisible[9]));\n\tfResult = Accumulate(fResult, RasterizeLine( vPixel, vScrVtx[3], vScrVtx[1]) * max(fFaceVisible[6], fFaceVisible[7]));\n\tfResult = Accumulate(fResult, RasterizeLine( vPixel, vScrVtx[3], vScrVtx[8]) * max(fFaceVisible[7], fFaceVisible[10]));\n\tfResult = Accumulate(fResult, RasterizeLine( vPixel, vScrVtx[4], vScrVtx[6]) * max(fFaceVisible[3], fFaceVisible[11]));\n\tfResult = Accumulate(fResult, RasterizeLine( vPixel, vScrVtx[5], vScrVtx[1]) * max(fFaceVisible[5], fFaceVisible[6]));\n\tfResult = Accumulate(fResult, RasterizeLine( vPixel, vScrVtx[5], vScrVtx[3]) * max(fFaceVisible[6], fFaceVisible[10]));\n\tfResult = Accumulate(fResult, RasterizeLine( vPixel, vScrVtx[5], vScrVtx[8]) * max(fFaceVisible[10], fFaceVisible[12]));\n\tfResult = Accumulate(fResult, RasterizeLine( vPixel, vScrVtx[6], vScrVtx[2]) * max(fFaceVisible[2], fFaceVisible[9]));\n\tfResult = Accumulate(fResult, RasterizeLine( vPixel, vScrVtx[6], vScrVtx[9]) * max(fFaceVisible[9], fFaceVisible[12]));\n\tfResult = Accumulate(fResult, RasterizeLine( vPixel, vScrVtx[7], vScrVtx[4]) * max(fFaceVisible[4], fFaceVisible[11]));\n\tfResult = Accumulate(fResult, RasterizeLine( vPixel, vScrVtx[7], vScrVtx[6]) * max(fFaceVisible[11], fFaceVisible[12]));\n\tfResult = Accumulate(fResult, RasterizeLine( vPixel, vScrVtx[8], vScrVtx[10]) * max(fFaceVisible[7], fFaceVisible[12]));\n\tfResult = Accumulate(fResult, RasterizeLine( vPixel, vScrVtx[9], vScrVtx[5]) * max(fFaceVisible[8], fFaceVisible[12]));\n\tfResult = Accumulate(fResult, RasterizeLine( vPixel, vScrVtx[10], vScrVtx[11]) * max(fFaceVisible[1], fFaceVisible[12]));\n\tfResult = Accumulate(fResult, RasterizeLine( vPixel, vScrVtx[11], vScrVtx[0]) * max(fFaceVisible[1], fFaceVisible[4]));\n\tfResult = Accumulate(fResult, RasterizeLine( vPixel, vScrVtx[11], vScrVtx[7]) * max(fFaceVisible[4], fFaceVisible[12]));\n\n\tif(fFaceVisible[13] > 0.0)\t\n\t{\n\t\tfResult = Accumulate(fResult, RasterizeLine( vPixel, vScrVtx[12], vScrVtx[13] ));\n\t\tfResult = Accumulate(fResult, RasterizeLine( vPixel, vScrVtx[13], vScrVtx[18] ));\n\t\tfResult = Accumulate(fResult, RasterizeLine( vPixel, vScrVtx[14], vScrVtx[15] ));\n\t\tfResult = Accumulate(fResult, RasterizeLine( vPixel, vScrVtx[15], vScrVtx[16] ));\n\t\tfResult = Accumulate(fResult, RasterizeLine( vPixel, vScrVtx[16], vScrVtx[17] ));\n\t\tfResult = Accumulate(fResult, RasterizeLine( vPixel, vScrVtx[17], vScrVtx[14] ));\n\t\tfResult = Accumulate(fResult, RasterizeLine( vPixel, vScrVtx[18], vScrVtx[19] ));\n\t\tfResult = Accumulate(fResult, RasterizeLine( vPixel, vScrVtx[19], vScrVtx[12] ));\n\t\tfResult = Accumulate(fResult, RasterizeLine( vPixel, vScrVtx[25], vScrVtx[26] ));\n\t\tfResult = Accumulate(fResult, RasterizeLine( vPixel, vScrVtx[26], vScrVtx[27] ));\n\t\tfResult = Accumulate(fResult, RasterizeLine( vPixel, vScrVtx[27], vScrVtx[25] ));\n\t\tfResult = Accumulate(fResult, RasterizeLine( vPixel, vScrVtx[22], vScrVtx[23] ));\n\t\tfResult = Accumulate(fResult, RasterizeLine( vPixel, vScrVtx[23], vScrVtx[24] ));\n\t\tfResult = Accumulate(fResult, RasterizeLine( vPixel, vScrVtx[24], vScrVtx[22] ));\n\t}\n\t\n\t// gun\n\tfResult = Accumulate(fResult, RasterizeLine( vPixel, vScrVtx[28], vScrVtx[29]));\n\n\t#ifdef XOR_PIXELS\t\n\tfResult = mod(fResult, 2.0);\n\t#endif\n\t\n\t// Clip pixel to window border\n\tfResult *= IsPixelInWindow(vPixel);\n\t\n\t// Scanline Effect\n\t#ifdef SCANLINE_EFFECT\t\n\t\tfloat fScanlineEffect = cos((vWindowPixelCords.y + 0.5) * 3.1415 * 2.0) * 0.5 + 0.5;\n\t\tfResult = (fResult * 0.9 + 0.1) * (fScanlineEffect * 0.2 + 0.8);\n\t#endif\n\t\t\n\tfragColor = vec4(vec3(fResult),1.0);\n}\n\n#endif\n\n#ifdef SPECTRUM\n\n// Screen Image - @P_Malin\n\n//#define LOADING_LOOP\n \nvec2 kResolution = vec2(256.0, 192.0);\n \n// Border phases\n\nconst float kPhaseBlank = 0.0;\nconst float kPhaseSilent = 1.0;\nconst float kPhaseHeader = 2.0;\nconst float kPhaseData = 3.0;\nconst float kPhaseRunning = 4.0;\n \n// Loading phases\n\nconst vec3 vTimeSilent1  = vec3(1.0,\t5.0,                       kPhaseSilent);\nconst vec3 vTimeHeader1  = vec3(2.0,  vTimeSilent1.y + 2.0,      kPhaseHeader);\nconst vec3 vTimeData1    = vec3(3.0,  vTimeHeader1.y + 0.125,    kPhaseData);\n \nconst vec3 vTimeBlank2   = vec3(4.0,  vTimeData1.y + 1.0,        kPhaseBlank);\nconst vec3 vTimeSilent2  = vec3(5.0,  vTimeBlank2.y + 2.0,       kPhaseSilent);\nconst vec3 vTimeHeader2  = vec3(6.0,  vTimeSilent2.y + 2.0,      kPhaseHeader);\nconst vec3 vTimeData2    = vec3(7.0,  vTimeHeader2.y + 1.0,      kPhaseData);\n \nconst vec3 vTimeSilent3  = vec3(8.0,  vTimeData2.y + 2.0,        kPhaseSilent);\nconst vec3 vTimeHeader3  = vec3(9.0,  vTimeSilent3.y + 2.0,      kPhaseHeader);\nconst vec3 vTimeData3    = vec3(10.0, vTimeHeader3.y + 0.125,    kPhaseData);\n \nconst vec3 vTimeSilent4  = vec3(11.0, vTimeData3.y + 2.0,        kPhaseSilent);\nconst vec3 vTimeHeader4  = vec3(12.0, vTimeSilent4.y + 2.0,      kPhaseHeader);\nconst vec3 vTimeData4    = vec3(13.0, vTimeHeader4.y + 38.0,     kPhaseData);\n \nconst vec3 vTimeRunning  = vec3(14.0, vTimeData4.y + 10.0,       kPhaseRunning);\n \nconst vec3 vTimeTotal    = vec3(15.0, vTimeRunning.y,            kPhaseBlank);\n       \nvec4 GetPhase(float fTime)\n{             \n        vec3 vResult = vTimeRunning;\n                \n        vResult = mix( vResult, vTimeData4, step(fTime, vTimeData4.y ) );\n        vResult = mix( vResult, vTimeHeader4, step(fTime, vTimeHeader4.y ) );\n        vResult = mix( vResult, vTimeSilent4, step(fTime, vTimeSilent4.y ) );\n \n        vResult = mix( vResult, vTimeData3, step(fTime, vTimeData3.y ) );\n        vResult = mix( vResult, vTimeHeader3, step(fTime, vTimeHeader3.y ) );\n        vResult = mix( vResult, vTimeSilent3, step(fTime, vTimeSilent3.y ) );\n               \n        vResult = mix( vResult, vTimeData2, step(fTime, vTimeData2.y ) );\n        vResult = mix( vResult, vTimeHeader2, step(fTime, vTimeHeader2.y ) );\n        vResult = mix( vResult, vTimeSilent2, step(fTime, vTimeSilent2.y ) );\n        vResult = mix( vResult, vTimeBlank2, step(fTime, vTimeBlank2.y ) );\n \n        vResult = mix( vResult, vTimeData1, step(fTime, vTimeData1.y ) );\n        vResult = mix( vResult, vTimeHeader1, step(fTime, vTimeHeader1.y ) );\n        vResult = mix( vResult, vTimeSilent1, step(fTime, vTimeSilent1.y ) );\n               \n        return vec4(vResult.z, vResult.x, fTime - vResult.y, vResult.y);\n}\n \nfloat GetRasterPosition(in vec2 fragCoord)\n{\n        return (fragCoord.x + fragCoord.y * iResolution.x) / (iResolution.x * iResolution.y);\n}\n \nfloat IsBorder(vec2 vScreenUV)\n{\n        if(vScreenUV.x < 0.0)\n                        return 1.0;\n        if(vScreenUV.x >= 1.0)\n                        return 1.0;\n        if(vScreenUV.y < 0.0)\n                        return 1.0;\n        if(vScreenUV.y >= 1.0)\n                        return 1.0;\n       \n        return 0.0;\n}\n \n \nvec3 GetBorderColour(float fPhase,in vec2 fragCoord)\n{\n\tfloat raster = GetRasterPosition(fragCoord);\n\t\n\tvec3 vCol = vec3(0.0);\n\t\n\tif(fPhase == kPhaseBlank)\n\t{                       \n\t\tvCol = vec3(1.0);           \n\t}\n\telse  \n\tif(fPhase == kPhaseSilent)\n\t{\n\t\tfloat fBlend = step(fract(iTime * 0.5), 0.5);\n\t\tvCol = mix( vec3(0.0, 1.0, 1.0), vec3(1.0, 0.0, 0.0), fBlend);           \n\t}\n\telse\n\tif(fPhase == kPhaseHeader)\n\t{\n\t\tfloat fBarSize = 12.0;\n\t\tfloat fScrollSpeed = 10.0;\n\t\tfloat fBlend = step(fract(raster * fBarSize + iTime * fScrollSpeed), 0.5);\n\t\tvCol = mix( vec3(0.0, 1.0, 1.0), vec3(1.0, 0.0, 0.0), fBlend);           \n\t}\n\telse\n\tif(fPhase == kPhaseData)\n\t{\n\t\tfloat fBarSize = 25.0;\n\t\tfloat fScrollSpeed = 1.0;\n\t\tfloat fBlend = step(fract(raster * fBarSize + iTime * fScrollSpeed + sin(iTime * 20.0 + raster * 16.0)), 0.5);\n\t\tvCol = mix(vec3(1.0, 1.0, 0.0), vec3(0.0, 0.0, 1.0), fBlend);                     \n\t}\n\t\n\treturn vCol;\n}\n \n \nfloat GetLoadingScreenIntensity( vec2 vPos )\n{\n\tvec2 vUV = vPos / kResolution;\n\tfloat r = 0.25;\n\tvec2 vDist = (vUV - 0.5) / r;\n\tfloat len = length(vDist);\n\tvec3 vNormal = vec3(vDist.x, sqrt(1.0 - len * len), vDist.y);\n\tvec3 vLight = normalize( vec3(1.0, 1.0, -1.0) );\n\tif(len < 1.0)\n\t{\n\t\treturn max(0.0, dot(vNormal, vLight));\n\t}\n\t\n\treturn 0.7 - vUV.y * 0.6;\n}\n \nfloat CrossHatch(float fIntensity, vec2 vPos)\n{\n\tvec2 vGridPos = mod(vPos, 4.0);\n\t\n\tfloat fThreshold = fract(vGridPos.x * 0.25 + vGridPos.y * 0.5) * 0.75 + fract(vGridPos.y * 0.25 + vGridPos.x * 0.5) * 0.25;\n\t\n\treturn step(fIntensity, fThreshold);\n}\n \nfloat GetLoadingScreenPixel( vec2 vPos )\n{\n        return CrossHatch(GetLoadingScreenIntensity(vPos), vPos);\n}\n \nvec2 GetScreenPixelCoord( vec2 vScreenUV )\n{\n        vec2 vPixelPos = floor(vScreenUV * kResolution);\n        vPixelPos.y = 192.0 - vPixelPos.y;\n       \n        return vPixelPos;\n}\n \nfloat PixelAddress( vec2 vPixelPos )\n{               \n        float fBand = floor(vPixelPos.y / 64.0);\n       \n        float fBandPos = mod(vPixelPos.y, 64.0);\n \n        float fCharRow = mod(fBandPos, 8.0);\n        float fCharPos = floor(fBandPos / 8.0);\n \n        float fBytePos = floor(vPixelPos.x / 8.0);\n \n        float fLineTime = fBand * 64.0 + fCharRow * 8.0 + fCharPos;\n        return (fBytePos + fLineTime * (256.0 / 8.0));\n}\n \nfloat AttributeAddress(vec2 vCharPos)\n{             \n\tfloat kAttributeStart = 256.0 * 192.0 / 8.0;\n\treturn kAttributeStart + vCharPos.x + vCharPos.y * 32.0;\n}\n \nfloat GetCharByte(const in float value)\n{\n        float result = 0.0;\n        result = mix(result, 0.0, step(value, 919.0) );\n        result = mix(result, 32.0, step(value, 918.5) );\n        result = mix(result, 28.0, step(value, 914.5) );\n        result = mix(result, 0.0, step(value, 913.5) );\n        result = mix(result, 56.0, step(value, 894.5) );\n        result = mix(result, 68.0, step(value, 893.5) );\n        result = mix(result, 56.0, step(value, 890.5) );\n        result = mix(result, 0.0, step(value, 889.5) );\n        result = mix(result, 84.0, step(value, 878.5) );\n        result = mix(result, 104.0, step(value, 874.5) );\n        result = mix(result, 0.0, step(value, 873.5) );\n        result = mix(result, 56.0, step(value, 851.5) );\n        result = mix(result, 4.0, step(value, 830.5) );\n        result = mix(result, 60.0, step(value, 829.5) );\n        result = mix(result, 68.0, step(value, 828.5) );\n        result = mix(result, 60.0, step(value, 826.5) );\n        result = mix(result, 0.0, step(value, 825.5) );\n        result = mix(result, 60.0, step(value, 782.5) );\n        result = mix(result, 68.0, step(value, 781.5) );\n        result = mix(result, 60.0, step(value, 780.5) );\n        result = mix(result, 4.0, step(value, 779.5) );\n        result = mix(result, 56.0, step(value, 778.5) );\n        result = mix(result, 0.0, step(value, 777.5) );\n        result = mix(result, 60.0, step(value, 670.5) );\n        result = mix(result, 66.0, step(value, 669.5) );\n        result = mix(result, 2.0, step(value, 668.5) );\n        result = mix(result, 60.0, step(value, 667.5) );\n        result = mix(result, 64.0, step(value, 666.5) );\n        result = mix(result, 60.0, step(value, 665.5) );\n        result = mix(result, 0.0, step(value, 664.5) );\n        result = mix(result, 64.0, step(value, 646.5) );\n        result = mix(result, 124.0, step(value, 644.5) );\n        result = mix(result, 66.0, step(value, 643.5) );\n        result = mix(result, 124.0, step(value, 641.5) );\n        result = mix(result, 0.0, step(value, 640.5) );\n        result = mix(result, 60.0, step(value, 638.5) );\n        result = mix(result, 66.0, step(value, 637.5) );\n        result = mix(result, 60.0, step(value, 633.5) );\n        result = mix(result, 0.0, step(value, 632.5) );\n        result = mix(result, 66.0, step(value, 630.5) );\n        result = mix(result, 70.0, step(value, 629.5) );\n        result = mix(result, 74.0, step(value, 628.5) );\n        result = mix(result, 82.0, step(value, 627.5) );\n        result = mix(result, 98.0, step(value, 626.5) );\n        result = mix(result, 66.0, step(value, 625.5) );\n        result = mix(result, 0.0, step(value, 624.5) );\n        result = mix(result, 126.0, step(value, 614.5) );\n        result = mix(result, 64.0, step(value, 613.5) );\n        result = mix(result, 0.0, step(value, 608.5) );\n        result = mix(result, 62.0, step(value, 590.5) );\n        result = mix(result, 8.0, step(value, 589.5) );\n        result = mix(result, 62.0, step(value, 585.5) );\n        result = mix(result, 0.0, step(value, 584.5) );\n        result = mix(result, 60.0, step(value, 574.5) );\n        result = mix(result, 66.0, step(value, 573.5) );\n        result = mix(result, 78.0, step(value, 572.5) );\n        result = mix(result, 64.0, step(value, 571.5) );\n        result = mix(result, 66.0, step(value, 570.5) );\n        result = mix(result, 60.0, step(value, 569.5) );\n        result = mix(result, 0.0, step(value, 568.5) );\n        result = mix(result, 120.0, step(value, 550.5) );\n        result = mix(result, 68.0, step(value, 549.5) );\n        result = mix(result, 66.0, step(value, 548.5) );\n        result = mix(result, 68.0, step(value, 546.5) );\n        result = mix(result, 120.0, step(value, 545.5) );\n        result = mix(result, 0.0, step(value, 544.5) );\n        result = mix(result, 66.0, step(value, 526.5) );\n        result = mix(result, 126.0, step(value, 524.5) );\n        result = mix(result, 66.0, step(value, 523.5) );\n        result = mix(result, 60.0, step(value, 521.5) );\n        result = mix(result, 0.0, step(value, 520.5) );\n        result = mix(result, 16.0, step(value, 470.5) );\n        result = mix(result, 0.0, step(value, 469.5) );\n        result = mix(result, 16.0, step(value, 467.5) );\n        result = mix(result, 0.0, step(value, 466.5) );\n        return result;   \n}\n \nfloat GetBit( float fByte, float fBit )\n{\n        return mod(floor(fByte / pow(2.0, 7.0-fBit)), 2.0) ;\n}\n \nfloat GetCharPixel( float fChar, vec2 vPos )\n{\n        float fCharAddress = fChar * 8.0 + vPos.y;\n       \n        float fCharBin = GetCharByte(fCharAddress);\n       \n        return GetBit(fCharBin, vPos.x);\n}\n \nfloat GetProgramStringChar(float fPos)\n{\n        float fChar = 32.0;    \n        fChar = mix(fChar, 76.0, step(fPos, 12.5) );\n        fChar = mix(fChar, 83.0, step(fPos, 11.5) );\n        fChar = mix(fChar, 76.0, step(fPos, 10.5) );\n        fChar = mix(fChar, 71.0, step(fPos, 9.5) );\n        fChar = mix(fChar, 32.0, step(fPos, 8.5) );\n        fChar = mix(fChar, 58.0, step(fPos, 7.5) );\n        fChar = mix(fChar, 109.0, step(fPos, 6.5) );\n        fChar = mix(fChar, 97.0, step(fPos, 5.5) );\n        fChar = mix(fChar, 114.0, step(fPos, 4.5) );\n        fChar = mix(fChar, 103.0, step(fPos, 3.5) );\n        fChar = mix(fChar, 111.0, step(fPos, 2.5) );\n        fChar = mix(fChar, 114.0, step(fPos, 1.5) );\n        fChar = mix(fChar, 80.0, step(fPos, 0.5) );\n        return fChar;\n}\n \nfloat GetLoadingStringChar(float fPos)\n{\n        float fChar = 32.0;    \n        fChar = mix(fChar, 76.0, step(fPos, 11.0) );\n        fChar = mix(fChar, 83.0, step(fPos, 10.5) );\n        fChar = mix(fChar, 76.0, step(fPos, 9.5) );\n        fChar = mix(fChar, 71.0, step(fPos, 8.5) );\n        fChar = mix(fChar, 32.0, step(fPos, 7.5) );\n        fChar = mix(fChar, 71.0, step(fPos, 6.5) );\n        fChar = mix(fChar, 78.0, step(fPos, 5.5) );\n        fChar = mix(fChar, 73.0, step(fPos, 4.5) );\n        fChar = mix(fChar, 68.0, step(fPos, 3.5) );\n        fChar = mix(fChar, 65.0, step(fPos, 2.5) );\n        fChar = mix(fChar, 79.0, step(fPos, 1.5) );\n        fChar = mix(fChar, 76.0, step(fPos, 0.5) );\n        return fChar;\n}\n \nfloat GetProgramText(vec2 vPixelPos)\n{     \n        vec2 vCharCoord = floor(vPixelPos / 8.0);\n       \n        float fChar = GetProgramStringChar(vCharCoord.x);\n       \n        if(vCharCoord.y != 0.0)\n                fChar = 32.0;\n       \n        return GetCharPixel(fChar, mod(vPixelPos, 8.0));\n}\n \nfloat GetLoadingText(vec2 vPixelPos)\n{     \n        vec2 vCharCoord = floor(vPixelPos / 8.0);\n       \n        float fChar = GetLoadingStringChar(vCharCoord.x);\n       \n        float inString = 1.0;\n        if(vCharCoord.x < 0.0)\n                fChar = 32.0;\n       \n        if(vCharCoord.y != 0.0)\n                fChar = 32.0;\n       \n        return GetCharPixel(fChar, mod(vPixelPos, 8.0));\n}\n \nfloat GetScreenPixel(vec2 vScreenPixel)\n{\n\t// plasma thing\n\tfloat f = sin(vScreenPixel.x *0.0432 + sin(vScreenPixel.y * 0.0423)+ iTime * 3.0);\n\tf = f + sin(vScreenPixel.y * 0.0454513 + sin(vScreenPixel.x * 0.07213) + iTime * 5.0);\n\tf = f + sin(vScreenPixel.x * 0.043353 + sin(vScreenPixel.y * 0.043413) + iTime * 8.0);\n\tf = f + sin(vScreenPixel.y * 0.0443513 + sin(vScreenPixel.x * 0.036313) + iTime * 10.0);\n\tf = f * 0.125 + 0.5;\n\t\n\treturn CrossHatch(f, vScreenPixel);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{           \n\tfloat fSequenceTime = iTime;\n\t\n\t#ifdef LOADING_LOOP\n\tfSequenceTime = mod(fSequenceTime, vTimeTotal.y);\n\t#endif\n\t\n\tvec3 col = vec3(1.0);\n\t\n\tvec4 vPhase = GetPhase(fSequenceTime);\n\t\n\tvec2 vUV = ( fragCoord.xy / iResolution.xy );\n\tvec2 vScreenUV = (vUV - 0.1) / 0.8;\n\tif(IsBorder(vScreenUV) > 0.0)\n\t{\n\t\tcol = GetBorderColour(vPhase.x, fragCoord);\n\t}\n\telse\n\t{\n\t\tvec2 vScreenCoord = GetScreenPixelCoord(vScreenUV);\n\t\tvec2 vAttribCoord = floor(vScreenCoord / 8.0);\n\n\t\tfloat fPixelValue = 0.0;\n\t\tvec3 vInk = vec3(0.0);\n\t\tvec3 vPaper = vec3(1.0);\n\t\t\n\t\tif(vPhase.x != kPhaseRunning)\n\t\t{\n\t\t\t// loading\n\t\t\tfloat fLoadScreenTime = fSequenceTime - vTimeHeader4.y;\n\t\t\t\t\t\t\t\t\t\t       \n\t\t\tfloat fAddressLoaded = fLoadScreenTime * 192.0;\n\t\t\tif(PixelAddress(vScreenCoord) > fAddressLoaded)\n\t\t\t{\n\t\t\t\tif(vPhase.y < 4.0)\n\t\t\t\t{\n\t\t\t\t\tcol = vec3(1.0);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\tif(vPhase.y < 8.0)\n\t\t\t\t{\n\t\t\t\t\tvec2 vTextPos = vec2(0.0, 8.0);\n\t\t\t\t\tfPixelValue = GetProgramText(vScreenCoord - vTextPos);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvec2 vTextPos = vec2(10.0 * 8.0, 19.0 * 8.0);\n\t\t\t\t\tfPixelValue = GetLoadingText(vScreenCoord - vTextPos);\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// loading screen\n\t\t\t\tfPixelValue = GetLoadingScreenPixel(vScreenCoord);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t}\n\t\t\n\t\t\tif(AttributeAddress(vAttribCoord) < fAddressLoaded)\n\t\t\t{\n\t\t\t\tvInk = vec3(0.0, 0.0, 1.0);\n\t\t\t\tvPaper = vec3(1.0, 1.0, 0.0);\n\t\t\t}\t\t\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// running\n\t\t\tfPixelValue = GetScreenPixel(vScreenCoord);\n\t\t\t\n\t\t\tvec2 vTextPos = vec2(-8.0 * 8.0, 8.0);\n\t\t\tfloat fAttribValue = GetLoadingText(vAttribCoord - vTextPos );\n\t\t\tvPaper = mix(vec3(0.0, 1.0, 1.0), vec3(1.0, 0.0, 0.0), fAttribValue);\n\t\t\tvInk = vec3(0.0, 0.0, 1.0);\n\t\t}     \n\t\n\t\t//fPixelValue = GetScreenPixel(vScreenCoord); // force final effect\t\t\t\n\t\t//fPixelValue = GetLoadingScreenPixel( vScreenCoord); // force loading screen\n\t\n\t\tcol = mix(vPaper, vInk, fPixelValue);\n\t\t\n\t}\n\n\tfloat kBrightness = 0.8;\n\tfragColor = vec4( col * kBrightness, 1.0 );  \n}\n\n#endif\n\n#ifdef C64\nhighp vec4 font2(int c) {\n  vec4 v = vec4(0);\n  v=mix(v, vec4(0x3c66, 0x6e6e, 0x6062, 0x3c00), step(-0.500, float(c)));\n  v=mix(v, vec4(0x183c, 0x667e, 0x6666, 0x6600), step(0.500, float(c)));\n  v=mix(v, vec4(0x7c66, 0x667c, 0x6666, 0x7c00), step(1.500, float(c)));\n  v=mix(v, vec4(0x3c66, 0x6060, 0x6066, 0x3c00), step(2.500, float(c)));\n  v=mix(v, vec4(0x786c, 0x6666, 0x666c, 0x7800), step(3.500, float(c)));\n  v=mix(v, vec4(0x7e60, 0x6078, 0x6060, 0x7e00), step(4.500, float(c)));\n  v=mix(v, vec4(0x7e60, 0x6078, 0x6060, 0x6000), step(5.500, float(c)));\n  v=mix(v, vec4(0x3c66, 0x606e, 0x6666, 0x3c00), step(6.500, float(c)));\n  v=mix(v, vec4(0x6666, 0x667e, 0x6666, 0x6600), step(7.500, float(c)));\n  v=mix(v, vec4(0x3c18, 0x1818, 0x1818, 0x3c00), step(8.500, float(c)));\n  v=mix(v, vec4(0x1e0c, 0xc0c, 0xc6c, 0x3800), step(9.500, float(c)));\n  v=mix(v, vec4(0x666c, 0x7870, 0x786c, 0x6600), step(10.500, float(c)));\n  v=mix(v, vec4(0x6060, 0x6060, 0x6060, 0x7e00), step(11.500, float(c)));\n  v=mix(v, vec4(0x6377, 0x7f6b, 0x6363, 0x6300), step(12.500, float(c)));\n  v=mix(v, vec4(0x6676, 0x7e7e, 0x6e66, 0x6600), step(13.500, float(c)));\n  v=mix(v, vec4(0x3c66, 0x6666, 0x6666, 0x3c00), step(14.500, float(c)));\n  v=mix(v, vec4(0x7c66, 0x667c, 0x6060, 0x6000), step(15.500, float(c)));\n  v=mix(v, vec4(0x3c66, 0x6666, 0x663c, 0xe00), step(16.500, float(c)));\n  v=mix(v, vec4(0x7c66, 0x667c, 0x786c, 0x6600), step(17.500, float(c)));\n  v=mix(v, vec4(0x3c66, 0x603c, 0x666, 0x3c00), step(18.500, float(c)));\n  v=mix(v, vec4(0x7e18, 0x1818, 0x1818, 0x1800), step(19.500, float(c)));\n  v=mix(v, vec4(0x6666, 0x6666, 0x6666, 0x3c00), step(20.500, float(c)));\n  v=mix(v, vec4(0x6666, 0x6666, 0x663c, 0x1800), step(21.500, float(c)));\n  v=mix(v, vec4(0x6363, 0x636b, 0x7f77, 0x6300), step(22.500, float(c)));\n  v=mix(v, vec4(0x6666, 0x3c18, 0x3c66, 0x6600), step(23.500, float(c)));\n  v=mix(v, vec4(0x6666, 0x663c, 0x1818, 0x1800), step(24.500, float(c)));\n  v=mix(v, vec4(0x7e06, 0xc18, 0x3060, 0x7e00), step(25.500, float(c)));\n  v=mix(v, vec4(0x3c30, 0x3030, 0x3030, 0x3c00), step(26.500, float(c)));\n  v=mix(v, vec4(0xc12, 0x307c, 0x3062, 0xfc00), step(27.500, float(c)));\n  v=mix(v, vec4(0x3c0c, 0xc0c, 0xc0c, 0x3c00), step(28.500, float(c)));\n  v=mix(v, vec4(0x18, 0x3c7e, 0x1818, 0x1818), step(29.500, float(c)));\n  v=mix(v, vec4(0x10, 0x307f, 0x7f30, 0x1000), step(30.500, float(c)));\n  v=mix(v, vec4(0x0, 0x0, 0x0, 0x0), step(31.500, float(c)));\n  v=mix(v, vec4(0x1818, 0x1818, 0x0, 0x1800), step(32.500, float(c)));\n  v=mix(v, vec4(0x6666, 0x6600, 0x0, 0x0), step(33.500, float(c)));\n  v=mix(v, vec4(0x6666, 0xff66, 0xff66, 0x6600), step(34.500, float(c)));\n  v=mix(v, vec4(0x183e, 0x603c, 0x67c, 0x1800), step(35.500, float(c)));\n  v=mix(v, vec4(0x6266, 0xc18, 0x3066, 0x4600), step(36.500, float(c)));\n  v=mix(v, vec4(0x3c66, 0x3c38, 0x6766, 0x3f00), step(37.500, float(c)));\n  v=mix(v, vec4(0x60c, 0x1800, 0x0, 0x0), step(38.500, float(c)));\n  v=mix(v, vec4(0xc18, 0x3030, 0x3018, 0xc00), step(39.500, float(c)));\n  v=mix(v, vec4(0x3018, 0xc0c, 0xc18, 0x3000), step(40.500, float(c)));\n  v=mix(v, vec4(0x66, 0x3cff, 0x3c66, 0x0), step(41.500, float(c)));\n  v=mix(v, vec4(0x18, 0x187e, 0x1818, 0x0), step(42.500, float(c)));\n  v=mix(v, vec4(0x0, 0x0, 0x18, 0x1830), step(43.500, float(c)));\n  v=mix(v, vec4(0x0, 0x7e, 0x0, 0x0), step(44.500, float(c)));\n  v=mix(v, vec4(0x0, 0x0, 0x18, 0x1800), step(45.500, float(c)));\n  v=mix(v, vec4(0x3, 0x60c, 0x1830, 0x6000), step(46.500, float(c)));\n  v=mix(v, vec4(0x3c66, 0x6e76, 0x6666, 0x3c00), step(47.500, float(c)));\n  v=mix(v, vec4(0x1818, 0x3818, 0x1818, 0x7e00), step(48.500, float(c)));\n  v=mix(v, vec4(0x3c66, 0x60c, 0x3060, 0x7e00), step(49.500, float(c)));\n  v=mix(v, vec4(0x3c66, 0x61c, 0x666, 0x3c00), step(50.500, float(c)));\n  v=mix(v, vec4(0x60e, 0x1e66, 0x7f06, 0x600), step(51.500, float(c)));\n  v=mix(v, vec4(0x7e60, 0x7c06, 0x666, 0x3c00), step(52.500, float(c)));\n  v=mix(v, vec4(0x3c66, 0x607c, 0x6666, 0x3c00), step(53.500, float(c)));\n  v=mix(v, vec4(0x7e66, 0xc18, 0x1818, 0x1800), step(54.500, float(c)));\n  v=mix(v, vec4(0x3c66, 0x663c, 0x6666, 0x3c00), step(55.500, float(c)));\n  v=mix(v, vec4(0x3c66, 0x663e, 0x666, 0x3c00), step(56.500, float(c)));\n  v=mix(v, vec4(0x0, 0x1800, 0x18, 0x0), step(57.500, float(c)));\n  v=mix(v, vec4(0x0, 0x1800, 0x18, 0x1830), step(58.500, float(c)));\n  v=mix(v, vec4(0xe18, 0x3060, 0x3018, 0xe00), step(59.500, float(c)));\n  v=mix(v, vec4(0x0, 0x7e00, 0x7e00, 0x0), step(60.500, float(c)));\n  v=mix(v, vec4(0x7018, 0xc06, 0xc18, 0x7000), step(61.500, float(c)));\n  v=mix(v, vec4(0x3c66, 0x60c, 0x1800, 0x1800), step(62.500, float(c)));\n  v=mix(v, vec4(0x0, 0xff, 0xff00, 0x0), step(63.500, float(c)));\n  v=mix(v, vec4(0x81c, 0x3e7f, 0x7f1c, 0x3e00), step(64.500, float(c)));\n  v=mix(v, vec4(0x1818, 0x1818, 0x1818, 0x1818), step(65.500, float(c)));\n  v=mix(v, vec4(0x0, 0xff, 0xff00, 0x0), step(66.500, float(c)));\n  v=mix(v, vec4(0x0, 0xffff, 0x0, 0x0), step(67.500, float(c)));\n  v=mix(v, vec4(0xff, 0xff00, 0x0, 0x0), step(68.500, float(c)));\n  v=mix(v, vec4(0x0, 0x0, 0xffff, 0x0), step(69.500, float(c)));\n  v=mix(v, vec4(0x3030, 0x3030, 0x3030, 0x3030), step(70.500, float(c)));\n  v=mix(v, vec4(0xc0c, 0xc0c, 0xc0c, 0xc0c), step(71.500, float(c)));\n  v=mix(v, vec4(0x0, 0xe0, 0xf038, 0x1818), step(72.500, float(c)));\n  v=mix(v, vec4(0x1818, 0x1c0f, 0x700, 0x0), step(73.500, float(c)));\n  v=mix(v, vec4(0x1818, 0x38f0, 0xe000, 0x0), step(74.500, float(c)));\n  v=mix(v, vec4(0xc0c0, 0xc0c0, 0xc0c0, 0xffff), step(75.500, float(c)));\n  v=mix(v, vec4(0xc0e0, 0x7038, 0x1c0e, 0x703), step(76.500, float(c)));\n  v=mix(v, vec4(0x307, 0xe1c, 0x3870, 0xe0c0), step(77.500, float(c)));\n  v=mix(v, vec4(0xffff, 0xc0c0, 0xc0c0, 0xc0c0), step(78.500, float(c)));\n  v=mix(v, vec4(0xffff, 0x303, 0x303, 0x303), step(79.500, float(c)));\n  v=mix(v, vec4(0x3c, 0x7e7e, 0x7e7e, 0x3c00), step(80.500, float(c)));\n  v=mix(v, vec4(0x0, 0x0, 0xff, 0xff00), step(81.500, float(c)));\n  v=mix(v, vec4(0x367f, 0x7f7f, 0x3e1c, 0x800), step(82.500, float(c)));\n  v=mix(v, vec4(0x6060, 0x6060, 0x6060, 0x6060), step(83.500, float(c)));\n  v=mix(v, vec4(0x0, 0x7, 0xf1c, 0x1818), step(84.500, float(c)));\n  v=mix(v, vec4(0xc3e7, 0x7e3c, 0x3c7e, 0xe7c3), step(85.500, float(c)));\n  v=mix(v, vec4(0x3c, 0x7e66, 0x667e, 0x3c00), step(86.500, float(c)));\n  v=mix(v, vec4(0x1818, 0x6666, 0x1818, 0x3c00), step(87.500, float(c)));\n  v=mix(v, vec4(0x606, 0x606, 0x606, 0x606), step(88.500, float(c)));\n  v=mix(v, vec4(0x81c, 0x3e7f, 0x3e1c, 0x800), step(89.500, float(c)));\n  v=mix(v, vec4(0x1818, 0x18ff, 0xff18, 0x1818), step(90.500, float(c)));\n  v=mix(v, vec4(0xc0c0, 0x3030, 0xc0c0, 0x3030), step(91.500, float(c)));\n  v=mix(v, vec4(0x1818, 0x1818, 0x1818, 0x1818), step(92.500, float(c)));\n  v=mix(v, vec4(0x0, 0x33e, 0x7636, 0x3600), step(93.500, float(c)));\n  v=mix(v, vec4(0xff7f, 0x3f1f, 0xf07, 0x301), step(94.500, float(c)));\n  v=mix(v, vec4(0x0, 0x0, 0x0, 0x0), step(95.500, float(c)));\n  v=mix(v, vec4(0xf0f0, 0xf0f0, 0xf0f0, 0xf0f0), step(96.500, float(c)));\n  v=mix(v, vec4(0x0, 0x0, 0xffff, 0xffff), step(97.500, float(c)));\n  v=mix(v, vec4(0xff00, 0x0, 0x0, 0x0), step(98.500, float(c)));\n  v=mix(v, vec4(0x0, 0x0, 0x0, 0xff), step(99.500, float(c)));\n  v=mix(v, vec4(0xc0c0, 0xc0c0, 0xc0c0, 0xc0c0), step(100.500, float(c)));\n  v=mix(v, vec4(0xcccc, 0x3333, 0xcccc, 0x3333), step(101.500, float(c)));\n  v=mix(v, vec4(0x303, 0x303, 0x303, 0x303), step(102.500, float(c)));\n  v=mix(v, vec4(0x0, 0x0, 0xcccc, 0x3333), step(103.500, float(c)));\n  v=mix(v, vec4(0xfffe, 0xfcf8, 0xf0e0, 0xc080), step(104.500, float(c)));\n  v=mix(v, vec4(0x303, 0x303, 0x303, 0x303), step(105.500, float(c)));\n  v=mix(v, vec4(0x1818, 0x181f, 0x1f18, 0x1818), step(106.500, float(c)));\n  v=mix(v, vec4(0x0, 0x0, 0xf0f, 0xf0f), step(107.500, float(c)));\n  v=mix(v, vec4(0x1818, 0x181f, 0x1f00, 0x0), step(108.500, float(c)));\n  v=mix(v, vec4(0x0, 0xf8, 0xf818, 0x1818), step(109.500, float(c)));\n  v=mix(v, vec4(0x0, 0x0, 0x0, 0xffff), step(110.500, float(c)));\n  v=mix(v, vec4(0x0, 0x1f, 0x1f18, 0x1818), step(111.500, float(c)));\n  v=mix(v, vec4(0x1818, 0x18ff, 0xff00, 0x0), step(112.500, float(c)));\n  v=mix(v, vec4(0x0, 0xff, 0xff18, 0x1818), step(113.500, float(c)));\n  v=mix(v, vec4(0x1818, 0x18f8, 0xf818, 0x1818), step(114.500, float(c)));\n  v=mix(v, vec4(0xc0c0, 0xc0c0, 0xc0c0, 0xc0c0), step(115.500, float(c)));\n  v=mix(v, vec4(0xe0e0, 0xe0e0, 0xe0e0, 0xe0e0), step(116.500, float(c)));\n  v=mix(v, vec4(0x707, 0x707, 0x707, 0x707), step(117.500, float(c)));\n  v=mix(v, vec4(0xffff, 0x0, 0x0, 0x0), step(118.500, float(c)));\n  v=mix(v, vec4(0xffff, 0xff00, 0x0, 0x0), step(119.500, float(c)));\n  v=mix(v, vec4(0x0, 0x0, 0xff, 0xffff), step(120.500, float(c)));\n  v=mix(v, vec4(0x303, 0x303, 0x303, 0xffff), step(121.500, float(c)));\n  v=mix(v, vec4(0x0, 0x0, 0xf0f0, 0xf0f0), step(122.500, float(c)));\n  v=mix(v, vec4(0xf0f, 0xf0f, 0x0, 0x0), step(123.500, float(c)));\n  v=mix(v, vec4(0x1818, 0x18f8, 0xf800, 0x0), step(124.500, float(c)));\n  v=mix(v, vec4(0xf0f0, 0xf0f0, 0x0, 0x0), step(125.500, float(c)));\n  v=mix(v, vec4(0xf0f0, 0xf0f0, 0xf0f, 0xf0f), step(126.500, float(c)));\n  return v;\n}\n\nhighp vec4 font(int c) {\n    if (c < 128) return font2(c);\n    return vec4(0xffff) - font2(c - 128);\n}\n\nvec4 colors(int c) {\n    if (c ==  0) return vec4(0x00,0x00,0x00,1);\n    if (c ==  1) return vec4(0xFF,0xFF,0xFF,1);\n    if (c ==  2) return vec4(0x68,0x37,0x2B,1);\n    if (c ==  3) return vec4(0x70,0xA4,0xB2,1);\n    if (c ==  4) return vec4(0x6F,0x3D,0x86,1);\n    if (c ==  5) return vec4(0x58,0x8D,0x43,1);\n    if (c ==  6) return vec4(0x35,0x28,0x79,1);\n    if (c ==  7) return vec4(0xB8,0xC7,0x6F,1);\n    if (c ==  8) return vec4(0x6F,0x4F,0x25,1);\n    if (c ==  9) return vec4(0x43,0x39,0x00,1);\n    if (c == 10) return vec4(0x9A,0x67,0x59,1);\n    if (c == 11) return vec4(0x44,0x44,0x44,1);\n    if (c == 12) return vec4(0x6C,0x6C,0x6C,1);\n    if (c == 13) return vec4(0x9A,0xD2,0x84,1);\n    if (c == 14) return vec4(0x6C,0x5E,0xB5,1);\n    if (c == 15) return vec4(0x95,0x95,0x95,1);\n    return vec4(0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 1.1 - 0.05;\n    if ( any( lessThan( uv, vec2(0) ) ) || any( greaterThanEqual( uv, vec2(1) ) ) )\n    {\n        fragColor = colors(14) / 180.0;\n        return;\n    }\n    vec2 sz = vec2(40.0, 20.0);\n    vec2 fb_pos = floor(uv * sz) + vec2(0.5, 0.5);\n    fb_pos.y = sz.y - fb_pos.y;\n    fb_pos /= iResolution.xy;\n    \n\tvec4 fb = texture(iChannel0, fb_pos);\n    highp vec4 char = font(int(fb.x));\n\n    vec2 p = mod(uv * sz * 8.0, 8.0);\n\tint line = 7 - int(p.y);\n    highp float pixels = 0.0;\n    if (line == 0) pixels = char.x / 256.0;\n    if (line == 1) pixels = char.x;\n    if (line == 2) pixels = char.y / 256.0;\n    if (line == 3) pixels = char.y;\n    if (line == 4) pixels = char.z / 256.0;\n    if (line == 5) pixels = char.z;\n    if (line == 6) pixels = char.w / 256.0;\n    if (line == 7) pixels = char.w;\n\n    if (mod(pixels * pow(2.0, floor(p.x)), 256.0) > 127.5) {\n        fragColor = colors(int(fb.y)) / 180.0;\n    } else {\n        fragColor = colors(int(fb.z)) / 180.0;\n    }\n}\n#endif\n\n#ifdef MANDELBROT\n\n///////////////////////////\n// Keyboard\n///////////////////////////\n\nconst float KEY_SPACE = 32.5/256.0;\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_UP    = 38.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\nconst float KEY_DOWN  = 40.5/256.0;\n\nconst float KEY_PLUS \t= 187.5/256.0;\nconst float KEY_MINUS  \t= 189.5/256.0;\n\nbool Key_IsPressed(float key)\n{\n    return texture( iChannel1, vec2(key, 0.0) ).x > 0.0;\n}\n\nbool Key_IsToggled(float key)\n{\n    return texture( iChannel1, vec2(key, 1.0) ).x > 0.0;\n}\n\n///////////////////////////\n\n\nfloat VGARainbowChannel( float i, float a, float b, float c, float d, float e )\n{    \n    if ( i >= 8.0 ) i = 16.0 - i;\n    if ( i <= 0.0 ) return a;\n    if ( i == 1.0 ) return b;\n    if ( i == 2.0 ) return c;\n    if ( i == 3.0 ) return d;\n    if ( i >= 4.0 ) return e;\n    return a;\n}\n\nvec3 VGARainbow( float i, float a, float e )\n{\n    vec3 vi = mod( vec3( i ) + vec3(0,16,8), vec3(24) );\n\n    float b = floor(a * 3./4. + e * 1.0 / 4.0 + 0.25);\n    float c = floor(a * 2./4. + e * 2.0 / 4.0 + 0.25);\n    float d = floor(a * 1./4. + e * 3.0 / 4.0 + 0.25);\n    \n    vec3 col;\n    col.r = VGARainbowChannel( vi.r, a, b, c, d, e );\n    col.g = VGARainbowChannel( vi.g, a, b, c, d, e );\n    col.b = VGARainbowChannel( vi.b, a, b, c, d, e );\n\n    return col;\n}\n\nvec3 VGAPaletteEntry( float i )\n{\n    i = floor( i );\n    \n    // EGA\n    if ( i < 16.0 )\n    {\n        vec3 col;\n        col.b  = floor( mod( i / 1.0, 2.0  )) * 2.0;\n        col.g  = floor( mod( i / 2.0, 2.0  )) * 2.0;\n        col.r  = floor( mod( i / 4.0, 2.0  )) * 2.0;        \n        \n        col += floor( mod( i / 8.0, 2.0  ) );\n        \n        if ( i == 6.0 ) col = vec3(2,1,0); // Special brown!\n\n        return col * 21.;\n    }\n\n    // Greys\n    if ( i == 16.0 ) return vec3(0.0);\n    \n    if ( i < 32.0 )\n    {        \n        float x = (i - 17.0);        \n        return vec3( floor( .00084 * x * x * x * x - .01662 * x * x * x + .1859 * x * x + 2.453 * x + 5.6038 ) );\n    }\n    \n    // Rainbows\n    float rainbowIndex = mod( i - 32.0, 24.0 );\n    float rainbowType = floor( (i - 32.0) / 24.0 );\n    \n    float rainbowTypeMod = floor( mod( rainbowType, 3.0 ) );\n    float rainbowTypeDiv = floor( rainbowType / 3.0 );\n    \n    float rainbowLow = 0.;\n    if ( rainbowTypeMod == 1.0 ) rainbowLow = 31.0;\n    if ( rainbowTypeMod == 2.0 ) rainbowLow = 45.0;\n    \n    float rainbowHigh = 63.;\n    if ( rainbowTypeDiv == 1.0 )\n    {\n        rainbowHigh = 28.0;\n        rainbowLow = floor( rainbowLow / 2.2 );\n    }\n    if ( rainbowTypeDiv == 2.0 )\n    {\n        rainbowHigh = 16.0;\n        rainbowLow = floor( rainbowLow / 3.8 );\n    }\n    \n    if ( rainbowType < 9.0 )\n    {\n\t    return VGARainbow( rainbowIndex, rainbowLow, rainbowHigh );\n    }\n    \n    return vec3( 0.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 vUV = fragCoord.xy / iResolution.xy;\n    \n    vec2 vFakeResolution = vec2(640,480);\n    vUV = floor(vUV * vFakeResolution) / vFakeResolution;\n    \n    vec2 vFocus = vec2(-0.5, 0.0);\n    vec2 vScale = vec2(2.0);\n    \n    if ( false )  // disable mouse control\n    if ( iMouse.z > 0.0 )\n    {\n    \tvFocus += 2.0 * ((iMouse.xy / iResolution.xy) * 2.0 - 1.0);\n    \tvScale *= 0.02;\n    }\n    \n    vScale.y /= iResolution.x / iResolution.y;\n    \n    vec2 z = vec2(0);\n    vec2 c = vFocus + (vUV * 2.0 - 1.0) * vScale;\n    \n    bool bInside = true;\n    \n    float fIter = 0.0;\n    for(int iter = 0; iter < 512; iter++)\n    {        \n \t\tz = mat2(z,-z.y,z.x) * z + c;\n     \n        if ( dot(z,z) > 4.0 )            \n        {\n            bInside = false;\n            break;\n        }       \n        \n        fIter++;\n    }\n    \n    float fIndex = 0.0;\n    if ( bInside ) \n    {\n        //fIndex = 0.0; // black set\n        fIndex = 1.0; // blue set\n    }\n    else\n    {\n \n        if ( Key_IsToggled( KEY_PLUS ) || Key_IsToggled( KEY_RIGHT ) )\n        {\n        \tfIter += iTime * 10.0;\n        }\n        else\n        if ( Key_IsToggled( KEY_MINUS ) || Key_IsToggled( KEY_LEFT ) )\n        {\n        \tfIter -= iTime * 10.0;\n        }\n        \n    \tfIndex = 1.0 + mod( fIter, 255.0 );\n    }\n    \n\tfragColor.rgb = VGAPaletteEntry( fIndex ) / 63.0;\n    fragColor.a = 1.0;\n}\n\n#endif\n\n#ifdef SHADERTOY\n// Shadertoy font shader - @P_Malin\n\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// ----------------------------------------------------------------------------------------\n\n//#define LOW_QUALITY\n\n// The main characters are made up from a number of curve segments.\n// I made another shader to illustrate how these work:\n//\n//     https://www.shadertoy.com/view/Xds3Dn\n//\n// The middle of the characters are filled in triangles or convex quadrilaterals\n// Enable this define to see just the curved sections:\n\n//#define CURVES_ONLY\n\n// Initially I made most of characters this way but I ran into the constant register limit. \n// To avoid this, the curved sections of the â€˜oâ€™, â€˜aâ€™ and â€˜dâ€™ are oval shapes. \n// Also I managed to cut the constant data down dramatically by sharing a lot of\n// the shapes in the font (see the comments in the function Shadertoy() ). \n// For example the tails for â€˜hâ€™, â€™aâ€™, â€˜dâ€™, â€˜tâ€™, the left hand side of the â€˜yâ€™ and the \n// top of the â€˜hâ€™ all use the same shape! \n// I was probably more happy that I should have been when I realised I could share\n// the shape making the curve of the â€˜râ€™ with the little loop on the â€˜oâ€™.\n//\n// I experimented with a distance field version but it looked like it would involve \n// a lot more work and I thought Iâ€™d already spent too much time on this shader :)\n\n#ifdef LOW_QUALITY\n\n\t#define AA_X 1\n\t#define AA_Y 1\n\n#else\n\n\t#define AA_X 2\n\t#define AA_Y 2\n\n#endif\n\n\nfloat TestCurve(vec2 uv)\n{\n\tuv = 1.0 - uv;\n    return 1.0 - dot(uv, uv);\n}\n\nfloat Cross( const in vec2 A, const in vec2 B )\n{\n    return A.x * B.y - A.y * B.x;\n}\n\nvec2 GetUV(const in vec2 A, const in vec2 B, const in vec2 C, const in vec2 P)\n{\n    vec2 vPB = B - P;\n    float f1 = Cross(A-B, vPB);\n    float f2 = Cross(B-C, vPB);\n    float f3 = Cross(C-A, C-P);\n    \n    return vec2(f1, f2) / (f1 + f2 + f3);\n}\n\nfloat InCurve( const in vec2 A, const in vec2 B, const in vec2 C, const in vec2 P )\n{\n    vec2 vCurveUV = GetUV(A, B, C, P);\n    \n    float fResult = -1.0;\n\n\tfResult = max(fResult, (-vCurveUV.x));\n\tfResult = max(fResult, (-vCurveUV.y));\n\tfResult = max(fResult, (vCurveUV.x + vCurveUV.y - 1.0));\n\n\tfloat fCurveResult = TestCurve(vCurveUV);\n\t\t\n\tfResult = max(fResult, fCurveResult);\t\n\t\n    return fResult;\n}\n\nfloat InCurve2( const in vec2 A, const in vec2 B, const in vec2 C, const in vec2 P )\n{\n    vec2 vCurveUV = GetUV(A, B, C, P);\n\t\n    float fResult = -1.0;\n\n\tfResult = max(fResult, (vCurveUV.x + vCurveUV.y - 1.0));\n\t\n\tfloat fCurveResult = -TestCurve(vCurveUV);\n\t\n\tfResult = max(fResult, fCurveResult);\t\n\t\n    return fResult;\n}\n\nfloat InTri( const in vec2 A, const in vec2 B, const in vec2 C, const in vec2 P )\n{\n\t#ifdef CURVES_ONLY\n\treturn 1.0;\n\t#endif\n\t\n    float f1 = Cross(B-A, A-P);\n    float f2 = Cross(C-B, B-P);\n    float f3 = Cross(A-C, C-P);\n\t\n    return (max(max(f1, f2), f3));\n}\n\nfloat InQuad( const in vec2 A, const in vec2 B, const in vec2 C, const in vec2 D, const in vec2 P )\n{\n\t#ifdef CURVES_ONLY\n\treturn 1.0;\n\t#endif\n\t\n    float f1 = Cross(B-A, A-P);\n    float f2 = Cross(C-B, B-P);\n    float f3 = Cross(D-C, C-P);\n    float f4 = Cross(A-D, D-P);\n    \n    return (max(max(max(f1, f2), f3), f4));\n}\n\n\nfloat Glyph0(const in vec2 uv)\n{\n    const vec2  vP0 = vec2 ( 0.112, 0.056 );\n    const vec2  vP1 = vec2 ( 0.136, 0.026 );\n    const vec2  vP2 = vec2 ( 0.108, 0.022 );\n    const vec2  vP3 = vec2 ( 0.083, 0.017 ); \n    const vec2  vP4 = vec2 ( 0.082, 0.036 ); \n    const vec2  vP5 = vec2 ( 0.088, 0.062 ); \n    const vec2  vP6 = vec2 ( 0.115, 0.086 ); \n    const vec2  vP7 = vec2 ( 0.172, 0.147 ); \n    const vec2  vP8 = vec2 ( 0.100, 0.184 ); \n    const vec2  vP9 = vec2 ( 0.034, 0.206 ); \n    const vec2 vP10 = vec2 ( 0.021, 0.160 ); \n    const vec2 vP11 = vec2 ( 0.011, 0.114 ); \n    const vec2 vP12 = vec2 ( 0.052, 0.112 ); \n    const vec2 vP13 = vec2 ( 0.070, 0.108 ); \n    const vec2 vP14 = vec2 ( 0.075, 0.126 );\n    const vec2 vP15 = vec2 ( 0.049, 0.124 );\n    const vec2 vP16 = vec2 ( 0.047, 0.148 );\n    const vec2 vP17 = vec2 ( 0.046, 0.169 );\n    const vec2 vP18 = vec2 ( 0.071, 0.171 );\n    const vec2 vP19 = vec2 ( 0.098, 0.171 ); \n    const vec2 vP20 = vec2 ( 0.097, 0.143 ); \n    const vec2 vP21 = vec2 ( 0.100, 0.118 ); \n    const vec2 vP22 = vec2 ( 0.080, 0.100 ); \n    const vec2 vP23 = vec2 ( 0.055, 0.083 ); \n    const vec2 vP24 = vec2 ( 0.050, 0.052 ); \n    const vec2 vP25 = vec2 ( 0.052, 0.004 ); \n    const vec2 vP26 = vec2 ( 0.107, 0.010 ); \n    const vec2 vP27 = vec2 ( 0.148, 0.011 ); \n    const vec2 vP28 = vec2 ( 0.140, 0.041 ); \n    const vec2 vP29 = vec2 ( 0.139, 0.069 ); \n\n    float fDist = 1.0;\n\n\tfDist = min( fDist, InCurve2(vP6,vP7,vP8, uv) );\n    fDist = min( fDist, InCurve2(vP8,vP9,vP10, uv) );\n\tfDist = min( fDist, InCurve2(vP10,vP11,vP12, uv) );\n    fDist = min( fDist, InCurve2(vP12,vP13,vP14, uv) );\n\tfDist = min( fDist, InCurve(vP14,vP15,vP16, uv) );\n    fDist = min( fDist, InCurve(vP16,vP17,vP18, uv) );\n    fDist = min( fDist, InCurve(vP18,vP19,vP20, uv) );\n    fDist = min( fDist, InCurve(vP20,vP21,vP22, uv) );\n\tfDist = min( fDist, InCurve2(vP22,vP23,vP24, uv) );\n    fDist = min( fDist, InCurve2(vP24,vP25,vP26, uv) );\n    fDist = min( fDist, InCurve2(vP26,vP27,vP28, uv) );\n    fDist = min( fDist, InCurve2(vP28,vP29,vP0, uv) );\n\tfDist = min( fDist, InCurve(vP0,vP1,vP2, uv) );\n\tfDist = min( fDist, InCurve(vP2,vP3,vP4, uv) );\n    fDist = min( fDist, InCurve(vP4,vP5,vP6, uv) );\n\n\n    fDist = min( fDist, InTri(vP0, vP1, vP28, uv) );\n\tfDist = min( fDist, InQuad(vP26, vP1, vP2, vP3, uv) );\n    fDist = min( fDist, InTri(vP3, vP4, vP24, uv) );\n    fDist = min( fDist, InTri(vP4, vP5, vP24, uv) );\n    fDist = min( fDist, InTri(vP24, vP5, vP22, uv) );\n    fDist = min( fDist, InTri(vP5, vP6, vP22, uv) );\n    fDist = min( fDist, InTri(vP22, vP6, vP21, uv) );\n    fDist = min( fDist, InTri(vP6, vP8, vP21, uv) );\n    fDist = min( fDist, InTri(vP21, vP8, vP20, uv) );\n    fDist = min( fDist, InTri(vP20, vP8, vP19, uv) );\n    fDist = min( fDist, InTri(vP19, vP8, vP18, uv) );\n    fDist = min( fDist, InTri(vP18, vP8, vP10, uv) );\n    fDist = min( fDist, InTri(vP10, vP16, vP17, uv) );\n    fDist = min( fDist, InTri(vP10, vP15, vP16, uv) );\n    fDist = min( fDist, InTri(vP10, vP12, vP16, uv) );\n    fDist = min( fDist, InTri(vP12, vP14, vP15, uv) );\n\n    return fDist;\n}\n\nfloat Glyph1(const in vec2 uv, const in vec2 vOffset)\n{\n    vec2 vP0 = vec2 ( 0.171, 0.026 ) + vOffset;\n    vec2 vP1 = vec2 ( 0.204, 0.022 ) + vOffset;\n    const vec2 vP2 = vec2 ( 0.170, 0.185 );\n    const vec2 vP3 = vec2 ( 0.137, 0.185 );\n    \n    return InQuad(vP0, vP1, vP2, vP3, uv);\n}\n\nfloat Glyph3(const in vec2 uv, vec2 vOffset)\n{\n    vec2 vP0 = vec2 ( 0.212, 0.112 ) + vOffset;\n    vec2 vP2 = vec2 ( 0.243, 0.112 ) + vOffset;\n    const vec2  vP4 = vec2 ( 0.234, 0.150 );\n    const vec2  vP5 = vec2 ( 0.230, 0.159 );\n    const vec2  vP6 = vec2 ( 0.243, 0.164 );\n    const vec2  vP7 = vec2 ( 0.257, 0.164 );\n    const vec2  vP8 = vec2 ( 0.261, 0.148 );\n    const vec2 vP10 = vec2 ( 0.265, 0.164 );\n    const vec2 vP11 = vec2 ( 0.256, 0.180 );\n    const vec2 vP12 = vec2 ( 0.239, 0.185 );\n    const vec2 vP13 = vec2 ( 0.194, 0.194 );\n    const vec2 vP14 = vec2 ( 0.203, 0.150 );\n    const vec2 vP16 = vec2 ( 0.212, 0.113 );\n\n    float fDist = 1.0;\n    fDist = min( fDist, InCurve(vP4,vP5,vP6, uv) );\n    fDist = min( fDist, InCurve(vP6,vP7,vP8, uv) );\n    fDist = min( fDist, InCurve2(vP10,vP11,vP12, uv) );\n    fDist = min( fDist, InCurve2(vP12,vP13,vP14, uv) );\n\n    fDist = min( fDist, InQuad(vP0, vP2, vP4, vP14, uv) );\n    fDist = min( fDist, InTri(vP14, vP4, vP5, uv) );\n    fDist = min( fDist, InTri(vP14, vP5, vP12, uv) );\n    fDist = min( fDist, InTri(vP5, vP6, vP12, uv) );\n    fDist = min( fDist, InTri(vP6, vP7, vP12, uv) );\n    fDist = min( fDist, InTri(vP6, vP10, vP12, uv) );\n    fDist = min( fDist, InTri(vP8, vP10, vP7, uv) );\n    \n    return fDist;\n}\n\nfloat Glyph4(const in vec2 uv)\n{\n    vec2 vP = uv - vec2(0.305, 0.125);\n    vP /= 0.065;\n    vP.x *= 1.5;\n    vP.x += vP.y * 0.25;\n    \n    vec2 vP2 = vP;\n\n    vP.y = abs(vP.y);\n    vP.y = pow(vP.y, 1.2);\n    float f= length(vP);\n    \n    vP2.x *= 1.2;\n    float f2 = length(vP2 * 1.5 - vec2(0.6, 0.0));\n        \n    return max(f - 1.0, 1.0 - f2) / 20.0;\n} \n\nfloat Glyph5(const in vec2 uv)\n{\n    const vec2  vP0 = vec2 ( 0.507, 0.138 );\n    const vec2  vP1 = vec2 ( 0.510, 0.065 );\n    const vec2  vP2 = vec2 ( 0.570, 0.066 );\n    const vec2  vP3 = vec2 ( 0.598, 0.066 );\n    const vec2  vP4 = vec2 ( 0.594, 0.092 );\n    const vec2  vP5 = vec2 ( 0.599, 0.131 );\n    const vec2  vP6 = vec2 ( 0.537, 0.137 );\n    const vec2  vP8 = vec2 ( 0.538, 0.125 );\n    const vec2  vP9 = vec2 ( 0.564, 0.129 );\n    const vec2 vP10 = vec2 ( 0.574, 0.100 );\n    const vec2 vP11 = vec2 ( 0.584, 0.085 );\n    const vec2 vP12 = vec2 ( 0.571, 0.079 );\n    const vec2 vP13 = vec2 ( 0.557, 0.081 );\n    const vec2 vP14 = vec2 ( 0.549, 0.103 );\n    const vec2 vP15 = vec2 ( 0.518, 0.166 );\n    const vec2 vP16 = vec2 ( 0.557, 0.166 );\n    const vec2 vP17 = vec2 ( 0.589, 0.163 );\n    const vec2 vP18 = vec2 ( 0.602, 0.137 );\n    const vec2 vP20 = vec2 ( 0.602, 0.152 );\n    const vec2 vP21 = vec2 ( 0.572, 0.194 );\n    const vec2 vP22 = vec2 ( 0.537, 0.185 );\n    const vec2 vP23 = vec2 ( 0.503, 0.189 );\n    \n    float fDist = 1.0;\n    fDist = min( fDist, InCurve2(vP0,vP1,vP2, uv) ); \n    fDist = min( fDist, InCurve2(vP2,vP3,vP4, uv) ); \n    fDist = min( fDist, InCurve2(vP4,vP5,vP6, uv) );\n    fDist = min( fDist, InCurve(vP8,vP9,vP10, uv) ); \n    fDist = min( fDist, InCurve(vP10,vP11,vP12, uv) ); \n    fDist = min( fDist, InCurve(vP12,vP13,vP14, uv) );\n    fDist = min( fDist, InCurve(vP14,vP15,vP16, uv) );\n    fDist = min( fDist, InCurve(vP16,vP17,vP18, uv) ); \n    fDist = min( fDist, InCurve2(vP20,vP21,vP22, uv) ); \n    fDist = min( fDist, InCurve2(vP22,vP23,vP0, uv) );\n\n    fDist = min( fDist, InTri(vP0, vP2, vP13, uv) );\n    fDist = min( fDist, InTri(vP13, vP2, vP12, uv) );\n    fDist = min( fDist, InTri(vP2, vP11, vP12, uv) );\n    fDist = min( fDist, InTri(vP2, vP4, vP11, uv) );\n    fDist = min( fDist, InTri(vP11, vP4, vP10, uv) );\n    fDist = min( fDist, InTri(vP10, vP4, vP9, uv) );\n    fDist = min( fDist, InTri(vP6, vP8, vP9, uv) );\n    fDist = min( fDist, InTri(vP0, vP13, vP14, uv) );\n    fDist = min( fDist, InTri(vP0, vP14, vP15, uv) );\n    fDist = min( fDist, InTri(vP15, vP16, vP22, uv) );\n    fDist = min( fDist, InTri(vP16, vP17, vP22, uv) );\n    fDist = min( fDist, InTri(vP17, vP18, vP20, uv) );\n    \n    return fDist;\n}\n\nfloat Glyph6(const in vec2 uv)\n{\n    const vec2  vP0 = vec2 ( 0.638 , 0.087 ); \n    const vec2  vP1 = vec2 ( 0.648 , 0.073 ); \n    const vec2  vP2 = vec2 ( 0.673 , 0.068 ); \n    const vec2  vP3 = vec2 ( 0.692 , 0.069 ); \n    const vec2  vP4 = vec2 ( 0.687 , 0.086 ); \n    const vec2  vP5 = vec2 ( 0.688 , 0.104 ); \n    const vec2  vP6 = vec2 ( 0.672 , 0.102 ); \n    const vec2  vP7 = vec2 ( 0.659 , 0.099 ); \n    const vec2  vP8 = vec2 ( 0.663 , 0.092 ); \n    const vec2  vP9 = vec2 ( 0.662 , 0.086 ); \n    const vec2 vP10 = vec2 ( 0.655 , 0.086 ); \n    const vec2 vP11 = vec2 ( 0.644 , 0.087 ); \n    const vec2 vP12 = vec2 ( 0.637 , 0.102 ); \n    const vec2 vP13 = vec2 ( 0.638 , 0.094 ); \n\n    float fDist = 1.0;\n    fDist = min( fDist, InCurve2(vP0,vP1,vP2, uv) ); \n    fDist = min( fDist, InCurve2(vP2,vP3,vP4, uv) ); \n    fDist = min( fDist, InCurve2(vP4,vP5,vP6, uv) ); \n    fDist = min( fDist, InCurve2(vP6,vP7,vP8, uv) ); \n    fDist = min( fDist, InCurve(vP8,vP9,vP10, uv) ); \n    fDist = min( fDist, InCurve(vP10,vP11,vP12, uv) );\n\n    fDist = min( fDist, InQuad(vP2, vP4, vP6, vP8, uv) );\n    fDist = min( fDist, InTri(vP9, vP2, vP8, uv) );\n    fDist = min( fDist, InTri(vP10, vP2, vP9, uv) );\n    fDist = min( fDist, InQuad(vP0, vP2, vP10, vP11, uv) );\n    fDist = min( fDist, InTri(vP11, vP12, vP0, uv) );\n    \n    return fDist;\n}\n\nfloat Glyph7(const in vec2 uv)\n{\n    const vec2 vP0 = vec2 ( 0.693 , 0.068 );\n    const vec2 vP1 = vec2 ( 0.748 , 0.069 );\n    const vec2 vP2 = vec2 ( 0.747 , 0.078 );\n    const vec2 vP3 = vec2 ( 0.691 , 0.077 );\n    \n    return InQuad(vP0, vP1, vP2, vP3, uv);\n}\n\n\nfloat Glyph8(const in vec2 uv)\n{ \n    vec2 vP = uv - vec2(0.788, 0.125);\n    vP /= 0.065;\n    vP.x *= 1.4;\n    vP.x += vP.y * 0.25;\n    \n    vec2 vP2 = vP;\n    \n    vP.y = abs(vP.y);\n    vP.y = pow(vP.y, 1.2);\n    float f= length(vP);\n    \n    vP2.x *= 1.5;\n    float f2 = length(vP2 * 1.5 - vec2(0.3, 0.0));\n    \n    \n    return max(f - 1.0, 1.0 - f2) / 20.0;\n}\n\nfloat Glyph11(const in vec2 uv)\n{\n    const vec2  vP0 = vec2 ( 0.921 , 0.070 );\n    const vec2  vP2 = vec2 ( 0.955 , 0.070 );\n    const vec2  vP4 = vec2 ( 0.926 , 0.202 );\n    const vec2  vP5 = vec2 ( 0.926 , 0.240 );\n    const vec2  vP6 = vec2 ( 0.885 , 0.243 );\n    const vec2  vP7 = vec2 ( 0.852 , 0.239 );\n    const vec2  vP8 = vec2 ( 0.859 , 0.219 );\n    const vec2  vP9 = vec2 ( 0.862 , 0.192 );\n    const vec2 vP10 = vec2 ( 0.889 , 0.189 );\n    const vec2 vP12 = vec2 ( 0.928 , 0.178 );\n    const vec2 vP13 = vec2 ( 0.949 , 0.173 );\n    const vec2 vP14 = vec2 ( 0.951 , 0.162 );\n    const vec2 vP15 = vec2 ( 0.960 , 0.150 );\n    const vec2 vP16 = vec2 ( 0.960 , 0.144 );\n    const vec2 vP18 = vec2 ( 0.971 , 0.144 );\n    const vec2 vP19 = vec2 ( 0.968 , 0.157 );\n    const vec2 vP20 = vec2 ( 0.957 , 0.171 );\n    const vec2 vP21 = vec2 ( 0.949 , 0.182 );\n    const vec2 vP22 = vec2 ( 0.922 , 0.189 );\n    const vec2 vP24 = vec2 ( 0.900 , 0.196 );\n    const vec2 vP25 = vec2 ( 0.866 , 0.205 );\n    const vec2 vP26 = vec2 ( 0.871 , 0.217 );\n    const vec2 vP27 = vec2 ( 0.871 , 0.225 );\n    const vec2 vP28 = vec2 ( 0.880 , 0.224 );\n    const vec2 vP29 = vec2 ( 0.889 , 0.218 );\n    const vec2 vP30 = vec2 ( 0.893 , 0.203 );\n\n    float fDist = 1.0;\n    fDist = min( fDist, InCurve2(vP4,vP5,vP6, uv) );\n    fDist = min( fDist, InCurve2(vP6,vP7,vP8, uv) );\n    fDist = min( fDist, InCurve2(vP8,vP9,vP10, uv) );\n    fDist = min( fDist, InCurve(vP12,vP13,vP14, uv) );\n\n    fDist = min( fDist, InCurve(vP14,vP15,vP16, uv) );\n    fDist = min( fDist, InCurve2(vP18,vP19,vP20, uv) );\n    fDist = min( fDist, InCurve2(vP20,vP21,vP22, uv) );\n\n    fDist = min( fDist, InCurve(vP24,vP25,vP26, uv) );\n    fDist = min( fDist, InCurve(vP26,vP27,vP28, uv) );\n    fDist = min( fDist, InCurve(vP28,vP29,vP30, uv) );\n    \n    fDist = min( fDist, InQuad(vP0, vP2, vP4, vP30, uv) );\n\n    fDist = min( fDist, InQuad(vP10, vP12, vP22, vP24, uv) );\n        \n    fDist = min( fDist, InTri(vP30, vP4, vP6, uv) );\n    fDist = min( fDist, InTri(vP30, vP6, vP29, uv) );\n    fDist = min( fDist, InTri(vP28, vP29, vP6, uv) );\n    fDist = min( fDist, InTri(vP28, vP6, vP27, uv) );\n    \n    fDist = min( fDist, InTri(vP8, vP27, vP6, uv) );\n    \n    fDist = min( fDist, InTri(vP8, vP26, vP27, uv) );\n    fDist = min( fDist, InTri(vP8, vP25, vP26, uv) );\n    fDist = min( fDist, InTri(vP25, vP10, vP24, uv) );\n    \n    fDist = min( fDist, InTri(vP12, vP13, vP20, uv) );\n    fDist = min( fDist, InTri(vP12, vP20, vP22, uv) );\n    fDist = min( fDist, InTri(vP13, vP14, vP20, uv) );\n    fDist = min( fDist, InTri(vP15, vP20, vP14, uv) );\n    fDist = min( fDist, InTri(vP15, vP18, vP20, uv) );\n    fDist = min( fDist, InTri(vP15, vP16, vP18, uv) );\n    \n    return fDist;\n}\n\nfloat Shadertoy(in vec2 uv)\n{\n    float fResult = 1.0;\n    \n    fResult = min(fResult, Glyph0(uv)); // S\n\n    vec2 vUVOffset = vec2(0.001, 0.0); // tail of h\n    vec2 vTailOffset = vec2(0.0, 0.0);  \n    float fUVScale = 1.0;\n\n    if(uv.x < 0.3)\n    {\n        if(uv.y < 0.12)\n        {\n            // top of h\n            fUVScale = -1.0;\n            vUVOffset = vec2(0.448, 0.25);  \n            vTailOffset = vec2(0.0, 0.0);   \n        }\n    }\n    else if(uv.x < 0.4)    \n    {\n        // tail of a\n        vUVOffset = vec2(-0.124, 0.0);  \n        vTailOffset = vec2(0.01, -0.04);    \n    }\n    else if(uv.x < 0.6)\n    {\n        // tail of d\n        vUVOffset = vec2(-0.248, 0.0);  \n        vTailOffset = vec2(0.02, -0.1); \n    }\n    else if(uv.x < 0.83)\n    {\n        // stalk of t\n        vUVOffset = vec2(-0.48, 0.0);   \n        vTailOffset = vec2(0.02, -0.1); \n    }\n    else\n    {\n        // start of y\n        vUVOffset = vec2(-0.645, 0.0);  \n        vTailOffset = vec2(0.005, -0.042);  \n    }\n    \n    fResult = min(fResult, Glyph3(uv * fUVScale + vUVOffset, vTailOffset)); // tails h, a, d, t, start of y and top of h\n\n\n    vec2 vUVOffset3 = vec2(0.0, 0.0);   // vertical of h\n    vec2 vTailOffset3 = vec2(0.0, 0.0);\n    \n    if(uv.x > 0.5)\n    {\n        // vertical of r\n        vUVOffset3 = vec2(-0.45, 0.0);  \n        vTailOffset3 = vec2(-0.01, 0.04);   \n    }\n    \n    fResult = min(fResult, Glyph1(uv + vUVOffset3, vTailOffset3)); // vertical of h, r\n\n    vec2 vUVOffset2 = vec2(0.0, 0.0); // curve of a\n    if(uv.x > 0.365)\n    {\n        vUVOffset2 = vec2(-0.125, 0.0); // curve of d\n    }\n\n    fResult = min(fResult, Glyph4(uv + vUVOffset2)); // curve of a, d\n    \n    fResult = min(fResult, Glyph5(uv)); // e\n\n    vec2 vUVOffset4 = vec2(0.001, 0.0); // top of r\n    vec2 vUVScale4 = vec2(1.0, 1.0);        \n    \n    if(uv.x > 0.7)\n    {\n        // o loop\n        vUVOffset4.x = 1.499;\n        vUVOffset4.y = 0.19;\n        \n        vUVScale4.x = -1.0;\n        vUVScale4.y = -1.0;\n    }\n    \n    fResult = min(fResult, Glyph6(uv * vUVScale4 + vUVOffset4)); // top of r and o loop\n\n    fResult = min(fResult, Glyph7(uv)); // cross t    \n    \n    fResult = min(fResult, Glyph8(uv)); // o1\n    \n    fResult = min(fResult, Glyph11(uv)); // y2        \n\n    return fResult; \n}\n\nvec2 GetUVCentre(const vec2 vInputUV)\n{\n\tvec2 vFontUV = vInputUV;\n    vFontUV.y -= 0.35;\n\t\t\n\treturn vFontUV;\n}\n\nvec2 GetUVScroll(const vec2 vInputUV, float t)\n{\n\tvec2 vFontUV = vInputUV;\n\tvFontUV *= 0.25;\n\t\n    vFontUV.y -= 0.005;\n\tvFontUV.x += t * 3.0 - 1.5;\n\t\n\treturn vFontUV;\n}\n\nvec2 GetUVRepeat(const vec2 vInputUV, float t2)\n{\n\tvec2 vFontUV = vInputUV;\n\t\n\tvFontUV *= vec2(1.0, 4.0);\n\t\n\tvFontUV.x += floor(vFontUV.y) * t2;\n\t\n\tvFontUV = fract(vFontUV);\n\t\n\tvFontUV /= vec2(1.0, 4.0);\n\t\t\n\treturn vFontUV;\n}\n\nvec2 GetUVRotate(const vec2 vInputUV, float t)\n{\n\tvec2 vFontUV = vInputUV - 0.5;\n\t\n\tfloat s = sin(t);\n\tfloat c = cos(t);\n\t\n\tvFontUV = vec2(  vFontUV.x * c + vFontUV.y * s,\n\t\t\t        -vFontUV.x * s + vFontUV.y * c );\n\t\n\tvFontUV += 0.5;\n\t\n\treturn vFontUV;\n}\n\nvec3 StyleDefault( float f )\n{\n\treturn mix(vec3(0.25), vec3(1.0), f);\n}\n\nvec3 StyleScanline( float f, in vec2 fragCoord )\n{\n\tfloat fShade = f * 0.8 + 0.2;\n\t\n    // disable\n\t//fShade *= mod(fragCoord.y, 2.0);\n\t\n\treturn mix(vec3(0.01, 0.2, 0.01), vec3(0.01, 1.0, 0.02), fShade);\n}\n\nvec3 StyleStamp( float fFont, vec2 uv )\n{\n\tvec3 t1 = texture(iChannel2, uv + 0.005).rgb;\n\tvec3 t2 = texture(iChannel2, uv).rgb;\n\tfloat dt = clamp(0.5 + (t1.x - t2.x), 0.0, 1.0);\n\tfloat fWear = clamp((0.9 - t2.x) * 4.0, 0.0, 1.0);\n\tfloat f =  clamp(fFont * fWear, 0.0, 1.0);\n\treturn mix( vec3(1.0, 0.98, 0.9) * (dt * 0.1 + 0.9), vec3(0.7, 0.0, 0.0), f);\n}\n\nvec3 StyleWood( float fFont, vec2 uv )\n{\n\tvec3 t = texture(iChannel2, uv).rgb;\n\tfloat fWear = fFont * smoothstep(0.0, 0.4, t.b);\n\treturn mix(t, vec3(0.0), fWear);\n}\n\nvec4 GetRandom4(float x)\n{\n\treturn fract(vec4(987.65, 432.10, 765.43, 210.98) * sin(vec4(123.456, 789.123, 456.789, 567.890) * x));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tfloat fSequenceLength = 5.0;\n\t\n\tfloat fTime = iTime;\n\t\n\tfloat fBlendSpeed = 0.05;\n\t\n\t// Skip the initial fade-in\n\tfTime += fBlendSpeed * fSequenceLength;\n\t\n\tfloat fInt = floor(fTime / fSequenceLength);\n\tfloat fFract = fract(fTime / fSequenceLength);\n\t\n\tvec4 vRandom4 = GetRandom4(fInt);\n\tvec2 vRandom2 = floor(vRandom4.xy * vec2(1234.56, 123.45));\n\t\n\tfloat fUVEffect = mod(vRandom2.x, 4.0);\n\tfloat fScreenEffect = mod(vRandom2.y, 4.0);\n\n\tif(fInt < 0.5)\n\t{\n\t\tfUVEffect = 0.0;\n\t\tfScreenEffect = 0.0;\n\t}\n\n\tvec4 vResult = vec4(0.0);\n\t\t\n\tfloat fX = 0.0;\n\tfor(int iX=0; iX<AA_X; iX++)\n\t{\n\t\tfloat fY = 0.0;\n\t\tfor(int y=0; y<AA_Y; y++)\n\t\t{\n\t\n\t\t\tvec2 vUV = (fragCoord.xy + vec2(fX, fY)) / iResolution.xy;\n\t\t\tvUV.x = ((vUV.x - 0.5) * (iResolution.x / iResolution.y)) + 0.5;    \n\t\t\tvUV.y = 1.0 - vUV.y;\n\t\t\t\t\n\t\t\tvec2 vFontUV = vUV;\n\t\t\tvec2 vBgUV = vUV;\n\t\t\t\n            if ( false ) \n\t\t\tif(iMouse.z > 0.0)\n\t\t\t{\n\t\t\t\tfUVEffect = 999.0;\n\t\t\t\tfScreenEffect = 0.0;\n\t\t\t\tfFract = 0.5;\n\t\t\t\t\n\t\t\t\tvFontUV *= 0.25;\n\t\t\t\tvFontUV += iMouse.xy / iResolution.xy;\n\t\t\t\tvFontUV.y -= 0.5;\n\t\t\t\tvBgUV = vFontUV;\n\t\t\t}\t\n\t\t\t\n\t\t\tif(fUVEffect < 0.5)\n\t\t\t{\n\t\t\t\tvFontUV = GetUVCentre(vBgUV);\n\t\t\t}\n\t\t\telse\n\t\t\tif(fUVEffect < 1.5)\n\t\t\t{\n\t\t\t\tvBgUV = GetUVScroll(vBgUV, fFract);\n\t\t\t\tvFontUV = vBgUV;\n\t\t\t}\n\t\t\telse\n\t\t\tif(fUVEffect < 2.5)\n\t\t\t{\n\t\t\t\tfloat fSpeed = 0.1 + vRandom4.z;\n\t\t\t\tvBgUV.x += fFract * fSpeed;\n\t\t\t\tvFontUV = GetUVRepeat(vBgUV, 0.25);\n\t\t\t}\n\t\t\telse\n\t\t\tif(fUVEffect < 3.5)\n\t\t\t{\n\t\t\t\tfloat fSpeed = 1.0 + vRandom4.z * 2.0;\n\t\t\t\tif(vRandom4.w > 0.5)\n\t\t\t\t{\n\t\t\t\t\tfSpeed = -fSpeed;\n\t\t\t\t}\n\t\t\t\tvBgUV = GetUVRotate(vBgUV, 1.0 + fSpeed * fFract);\n\t\t\t\tvFontUV = GetUVRepeat(vBgUV, 0.0);\n\t\t\t}\n\t\t\t\n\t\t\tfloat fShadertoy = step(Shadertoy(vFontUV), 0.0);\n\t\t\t\t\n\t\t\tif(fScreenEffect < 0.5)\n\t\t\t{\n\t\t\t\tvResult += vec4(StyleDefault(fShadertoy), 1.0);\n\t\t\t}\n\t\t\telse if(fScreenEffect < 1.5)\n\t\t\t{\n\t\t\t\tvResult += vec4(StyleScanline(fShadertoy, fragCoord), 1.0);\n\t\t\t}\n\t\t\telse if(fScreenEffect < 2.5)\n\t\t\t{\n\t\t\t\tvResult += vec4(StyleStamp(fShadertoy, vBgUV), 1.0);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvResult += vec4(StyleWood(fShadertoy, vBgUV), 1.0);\n\t\t\t}\n\n\t\t\tfY += 1.0 / float(AA_Y);\n\t\t}\n\t\t\n\t\tfX += 1.0 / float(AA_X);\n\t}\n\t\n\tvResult.xyz /= vResult.w;\n\n\tfloat fFade = 0.0;\t\n\tif(fFract > (1.0 - fBlendSpeed))\n\t{\n\t\tfFade = smoothstep(1.0 - fBlendSpeed, 1.0, fFract);\n\t}\n\n\tif(fFract < fBlendSpeed)\n\t{\n\t\tfFade = smoothstep(fBlendSpeed, 0.0, fFract);\n\t}\n\n\tvResult = mix(vResult, vec4(1.0), fFade);\n\t\n    fragColor = vec4(vResult.xyz, 1.0);\n}\n#endif\n",
   "name": "Buffer B",
   "description": "",
   "type": "buffer"
  },
  {
   "inputs": [
    {
     "id": "XsX3zn",
     "filepath": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png",
     "type": "cubemap",
     "channel": 1,
     "sampler": {
      "filter": "mipmap",
      "wrap": "clamp",
      "vflip": "false",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    },
    {
     "id": "4df3Rr",
     "filepath": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg",
     "type": "texture",
     "channel": 2,
     "sampler": {
      "filter": "mipmap",
      "wrap": "repeat",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    },
    {
     "id": "XsXGR8",
     "filepath": "/media/previz/buffer01.png",
     "type": "buffer",
     "channel": 0,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    }
   ],
   "outputs": [
    {
     "id": "4sXGR8",
     "channel": 0
    }
   ],
   "code": "// Meta CRT - @P_Malin\n// https://www.shadertoy.com/view/4dlyWX#\n// In which I add and remove aliasing\n\n// Scene Rendering\n\n#define ENABLE_TAA_JITTER\n\n#define kMaxTraceDist 1000.0\n#define kFarDist 1100.0\n\n#define MAT_FG_BEGIN \t10\n\n///////////////////////////\n// Scene\n///////////////////////////\n\nstruct SceneResult\n{\n\tfloat fDist;\n\tint iObjectId;\n    vec3 vUVW;\n};\n    \nvoid Scene_Union( inout SceneResult a, in SceneResult b )\n{\n    if ( b.fDist < a.fDist )\n    {\n        a = b;\n    }\n}\n\n    \nvoid Scene_Subtract( inout SceneResult a, in SceneResult b )\n{\n    if ( a.fDist < -b.fDist )\n    {\n        a.fDist = -b.fDist;\n        a.iObjectId = b.iObjectId;\n        a.vUVW = b.vUVW;\n    }\n}\n\nSceneResult Scene_GetDistance( vec3 vPos );    \n\nvec3 Scene_GetNormal(const in vec3 vPos)\n{\n    const float fDelta = 0.0001;\n    vec2 e = vec2( -1, 1 );\n    \n    vec3 vNormal = \n        Scene_GetDistance( e.yxx * fDelta + vPos ).fDist * e.yxx + \n        Scene_GetDistance( e.xxy * fDelta + vPos ).fDist * e.xxy + \n        Scene_GetDistance( e.xyx * fDelta + vPos ).fDist * e.xyx + \n        Scene_GetDistance( e.yyy * fDelta + vPos ).fDist * e.yyy;\n    \n    return normalize( vNormal );\n}    \n    \nSceneResult Scene_Trace( const in vec3 vRayOrigin, const in vec3 vRayDir, float minDist, float maxDist )\n{\t\n    SceneResult result;\n    result.fDist = 0.0;\n    result.vUVW = vec3(0.0);\n    result.iObjectId = -1;\n    \n\tfloat t = minDist;\n\tconst int kRaymarchMaxIter = 128;\n\tfor(int i=0; i<kRaymarchMaxIter; i++)\n\t{\t\t\n        float epsilon = 0.0001 * t;\n\t\tresult = Scene_GetDistance( vRayOrigin + vRayDir * t );\n        if ( abs(result.fDist) < epsilon )\n\t\t{\n\t\t\tbreak;\n\t\t}\n                        \n        if ( t > maxDist )\n        {\n            result.iObjectId = -1;\n\t        t = maxDist;\n            break;\n        }       \n        \n        if ( result.fDist > 1.0 )\n        {\n            result.iObjectId = -1;            \n        }    \n        \n        t += result.fDist;        \n\t}\n    \n    result.fDist = t;\n\n\n    return result;\n}    \n\nfloat Scene_TraceShadow( const in vec3 vRayOrigin, const in vec3 vRayDir, const in float fMinDist, const in float fLightDist )\n{\n    //return 1.0;\n    //return ( Scene_Trace( vRayOrigin, vRayDir, 0.1, fLightDist ).fDist < fLightDist ? 0.0 : 1.0;\n    \n\tfloat res = 1.0;\n    float t = fMinDist;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = Scene_GetDistance( vRayOrigin + vRayDir * t ).fDist;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.0001 || t>fLightDist ) break;\n    }\n    return clamp( res, 0.0, 1.0 );    \n}\n\nfloat Scene_GetAmbientOcclusion( const in vec3 vPos, const in vec3 vDir )\n{\n    float fOcclusion = 0.0;\n    float fScale = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float fOffsetDist = 0.001 + 0.1*float(i)/4.0;\n        vec3 vAOPos = vDir * fOffsetDist + vPos;\n        float fDist = Scene_GetDistance( vAOPos ).fDist;\n        fOcclusion += (fOffsetDist - fDist) * fScale;\n        fScale *= 0.4;\n    }\n    \n    return clamp( 1.0 - 30.0*fOcclusion, 0.0, 1.0 );\n}\n\n///////////////////////////\n// Lighting\n///////////////////////////\n    \nstruct SurfaceInfo\n{\n    vec3 vPos;\n    vec3 vNormal;\n    vec3 vBumpNormal;    \n    vec3 vAlbedo;\n    vec3 vR0;\n    float fSmoothness;\n    vec3 vEmissive;\n};\n    \nSurfaceInfo Scene_GetSurfaceInfo( const in vec3 vRayOrigin,  const in vec3 vRayDir, SceneResult traceResult );\n\nstruct SurfaceLighting\n{\n    vec3 vDiffuse;\n    vec3 vSpecular;\n};\n    \nSurfaceLighting Scene_GetSurfaceLighting( const in vec3 vRayDir, in SurfaceInfo surfaceInfo );\n\nfloat Light_GIV( float dotNV, float k)\n{\n\treturn 1.0 / ((dotNV + 0.0001) * (1.0 - k)+k);\n}\n\nvoid Light_Add(inout SurfaceLighting lighting, SurfaceInfo surface, const in vec3 vViewDir, const in vec3 vLightDir, const in vec3 vLightColour)\n{\n\tfloat fNDotL = clamp(dot(vLightDir, surface.vBumpNormal), 0.0, 1.0);\n\t\n\tlighting.vDiffuse += vLightColour * fNDotL;\n    \n\tvec3 vH = normalize( -vViewDir + vLightDir );\n\tfloat fNdotV = clamp(dot(-vViewDir, surface.vBumpNormal), 0.0, 1.0);\n\tfloat fNdotH = clamp(dot(surface.vBumpNormal, vH), 0.0, 1.0);\n    \n\tfloat alpha = 1.0 - surface.fSmoothness;\n\t// D\n\n\tfloat alphaSqr = alpha * alpha;\n\tfloat denom = fNdotH * fNdotH * (alphaSqr - 1.0) + 1.0;\n\tfloat d = alphaSqr / (PI * denom * denom);\n\n\tfloat k = alpha / 2.0;\n\tfloat vis = Light_GIV(fNDotL, k) * Light_GIV(fNdotV, k);\n\n\tfloat fSpecularIntensity = d * vis * fNDotL;    \n\tlighting.vSpecular += vLightColour * fSpecularIntensity;    \n}\n\nvoid Light_AddPoint(inout SurfaceLighting lighting, SurfaceInfo surface, const in vec3 vViewDir, const in vec3 vLightPos, const in vec3 vLightColour)\n{    \n    vec3 vPos = surface.vPos;\n\tvec3 vToLight = vLightPos - vPos;\t\n    \n\tvec3 vLightDir = normalize(vToLight);\n\tfloat fDistance2 = dot(vToLight, vToLight);\n\tfloat fAttenuation = 100.0 / (fDistance2);\n\t\n\tfloat fShadowFactor = Scene_TraceShadow( surface.vPos, vLightDir, 0.1, length(vToLight) );\n\t\n\tLight_Add( lighting, surface, vViewDir, vLightDir, vLightColour * fShadowFactor * fAttenuation);\n}\n\nvoid Light_AddDirectional(inout SurfaceLighting lighting, SurfaceInfo surface, const in vec3 vViewDir, const in vec3 vLightDir, const in vec3 vLightColour)\n{\t\n\tfloat fAttenuation = 1.0;\n\tfloat fShadowFactor = Scene_TraceShadow( surface.vPos, vLightDir, 0.1, 10.0 );\n\t\n\tLight_Add( lighting, surface, vViewDir, vLightDir, vLightColour * fShadowFactor * fAttenuation);\n}\n\nvec3 Light_GetFresnel( vec3 vView, vec3 vNormal, vec3 vR0, float fGloss )\n{\n    float NdotV = max( 0.0, dot( vView, vNormal ) );\n\n    return vR0 + (vec3(1.0) - vR0) * pow( 1.0 - NdotV, 5.0 ) * pow( fGloss, 20.0 );\n}\n\nvoid Env_AddPointLightFlare(inout vec3 vEmissiveGlow, const in vec3 vRayOrigin, const in vec3 vRayDir, const in float fIntersectDistance, const in vec3 vLightPos, const in vec3 vLightColour)\n{\n    vec3 vToLight = vLightPos - vRayOrigin;\n    float fPointDot = dot(vToLight, vRayDir);\n    fPointDot = clamp(fPointDot, 0.0, fIntersectDistance);\n\n    vec3 vClosestPoint = vRayOrigin + vRayDir * fPointDot;\n    float fDist = length(vClosestPoint - vLightPos);\n\tvEmissiveGlow += sqrt(vLightColour * 0.05 / (fDist * fDist));\n}\n\nvoid Env_AddDirectionalLightFlareToFog(inout vec3 vFogColour, const in vec3 vRayDir, const in vec3 vLightDir, const in vec3 vLightColour)\n{\n\tfloat fDirDot = clamp(dot(vLightDir, vRayDir) * 0.5 + 0.5, 0.0, 1.0);\n\tfloat kSpreadPower = 2.0;\n\tvFogColour += vLightColour * pow(fDirDot, kSpreadPower) * 0.25;\n}\n\n\n///////////////////////////\n// Rendering\n///////////////////////////\n\nvec4 Env_GetSkyColor( const vec3 vViewPos, const vec3 vViewDir );\nvec3 Env_ApplyAtmosphere( const in vec3 vColor, const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist );\nvec3 FX_Apply( in vec3 vColor, const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist);\n\nvec4 Scene_GetColorAndDepth( vec3 vRayOrigin, vec3 vRayDir )\n{\n\tvec3 vResultColor = vec3(0.0);\n            \n\tSceneResult firstTraceResult;\n    \n    float fStartDist = 0.0f;\n    float fMaxDist = 10.0f;\n    \n    vec3 vRemaining = vec3(1.0);\n    \n\tfor( int iPassIndex=0; iPassIndex < 3; iPassIndex++ )\n    {\n    \tSceneResult traceResult = Scene_Trace( vRayOrigin, vRayDir, fStartDist, fMaxDist );\n\n        if ( iPassIndex == 0 )\n        {\n            firstTraceResult = traceResult;\n        }\n        \n        vec3 vColor = vec3(0);\n        vec3 vReflectAmount = vec3(0);\n        \n\t\tif( traceResult.iObjectId < 0 )\n\t\t{\n            vColor = Env_GetSkyColor( vRayOrigin, vRayDir ).rgb;\n        }\n        else\n        {\n            \n            SurfaceInfo surfaceInfo = Scene_GetSurfaceInfo( vRayOrigin, vRayDir, traceResult );\n            SurfaceLighting surfaceLighting = Scene_GetSurfaceLighting( vRayDir, surfaceInfo );\n                \n            // calculate reflectance (Fresnel)\n\t\t\tvReflectAmount = Light_GetFresnel( -vRayDir, surfaceInfo.vBumpNormal, surfaceInfo.vR0, surfaceInfo.fSmoothness );\n\t\t\t\n\t\t\tvColor = (surfaceInfo.vAlbedo * surfaceLighting.vDiffuse + surfaceInfo.vEmissive) * (vec3(1.0) - vReflectAmount); \n            \n            vec3 vReflectRayOrigin = surfaceInfo.vPos;\n            vec3 vReflectRayDir = normalize( reflect( vRayDir, surfaceInfo.vBumpNormal ) );\n            fStartDist = 0.001 / max(0.0000001,abs(dot( vReflectRayDir, surfaceInfo.vNormal ))); \n\n            vColor += surfaceLighting.vSpecular * vReflectAmount;            \n\n\t\t\tvColor = Env_ApplyAtmosphere( vColor, vRayOrigin, vRayDir, traceResult.fDist );\n\t\t\tvColor = FX_Apply( vColor, vRayOrigin, vRayDir, traceResult.fDist );\n            \n            vRayOrigin = vReflectRayOrigin;\n            vRayDir = vReflectRayDir;\n        }\n        \n        vResultColor += vColor * vRemaining;\n        vRemaining *= vReflectAmount;        \n    }\n \n    return vec4( vResultColor, EncodeDepthAndObject( firstTraceResult.fDist, firstTraceResult.iObjectId ) );\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n/////////////////////////\n// Scene Description\n/////////////////////////\n\n// Materials\n\n#define MAT_SKY\t\t \t-1\n#define MAT_DEFAULT \t 0\n#define MAT_SCREEN\t\t 1\n#define MAT_TV_CASING    2\n#define MAT_TV_TRIM      3\n#define MAT_CHROME       4\n\n\nvec3 PulseIntegral( vec3 x, float s1, float s2 )\n{\n    // Integral of function where result is 1.0 between s1 and s2 and 0 otherwise        \n\n    // V1\n    //if ( x > s2 ) return s2 - s1;\n\t//else if ( x > s1 ) return x - s1;\n\t//return 0.0f; \n    \n    // V2\n    //return clamp( (x - s1), 0.0f, s2 - s1);\n    //return t;\n    \n    return clamp( (x - s1), vec3(0.0f), vec3(s2 - s1));\n}\n\nfloat PulseIntegral( float x, float s1, float s2 )\n{\n    // Integral of function where result is 1.0 between s1 and s2 and 0 otherwise        \n\n    // V1\n    //if ( x > s2 ) return s2 - s1;\n\t//else if ( x > s1 ) return x - s1;\n\t//return 0.0f; \n    \n    // V2\n    //return clamp( (x - s1), 0.0f, s2 - s1);\n    //return t;\n    \n    return clamp( (x - s1), (0.0f), (s2 - s1));\n}\n\nvec3 Bayer( vec2 vUV, vec2 vBlur )\n{\n    vec3 x = vec3(vUV.x);\n    vec3 y = vec3(vUV.y);           \n\n    x += vec3(0.66, 0.33, 0.0);\n    y += 0.5 * step( fract( x * 0.5 ), vec3(0.5) );\n        \n    //x -= 0.5f;\n    //y -= 0.5f;\n    \n    x = fract( x );\n    y = fract( y );\n    \n    // cell centered at 0.5\n    \n    vec2 vSize = vec2(0.16f, 0.75f);\n    \n    vec2 vMin = 0.5 - vSize * 0.5;\n    vec2 vMax = 0.5 + vSize * 0.5;\n    \n    vec3 vResult= vec3(0.0);\n    \n    vec3 vResultX = (PulseIntegral( x + vBlur.x, vMin.x, vMax.x) - PulseIntegral( x - vBlur.x, vMin.x, vMax.x)) / min( vBlur.x, 1.0);\n    vec3 vResultY = (PulseIntegral(y + vBlur.y, vMin.y, vMax.y) - PulseIntegral(y - vBlur.y, vMin.y, vMax.y))  / min( vBlur.y, 1.0);\n    \n    vResult = min(vResultX,vResultY)  * 5.0;\n        \n    //vResult = vec3(1.0);\n    \n    return vResult;\n}\n\nvec3 GetPixelMatrix( vec2 vUV )\n{\n#if 1\n    vec2 dx = dFdx( vUV );\n    vec2 dy = dFdy( vUV );\n    float dU = length( vec2( dx.x, dy.x ) );\n    float dV = length( vec2( dx.y, dy.y ) );\n    if (dU <= 0.0 || dV <= 0.0 ) return vec3(1.0);\n    return Bayer( vUV, vec2(dU, dV) * 1.0);\n#else\n    return vec3(1.0);\n#endif\n}\n\nfloat Scanline( float y, float fBlur )\n{   \n    float fResult = sin( y * 10.0 ) * 0.45 + 0.55;\n    return mix( fResult, 1.0f, min( 1.0, fBlur ) );\n}\n\n\nfloat GetScanline( vec2 vUV )\n{\n#if 1\n    vUV.y *= 0.25;\n    vec2 dx = dFdx( vUV );\n    vec2 dy = dFdy( vUV );\n    float dV = length( vec2( dx.y, dy.y ) );\n    if (dV <= 0.0 ) return 1.0;\n    return Scanline( vUV.y, dV * 1.3 );\n#else\n    return 1.0;\n#endif\n}\n\n\nvec2 kScreenRsolution = vec2(480.0f, 576.0f);\n\nstruct Interference\n{\n    float noise;\n    float scanLineRandom;\n};\n\nfloat InterferenceHash(float p)\n{\n    float hashScale = 0.1031;\n\n    vec3 p3  = fract(vec3(p, p, p) * hashScale);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nfloat InterferenceSmoothNoise1D( float x )\n{\n    float f0 = floor(x);\n    float fr = fract(x);\n\n    float h0 = InterferenceHash( f0 );\n    float h1 = InterferenceHash( f0 + 1.0 );\n\n    return h1 * fr + h0 * (1.0 - fr);\n}\n\n\nfloat InterferenceNoise( vec2 uv )\n{\n\tfloat displayVerticalLines = 483.0;\n    float scanLine = floor(uv.y * displayVerticalLines); \n    float scanPos = scanLine + uv.x;\n\tfloat timeSeed = fract( iTime * 123.78 );\n    \n    return InterferenceSmoothNoise1D( scanPos * 234.5 + timeSeed * 12345.6 );\n}\n    \nInterference GetInterference( vec2 vUV )\n{\n    Interference interference;\n        \n    interference.noise = InterferenceNoise( vUV );\n    interference.scanLineRandom = InterferenceHash(vUV.y * 100.0 + fract(iTime * 1234.0) * 12345.0);\n    \n    return interference;\n}\n    \nvec3 SampleScreen( vec3 vUVW )\n{   \n    vec3 vAmbientEmissive = vec3(0.1);\n    vec3 vBlackEmissive = vec3(0.02);\n    float fBrightness = 1.75;\n    vec2 vResolution = vec2(480.0f, 576.0f);\n    vec2 vPixelCoord = vUVW.xy * vResolution;\n    \n    vec3 vPixelMatrix = GetPixelMatrix( vPixelCoord );\n    float fScanline = GetScanline( vPixelCoord );\n      \n    vec2 vTextureUV = vUVW.xy;\n    //vec2 vTextureUV = vPixelCoord;\n    vTextureUV = floor(vTextureUV * vResolution * 2.0) / (vResolution * 2.0f);\n    \n    Interference interference = GetInterference( vTextureUV );\n\n    float noiseIntensity = 0.1;\n    \n    //vTextureUV.x += (interference.scanLineRandom * 2.0f - 1.0f) * 0.025f * noiseIntensity;\n    \n    \n    vec3 vPixelEmissive = textureLod( iChannel0, vTextureUV.xy, 0.0 ).rgb;\n        \n    vPixelEmissive = clamp( vPixelEmissive + (interference.noise - 0.5) * 2.0 * noiseIntensity, 0.0, 1.0 );\n    \n\tvec3 vResult = (vPixelEmissive * vPixelEmissive * fBrightness + vBlackEmissive) * vPixelMatrix * fScanline + vAmbientEmissive;\n    \n    // TODO: feather edge?\n    if( any( greaterThanEqual( vUVW.xy, vec2(1.0) ) ) || any ( lessThan( vUVW.xy, vec2(0.0) ) ) || ( vUVW.z > 0.0 ) )\n    {\n        return vec3(0.0);\n    }\n    \n    return vResult;\n    \n}\n\nSurfaceInfo Scene_GetSurfaceInfo( const in vec3 vRayOrigin,  const in vec3 vRayDir, SceneResult traceResult )\n{\n    SurfaceInfo surfaceInfo;\n    \n    surfaceInfo.vPos = vRayOrigin + vRayDir * (traceResult.fDist);\n    \n    surfaceInfo.vNormal = Scene_GetNormal( surfaceInfo.vPos ); \n    surfaceInfo.vBumpNormal = surfaceInfo.vNormal;\n    surfaceInfo.vAlbedo = vec3(1.0);\n    surfaceInfo.vR0 = vec3( 0.02 );\n    surfaceInfo.fSmoothness = 1.0;\n    surfaceInfo.vEmissive = vec3( 0.0 );\n    //return surfaceInfo;\n        \n    if ( traceResult.iObjectId == MAT_DEFAULT )\n    {\n    \tsurfaceInfo.vR0 = vec3( 0.02 );\n\t    surfaceInfo.vAlbedo = textureLod( iChannel2, traceResult.vUVW.xz * 2.0, 0.0 ).rgb;\n        surfaceInfo.vAlbedo = surfaceInfo.vAlbedo * surfaceInfo.vAlbedo;\n                        \n    \tsurfaceInfo.fSmoothness = clamp( 1.0 - surfaceInfo.vAlbedo.r * surfaceInfo.vAlbedo.r * 2.0, 0.0, 1.0);\n        \n    }\n    \n    if ( traceResult.iObjectId == MAT_SCREEN )\n    {\n        surfaceInfo.vAlbedo = vec3(0.02); \n        surfaceInfo.vEmissive = SampleScreen( traceResult.vUVW );        \n    }\n\n    if ( traceResult.iObjectId == MAT_TV_CASING )\n    {\n        surfaceInfo.vAlbedo = vec3(0.5, 0.4, 0.3); \n\t    surfaceInfo.fSmoothness = 0.4;        \n    }\n    \n    if ( traceResult.iObjectId == MAT_TV_TRIM )\n    {\n        surfaceInfo.vAlbedo = vec3(0.03, 0.03, 0.05); \n\t    surfaceInfo.fSmoothness = 0.5;\n    }    \n\n    if ( traceResult.iObjectId == MAT_CHROME )\n    {\n        surfaceInfo.vAlbedo = vec3(0.01, 0.01, 0.01); \n\t    surfaceInfo.fSmoothness = 0.9;\n    \tsurfaceInfo.vR0 = vec3( 0.8 );\n    }    \n \n    return surfaceInfo;\n}\n\n// Scene Description\n\nfloat SmoothMin( float a, float b, float k )\n{\n\t//return min(a,b);\n\t\n\t\n    //float k = 0.06;\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat UdRoundBox( vec3 p, vec3 b, float r )\n{\n    //vec3 vToFace = abs(p) - b;\n    //vec3 vConstrained = max( vToFace, 0.0 );\n    //return length( vConstrained ) - r;\n    return length(max(abs(p)-b,0.0))-r;\n}\n\nSceneResult Scene_GetCRT( vec3 vScreenDomain, vec2 vScreenWH, float fScreenCurveRadius, float fBevel, float fDepth )\n{\n    SceneResult resultScreen;\n#if 1\n    vec3 vScreenClosest;\n    vScreenClosest.xy = max(abs(vScreenDomain.xy)-vScreenWH,0.0);\n    vec2 vCurveScreenDomain = vScreenDomain.xy;\n    vCurveScreenDomain = clamp( vCurveScreenDomain, -vScreenWH, vScreenWH );\n    float fCurveScreenProjection2 = fScreenCurveRadius * fScreenCurveRadius - vCurveScreenDomain.x * vCurveScreenDomain.x - vCurveScreenDomain.y * vCurveScreenDomain.y;\n    float fCurveScreenProjection = sqrt( fCurveScreenProjection2 ) - fScreenCurveRadius;\n    vScreenClosest.z = vScreenDomain.z - clamp( vScreenDomain.z, -fCurveScreenProjection, fDepth );\n    resultScreen.vUVW.z = vScreenDomain.z + fCurveScreenProjection;        \n    resultScreen.fDist = (length( vScreenClosest ) - fBevel) * 0.95;\n    //resultScreen.fDist = (length( vScreenDomain - vec3(0,0,fScreenCurveRadius)) - fScreenCurveRadius - fBevel);    \n#endif    \n    \n#if 0\n    vec3 vScreenClosest;\n    vScreenClosest.xyz = max(abs(vScreenDomain.xyz)-vec3(vScreenWH, fDepth),0.0);\n    float fRoundDist = length( vScreenClosest.xyz ) - fBevel;\n    float fSphereDist = length( vScreenDomain - vec3(0,0,fScreenCurveRadius) ) - (fScreenCurveRadius + fBevel);    \n    resultScreen.fDist = max(fRoundDist, fSphereDist);\n#endif    \n    \n    resultScreen.vUVW.xy = (vScreenDomain.xy / vScreenWH) * 0.5 + 0.5f;\n\tresultScreen.iObjectId = MAT_SCREEN;\n    return resultScreen;\n}\n\nSceneResult Scene_GetComputer( vec3 vPos )\n{\n    SceneResult resultComputer;\n    resultComputer.vUVW = vPos.xzy;\n\t\n    float fXSectionStart = -0.2;\n    float fXSectionLength = 0.15;\n    float fXSectionT = clamp( (vPos.z - fXSectionStart) / fXSectionLength, 0.0, 1.0);\n    float fXSectionR1 = 0.03;\n    float fXSectionR2 = 0.05;\n    float fXSectionR = mix( fXSectionR1, fXSectionR2, fXSectionT );\n    float fXSectionZ = fXSectionStart + fXSectionT * fXSectionLength;\n    \n    vec2 vXSectionCentre = vec2(fXSectionR, fXSectionZ );\n    vec2 vToPos = vPos.yz - vXSectionCentre;\n    float l = length( vToPos );\n    if ( l > fXSectionR ) l = fXSectionR;\n    vec2 vXSectionClosest = vXSectionCentre + normalize(vToPos) * l;\n    //float fXSectionDist = length( vXSectionClosest ) - fXSectionR;\n    \n    float x = max( abs( vPos.x ) - 0.2f, 0.0 );\n\n    resultComputer.fDist = length( vec3(x, vXSectionClosest - vPos.yz) )-0.01;\n    //resultComputer.fDist = x;\n        \n    resultComputer.iObjectId = MAT_TV_CASING;\n/*\n    vec3 vKeyPos = vPos.xyz - vec3(0,0.125,0);\n    vKeyPos.y -= vKeyPos.z * (fXSectionR2 - fXSectionR1) * 2.0 / fXSectionLength;\n    float fDomainRepeatScale = 0.02;\n    if ( fract(vKeyPos.z * 0.5 / fDomainRepeatScale + 0.25) > 0.5) vKeyPos.x += fDomainRepeatScale * 0.5;\n    vec2 vKeyIndex = round(vKeyPos.xz / fDomainRepeatScale);\n    vKeyIndex.x = clamp( vKeyIndex.x, -8.0, 8.0 );\n    vKeyIndex.y = clamp( vKeyIndex.y, -10.0, -5.0 );\n    //vKeyPos.xz = (fract( vKeyPos.xz / fDomainRepeatScale ) - 0.5) * fDomainRepeatScale;\n    vKeyPos.xz = (vKeyPos.xz - (vKeyIndex) * fDomainRepeatScale);\n    vKeyPos.xz /= 0.7 + vKeyPos.y;\n    SceneResult resultKey;    \n    resultKey.vUVW = vPos.xzy;\n    resultKey.fDist = UdRoundBox( vKeyPos, vec3(0.01), 0.001 );\n    resultKey.iObjectId = MAT_TV_TRIM;\n    Scene_Union( resultComputer, resultKey );\n*/    \n    return resultComputer;\n}\n\nSceneResult Scene_GetDistance( vec3 vPos )\n{\n    SceneResult result;\n    \n\t//result.fDist = vPos.y;\n    float fBenchBevel = 0.01;\n    result.fDist = UdRoundBox( vPos - vec3(0,-0.02-fBenchBevel,0.0), vec3(2.0, 0.02, 1.0), fBenchBevel );\n    result.vUVW = vPos;\n\tresult.iObjectId = MAT_DEFAULT;        \n    \n    vec3 vSetPos = vec3(0.0, 0.0, 0.0);\n    vec3 vScreenPos = vSetPos + vec3(0.0, 0.25, 0.00);\n    \n    //vPos.x = fract( vPos.x - 0.5) - 0.5;\n    \n    vec2 vScreenWH = vec2(4.0, 3.0) / 25.0;\n\n    SceneResult resultSet;\n    resultSet.vUVW = vPos.xzy;\n\tresultSet.fDist = UdRoundBox( vPos - vScreenPos - vec3(0.0,-0.01,0.2), vec3(.21, 0.175, 0.18), 0.01 );\n    resultSet.iObjectId = MAT_TV_CASING;\n    Scene_Union( result, resultSet );\n\n    SceneResult resultSetRecess;\n    resultSetRecess.vUVW = vPos.xzy;\n    resultSetRecess.fDist = UdRoundBox( vPos - vScreenPos - vec3(0.0,-0.0, -0.05), vec3(vScreenWH + 0.01, 0.05) + 0.005, 0.015 );\n    resultSetRecess.iObjectId = MAT_TV_TRIM;\n\tScene_Subtract( result, resultSetRecess );\n    \n    SceneResult resultSetBase;\n    resultSetBase.vUVW = vPos.xzy;\n    float fBaseBevel = 0.03;\n\tresultSetBase.fDist = UdRoundBox( vPos - vSetPos - vec3(0.0,0.04,0.22), vec3(0.2, 0.04, 0.17) - fBaseBevel, fBaseBevel );\n    resultSetBase.iObjectId = MAT_TV_CASING;\n    Scene_Union( result, resultSetBase );\n\n\tSceneResult resultScreen = Scene_GetCRT( vPos - vScreenPos, vScreenWH, 0.75f, 0.02f, 0.1f );\n    Scene_Union( result, resultScreen );    \n    \n    //SceneResult resultComputer = Scene_GetComputer( vPos - vec3(0.0, 0.0, -0.1) );\n    //Scene_Union( result, resultComputer );\n\n    SceneResult resultSphere;\n    resultSet.vUVW = vPos.xzy;\n\tresultSet.fDist = length(vPos - vec3(0.35,0.075,-0.1)) - 0.075;\n    resultSet.iObjectId = MAT_CHROME;\n    Scene_Union( result, resultSet );    \n    \n    return result;\n}\n\n\n\n// Scene Lighting\n\nvec3 g_vSunDir = normalize(vec3(0.3, 0.4, -0.5));\nvec3 g_vSunColor = vec3(1, 0.95, 0.8) * 3.0;\nvec3 g_vAmbientColor = vec3(0.8, 0.8, 0.8) * 1.0;\n\nSurfaceLighting Scene_GetSurfaceLighting( const in vec3 vViewDir, in SurfaceInfo surfaceInfo )\n{\n    SurfaceLighting surfaceLighting;\n    \n    surfaceLighting.vDiffuse = vec3(0.0);\n    surfaceLighting.vSpecular = vec3(0.0);    \n    \n    Light_AddDirectional( surfaceLighting, surfaceInfo, vViewDir, g_vSunDir, g_vSunColor );\n    \n    Light_AddPoint( surfaceLighting, surfaceInfo, vViewDir, vec3(1.4, 2.0, 0.8), vec3(1,1,1) * 0.2 );\n    \n    float fAO = Scene_GetAmbientOcclusion( surfaceInfo.vPos, surfaceInfo.vNormal );\n    // AO\n    surfaceLighting.vDiffuse += fAO * (surfaceInfo.vBumpNormal.y * 0.5 + 0.5) * g_vAmbientColor;\n    \n    return surfaceLighting;\n}\n\n// Environment\n\nvec4 Env_GetSkyColor( const vec3 vViewPos, const vec3 vViewDir )\n{\n\tvec4 vResult = vec4( 0.0, 0.0, 0.0, kFarDist );\n\n#if 1\n    vec3 vEnvMap = textureLod( iChannel1, vViewDir.zyx, 0.0 ).rgb;\n    vResult.rgb = vEnvMap;\n#endif    \n    \n#if 0\n    vec3 vEnvMap = textureLod( iChannel1, vViewDir.zyx, 0.0 ).rgb;\n    vEnvMap = vEnvMap * vEnvMap;\n    float kEnvmapExposure = 0.999;\n    vResult.rgb = -log2(1.0 - vEnvMap * kEnvmapExposure);\n\n#endif\n    \n    // Sun\n    //float NdotV = dot( g_vSunDir, vViewDir );\n    //vResult.rgb += smoothstep( cos(radians(.7)), cos(radians(.5)), NdotV ) * g_vSunColor * 5000.0;\n\n    return vResult;\t\n}\n\nfloat Env_GetFogFactor(const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist )\n{    \n\tfloat kFogDensity = 0.00001;\n\treturn exp(fDist * -kFogDensity);\t\n}\n\nvec3 Env_GetFogColor(const in vec3 vDir)\n{    \n\treturn vec3(0.2, 0.5, 0.6) * 2.0;\t\t\n}\n\nvec3 Env_ApplyAtmosphere( const in vec3 vColor, const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist )\n{\n    //return vColor;\n    vec3 vResult = vColor;\n    \n    \n\tfloat fFogFactor = Env_GetFogFactor( vRayOrigin, vRayDir, fDist );\n\tvec3 vFogColor = Env_GetFogColor( vRayDir );\t\n\t//Env_AddDirectionalLightFlareToFog( vFogColor, vRayDir, g_vSunDir, g_vSunColor * 3.0);    \n    vResult = mix( vFogColor, vResult, fFogFactor );\n\n    return vResult;\t    \n}\n\n\nvec3 FX_Apply( in vec3 vColor, const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist)\n{    \n    return vColor;\n}\n\n\nvec4 MainCommon( vec3 vRayOrigin, vec3 vRayDir )\n{\n\tvec4 vColorLinAndDepth = Scene_GetColorAndDepth( vRayOrigin, vRayDir );    \n    vColorLinAndDepth.rgb = max( vColorLinAndDepth.rgb, vec3(0.0) );\n    \n    vec4 vFragColor = vColorLinAndDepth;\n    \n    float fExposure = 2.0f;\n    \n    vFragColor.rgb *= fExposure;\n    \n    vFragColor.a = vColorLinAndDepth.w;\n    \n    return vFragColor;\n}\n\nCameraState GetCameraPosition( int index )\n{\n    CameraState cam;\n\n    vec3 vFocus = vec3(0,0.25,-0.012);   \n    \n    if ( index > 9 )\n    {\n    \tindex = int(hash11(float(index) / 10.234) * 100.0);\n    \tindex = index % 10;\n    }\n\n    //index=2;\n    \n    if ( index == 0 )\n    {\n        cam.vPos = vec3(-0.1,0.2,-0.08);\n        cam.vTarget = vec3(0,0.25,0.1);\n        cam.fFov = 10.0;\n    }\n    if ( index == 1 )\n    {\n        cam.vPos = vec3(0.01,0.334,-0.03);\n        cam.vTarget = vec3(0,0.3,0.1);\n        cam.fFov = 10.0;\n    }\n    if ( index == 2 )\n    {\n        cam.vPos = vec3(-0.8,0.3,-1.0);\n        cam.vTarget = vec3(0.4,0.18,0.5);\n        cam.fFov = 10.0;\n    }\n    if ( index == 3 )\n    {\n        cam.vPos = vec3(-0.8,1.0,-1.5);\n        cam.vTarget = vec3(0.2,0.0,0.5);\n        cam.fFov = 10.0;\n    }\n    if ( index == 4 )\n    {\n        cam.vPos = vec3(-0.8,0.3,-1.0);\n        cam.vTarget = vec3(0.4,0.18,0.5);\n        cam.fFov = 20.0;\n    }\n    if ( index == 5 )\n    {\n        cam.vPos = vec3(-0.244,0.334,-0.0928);\n        cam.vTarget = vec3(0,0.25,0.1);\n        cam.fFov = 20.0;\n    }\n    if ( index == 6 )\n    {\n        cam.vPos = vec3(0.0,0.1,-0.5);\n        cam.vTarget = vec3(0.2,0.075,-0.1);\n        vFocus = cam.vTarget; \n        cam.fFov = 15.0;\n    }\n    if ( index == 7 )\n    {\n        cam.vPos = vec3(-0.01,0.01,-0.25);\n        cam.vTarget = vec3(0.01,0.27,0.1);\n        vFocus = cam.vTarget; \n        cam.fFov = 23.0;\n    }\n    if ( index == 8 )\n    {\n        cam.vPos = vec3(-0.23,0.3,-0.05);\n        cam.vTarget = vec3(0.1,0.2,0.1);\n        cam.fFov = 15.0;\n    }\n    if ( index == 9 )\n    {\n        cam.vPos = vec3(0.4,0.2,-0.2);\n        cam.vTarget = vec3(-0.1,0.25,0.1);\n        cam.fFov = 12.0;\n    }\n    \n    cam.fPlaneInFocus = length( vFocus - cam.vPos);\n    cam.vJitter = vec2(0.0);        \n    \n    return cam;\n}\n\nvoid mainImage( out vec4 vFragColor, in vec2 vFragCoord )\n{\n    vec2 vUV = vFragCoord.xy / iResolution.xy; \n\n    CameraState cam;\n    \n    {\n    \tCameraState camA;\n    \tCameraState camB;\n    \n        float fSeqTime = iTime;\n        float fSequenceSegLength = 5.0;\n        float fSeqIndex = floor(fSeqTime / fSequenceSegLength);\n        float fSeqPos = fract(fSeqTime / fSequenceSegLength);\n        int iIndex = int(fSeqIndex);\n\t\tint iIndexNext = int(fSeqIndex) + 1;\n        camA = GetCameraPosition(iIndex);\n        camB = GetCameraPosition(iIndexNext);\n        \n        float t = smoothstep(0.3, 1.0, fSeqPos);\n        cam.vPos = mix(camA.vPos, camB.vPos, t );\n        cam.vTarget = mix(camA.vTarget, camB.vTarget, t );\n        cam.fFov = mix(camA.fFov, camB.fFov, t );\n        cam.fPlaneInFocus = mix(camA.fPlaneInFocus, camB.fPlaneInFocus, t );\n    }\n    \n    if ( iMouse.z > 0.0 )\n    {\n        float fDist = 0.01 + 3.0 * (iMouse.y / iResolution.y);\n\n        float fAngle = (iMouse.x / iResolution.x) * radians(360.0);\n    \t//float fElevation = (iMouse.y / iResolution.y) * radians(90.0);\n    \tfloat fElevation = 0.15f * radians(90.0);    \n\n        cam.vPos = vec3(sin(fAngle) * fDist * cos(fElevation),sin(fElevation) * fDist,cos(fAngle) * fDist * cos(fElevation));\n        cam.vTarget = vec3(0,0.25,0.1);\n        cam.vPos +=cam.vTarget;\n        cam.fFov = 20.0 / (1.0 + fDist * 0.5);\n    \tvec3 vFocus = vec3(0,0.25,-0.012);\t    \n\t    cam.fPlaneInFocus = length( vFocus - cam.vPos );\n    }\n    \n#if 0\n    {\n        float fDist = 0.5;\n\n        float fAngle = 0.6 * PI * 2.0f;\n        float fElevation = 0.2;\n        \n        cam.vPos = vec3(sin(fAngle) * fDist * cos(fElevation),sin(fElevation) * fDist,cos(fAngle) * fDist * cos(fElevation));\n        cam.vTarget = vec3(0.05,0.25,0.1);\n        cam.vPos +=cam.vTarget;\n        cam.fFov = 22.0;\n    \tvec3 vFocus = vec3(0,0.25,-0.012);\t    \n\t    cam.fPlaneInFocus = length( vFocus - cam.vPos );\n    }\n#endif\n    \n#ifdef ENABLE_TAA_JITTER\n    cam.vJitter = hash21( fract( iTime ) ) - 0.5f;\n#endif\n    \n            \n    vec3 vRayOrigin, vRayDir;\n    vec2 vJitterUV = vUV + cam.vJitter / iResolution.xy;\n    Cam_GetCameraRay( vJitterUV, iResolution.xy, cam, vRayOrigin, vRayDir );\n \n    float fHitDist = 0.0f;\n    vFragColor = MainCommon( vRayOrigin, vRayDir );\n    \n    \n\tCam_StoreState( ivec2(0), cam, vFragColor, ivec2(vFragCoord.xy) );    \n}\n",
   "name": "Buffer C",
   "description": "",
   "type": "buffer"
  },
  {
   "inputs": [
    {
     "id": "4sXGR8",
     "filepath": "/media/previz/buffer02.png",
     "type": "buffer",
     "channel": 0,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    },
    {
     "id": "XdfGR8",
     "filepath": "/media/previz/buffer03.png",
     "type": "buffer",
     "channel": 1,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    }
   ],
   "outputs": [
    {
     "id": "XdfGR8",
     "channel": 0
    }
   ],
   "code": "// Meta CRT - @P_Malin\n// https://www.shadertoy.com/view/4dlyWX#\n// In which I add and remove aliasing\n\n// Temporal Anti-aliasing Pass\n\n#define ENABLE_TAA\n\n#define iChannelCurr iChannel0\n#define iChannelHistory iChannel1\n\nvec3 Tonemap( vec3 x )\n{\n    float a = 0.010;\n    float b = 0.132;\n    float c = 0.010;\n    float d = 0.163;\n    float e = 0.101;\n\n    return ( x * ( a * x + b ) ) / ( x * ( c * x + d ) + e );\n}\n\nvec3 TAA_ColorSpace( vec3 color )\n{\n    return Tonemap(color);\n}\n\n\nvoid mainImage( out vec4 vFragColor, in vec2 vFragCoord )\n{\n    CameraState camCurr;\n\tCam_LoadState( camCurr, iChannelCurr, ivec2(0) );\n    \n    CameraState camPrev;\n\tCam_LoadState( camPrev, iChannelHistory, ivec2(0) );\n\n    vec2 vUV = vFragCoord.xy / iResolution.xy;\n \tvec2 vUnJitterUV = vUV - camCurr.vJitter / iResolution.xy;    \n    \n    vFragColor = textureLod(iChannelCurr, vUnJitterUV, 0.0);\n    \n    \n#ifdef ENABLE_TAA\n    vec3 vRayOrigin, vRayDir;\n    Cam_GetCameraRay( vUV, iResolution.xy, camCurr, vRayOrigin, vRayDir );    \n    float fDepth;\n    int iObjectId;\n    vec4 vCurrTexel = texelFetch( iChannelCurr, ivec2(vFragCoord.xy), 0);\n    fDepth = DecodeDepthAndObjectId( vCurrTexel.w, iObjectId );\n    vec3 vWorldPos = vRayOrigin + vRayDir * fDepth;\n    \n    vec2 vPrevUV = Cam_GetUVFromWindowCoord( Cam_WorldToWindowCoord(vWorldPos, camPrev), iResolution.xy );// + camPrev.vJitter / iResolution.xy;\n        \n    if ( all( greaterThanEqual( vPrevUV, vec2(0) )) && all( lessThan( vPrevUV, vec2(1) )) )\n\t{\n        vec3 vMin = vec3( 10000);\n        vec3 vMax = vec3(-10000);\n        \n\t    ivec2 vCurrXY = ivec2(floor(vFragCoord.xy));    \n        \n        int iNeighborhoodSize = 1;\n        for ( int iy=-iNeighborhoodSize; iy<=iNeighborhoodSize; iy++)\n        {\n            for ( int ix=-iNeighborhoodSize; ix<=iNeighborhoodSize; ix++)\n            {\n                ivec2 iOffset = ivec2(ix, iy);\n\t\t        vec3 vTest = TAA_ColorSpace( texelFetch( iChannelCurr, vCurrXY + iOffset, 0 ).rgb );\n                                \n                vMin = min( vMin, vTest );\n                vMax = max( vMax, vTest );\n            }\n        }\n        \n        float epsilon = 0.001;\n        vMin -= epsilon;\n        vMax += epsilon;\n        \n        float fBlend = 0.0f;\n        \n        //ivec2 vPrevXY = ivec2(floor(vPrevUV.xy * iResolution.xy));\n        vec4 vHistory = textureLod( iChannelHistory, vPrevUV, 0.0 );\n\n        vec3 vPrevTest = TAA_ColorSpace( vHistory.rgb );\n        if( all( greaterThanEqual(vPrevTest, vMin ) ) && all( lessThanEqual( vPrevTest, vMax ) ) )\n        {\n            fBlend = 0.9;\n            //vFragColor.r *= 0.0;\n        }\n        \n        vFragColor.rgb = mix( vFragColor.rgb, vHistory.rgb, fBlend);\n    }  \n    else\n    {\n        //vFragColor.gb *= 0.0;\n    }\n\n#endif\n    \n    vFragColor.rgb += (hash13( vec3( vFragCoord, iTime ) ) * 2.0 - 1.0) * 0.03;\n    \n\tCam_StoreState( ivec2(0), camCurr, vFragColor, ivec2(vFragCoord.xy) );    \n\tCam_StoreState( ivec2(3,0), camPrev, vFragColor, ivec2(vFragCoord.xy) );    \n}\n",
   "name": "Buffer D",
   "description": "",
   "type": "buffer"
  },
  {
   "inputs": [],
   "outputs": [],
   "code": "#define PI 3.141592654\n\n\n///////////////////////////\n// Hash Functions\n///////////////////////////\n\n// From: Hash without Sine by Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\n\n// *** Use this for integer stepped ranges, ie Value-Noise/Perlin noise functions.\n//#define HASHSCALE1 .1031\n//#define HASHSCALE3 vec3(.1031, .1030, .0973)\n//#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n\n// For smaller input rangers like audio tick or 0-1 UVs use these...\n#define HASHSCALE1 443.8975\n#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n#define HASHSCALE4 vec3(443.897, 441.423, 437.195, 444.129)\n\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\n///////////////////////////\n// Data Storage\n///////////////////////////\n\nvec4 LoadVec4( sampler2D sampler, in ivec2 vAddr )\n{\n    return texelFetch( sampler, vAddr, 0 );\n}\n\nvec3 LoadVec3( sampler2D sampler, in ivec2 vAddr )\n{\n    return LoadVec4( sampler, vAddr ).xyz;\n}\n\nbool AtAddress( ivec2 p, ivec2 c ) { return all( equal( p, c ) ); }\n\nvoid StoreVec4( in ivec2 vAddr, in vec4 vValue, inout vec4 fragColor, in ivec2 fragCoord )\n{\n    fragColor = AtAddress( fragCoord, vAddr ) ? vValue : fragColor;\n}\n\nvoid StoreVec3( in ivec2 vAddr, in vec3 vValue, inout vec4 fragColor, in ivec2 fragCoord )\n{\n    StoreVec4( vAddr, vec4( vValue, 0.0 ), fragColor, fragCoord);\n}\n\n///////////////////////////\n// Camera\n///////////////////////////\n\nstruct CameraState\n{\n    vec3 vPos;\n    vec3 vTarget;\n    float fFov;\n    vec2 vJitter;\n    float fPlaneInFocus;\n};\n    \nvoid Cam_LoadState( out CameraState cam, sampler2D sampler, ivec2 addr )\n{\n    vec4 vPos = LoadVec4( sampler, addr + ivec2(0,0) );\n    cam.vPos = vPos.xyz;\n    vec4 targetFov = LoadVec4( sampler, addr + ivec2(1,0) );\n    cam.vTarget = targetFov.xyz;\n    cam.fFov = targetFov.w;\n    vec4 jitterDof = LoadVec4( sampler, addr + ivec2(2,0) );\n    cam.vJitter = jitterDof.xy;\n    cam.fPlaneInFocus = jitterDof.z;\n}\n\nvoid Cam_StoreState( ivec2 addr, const in CameraState cam, inout vec4 fragColor, in ivec2 fragCoord )\n{\n    StoreVec4( addr + ivec2(0,0), vec4( cam.vPos, 0 ), fragColor, fragCoord );\n    StoreVec4( addr + ivec2(1,0), vec4( cam.vTarget, cam.fFov ), fragColor, fragCoord );    \n    StoreVec4( addr + ivec2(2,0), vec4( cam.vJitter, cam.fPlaneInFocus, 0 ), fragColor, fragCoord );    \n}\n\nmat3 Cam_GetWorldToCameraRotMatrix( const CameraState cameraState )\n{\n    vec3 vForward = normalize( cameraState.vTarget - cameraState.vPos );\n\tvec3 vRight = normalize( cross(vec3(0, 1, 0), vForward) );\n\tvec3 vUp = normalize( cross(vForward, vRight) );\n    \n    return mat3( vRight, vUp, vForward );\n}\n\nvec2 Cam_GetViewCoordFromUV( vec2 vUV, vec2 res )\n{\n\tvec2 vWindow = vUV * 2.0 - 1.0;\n\tvWindow.x *= res.x / res.y;\n\n\treturn vWindow;\t\n}\n\nvoid Cam_GetCameraRay( vec2 vUV, vec2 res, CameraState cam, out vec3 vRayOrigin, out vec3 vRayDir )\n{\n    vec2 vView = Cam_GetViewCoordFromUV( vUV, res );\n    vRayOrigin = cam.vPos;\n    float fPerspDist = 1.0 / tan( radians( cam.fFov ) );\n    vRayDir = normalize( Cam_GetWorldToCameraRotMatrix( cam ) * vec3( vView, fPerspDist ) );\n}\n\nvec2 Cam_GetUVFromWindowCoord( vec2 vWindow, vec2 res )\n{\n    vec2 vScaledWindow = vWindow;\n    vScaledWindow.x *= res.y / res.x;\n\n    return (vScaledWindow * 0.5 + 0.5);\n}\n\nvec2 Cam_WorldToWindowCoord(const in vec3 vWorldPos, const in CameraState cameraState )\n{\n    vec3 vOffset = vWorldPos - cameraState.vPos;\n    vec3 vCameraLocal;\n\n    vCameraLocal = vOffset * Cam_GetWorldToCameraRotMatrix( cameraState );\n\t\n    vec2 vWindowPos = vCameraLocal.xy / (vCameraLocal.z * tan( radians( cameraState.fFov ) ));\n    \n    return vWindowPos;\n}\n\nfloat EncodeDepthAndObject( float depth, int objectId )\n{\n    //depth = max( 0.0, depth );\n    //objectId = max( 0, objectId + 1 );\n    //return exp2(-depth) + float(objectId);\n    return depth;\n}\n\nfloat DecodeDepthAndObjectId( float value, out int objectId )\n{\n    objectId = 0;\n    return max(0.0, value);\n    //objectId = int( floor( value ) ) - 1; \n    //return abs( -log2(fract(value)) );\n}\n\n///////////////////////////////",
   "name": "Common",
   "description": "",
   "type": "common"
  }
 ]
}