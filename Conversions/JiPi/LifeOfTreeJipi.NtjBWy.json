{
 "ver": "0.1",
 "info": {
  "id": "NtjBWy",
  "date": "0",
  "viewed": 0,
  "name": "Life of tree JiPi",
  "description": "[Use Mouse] Rq: The position of the sun is the real one for the date of the TimeLapse picture. The hour is fixed and given by UTC_HOUR. Latitude an longitude could be changed (see SunAtTime function for full calculation).\nNeed little bit of optimization",
  "likes": 0,
  "published": "Private",
  "usePreview": 0,
  "tags": [
   "sun",
   "tree",
   "position",
   "seasons"
  ],
  "hasliked": 0,
  "parentid": "XsS3Dm",
  "parentname": "Life of tree"
 },
 "renderpass": [
  {
   "inputs": [],
   "outputs": [
    {
     "id": "4dfGRr",
     "channel": 0
    }
   ],
   "code": "// Created by sebastien durand /2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// TODO debug this for new chrome !!\n\n//#define NO_LEAF\n//#define BENJAMIN_BUTTON\n\n#define ZERO min(0,iFrame) \n\nconst float \n\tPI = 3.14159265358979323846,\n\tPI2 = 2.*PI,\n    AU = 149597870.61, // Astronomical Unit = Mean distance of the earth from the sun - Km\n\tTORAD = PI/180.,\n    TODEG = 180./PI;\nconst float \n    LATITUDE = 42., \n    LONGITUDE = 1.,\n    UTC_HOUR = 7.8,\n\tOLD_TREE = 1.3,\n\tVERY_OLD_TREE = 3.;\n\nconst vec3\n    Julia=vec3(-.1825,-.905,-.2085),\n    ba=vec3(0.,0.7,0.),\n\tba2=vec3(0.,2.1,0.),\n    SUN_COLOR=vec3(1., .75, .6);\n\nfloat \n    oobdb = 1./dot(ba,ba),\n    oobd2 = 1./dot(ba2,ba2);\n\nfloat jGlobalTime,life, season, treeStep, frc, f2, thinBranch, rBranch, clpOld, clpVeryOld;  \nint bEnd, fStart, fEnd;\nvec3 sunLight, sunColour;\n\n\nbool intersectSphere(in vec3 ro, in vec3 rd, in float r) {\n\tfloat b = dot(rd,ro), d = b*b - dot(ro,ro) + r*r;\n\treturn (d>0. && -sqrt(d)-b > 0.);\n}\n\n\n\n\n\n// - Tools ---------------------------------------------------------------------------\n\nfloat hash(in float n) { return fract(sin(n) * 43758.5453123); }\n\n// polynomial smooth min (k = 0.1) - iq;\nfloat smin(in float a, in float b, in float k ){\n    float h = clamp(.5+.5*(b-a)/k, .0, 1.);\n    return mix(b,a,h) - k*h*(1.-h);\n}\n\nfloat Noise(in vec2 x) {\n    vec2 p=floor(x), f=fract(x);\n    f *= f*(3.-2.*f);\n    float n = p.x + p.y*57.;\n    return mix(mix(hash(n+ 0.), hash(n+ 1.),f.x),\n               mix(hash(n+57.), hash(n+58.),f.x),f.y);\n\n}\n\nmat3 rotAA(in vec3 v, in float angle){//axis angle rotation\n\tfloat c=cos(angle);\n\tvec3  s=v*sin(angle);\n\treturn mat3(v.xxx*v,v.yyy*v,v.zzz*v)*(1.0-c)+\n\t\t   mat3(c,-s.z,s.y,s.z,c,-s.x,-s.y,s.x,c);\n}\n\n// -----------------------------------------------------------------------------------\n\nmat3 rmx,mrot;\n\n// - Shapes & distances --------------------------------------------------------------\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\nconst float MAX_DIST = 18.;\n\n\n\nfloat sdSubTree0(in vec3 p0) {\n\tfloat obj = 0.;\n\t//p.xz = mod(p.xz, 4.) - 2.;\n\tfloat text, dr=0.74074, dd, d0 = MAX_DIST, d = d0;\n\t\n\tvec3 p = p0; //, pBest;\n\tvec2 pt;\n\tfloat brBest;\n\tfloat k=1.;\n    int ffEnd = fEnd;\n    int ffStart = fStart;\n    \n\tfor (int n=ZERO; n<10; n++) {\n\t\tif (n>=bEnd) break;\n\t\tdd = (length(p-ba*clamp(dot(p,ba)*oobdb,0.,1.05))-rBranch+p.y*thinBranch)*dr;\n        d = (dd<d) ? smin(d,dd,.00155) : d;\n\t\tp.x = abs(p.x);\n\t\tp = p*rmx + k*Julia;\n\t\tdr *= 0.74074;\n        ffEnd--;\n        ffStart--;\n    }\n\tdd = (length(p-ba*clamp(dot(p,ba)*oobdb,-0.1,frc))-rBranch+p.y*thinBranch)*dr;\n\td = (dd<d) ? smin(d,dd,dr*.055) : d;\n\tk = .5;\n   \n    for (int n=ZERO; n<6; n++) {\n        if (n>ffEnd) break;\n\t\tif (n>=ffStart) { // Leafs\n\t\t\tp += (n==ffStart) ? (.08+sin(p.yzx*15.0)*.37) : vec3(0.);\n\t\t\tdd = (length(p- ba2*f2*clamp(dot(p.y,ba2.y)*oobd2,.0,3.))-0.2)*dr;\n\t\t\td = (dd<d) ? dd+.0001 : d;\n\t\t}\n\t\tp.x = abs(p.x);\n\t\tp = p*rmx + k*Julia;\n\t\tdr *= 0.74074;\n    }\n    return d;\n}\n\t\nfloat sdTree0(in vec3 p) {\n\t// Mix 2 tree to brake symetrie\n\tfloat scale =  mix(life, 1.5, clpOld);\n\t//p.z *= .8;\n\tp.xyz /= scale;//mix(life, 1.5, clpOld);\n\tp += vec3(0.,.06,0.)+ sin(p.yzx*vec3(5.,6.,3.))*0.017;\n\t// first part\n    float d1 = sdSubTree0(p);\t\n    // second part\n\tp.y /= 1.3;\n\tp.xyz *= mrot;\n\tfloat d2 = sdSubTree0(p);\t\n\t\n\td2 *= scale;\n\td1 *= scale;\n\treturn min(d1,d2);\n}\n\n\n// first based on Orchard@Night by eiffie (https://www.shadertoy.com/view/4s23Rh)\nvec2 sdSubTree(in vec3 p0) {\n\tfloat obj = 0.;\n\t//p.xz = mod(p.xz, 4.) - 2.;\n\tfloat text, dr=0.74074, dd, d0 = MAX_DIST, d = d0;\n\t\n\tvec3 p = p0, pBest;\n\tvec2 pt;\n\tfloat brBest;\n\tfloat k=1.;\n\tfor (int n=ZERO; n<14; n++) {\n        if (n>fEnd) break;\n\t\tif (n<bEnd) {\n\t\t\tdd = (length(p-ba*clamp(dot(p,ba)*oobdb,0.,1.05))-rBranch+p.y*thinBranch)*dr;\n\t\t\tif (dd < d) {\n\t\t\t\td = smin(d,dd,.00155);\n\t\t\t\tpBest = p;\n\t\t\t}\n\t\t}\n\t\telse if(n==bEnd) {\n\t\t\tdd = (length(p-ba*clamp(dot(p,ba)*oobdb,-0.1,frc))-rBranch+p.y*thinBranch)*dr;\n\t\t\tif (dd < d) {\n\t\t\t\td = smin(d,dd,dr*.055);\n\t\t\t\tpBest = p;\n\t\t\t}\n\t\t\tif (d<d0) {\n\t\t\t\t// TODO find best shade\n\t\t\t\ttext = cos(pBest.y*50.+2.5*hash(pBest.x*pBest.y));\n\t\t\t\tobj = 51. + text;\n\t\t\t\t//d+=text;//.005*Noise(pBest.xy*30.);\n\t\t\t\t//d0=d;\n\t\t\t}\n\t\t\tk = .5;\n\t\t}\t\n\t\telse if (n>=fStart && n<=fEnd) { // Leafs\n\t\t\tif(n==fStart) { // Debut feuille\n\t\t\t\tp +=.08+sin(p.yzx*15.0)*.37;\n\t\t\t//\tp.z*=.6 + .4*sin(p.y*.1);\n\t\t\t} \n\t\t\tdd = (length(p- ba2*f2*clamp(dot(p.y,ba2.y)*oobd2,.0,3.))-0.2)*dr;\n\t\t\tif (dd<d) {\n\t\t\t\td = dd+.0001;\n\t\t\t\tobj = float(n-fStart+2);\n\t\t\t}\n\t\t}\n\t\tp.x = abs(p.x);\n\t\tp = p*rmx + k*Julia;\n\t\tdr *= 0.74074;\n    }\n    return vec2(d, obj);\n}\n\t\nvec2 sdTree(in vec3 p) {\n\t// Mix 2 tree to brake symetrie\n\tfloat scale =  mix(life, 1.5, clpOld);\n\t//p.z *= .8;\n\tp.xyz /= scale;//mix(life, 1.5, clpOld);\n\tp += vec3(0.,.06,0.)+ sin(p.yzx*vec3(5.,6.,3.))*0.017;\n\t// first part\n    vec2 d1 = sdSubTree(p);\t\n    // second part\n\tp.y /= 1.3;\n\tp.xyz *= mrot;\n\tvec2 d2 = sdSubTree(p);\t\n\t\n\td2.x *= scale;\n\td1.x *= scale;\n\tfloat d = smin(d1.x,d2.x, .05*clamp(3.-p.y,0.,10.));\n    return vec2(d, (d1.x<d2.x) ? d1.y : d2.y);\n}\n\n\t\nfloat sdLandscape(in vec3 p) {\n    // Artificials hills\n\tfloat h=(.6-.6*cos(p.x/1.5)*cos(p.z/1.5))+(season>.75?.002:.006)*Noise(p.zx*35.); // very regular patern + a little bit of noise\n\treturn p.y+h-(season>.75?.08:.0);\n}\n\n//- Scene --------------------------------------------------------------------\n\n\nvec2 mapLandscape(in vec3 p) {\n\treturn vec2(sdLandscape(p), 1.);\n}\n\nvec2 mapTree(in vec3 p) {\n\tfloat \n        a = mix(.045,.001,clpOld)*p.y*cos(jGlobalTime*10.), // (life < OLD_TREE ? 22. : mix(22.,1.,clamp(life- OLD_TREE,0.,1.)))); \n\t    c = cos(a),\n        s = sin(a);\n    p.xz *= mat2(c,-s,s,c);\n\tp.y *= (1.05+ mix(.04*cos(jGlobalTime/4.*6.28+.8), 0., clpOld));\n\treturn sdTree(p);\n}\nfloat mapTree0(in vec3 p) {\n\tfloat \n        a = mix(.045,.001,clpOld)*p.y*cos(jGlobalTime*10.), // (life < OLD_TREE ? 22. : mix(22.,1.,clamp(life- OLD_TREE,0.,1.)))); \n\t    c = cos(a),\n        s = sin(a);\n    p.xz *= mat2(c,-s,s,c);\n\tp.y *= (1.05+ mix(.04*cos(jGlobalTime/4.*6.28+.8), 0., clpOld));\n\treturn sdTree0(p);\n}\n\nfloat map0(in vec3 p, bool tree, bool landscape) {\n    float res = 1000.;\n    if (tree)      res = min(res, mapTree0(p));\n    if (landscape) res = min(res, sdLandscape(p));\n\treturn res;\n}\n\nvec2 map(in vec3 p, bool tree, bool landscape) {\n    vec2 res = vec2(1000,-1);\n    if (tree)      res = opU(res, mapTree(p));\n    if (landscape) res = opU(res, mapLandscape(p));\n\treturn res;\n}\n\n//- Render --------------------------------------------------------------------------\n\nvec2 castRay(in vec3 ro, in vec3 rd, in float maxd) {\n    bool withTree = intersectSphere(ro-vec3(0.,2.6,0.), rd, 2.7);\n    // TODO intersect plane for landscape\n    \n\tfloat precis=.004, h=precis*2., t=5.;\n\tfloat res;\n    for( int i=ZERO; i<60; i++ ) {\t\t\n\t\tif (abs(h) < precis && t > maxd) break; \n        t += h;\n        res = map0(ro+rd*t, withTree, true);\n        h = res;\n    }\n    return vec2(t, (t<maxd) ? map(ro+rd*t, withTree, true).y : -1.);\n}\n\n\n//- Lighting -----------------------------------------------------------------------\n\n\n// Rolling hills by Dave Hoskins (https://www.shadertoy.com/view/Xsf3zX)\n// Grab all sky information for a given ray from camera\nvec3 GetSky(in vec3 rd, in bool withSun) {\n    float sunAmount = withSun ? max( dot( rd, sunLight), 0.0 ) : 0.0;\n\treturn clamp( \n\t\t\tmix(vec3(.1, .2, .3), vec3(.32, .32, .32), pow(1.0-max(rd.y,0.0),6.)) +\n\t\t\tsunColour * sunAmount * sunAmount * .25 +\n\t\t\tSUN_COLOR * min(pow(sunAmount, 800.0)*1.5, .3)\n\t\t, 0.0, 1.0);\n}\n\n\n// Merge grass into the sky background for correct fog colouring...\nvec3 ApplyFog(in vec3  rgb, in float dis, in vec3 sky){\n\treturn mix(rgb, sky, clamp(dis*dis*0.003, 0.0, 1.0));\n}\n\n// iq\nfloat softshadow(in vec3 ro, in vec3 rd) {\n#ifdef FAST\n\treturn 1.;\n#else\n\n\tfloat res = 1.0, h, t = .02;\n    for( int i=ZERO; i<16; i++ ) {\n\t//\tif (t < maxt) {\n\t\th = map0(ro + rd*t, true, true);\n\t\tres = min( res, 1.*h/t );\n\t\tt += 0.3;\n\t//\t}\n    }\n    return clamp(res, 0., 1.);\n#endif\t\n}\n\nconst vec2 eps = vec2(.001, 0.);\n/*\nvec3 calcNormal(in vec3 p, in bool tree, in bool landscape) {\n    vec2 e = vec2(eps.x, -eps.x); \n    return normalize(e.xyy * map0(p + e.xyy, tree, landscape) +\n                     e.yyx * map0(p + e.yyx, tree, landscape) + \n                     e.yxy * map0(p + e.yxy, tree, landscape) + \n                     e.xxx * map0(p + e.xxx, tree, landscape));\n}\n*/\nvec3 calcNormal( vec3 pos, vec3 ray, float t,  in bool tree, in bool landscape) {\n  //  vec2 e = vec2(eps.x, -eps.x); \n  //  return normalize(e.xyy * map(pos + e.xyy).x + e.yyx * map(pos + e.yyx).x + e.yxy * map(pos + e.yxy).x + e.xxx * map(pos + e.xxx).x);;\n\n\tfloat pitch = .2 * t / iResolution.x;\n    \n//#ifdef FAST\n//\t// don't sample smaller than the interpolation errors in Noise()\n\tpitch = max( pitch, .005 );\n//#endif\n\t\n\tvec2 d = vec2(-1,1) * pitch;\n\n\tvec3 p0 = pos+d.xxx; // tetrahedral offsets\n\tvec3 p1 = pos+d.xyy;\n\tvec3 p2 = pos+d.yxy;\n\tvec3 p3 = pos+d.yyx;\n\t\n\tfloat f0 =  map0(p0, tree, landscape);\n    float f1 = map0(p1, tree, landscape);\n\tfloat f2 = map0(p2, tree, landscape);\n\tfloat f3 = map0(p3, tree, landscape);\n\t\n\tvec3 grad = p0*f0+p1*f1+p2*f2+p3*f3 - pos*(f0+f1+f2+f3);\n\t//return normalize(grad);\t// prevent normals pointing away from camera (caused by precision errors)\n\treturn normalize(grad - max(.0,dot (grad,ray ))*ray);\n}\n\n\n\nfloat calcAO(in vec3 pos, in vec3 nor) {\n#ifdef FAST\t\n\treturn 1.;\n#else\n\tfloat dd, hr=.01, totao=.0, sca=1.;\t\n    for(int aoi=ZERO; aoi<5; aoi++ ) {\n        dd = map(nor * hr + pos, true, true).x;\n        totao += -(dd-hr)*sca;\n        sca *= .75;\n        hr += .05;\n    }\n    return clamp(1.-4.*totao, 0., 1.);\n#endif\n}\n\nvec3 render(in vec3 ro, in vec3 rd) { \n    vec3 col = vec3(0.0);\n    vec2 res = castRay(ro,rd,MAX_DIST);\n    float t = res.x, m = res.y;\nfloat ao = 1., sh = 1.;\n    if( m>-0.5 ) {\n        vec3 nor, pos = ro + t*rd;\n        \n\n\t\tif (m >= 2. && m<10.) {\n            nor = calcNormal( pos, rd, t, true, false);\n\t\t\tcol = mix(vec3(.35*m,3.-.08*m,0.), vec3(3.-.08*m,(m*.35),0.), season*1.3); // Automne\n\t\t} else if (m<2.) {\n            nor = calcNormal( pos, rd, t, false, true);\n\t\t\tcol = season>.75?vec3(1):\n\t\t\t\t  season>.3?vec3(1.3,0.9,0.3):\n\t\t\t\t  vec3(.3,0.9,0.3);\n\t\t} else {\n            nor = calcNormal( pos, rd, t, true, false);\n\t\t\tcol = vec3(.7+.3*(m-50.5));\n\t\t} \n\t\n\t\tao = calcAO(pos, nor );\n        float \n\t\t    amb = 1.,//clamp(.5+.5*nor.y, .0, 1.),\n            dif = clamp(dot( nor, sunLight ), 0., 1.),\n            bac = clamp(dot( nor, normalize(vec3(sunLight))), 0., 1.);//*clamp( 1.0-pos.y,0.0,1.0);\n\n\t//\tif( dif>.02 ) {\n\t\tsh = 4.*softshadow( pos, sunLight); \n\t\tdif *= sh;\n\t//}\n\n\t\tvec3 brdf = .1*ao*(amb*vec3(.10,.11,.13) + bac*.15) + 1.2*dif;\n\n\t\tfloat \n            pp = clamp(dot(reflect(rd,nor), sunLight),0.,1.),\n\t\t    spe = sh*pow(pp,16.),\n\t\t    fre = ao*pow( clamp(1.+dot(nor,rd),0.,1.), 2.);\n\n\t\tcol = col*brdf + col*spe + .5*fre;//*(.5+.5*col);\n\t\t  //  * exp(-.01*t*t);\n\n\t\t// TODO calculate sun color from position and use it here\n\t\tif(spe>0.0){\n\t\t\tcol+=.2*sunColour*pow(max(0.0,dot(reflect(rd,nor),sunLight)),8.)*spe;\n\t\t}\n\t\t#ifdef MIE_RAYLEIGH_SKY\n\t\t\tvec3 gp = vec3(ro.x, earth.rs + 3500.0, ro.z);\n\t\t\tcol = ApplyFog(col, res.x, compute_sky_light(gp, rd, earth, sun));\n\t\t#else\n\t\t\tcol = ApplyFog(col, res.x, GetSky(rd, true));\n\t\t#endif\n\t\t//\t\tDoLighting(col, pos, nor, rd, res.x);\n\n\t} else {\n\t\t#ifdef MIE_RAYLEIGH_SKY\n\t\t\tvec3 gp = vec3(ro.x, earth.rs + 3500.0, ro.z);\n\t\t\tcol = compute_sky_light(gp, rd, earth, sun);\n\t\t#else\n\t\t\tcol = GetSky(rd, true);\n\t\t#endif\n\t\tcol = ApplyFog( col, res.x, col);\n\t}\n\t\n\treturn vec3(clamp(col,0.,1.) );\n}\n\n\n//*********************************************************************************\n//    +----------------------------------------------------------------+\n//    |   Position of the sun in the sky at a given location and time  |\n// +----------------------------------------------------------------+\n// Based on LOW-Precision formulae for planetary positions by T.C. Van Flandern and H-F. Pulkkinen\n// http://articles.adsabs.harvard.edu/cgi-bin/nph-iarticle_query?1979ApJS...41..391V&defaultprint=YES&filetype=.pdf\n\nfloat julianDay2000(in int yr, in int mn, in int day, in int hr, in int m, in int s) {\n\tint im = (mn-14)/12, \n\t\tijulian = day - 32075 + 1461*(yr+4800+im)/4 + 367*(mn-2-im*12)/12 - 3*((yr+4900+im)/100)/4;\n\tfloat f = float(ijulian)-2451545.;\n\treturn f - 0.5 + float(hr)/24. + float(m)/1440. + float(s)/86400.;\n}\n\nfloat julianDay2000(in float unixTimeMs) {\n\treturn (unixTimeMs/86400.) - 10957.5;// = + 2440587.5-2451545; \n}\n\nvec2 SunAtTime(in float julianDay2000, in float latitude, in float longitude) {\n\tfloat zs,rightAscention, declination, sundist,\n\t\tt  = julianDay2000,\t//= jd - 2451545., // nb julian days since 01/01/2000 (1 January 2000 = 2451545 Julian Days)\n\t\tt0 = t/36525.,    \t\t // nb julian centuries since 2000      \n\t\tt1 = t0+1.,   \t\t \t // nb julian centuries since 1900\n\t\tLs = fract(.779072+.00273790931*t)*PI2, // mean longitude of sun\n\t\tMs = fract(.993126+.0027377785 *t)*PI2, // mean anomaly of sun\n\t\tGMST = 280.46061837 + 360.98564736629*t + (0.000387933 - t0/38710000.)*t0*t0, // Greenwich Mean Sidereal Time   \n// position of sun\n\t\tv = (.39785-.00021*t1)*sin(Ls)-.01*sin(Ls-Ms)+.00333*sin(Ls+Ms),\n\t\tu = 1.-.03349*cos(Ms)-.00014*cos(2.*Ls)+.00008*cos(Ls),\n\t\tw = -.0001-.04129 * sin(2.*Ls)+(.03211-.00008*t1)*sin(Ms)\n\t\t\t+.00104*sin(2.*Ls-Ms)-.00035*sin(2.*Ls+Ms);\n// calcul distance of sun\n\tsundist = 1.00021*sqrt(u)*AU;\n// calcul right ascention\n\tzs = w / sqrt(u-v*v);\n\trightAscention = Ls + atan(zs/sqrt(1.-zs*zs));\n// calcul declination\n\tzs = v / sqrt(u);\n\tdeclination = atan(zs/sqrt(1.-zs*zs));\n// position relative to geographic location\n\tfloat\n\t\tsin_dec = sin(declination),   cos_dec = cos(declination),\n\t\tsin_lat = sin(TORAD*latitude),cos_lat = cos(TORAD*latitude),\n\t\tlmst = mod((GMST + longitude)/15., 24.);\n\tif (lmst<0.) lmst += 24.;\n\tlmst = TORAD*lmst*15.;\n\tfloat\n\t\tha = lmst - rightAscention,       \n\t\televation = asin(sin_lat * sin_dec + cos_lat * cos_dec * cos(ha)),\n\t\tazimuth   = acos((sin_dec - (sin_lat*sin(elevation))) / (cos_lat*cos(elevation)));\n\treturn vec2(sin(ha)>0.? azimuth:PI2-azimuth, elevation);\n}\n\nvec3 getSunVector(in float jd, in float latitude, in float longitude) {\n\tvec2 ae = SunAtTime(jd, latitude, longitude);\n\t// X = north, Y = top\n\treturn normalize(vec3(-cos(ae.x)*cos(ae.y), sin(ae.y), sin(ae.x)*cos(ae.y)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n     rmx =  rotAA(normalize(vec3(.2174,1,.02174)),1.62729)*1.35;\n\t mrot = rotAA(normalize(vec3(.1,.95,.02)), 2.);\n\n// Picture params -------------------------------------------------------------------------\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.+2.*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\n// - Camera\t-------------------------------------------------------------------------------\n    float a0=1.5+iTime/12., r=2.5;\n    vec3 \n        ro = vec3(-9.+r*cos(a0+PI2*mo.x), \n\t\t\t\t  max(.75,1.5+.6*mo.y),\n\t\t\t\t  5.5+r*sin(a0+PI2*mo.x)),\n\t    ta = vec3(1.6, 1.9, -3.5 ),\n        // Camera tx\n        cw = normalize(ta-ro),\n\t    cu = cross(cw,vec3(0.,1.,0.)),\n\t    cv = cross(cu,cw),\n\t    rd = normalize(p.x*cu + p.y*cv + 2.5*cw);\n    \n// - Time / Season / Position of sun according to location and time ----------------------- \n#ifdef BENJAMIN_BUTTON\n    jGlobalTime = 20000.-iTime; // For Benjamin button tree, inverse the sign !\n#else\n\tjGlobalTime = 1.+iTime*.75;\t\t\n#endif\n\tlife =.5+mod(jGlobalTime,68.)/24.;\n\tseason = mod(jGlobalTime, 4.)/4.;\n\tfloat \n        day = floor(season*365.)+100.,\n\t    jd2000 = julianDay2000((day*24.+UTC_HOUR)*3600.);\n\t\n\tvec2 ae = SunAtTime(jd2000, LATITUDE, LONGITUDE);\n\t// X = north, Y = top\n\tsunLight = normalize(vec3(-cos(ae.x)*cos(ae.y), sin(ae.y), sin(ae.x)*cos(ae.y)));\n\n#ifdef MIE_RAYLEIGH_SKY\n\tsun.azi = ae.x;\n\tsun.alt = ae.y; \n#endif\n\t\n\tif (sunLight.y < .12) {\n    \tsunColour = mix(vec3(2.,.4,.2), SUN_COLOR, smoothstep(0.,1., sunLight.y*8.));\n\t} else {\n\t\tsunColour = SUN_COLOR;\n\t}\n\t\n// - Scene parameters according to season --------------------------------------------------\n\ttreeStep = clamp(life*life,0.,1.);\n\tfrc = fract(treeStep*10.);\n\tbEnd = int(treeStep*10.);\n\tf2 = sin(season*(3.14/.8)); /*- .33*cos(a*3.) + .2*cos(a*5.)*/;\n\tf2 = treeStep*treeStep*clamp(2.*f2,0.,1.);\n\tf2 = mix(f2, 0., clamp(2.*(life-OLD_TREE),0.,1.));\n#ifdef NO_LEAF\n\tfEnd = fStart = 20;\n#else\n\tfStart = (season>.8||life<.6||life>1.5*OLD_TREE) ? 20 : bEnd+1;//bEnd>6? bEnd+2:8; //1+int(3.*(sin(season*(3.14/.8))));\n\tfEnd =  fStart + (bEnd<8 ? 1:3);\n#endif\n\tthinBranch=.018;\n\trBranch = mix(.01,.07,treeStep);\n\tclpOld = clamp(life-OLD_TREE,0.,1.);\n\tclpVeryOld = clamp(life-VERY_OLD_TREE,0.,1.);\n    \n// - Render ------------------------------------------------------------------------------\n    vec3 col = render(ro, rd);\n    \n// - Post prod ---------------------------------------------------------------------------    \n\tcol = (sqrt(col)\n\t\t\t    + sunColour*mix(0., .051, sunLight.y<.05 ? 1.-sunLight.y*20. : 0.) // extra light at sunshine\n\t\t)\n\t    * mix(1.2, 5., 3.*clpVeryOld) // I see the light !\n\t    * pow(abs(16.*q.x*q.y*(1.-q.x)*(1.-q.y)), mix(.2, .25, clamp(life-VERY_OLD_TREE-.3,0.,1.))); // vigneting\n        \n    fragColor=vec4( col, 1.);\n}\n",
   "name": "Image",
   "description": "",
   "type": "image"
  }
 ]
}