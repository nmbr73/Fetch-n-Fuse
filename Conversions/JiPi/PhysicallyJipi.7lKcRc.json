{
 "ver": "0.1",
 "info": {
  "id": "7lKcRc",
  "date": "0",
  "viewed": 0,
  "name": "Physically JiPi",
  "description": "This is a physically accurate soap bubble\n-Simulates 81 wavelengths of light for interference effects\n-Soap film width thin on the top and thick on the bottom, 150 to 700nm initially\n-Micro-sloshing on the surface\n-Geometry perturbations",
  "likes": 0,
  "published": "Private",
  "usePreview": 0,
  "tags": [
   "raytracing",
   "interference",
   "soapbubble",
   "spectral"
  ],
  "hasliked": 0,
  "parentid": "XtKyRK",
  "parentname": "Physically-Based Soap Bubble"
 },
 "renderpass": [
  {
   "inputs": [
    {
     "id": "4sf3Rn",
     "filepath": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png",
     "type": "texture",
     "channel": 1,
     "sampler": {
      "filter": "mipmap",
      "wrap": "repeat",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    },
    {
     "id": "XdX3zn",
     "filepath": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg",
     "type": "cubemap",
     "channel": 0,
     "sampler": {
      "filter": "mipmap",
      "wrap": "clamp",
      "vflip": "false",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    }
   ],
   "outputs": [
    {
     "id": "4dfGRr",
     "channel": 0
    }
   ],
   "code": "// PHYSICALLY-BASED REAL-TIME SOAP BUBBLE\n// @author: Matteo Mannino\n// @about:\n// This simulates the interference for 81 wavelengths of light on a soap bubble film.\n// The idea was to use an RGB-to-Spectrum->FILTER->Spectrum-to-RGB process:\n// 1. The RGB-to-Spectrum filter comes from an assumed camera model and pseudo-inverse conversion approach\n// 2. The filter is the from Andrew Glassner's notebook. It gives the approximation of the power attenuation-per-wavelength\n//\t  that the interference creates given the film width and incident angle. 81 wavelengths are used. \n//    Andrew Glassner's notebook on Soap Bubbles (part 2): https://www.glassner.com/wp-content/uploads/2014/04/CG-CGA-PDF-00-11-Soap-Bubbles-2-Nov00.pdf\n//    (you can compare figure 17-18 to this simulation)\n// 3. For the final color, transform the Spectrum back to RGB\n//\n// The above process is condensed into a single filter function. Instead of summing over 81 wavelength coefficents, the fourier\n// coefficients of the filter are used (13 for cos and sin components each), and the fourier representation of the function\n// is used to evaluate the entire function. This is a vastly more efficient evaluation.\n//\n// As in Glassner's notes, the film width is thin on top and thick on the bottom (set to vary between 150nm on top and 700 on bottom)\n//\n// The surface micro-sloshing is simulated using time-varying 3d warp noise, \n// as described here: https://iquilezles.org/articles/warp\n// Only one level of warp is used.\n//\n// The bubble geometry is just 6 spheres aligned on each axis,randomly jittering, interpolated together\n// The ray-trace function returns both the front and backside of the sphere, so reflections can be computed for both.\n//\n// License: Creative Commons Attribution-NonCommercial 4.0 International\n\n// HDR VARS (need to fake an HDR envmap for the image-based reflections)\n#define hdrfunc(x) (exp(1.2*(x))-1.0)\n#define whitesatval hdrfunc(1.0)\n\n// SOAP REFRACTION VARS\nconst float R_0 = 0.0278;\nconst float nu = 1.4;\nconst float minfilmwidth = 150.0;\nconst float maxfilmwidth = 700.0;\nconst float varfilmwidth = 20.0;\n\n// RAY-TRACE EPSILON\nconst float eps = 0.001;\n\n//SOAP BUBBLE GEOMETRY VARS\nconst float PI = 3.141592653589793;\nconst float RADIUS = 0.8;\nconst float MAX_DEPTH = 9999999.0;\nconst float THRESH_DEPTH = 0.05;\nconst float DX = 0.10;\nconst float VX = 0.04;\nconst float sDX = 0.01;\nconst float sVX = 0.04;\n\n// TRANSFORMS FOR RGB-to-SPECTRUM-FILTER-SPECTRUM-to-RGB\nmat3 sparsespfiltconst;\nmat3 sparsespfilta[13];\nmat3 sparsespfiltb[13];\n\n// Fractal Brownian Motion\nfloat fBm(vec3 p) {\n\tfloat v = 0.0;\n    float amplitude = 4.0;\n    float scale = 1.0;\n    int octaves = 2;\n    for(int i = 0; i < octaves; ++i) {\n    \t//v += amplitude*texture(iChannel1, scale*p.xyz).r;\n        v += amplitude*texture(iChannel1, scale*p.xy).r;\n        amplitude *= 0.5;\n        scale *= 2.0;\n    }\n    return v;\n}\n\n// 1 level of warp noise for micro waves on bubble surface\nfloat warpnoise3(vec3 p) {\n    float f = 0.0;\n    const float c1 = 0.06;\n    const float tc = 0.05;\n    vec3 q = vec3(fBm(p + tc*iTime), \n                  fBm(p + vec3(5.1, 1.3, 2.2) + tc*iTime), \n                  fBm(p + vec3(3.4, 4.8, 5.5) + tc*iTime));\n    \n    return 1.2*fBm(p + c1*q);\n}\n\n// Pre-computed coefficients for spectral response\nvoid initialize_sparse_spectral_transforms()\n{\n    sparsespfiltconst = mat3(vec3(997.744490776777870, 0.000000000000000, 0.000000000000000), vec3(0.000000000000000, 1000.429230968840700, 0.000000000000000), vec3(0.000000000000000, 0.000000000000000, 1000.314923254210300));\n\tsparsespfilta[0] = mat3(vec3(-9.173541963568921, 0.000000000000000, 0.000000000000000), vec3(0.000000000000000, 0.000000000000000, 0.000000000000000), vec3(0.000000000000000, 0.000000000000000, 0.000000000000000));\n\tsparsespfilta[1] = mat3(vec3(-12.118820092848431, 0.000000000000000, 0.000000000000000), vec3(0.000000000000000, 0.362717643641774, 0.000000000000000), vec3(0.000000000000000, 0.000000000000000, 0.000000000000000));\n\tsparsespfilta[2] = mat3(vec3(-18.453733912103289, 0.000000000000000, 0.000000000000000), vec3(0.000000000000000, 1.063838675818334, 0.000000000000000), vec3(0.000000000000000, 0.000000000000000, 0.000000000000000));\n\tsparsespfilta[3] = mat3(vec3(-448.414255038845680, -26.846846493079958, 0.000000000000000), vec3(94.833575999184120, 9.525075729872752, 0.000000000000000), vec3(-48.773853498042200, 0.000000000000000, -0.416692876008104));\n\tsparsespfilta[4] = mat3(vec3(6.312176276235818, -29.044711065580177, 0.000000000000000), vec3(-187.629408328884550, -359.908263134928520, 0.000000000000000), vec3(0.000000000000000, 25.579031651446712, -0.722360089703890));\n\tsparsespfilta[5] = mat3(vec3(-33.547962219868452, 61.587972582979901, 0.000000000000000), vec3(97.565538879460178, -150.665614921761320, -30.220477643983013), vec3(1.552347379820659, -0.319166631512109, -0.935186347338915));\n\tsparsespfilta[6] = mat3(vec3(3.894757056395064, 0.000000000000000, 10.573132007634964), vec3(0.000000000000000, -3.434367603334157, -9.216617325755173), vec3(39.438244799684632, 0.000000000000000, -274.009089525723140));\n\tsparsespfilta[7] = mat3(vec3(3.824490469437192, 0.000000000000000, 0.000000000000000), vec3(0.000000000000000, -1.540065958710146, 35.179624268750139), vec3(0.000000000000000, 0.000000000000000, -239.475015979167920));\n\tsparsespfilta[8] = mat3(vec3(2.977660826364815, 0.000000000000000, 0.000000000000000), vec3(0.000000000000000, -1.042036915995045, 0.000000000000000), vec3(0.000000000000000, 0.000000000000000, -2.472524681362817));\n\tsparsespfilta[9] = mat3(vec3(2.307327051977537, 0.000000000000000, 0.000000000000000), vec3(0.000000000000000, -0.875061637866728, 0.000000000000000), vec3(0.000000000000000, 0.000000000000000, -1.409849313639845));\n\tsparsespfilta[10] = mat3(vec3(1.823790655724537, 0.000000000000000, 0.000000000000000), vec3(0.000000000000000, -0.781918646414733, 0.000000000000000), vec3(0.000000000000000, 0.000000000000000, -1.048825978147449));\n\tsparsespfilta[11] = mat3(vec3(0.000000000000000, 0.000000000000000, 0.000000000000000), vec3(0.000000000000000, 0.000000000000000, 0.000000000000000), vec3(0.000000000000000, 0.000000000000000, -0.868933490490107));\n\tsparsespfilta[12] = mat3(vec3(0.000000000000000, 0.000000000000000, 0.000000000000000), vec3(0.000000000000000, 0.000000000000000, 0.000000000000000), vec3(0.000000000000000, 0.000000000000000, -0.766926116519291));\n\tsparsespfiltb[0] = mat3(vec3(36.508697968439087, 0.000000000000000, 0.000000000000000), vec3(0.000000000000000, 0.000000000000000, 0.000000000000000), vec3(0.000000000000000, 0.000000000000000, 0.000000000000000));\n\tsparsespfiltb[1] = mat3(vec3(57.242341893668829, 0.000000000000000, 0.000000000000000), vec3(0.000000000000000, 38.326477066948989, 0.000000000000000), vec3(0.000000000000000, 0.000000000000000, 0.000000000000000));\n\tsparsespfiltb[2] = mat3(vec3(112.305664332688050, 0.000000000000000, 0.000000000000000), vec3(0.000000000000000, 59.761768151790150, 0.000000000000000), vec3(0.000000000000000, 0.000000000000000, 0.000000000000000));\n\tsparsespfiltb[3] = mat3(vec3(295.791838308625070, 58.489998502973329, 0.000000000000000), vec3(70.091833386311293, 120.512061156381040, 0.000000000000000), vec3(17.204619265336060, 0.000000000000000, 37.784871450121273));\n\tsparsespfiltb[4] = mat3(vec3(-253.802681237032970, -160.471170139118780, 0.000000000000000), vec3(-194.893137314865900, 220.339388056683760, 0.000000000000000), vec3(0.000000000000000, -22.651202495658183, 57.335351084503102));\n\tsparsespfiltb[5] = mat3(vec3(-114.597984116320400, 38.688618505605739, 0.000000000000000), vec3(30.320616033665370, -278.354607015268130, 9.944900164751438), vec3(-30.962164636838232, 37.612068254920686, 113.260728861048410));\n\tsparsespfiltb[6] = mat3(vec3(-78.527368894236332, 0.000000000000000, 30.382451414099631), vec3(0.000000000000000, -116.269817575252430, -55.801473552703627), vec3(0.353768568406928, 0.000000000000000, 243.785483416097240));\n\tsparsespfiltb[7] = mat3(vec3(-53.536668214025610, 0.000000000000000, 0.000000000000000), vec3(0.000000000000000, -68.933243211639621, 17.821880498324404), vec3(0.000000000000000, 0.000000000000000, -278.470203722289060));\n\tsparsespfiltb[8] = mat3(vec3(-42.646930307293360, 0.000000000000000, 0.000000000000000), vec3(0.000000000000000, -51.026918452773138, 0.000000000000000), vec3(0.000000000000000, 0.000000000000000, -113.420624636770270));\n\tsparsespfiltb[9] = mat3(vec3(-35.705990828985080, 0.000000000000000, 0.000000000000000), vec3(0.000000000000000, -40.934269625438475, 0.000000000000000), vec3(0.000000000000000, 0.000000000000000, -67.307342271105213));\n\tsparsespfiltb[10] = mat3(vec3(-30.901151041566411, 0.000000000000000, 0.000000000000000), vec3(0.000000000000000, -34.440424768095276, 0.000000000000000), vec3(0.000000000000000, 0.000000000000000, -49.156471643386766));\n\tsparsespfiltb[11] = mat3(vec3(0.000000000000000, 0.000000000000000, 0.000000000000000), vec3(0.000000000000000, 0.000000000000000, 0.000000000000000), vec3(0.000000000000000, 0.000000000000000, -39.178407337105710));\n\tsparsespfiltb[12] = mat3(vec3(0.000000000000000, 0.000000000000000, 0.000000000000000), vec3(0.000000000000000, 0.000000000000000, 0.000000000000000), vec3(0.000000000000000, 0.000000000000000, -32.812895526130347));\n}\n\n// Essentially the BRDF\nvec4 sp_spectral_filter(vec4 col, float filmwidth, float cosi)\n{\n    vec4 retcol = vec4(0.0, 0.0, 0.0, 1.0);\n    const float NN = 2001.0;\n    float a = 1.0/(nu*nu);\n    float cost = sqrt(a*cosi*cosi + (1.0-a));\n    float n = 2.0*PI*filmwidth*cost/NN;\n    float kn = 0.0;\n    mat3 filt = sparsespfiltconst;\n    \n    for(int i = 0; i < 13; i++)\n    {\n        kn = (float(i)+6.0f)*n;\n        filt += sparsespfilta[i]*cos(kn) + sparsespfiltb[i]*sin(kn);\n    }\n    \n    retcol.xyz = 4.0*(filt*col.xyz)/NN;\n    return retcol;\n}\n\n\n// Ray-sphere intersection. Returns both front and backside hit\nvec2 sphere(vec3 raydir, vec3 offset, vec4 sparams)\n{\n    vec3 tcenter = sparams.xyz - offset;\n \tfloat c = dot(tcenter,tcenter)-sparams.w*sparams.w;\n    float b = 2.0*dot(-tcenter, raydir);\n    //float a = 1.0;//dot(raydir, raydir);\n    float det = b*b-4.0*c;\n    vec2 hits = vec2(-1.0,-1.0);\n    if(det > 0.0) {\n    \tfloat t1 = 0.5*(-b+sqrt(det));\n    \tfloat t2 = 0.5*(-b-sqrt(det));\n        if(t1 < t2) { hits = vec2(t1,t2); }\n        else { hits = vec2(t2,t1); }\n    }\n    return hits;\n}\n\nvec3 reflected(vec3 raydir, vec3 normal)\n{\n    return raydir - 2.0*dot(raydir, normal)*normal;\n}\n\nfloat fresnel_schlick(vec3 raydir, vec3 normal)\n{\n    float a = 1.0 + dot(raydir, normal);\n\treturn mix(R_0, 1.0, a*a*a*a*a);//R_0 + (1.0-R_0)*a*a*a*a*a;\n}\n\nvec4 background(vec3 raydir)\n{\n    return texture(iChannel0, raydir);\n}\n\nvec4 fakehdr(vec4 col)\n{\n    vec4 hdrcol;\n    hdrcol.rgb = pow(col.rgb, vec3(2.2)); // gamma correct\n    float lum = dot(hdrcol.rgb, vec3(0.2126, 0.7152, 0.0722));\n    hdrcol.rgb = hdrfunc(lum)*hdrcol.rgb; // smooth transition, 0.5-1.0 -> 0.5-100.0\n    return hdrcol;\n}\n\nvec4 invfakehdr(vec4 hdrcol)\n{\n    vec4 ihdrcol;\n    float lum = dot(hdrcol.rgb, vec3(0.2126, 0.7152, 0.0722));\n    float tonescale = ((lum/(whitesatval*whitesatval))+1.0)*lum/(lum+1.0);\n    //ihdrcol.rgb = hdrcol.rgb/(vec3(1.0) + hdrcol.rgb);//hdrfunc(1.0);\n    ihdrcol.rgb = pow((tonescale/lum)*hdrcol.rgb,vec3(1.0/2.2));\n    ihdrcol.w = 1.0;\n    return ihdrcol;\n}\n\n\n// Intersects all spheres and interpolates all points close to the hits\n// The frontside and the backside hits are handled separately.\n// The normals for the backside hits are inverted (pointing inside the sphere) since that's the visible side.\nmat4 scene(vec3 raydir, vec3 offset, float time)\n{\n \tconst int NUMSPHERES = 6; // Cannot be greater than 6, sphere[] below hardcodes 6 indices \n    const float rate = 0.1;\n\tvec4 spheres[NUMSPHERES];\n    vec4 fronthits[NUMSPHERES];\n    vec4 backhits[NUMSPHERES];\n    vec2 hitdp[NUMSPHERES];\n    \n    spheres[0] = vec4( VX*sin(1.0*rate*time)+DX, sVX*sin(0.1*rate*time)+sDX, 0.0, RADIUS);\n    spheres[1] = vec4(-VX*sin(1.2*rate*time)-DX, sVX*sin(0.12*rate*time)+sDX, sVX*sin(0.11*rate*time)+sDX, RADIUS);\n    spheres[2] = vec4(-sVX*sin(0.1*rate*time)+sDX, VX*sin(1.1*rate*time)+DX,  0.0, RADIUS);\n    spheres[3] = vec4(sVX*sin(0.11*rate*time)+sDX, -VX*sin(1.5*rate*time)-DX, 0.0, RADIUS);\n    spheres[4] = vec4(sVX*sin(0.09*rate*time)+sDX, 0.0, VX*sin(1.3*rate*time)+DX, RADIUS);\n    spheres[5] = vec4(sVX*sin(0.1*rate*time)+sDX, 0.0, -VX*sin(0.8*rate*time)-DX, RADIUS);\n    vec4 minfronthit = vec4(0.0, 0.0, 0.0, MAX_DEPTH);\n    vec4 avgfronthit = vec4(0.0, 0.0, 0.0, 0.0);\n    vec4 minbackhit = vec4(0.0, 0.0, 0.0, -MAX_DEPTH);\n    vec4 avgbackhit = vec4(0.0, 0.0, 0.0, 0.0);\n    float count = 0.0;\n    float backcount = 0.0;\n    for(int i = 0; i < NUMSPHERES; i++) {\n  \t\thitdp[i] = sphere(raydir, offset, spheres[i]);\n        \n    \tvec3 frontpos = hitdp[i].x*raydir + offset;\n    \tvec3 backpos = hitdp[i].y*raydir + offset;\n    \tfronthits[i] = vec4(normalize(frontpos - spheres[i].xyz), hitdp[i].x);\n    \tbackhits[i] = vec4(normalize(spheres[i].xyz - backpos), hitdp[i].y);\n        \n        if(fronthits[i].w > 0.0) {    \n            if(count < 1.0) {\n                avgfronthit = fronthits[i];\n                count = 1.0;\n            }\n            else {\n                if(abs(fronthits[i].w - avgfronthit.w) < THRESH_DEPTH) {\n                \tcount += 1.0;\n            \t\tavgfronthit += fronthits[i];\n                }\n                else if(fronthits[i].w < minfronthit.w) {\n                    count = 1.0;\n                    avgfronthit = fronthits[i];\n                }\n            }\n            \n            if(fronthits[i].w < minfronthit.w) {\n            \tminfronthit = fronthits[i];\n            }\n        }\n        \n        if(backhits[i].w > 0.0) {\n            if(backcount < 1.0) {\n                avgbackhit = backhits[i];\n                backcount = 1.0;\n            }\n            else {\n                if(abs(backhits[i].w - avgbackhit.w) < THRESH_DEPTH) {\n                \tbackcount += 1.0;\n            \t\tavgbackhit += backhits[i];\n                }\n                else if(backhits[i].w > minbackhit.w) {\n                    backcount = 1.0;\n                    avgbackhit = backhits[i];\n                }\n            }\n            \n            if(backhits[i].w > minbackhit.w) {\n            \tminbackhit = backhits[i];\n            }\n        }\n    }\n    \n    mat4 rval = mat4(vec4(0.0, 0.0, 0.0, -1.0),\n                     vec4(0.0, 0.0, 0.0, -1.0),\n                     vec4(0.0, 0.0, 0.0, -1.0),\n                     vec4(0.0, 0.0, 0.0, -1.0));\n    if(count > 0.01 ) {\n        if(count < 1.1) {\n            rval[0] = vec4(normalize(minfronthit.xyz),minfronthit.w);\n        }\n        else {\n            // smooth the transition between spheres\n        \tavgfronthit.xyz = normalize(avgfronthit.xyz);\n        \tavgfronthit.w = avgfronthit.w/count;\n            float tt = min(1.0, (avgfronthit.w - minfronthit.w)/(0.4*THRESH_DEPTH));\n            vec4 rfronthit = tt*minfronthit + (1.0-tt)*avgfronthit;\n            rval[0] = vec4(normalize(rfronthit.xyz),rfronthit.w);\n        }\n    }\n    \n    if(backcount > 0.01 ) {\n        if(backcount < 1.1) {\n            rval[1] = vec4(normalize(minbackhit.xyz),minbackhit.w);\n        }\n        else {\n            // smooth the transition between spheres\n        \tavgbackhit.xyz = normalize(avgbackhit.xyz);\n        \tavgbackhit.w = avgbackhit.w/backcount;\n            float tt = min(1.0, (minbackhit.w - avgbackhit.w)/(0.4*THRESH_DEPTH));\n            vec4 rbackhit = tt*minbackhit + (1.0-tt)*avgbackhit;\n            rval[1] = vec4(normalize(rbackhit.xyz),rbackhit.w);\n        }\n    }\n    \n    return rval;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initialize_sparse_spectral_transforms();\n    \n    vec2 center = iResolution.xy / 2.0;\n    vec2 offset = (fragCoord.xy - center)/center.y;\n    float focallength = 1.0;\n    \n    float ang = 0.04*iTime;\n    mat3 rotatez = mat3( vec3(cos(2.0*PI*ang), 0.0, -sin(2.0*PI*ang)), \n                        vec3(0.0, 1.0, 0.0), vec3(sin(2.0*PI*ang), 0.0, cos(2.0*PI*ang)));\n    //mat3 rotatex = mat3(vec3(1.0, 0.0, 0.0), vec3(0.0, cos(2.0*PI*ang), -sin(2.0*PI*ang)), vec3(0.0, sin(2.0*PI*ang), cos(2.0*PI*ang)));\n    \n    mat3 rotatex = mat3(vec3(1.0, 0.0, 0.0), vec3(0.0, 0.8090, 0.5878), vec3(0.0, -0.5878, 0.8090));\n    mat3 rotate = rotatez;//*rotatex;\n    vec3 raydir = rotate*normalize(vec3(offset/focallength, 1.0)); // pinhole\n    vec3 rayorig = -1.5*rotate[2];\n\n    \n    mat4 scenenorms = scene(raydir, rayorig, 30.0*iTime);\n    vec4 col = fakehdr(background(raydir));\n    \n    if(scenenorms[0].w > 0.0)\n    {\n        for(int i = 0; i < 2; ++i) \n        {\n\t        vec3 rvec = reflected(raydir, scenenorms[i].xyz);\n\t \t    float R = fresnel_schlick(raydir, scenenorms[i].xyz);\n        \tfloat bubbleheight = 0.5 + (i == 0 ? 1.0 : -1.0)*0.5*scenenorms[i].y;\n        \tfloat filmwidth = varfilmwidth*warpnoise3(rayorig + scenenorms[i].w*raydir) + minfilmwidth + (1.0-bubbleheight)*(maxfilmwidth-minfilmwidth);\n\n        \tcol = R*sp_spectral_filter(fakehdr(background(rvec)), filmwidth, dot(scenenorms[i].xyz, raydir)) + (1.0-R)*col;\n\t\t\t\n            // DEBUG\n            //col = sp_spectral_filter(1.0*vec4(1.0,1.0,1.0,1.0), filmwidth, dot(scenenorms[1].xyz, raydir));\n        \t//col = vec4(0.8*max(0.0,dot(-raydir,scenenorms[0].xyz)));   \n        }\n    }\n    col.w = 1.0;\n    fragColor = invfakehdr(col);\n}",
   "name": "Image",
   "description": "",
   "type": "image"
  }
 ]
}