{
 "ver": "0.1",
 "info": {
  "id": "stcBzM",
  "date": "0",
  "viewed": 0,
  "name": "PBRGlint JiPi",
  "description": "Shadertoy implementation of Procedural Physically based BRDF for Real-Time Rendering of Glints\nXavier Chermain (ICUBE), Basile Sauvage (ICUBE), Jean-Michel Dishler (ICUBE) and Carsten Dachsbacher (KIT)\nAccepted for Pacific Graphic 2020 and CGF",
  "likes": 0,
  "published": "Private",
  "usePreview": 0,
  "tags": [
   "procedural",
   "brdf",
   "microfacet",
   "glint"
  ],
  "hasliked": 0,
  "parentid": "wstcRH",
  "parentname": "PBR Glint"
 },
 "renderpass": [
  {
   "inputs": [],
   "outputs": [
    {
     "id": "4dfGRr",
     "channel": 0
    }
   ],
   "code": "// The MIT License\n// Copyright Â© 2020 Xavier Chermain (ICUBE), Basile Sauvage (ICUBE), Jean-Michel Dishler (ICUBE), Carsten Dachsbacher (KIT)\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Shadertoy implementation of\n// Procedural Physically based BRDF for Real-Time Rendering of Glints\n// Xavier Chermain (ICUBE), Basile Sauvage (ICUBE), Jean-Michel Dishler (ICUBE) and Carsten Dachsbacher (KIT)\n// Pacific Graphic 2020, CGF special issue\n// Project page: http://igg.unistra.fr/People/chermain/real_time_glint/\n\n// Dictionary is generated on the fly (we cannot use pre-computed data on Shadertoy), \n// but with a limited number of lobes (16) to achieve a reasonable frame rate.\n// For a full-featured version (WebGL), see: http://igg.unistra.fr/People/reproctex/Demos/Real_Time_Glint/\n\n//=========================================================================================================================\n//================================================== PG2020 title =========================================================\n//=========================================================================================================================\n#define PG2020W 32u\n#define PG2020H 18u\nuint[] pg2020_bitfield = uint[]( 0x0u,0x0u,0x0u,0x003e7c00u,0x00024400u,0x00327c00u,0x00220400u,0x003e0400u,0x0u,0x0u,0x30e30e0u,0x4904900u,0x49e49e0u,0x4824820u,0x31e31e0u,0x0u,0x0u,0x0u );\nbool jfig(in uint x, in uint y) {\n    uint id = x + (PG2020H-1u-y)*PG2020W;\n    if (id>=PG2020W*PG2020H) return false;\n    return 0u != (pg2020_bitfield[id/32u] & (1u << (id&31u)));\n}\n\nfloat texel(int s, int t){\n    if(s < 0 || s >= int(PG2020W) || t < 0 || t >= int(PG2020H) || jfig(uint(s), uint(t)))\n    \treturn 0.;\n    \n    return 1.;\n}\n\nfloat pg2020TriangleFilter(vec2 st){\n\tfloat s = st.x * float(PG2020W) - 0.5;\n    float t = st.y * float(PG2020H) - 0.5;\n    int s0 = int(floor(s));\n    int t0 = int(floor(t));\n    float ds = s - float(s0);\n    float dt = t - float(t0);\n    return (1. - ds) * (1. - dt) * texel(s0, t0) +\n           (1. - ds) * dt * texel(s0, t0 + 1) +\n           ds * (1. - dt) * texel(s0 + 1, t0) +\n           ds * dt * texel(s0 + 1, t0 + 1);\n}\n\n//=========================================================================================================================\n//================================================== Material parameters ==================================================\n//==================================================== Can be changed =====================================================\n//=========================================================================================================================\n// Roughness of the glinty material [0.1, 1.]\n#define ALPHA_X 0.5\n#define ALPHA_Y 0.5\n\n// Microfacet relative area [0.01, 1.]. \n// Set to 0.01 with LOGMICROFACETDENSITY set tot 5. gives sparse glints (snow, sand, sparkling rocks)\n#define MICROFACETRELATIVEAREA 1.\n\n// Logarithmic microfacet density [5., 25.]\n#define LOGMICROFACETDENSITY 14.\n\n// Maximum anisotropy of the pixel footprint (not realy usefull in this scene)\n#define MAXANISOTROPY 8.\n\n// Varnished material (add a specular lobe with a small roughness)\n# define VARNISHED true\n\n//=========================================================================================================================\n//============================================== Parameters of the dictionary =============================================\n//=========================================================================================================================\n// Roughness used during the dictionary generation\n#define ALPHA_DIC 0.5\n// Number of distributions\n// In the paper, we use 192 marginal distributions of slope\n// In shadertoy, we generate the dictionary on the fly. So we use a large number of different NDFs\n#define N 999999\n// Number of levels. In the paper : 16. In shadertoy : 8\n#define NLEVELS 8\n// Size of the tabulated marginal distributions. In the paper : 64. In shadertoy : 32\n#define DISTRESOLUTION 32\n\n\n\n//=========================================================================================================================\n//================================================ Mathematical constants =================================================\n//=========================================================================================================================\n#define PI 3.141592\n#define IPI 0.318309\n#define ISQRT2 0.707106\n\n\n\n//=========================================================================================================================\n//=============================================== Beckmann anisotropic NDF ================================================\n//==================== Shadertoy implementation : Arthur Cavalier (https://www.shadertoy.com/user/H4w0) ===================\n//========================================= https://www.shadertoy.com/view/WlGXRt =========================================\n//=========================================================================================================================\n\n//-----------------------------------------------------------------------------\n//-- Beckmann Distribution ----------------------------------------------------\nfloat p22_beckmann_anisotropic(float x, float y, float alpha_x, float alpha_y)\n{\n    float x_sqr = x*x;\n    float y_sqr = y*y;\n    float sigma_x = alpha_x * ISQRT2;\n    float sigma_y = alpha_y * ISQRT2;\n    float sigma_x_sqr = sigma_x*sigma_x;\n    float sigma_y_sqr = sigma_y*sigma_y;\n    return( \n            exp( -0.5 * ((x_sqr/sigma_x_sqr) + (y_sqr/sigma_y_sqr)) )\n    / //-------------------------------------------------------------------\n                    ( 2. * PI * sigma_x * sigma_y )\n    );\n}\n\nfloat ndf_beckmann_anisotropic(vec3 omega_h, float alpha_x, float alpha_y)\n{\n    float slope_x = - (omega_h.x/omega_h.z);\n    float slope_y = - (omega_h.y/omega_h.z);\n    float cos_theta = omega_h.z;\n    float cos_2_theta = omega_h.z * omega_h.z;\n    float cos_4_theta = cos_2_theta * cos_2_theta;\n    float beckmann_p22 = p22_beckmann_anisotropic(slope_x,slope_y,alpha_x,alpha_y);\n    return(\n                beckmann_p22\n    / //---------------------------\n                cos_4_theta\n    );\n}\n\n//=========================================================================================================================\n//======================================== Schlick approximation of Fresnel ===============================================\n//=========================================================================================================================\nvec3 fresnel_schlick(in float wo_dot_wh, in vec3 F0)\n{\n    return F0 + (1. - F0) * pow(1. - wo_dot_wh, 5.);\n}\n\n//=========================================================================================================================\n//===================================== Microfacet BRDF of Cook and Torrance 1982 =========================================\n//=========================================================================================================================\nvec3 f_specular(vec3 wo, vec3 wi)\n{\n    if(wo.z <= 0.) return vec3(0.,0.,0.);\n    if(wi.z <= 0.) return vec3(0.,0.,0.);\n    vec3 wh = normalize(wo+wi);\n    if(wh.z <= 0.) return vec3(0.,0.,0.);\n    // Local masking shadowing\n    if (dot(wo, wh) <= 0. || dot(wi, wh) <= 0.) return vec3(0.);\n    float wi_dot_wh = clamp(dot(wi,wh),0.,1.);\n\n    float D = ndf_beckmann_anisotropic(wh,0.1, 0.1);\n    // V-cavity masking shadowing\n    float G1wowh = min(1., 2. * wh.z * wo.z / dot(wo, wh));\n    float G1wiwh = min(1., 2. * wh.z * wi.z / dot(wi, wh));\n    float G = G1wowh * G1wiwh;\n    \n\tvec3 F  = fresnel_schlick(wi_dot_wh,vec3(1., 1., 1.));\n        \n    return (D * F * G) / ( 4. * wo.z );\n}\n\n//=========================================================================================================================\n//=============================================== Diffuse Lambertian BRDF =================================================\n//=========================================================================================================================\nvec3 f_diffuse(vec3 wo, vec3 wi)\n{\n    if (wo.z <= 0.)\n        return vec3(0., 0., 0.);\n    if (wi.z <= 0.)\n        return vec3(0., 0., 0.);\n\n    return vec3(0.8, 0., 0.) * IPI * wi.z;\n}\n\n//=========================================================================================================================\n//=============================================== Inverse error function ==================================================\n//=========================================================================================================================\nfloat erfinv(float x)\n{\n    float w, p;\n    w = -log((1.0 - x) * (1.0 + x));\n    if (w < 5.000000)\n    {\n        w = w - 2.500000;\n        p = 2.81022636e-08;\n        p = 3.43273939e-07 + p * w;\n        p = -3.5233877e-06 + p * w;\n        p = -4.39150654e-06 + p * w;\n        p = 0.00021858087 + p * w;\n        p = -0.00125372503 + p * w;\n        p = -0.00417768164 + p * w;\n        p = 0.246640727 + p * w;\n        p = 1.50140941 + p * w;\n    }\n    else\n    {\n        w = sqrt(w) - 3.000000;\n        p = -0.000200214257;\n        p = 0.000100950558 + p * w;\n        p = 0.00134934322 + p * w;\n        p = -0.00367342844 + p * w;\n        p = 0.00573950773 + p * w;\n        p = -0.0076224613 + p * w;\n        p = 0.00943887047 + p * w;\n        p = 1.00167406 + p * w;\n        p = 2.83297682 + p * w;\n    }\n    return p * x;\n}\n\n//=========================================================================================================================\n//================================================== Hash function ========================================================\n//================================================== Inigo Quilez =========================================================\n//====================================== https://www.shadertoy.com/view/llGSzw ============================================\n//=========================================================================================================================\n// \nfloat hashIQ(uint n)\n{\n    // integer hash copied from Hugo Elias\n    n = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return float(n & 0x7fffffffU) / float(0x7fffffff);\n}\n\n//=========================================================================================================================\n//=============================================== Pyramid size at LOD level ===============================================\n//=========================================================================================================================\nint pyramidSize(int level)\n{\n    return int(pow(2., float(NLEVELS - 1 - level)));\n}\n\nfloat normalDistribution1D(float x, float mean, float std_dev) {\n    float xMinusMean = x - mean;\n    float xMinusMeanSqr = xMinusMean * xMinusMean;\n    return exp(-xMinusMeanSqr / (2. * std_dev * std_dev)) /\n           (std_dev * 2.506628);\n    // 2.506628 \\approx sqrt(2 * \\pi)\n}\n\n//=========================================================================================================================\n//========================================= Sampling from a Normal distribution ===========================================\n//=========================================================================================================================\nfloat sampleNormalDistribution(float U, float mu, float sigma)\n{\n    float x = sigma * 1.414213f * erfinv(2.0f * U - 1.0f) + mu;\n    return x;\n}\n\n//=========================================================================================================================\n//==================================== Evaluation of the i th marginal distribution P =====================================\n//========================================== with slope x and at LOD level ================================================\n//============================ Procedural version, because we cannot use data with Shadertoy ==============================\n//=========================================================================================================================\n\nfloat P_procedural(float x, int i, int level) {\n    \n    // We use even functions\n    x = abs(x);\n    // After 4 standard deviation sigma, we consider that the distribution equals zero\n    float sigma_dist_4 = 4. * ALPHA_DIC / 1.414214; // alpha_dist = 0.5 so sigma_dist \\approx 0.3535 (0.5 / sqrt(2))\n    if(x >= sigma_dist_4) return 0.;\n    \n    int nMicrofacetsCurrentLevel = int(pow(2., float(level)));\n    float density = 0.;\n    // Dictionary should be precomputed, but we cannot use memory with Shadertoy\n    // So we generate it on the fly with a very limited number of lobes\n    nMicrofacetsCurrentLevel = min(16, nMicrofacetsCurrentLevel);\n    \n    for (int n = 0; n < nMicrofacetsCurrentLevel; ++n) {\n        \n        float U_n = hashIQ(uint(i*7333+n*5741));\n        // alpha roughness equals sqrt(2) * RMS roughness\n        //     ALPHA_DIC     =   1.414214 * std_dev\n        // std_dev = ALPHA_DIC / 1.414214 \n        float currentMean = sampleNormalDistribution(U_n, 0., ALPHA_DIC / 1.414214);\n        density += normalDistribution1D(x, currentMean, 0.05) +\n                   normalDistribution1D(-x, currentMean, 0.05);\n    }\n    return density / float(nMicrofacetsCurrentLevel);\n}\n\n//=========================================================================================================================\n//=================== Spatially-varying, multiscale, rotated, and scaled slope distribution function ======================\n//================================================= Eq. 11, Alg. 3 ========================================================\n//=========================================================================================================================\nfloat P22_theta_alpha(vec2 slope_h, int l, int s0, int t0)\n{\n    \n    // Coherent index\n    // Eq. 18, Alg. 3, line 1\n    s0 *= 1 << l;\n    t0 *= 1 << l;\n\n    // Seed pseudo random generator\n    // Alg. 3, line 2\n    int rngSeed = s0 + 1549 * t0;\n\n    // Alg.3, line 3\n    float uMicrofacetRelativeArea = hashIQ(uint(rngSeed) * 13U);\n    // Discard cells by using microfacet relative area\n    // Alg.3, line 4\n    if (uMicrofacetRelativeArea > MICROFACETRELATIVEAREA)\n        return 0.f;\n\n    // Number of microfacets in a cell\n    // Alg. 3, line 5\n    float n = pow(2., float(2 * l - (2 * (NLEVELS - 1))));\n    n *= exp(LOGMICROFACETDENSITY);\n\n    // Corresponding continuous distribution LOD\n    // Alg. 3, line 6\n    float l_dist = log(n) / 1.38629; // 2. * log(2) = 1.38629\n    \n    // Alg. 3, line 7\n    float uDensityRandomisation = hashIQ(uint(rngSeed) * 2171U);\n\n    // Fix density randomisation to 2 to have better appearance\n    // Notation in the paper: \\zeta\n    float densityRandomisation = 2.;\n    \n    // Sample a Gaussian to randomise the distribution LOD around the distribution level l_dist\n    // Alg. 3, line 8\n    l_dist = sampleNormalDistribution(uDensityRandomisation, l_dist, densityRandomisation);\n\n    // Alg. 3, line 9\n    int l_disti = clamp(int(round(l_dist)), 0, NLEVELS);\n\n    // Alg. 3, line 10\n    if (l_disti == NLEVELS)\n        return p22_beckmann_anisotropic(slope_h.x, slope_h.y, ALPHA_X, ALPHA_Y);\n\n    // Alg. 3, line 13\n    float uTheta = hashIQ(uint(rngSeed));\n    float theta = 2.0 * PI * uTheta;\n\n    // Uncomment to remove random distribution rotation\n    // Lead to glint alignments with a small N\n    // theta = 0.;\n\n    float cosTheta = cos(theta);\n    float sinTheta = sin(theta);\n    \n    vec2 scaleFactor = vec2(ALPHA_X / ALPHA_DIC,\n                            ALPHA_Y / ALPHA_DIC);\n\n    // Rotate and scale slope\n    // Alg. 3, line 16\n    slope_h = vec2(slope_h.x * cosTheta / scaleFactor.x + slope_h.y * sinTheta / scaleFactor.y,\n                   -slope_h.x * sinTheta / scaleFactor.x + slope_h.y * cosTheta / scaleFactor.y);\n\n    // Alg. 3, line 17\n    float u1 = hashIQ(uint(rngSeed) * 16807U);\n    float u2 = hashIQ(uint(rngSeed) * 48271U);\n\n    // Alg. 3, line 18\n    int i = int(u1 * float(N));\n    int j = int(u2 * float(N));\n    \n    float P_i = P_procedural(slope_h.x, i, l_disti);\n    float P_j = P_procedural(slope_h.y, j, l_disti);\n\n    // Alg. 3, line 19\n    return P_i * P_j / (scaleFactor.x * scaleFactor.y);\n\n}\n\n//=========================================================================================================================\n//========================================= Alg. 2, P-SDF for a discrete LOD ==============================================\n//=========================================================================================================================\n\n// Most of this function is similar to pbrt-v3 EWA function,\n// which itself is similar to Heckbert 1889 algorithm, http://www.cs.cmu.edu/~ph/texfund/texfund.pdf, Section 3.5.9.\n// Go through cells within the pixel footprint for a given LOD l\n\nfloat P22_floorP(int l, vec2 slope_h, vec2 st, vec2 dst0, vec2 dst1)\n{\n    // Convert surface coordinates to appropriate scale for level\n    float pyrSize = float(pyramidSize(l));\n    st[0] = st[0] * pyrSize - 0.5f;\n    st[1] = st[1] * pyrSize - 0.5f;\n    dst0[0] *= pyrSize;\n    dst0[1] *= pyrSize;\n    dst1[0] *= pyrSize;\n    dst1[1] *= pyrSize;\n\n    // Compute ellipse coefficients to bound filter region\n    float A = dst0[1] * dst0[1] + dst1[1] * dst1[1] + 1.;\n    float B = -2. * (dst0[0] * dst0[1] + dst1[0] * dst1[1]);\n    float C = dst0[0] * dst0[0] + dst1[0] * dst1[0] + 1.;\n    float invF = 1. / (A * C - B * B * 0.25f);\n    A *= invF;\n    B *= invF;\n    C *= invF;\n\n    // Compute the ellipse's bounding box in texture space\n    float det = -B * B + 4. * A * C;\n    float invDet = 1. / det;\n    float uSqrt = sqrt(det * C), vSqrt = sqrt(A * det);\n    int s0 = int(ceil(st[0] - 2. * invDet * uSqrt));\n    int s1 = int(floor(st[0] + 2. * invDet * uSqrt));\n    int t0 = int(ceil(st[1] - 2. * invDet * vSqrt));\n    int t1 = int(floor(st[1] + 2. * invDet * vSqrt));\n\n    // Scan over ellipse bound and compute quadratic equation\n    float sum = 0.f;\n    float sumWts = 0.;\n    int nbrOfIter = 0;\n\n    for (int it = t0; it <= t1; ++it)\n    {\n        float tt = float(it) - st[1];\n        for (int is = s0; is <= s1; ++is)\n        {\n            float ss = float(is) - st[0];\n            // Compute squared radius and filter SDF if inside ellipse\n            float r2 = A * ss * ss + B * ss * tt + C * tt * tt;\n            if (r2 < 1.)\n            {\n                // Weighting function used in pbrt-v3 EWA function\n                float alpha = 2.;\n                float W_P = exp(-alpha * r2) - exp(-alpha);\n                // Alg. 2, line 3\n                sum += P22_theta_alpha(slope_h, l, is, it) * W_P;\n                \n                sumWts += W_P;\n            }\n            nbrOfIter++;\n            // Guardrail (Extremely rare case.)\n            if (nbrOfIter > 100)\n                break;\n        }\n        // Guardrail (Extremely rare case.)\n        if (nbrOfIter > 100)\n            break;\n    }\n    return sum / sumWts;\n}\n\n//=========================================================================================================================\n//=============================== Evaluation of our procedural physically based glinty BRDF ===============================\n//==================================================== Alg. 1, Eq. 14 =====================================================\n//=========================================================================================================================\nvec3 f_P(vec3 wo, vec3 wi, vec2 uv)\n{\n\t\n    if (wo.z <= 0.)\n        return vec3(0., 0., 0.);\n    if (wi.z <= 0.)\n        return vec3(0., 0., 0.);\n\n    // Alg. 1, line 1\n    vec3 wh = normalize(wo + wi);\n    if (wh.z <= 0.)\n        return vec3(0., 0., 0.);\n\n    // Local masking shadowing\n    if (dot(wo, wh) <= 0. || dot(wi, wh) <= 0.)\n        return vec3(0.);\n\n    // Eq. 1, Alg. 1, line 2\n    vec2 slope_h = vec2(-wh.x / wh.z, -wh.y / wh.z);\n\n    vec2 texCoord = uv;\n\n    float D_P = 0.;\n    float P22_P = 0.;\n\n    // ------------------------------------------------------------------------------------------------------\n    // Similar to pbrt-v3 MIPMap::Lookup function, http://www.pbr-book.org/3ed-2018/Texture/Image_Texture.html#EllipticallyWeightedAverage\n\n    // Alg. 1, line 3\n    vec2 dst0 = dFdx(texCoord);\n    vec2 dst1 = dFdy(texCoord);\n\n    // Compute ellipse minor and major axes\n    float dst0Length = length(dst0);\n    float dst1Length = length(dst1);\n\n    if (dst0Length < dst1Length)\n    {\n        // Swap dst0 and dst1\n        vec2 tmp = dst0;\n        dst0 = dst1;\n        dst1 = tmp;\n    }\n    float majorLength = length(dst0);\n    // Alg. 1, line 5\n    float minorLength = length(dst1);\n\n    // Clamp ellipse eccentricity if too large\n    // Alg. 1, line 4\n    if (minorLength * MAXANISOTROPY < majorLength && minorLength > 0.)\n    {\n        float scale = majorLength / (minorLength * MAXANISOTROPY);\n        dst1 *= scale;\n        minorLength *= scale;\n    }\n    // ------------------------------------------------------------------------------------------------------\n\n    // Without footprint, we evaluate the Cook Torrance BRDF\n    if (minorLength == 0.)\n    {\n        D_P = ndf_beckmann_anisotropic(wh, ALPHA_X, ALPHA_Y);\n    }\n    else\n    {\n        // Choose LOD\n        // Alg. 1, line 6\n        float l = max(0., float(NLEVELS) - 1. + log2(minorLength));\n        int il = int(floor(l));\n\n        // Alg. 1, line 7\n        float w = l - float(il);\n\n        // Alg. 1, line 8\n        P22_P = mix(P22_floorP(il, slope_h, texCoord, dst0, dst1),\n                    P22_floorP(il + 1, slope_h, texCoord, dst0, dst1),\n                    w);\n\n        // Eq. 13, Alg. 1, line 10\n        D_P = P22_P / (wh.z * wh.z * wh.z * wh.z);\n    }\n\n    // V-cavity masking shadowing\n    float G1wowh = min(1., 2. * wh.z * wo.z / dot(wo, wh));\n    float G1wiwh = min(1., 2. * wh.z * wi.z / dot(wi, wh));\n    float G = G1wowh * G1wiwh;\n\n    // Fresnel is set to one for simplicity here\n    // but feel free to use \"real\" Fresnel term\n    vec3 F = vec3(1., 1., 1.);\n\n    // Eq. 14, Alg. 1, line 11\n    // (wi dot wg) is cancelled by\n    // the cosine weight in the rendering equation\n    return (F * G * D_P) / (4. * wo.z);\n}\n\n//=========================================================================================================================\n//===================================================== Renderer ==========================================================\n//=========================================================================================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Light intensity\n    vec3 lightIntensity = vec3(50000.);\n    \n    // Texture position\n    vec2 uv = fragCoord/iResolution.y * 400.;\n    \n    // Vertex position\n    vec3 vertexPos = vec3(fragCoord - iResolution.xy/2., 0.);\n    \n    // Light position (varies over time)\n    float x_i = cos(iTime*0.6) * iResolution.x / 2.;\n    float y_i = cos(iTime) * iResolution.y / 2.;\n    vec3 lightPos = vec3(x_i, y_i, 100);\n    \n    // Camera position\n    vec3 cameraPos = vec3(0, 0, 100);\n    \n    // Compute normal from JFIG heightfield\n    float diff = 10.;\n    float hJFIGsm1t0 = pg2020TriangleFilter(vec2((fragCoord.x - diff)/iResolution.x, (fragCoord.y)/iResolution.y));\n    float hJFIGs1t0 = pg2020TriangleFilter(vec2((fragCoord.x + diff)/iResolution.x, (fragCoord.y)/iResolution.y));\n    float hJFIGs0tm1 = pg2020TriangleFilter(vec2((fragCoord.x)/iResolution.x, (fragCoord.y - diff)/iResolution.y));\n    float hJFIGs0t1 = pg2020TriangleFilter(vec2((fragCoord.x)/iResolution.x, (fragCoord.y + diff)/iResolution.y));\n    vec2 slope = vec2((hJFIGs1t0 - hJFIGsm1t0)/2.,\n                      (hJFIGs0t1 - hJFIGs0tm1)/2.);\n    slope *= 4.;\n    vec3 vertexNormal = vec3(-slope.x, -slope.y, 1.) / sqrt(slope.x*slope.x+slope.y*slope.y+1.);\n    \n    vec3 vertexTangent = vec3(1., 0., 0.);\n    // GramâSchmidt process\n    vertexTangent = vertexTangent - (dot(vertexNormal, vertexTangent) / dot(vertexNormal, vertexNormal)) * vertexNormal;\n    vec3 vertexBinormal = cross(vertexNormal, vertexTangent);\n    \n    // Matrix for transformation to tangent space\n    mat3 toLocal = mat3(\n        vertexTangent.x, vertexBinormal.x, vertexNormal.x,\n        vertexTangent.y, vertexBinormal.y, vertexNormal.y,\n        vertexTangent.z, vertexBinormal.z, vertexNormal.z ) ;\n    \n    // Incident direction\n    vec3 wi = normalize(toLocal * normalize(lightPos - vertexPos));\n    // Observer direction\n    vec3 wo = normalize(toLocal * normalize(cameraPos));\n    \n    vec3 radiance_glint = vec3(0.);\n    vec3 radiance_diffuse = vec3(0.);\n    vec3 radiance = vec3(0.);\n    \n    float distanceSquared = distance(vertexPos, lightPos);\n    distanceSquared *= distanceSquared;\n    vec3 Li = lightIntensity / distanceSquared;\n    \n    radiance_diffuse = f_diffuse(wo, wi) * Li;\n    \n    // Call our physically based glinty BRDF\n    radiance_glint = f_P(wo, wi, uv) * Li;\n    \n    radiance = 0.33*radiance_diffuse + vec3(0.13f,0.,0.);\n        \n    radiance += 0.33*radiance_glint;\n    if(VARNISHED){\n        radiance += 0.1 * f_specular(wo, wi) * Li;\n    }\n   \n    // Gamma\n    radiance = pow(radiance, vec3(1.0 / 2.2));\n\n    // Output to screen\n    fragColor = vec4(radiance, 1.0);\n}",
   "name": "Image",
   "description": "",
   "type": "image"
  }
 ]
}