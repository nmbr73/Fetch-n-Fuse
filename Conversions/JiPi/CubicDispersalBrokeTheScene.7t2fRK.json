{"Shader":{"ver":"0.1","info":{"id":"7t2fRK","date":"1652457268","viewed":19,"name":"Cubic Dispersal broke the scene","username":"iapafoto","description":"Inspired by  Tater [Cubic Dispersal] https:\/\/www.shadertoy.com\/view\/fldXWS\n\nThe goal of this Shader was to show that we can create a very simple Cut dispersal operator applicable to any scene with a simple function call (opCutDispersal).\n\n","likes":2,"published":3,"flags":0,"usePreview":0,"tags":["text","effect","font","slice","cubic","cut","operator","dispersal"],"hasliked":0},"renderpass":[{"inputs":[{"id":2,"src":"\/media\/a\/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":9,"src":"\/media\/a\/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","ctype":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":49,"src":"\/media\/a\/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":37,"channel":0}],"code":"\/\/ Created by Sebastien Durand - 2022\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\/\/ -----------------------------------------------\n\/\/ The goal of this Shader was to show that we can create a very simple Cut dispersal \n\/\/ operator applicable to any scene with a simple function call (opCutDispersal). (opCutVoronoi ).\n\/\/ -----------------------------------------------\n\/\/ Other cutting space: \n\/\/   [CrashTest]                       https:\/\/www.shadertoy.com\/view\/wsSGDD\n\/\/   [Voronoi broke the scene]         https:\/\/www.shadertoy.com\/view\/7tBBDw\n\/\/   [Cubic Dispersal broke the scene] https:\/\/www.shadertoy.com\/view\/7t2fRK\n\/\/ -----------------------------------------------\n\/\/ inspired by  Tater [Cubic Dispersal] https:\/\/www.shadertoy.com\/view\/fldXWS\n\n\n#define WITH_EDGE\n\/\/#define WITH_MIN_BLOCK_SIZE \/\/ introduce imprecisions\n\nfloat tOpen;\n\n\/\/ SPACE txt\n\/\/int[] gtxt = int[] (83,80,65,67,69);\n\/\/ SCENE\nint[] gtxt = int[] (83,67,69,78,69);\n\nmat2 rot(float a) {\n    return mat2(cos(a), sin(a), -sin(a), cos(a));;\n}\n\nvec3 hash33(vec3 p) {   \n\tp = vec3(dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t dot(p,vec3(113.5,271.9,124.6)));\n    return fract(sin(p)*43758.5453123);\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\/\/ --------------------------------------\n\/\/ Space Operators\n\/\/ --------------------------------------\n\n\/\/ [iq] https:\/\/www.shadertoy.com\/view\/4lyfzw\nfloat opExtrussion(vec3 p, float sdf, float h) {\n    vec2 w = vec2(sdf, abs(p.z) - h);\n  \treturn min(max(w.x,w.y),0.) + length(max(w,0.));\n}\n\n\/\/ [iapafoto] https:\/\/www.shadertoy.com\/view\/7t2fRK\nfloat opCutDispersal(inout vec3 uv, vec3 kdiv) {\n\n\n    uv.xz *= rot(.2);\n    uv.xy *= rot(.3);\n    \n#ifdef WITH_MIN_BLOCK_SIZE\n    float ITERS = 4.;\n#else\n    float ITERS = 3.;\n#endif    \n    vec3 l0 = 2.*1.9*vec3(4.8,1.4,1.2);\n    vec3 dMin = -l0*.5 - kdiv*pow(2.,ITERS-1.);\n    vec3 dMax = l0*.5 + kdiv*pow(2.,ITERS-1.);\n    \n    float MIN_SIZE = 0.105;\n    vec3 diff2 = vec3(1); \n    vec3 posTxt = uv;\n    vec3 div0;\n\n    float i = 0.;\n    \n    for(; i<ITERS;i++){\n        \/\/ divide the box into quads\n        div0 = vec3(.1) + .8*hash33(diff2);  \/\/ division sans interval\n        \n        \/\/ here is the magic!\n        \/\/ conversion of the ratio to keep constant size \n        vec3 dd = kdiv*pow(2.,ITERS-1.-i),\n            a0 = div0*l0,\n            a2 = a0 + dd,\n            l2 = l0 + 2.*dd,\n            div2 = a2\/l2; \/\/ ratio de division en tenant compte des bodures\n     \n        \/\/ On determine la division\n        vec3 divide = mix(dMin, dMax, div2);\n        \n#ifdef WITH_MIN_BLOCK_SIZE\n        \/\/Find the minimum dimension size\n        vec3 minAxis = min(abs(a0), abs(l0-a0));\n        float minSize = min(minAxis.x, min( minAxis.y, minAxis.z));\n        \n        \/\/ if minimum dimension is too small break out\n        \/\/ => this introduce imprecision in distance field\n        bool smallEnough = minSize < MIN_SIZE;\n        if (smallEnough && i + 1. > 1.) { break; }\n#endif\n\n        l0 = mix(l0-a0, a0, step(uv, divide)); \/\/ ne prendre que la partie du bon cot\u00e9\n        \n        \/\/ update the box domain\n        dMax = mix( dMax, divide, step(uv, divide ));\n        dMin = mix( divide, dMin, step(uv, divide ));\n\n        \/\/Deterministic seeding for future divisions \n        diff2 = step(uv, divide) - 10.*hash33(diff2);\n        posTxt -= dd*(.5 - step(uv, divide));\n    }\n     \n    \/\/Calculate 2d box sdf\n    vec3 center = (dMin + dMax)\/2.0;\n    vec3 dd0 = .5*kdiv*pow(2., ITERS-(i-1.));\n    float d = sdBox(uv-center, .5*(dMax - dMin) - .5*dd0);\n    uv = posTxt;\n    uv.xy *= rot(-.3);\n    uv.xz *= rot(-.2);\n    return d;\n}\n\n\n\/\/ --------------------------------------\n\/\/ Distance Functions\n\/\/ --------------------------------------\n\n\/\/ Adapted from [FabriceNeyret2] https:\/\/www.shadertoy.com\/view\/llyXRW\nfloat sdFont(vec2 p, int c) {\n    vec2 uv = (p + vec2(float(c%16), float(15-c\/16)) + .5)\/16.;\n    return max(max(abs(p.x) - .25, max(p.y - .35, -.38 - p.y)), textureLod(iChannel0, uv, 0.).w - 127.\/255.);\n}\n\nfloat sdMessage2D(vec2 p, int[5] txt, float scale) { \n    p.y += .1;\n    p \/= scale;\n \tfloat d = 999., w = .45; \/\/ letter width  \n    p.x += w*float(txt.length()-1)*.5; \/\/ center text arround 0\n    for (int id = 0; id<5; id++){\n    \td = min(d, sdFont(p, txt[id]));   \n    \tp.x -= w; \n    }\n    return scale*d;\n}\n\nfloat sdMessage3D(in vec3 p, int[5] txt, float scale, float h) { \n    return opExtrussion(p, sdMessage2D(p.xy, txt, scale), h);\n}\n\n\/\/ --------------------------------------\n\/\/ Distance to scene\n\/\/ --------------------------------------\nfloat map(vec3 p) {\n    float dcut = opCutDispersal(p, .7*vec3(.8,.4,.8)*tOpen), \/\/opSuperCut(p),\n          dScn = sdMessage3D(p, gtxt,4.,1.);\n    return max(dScn, dcut);\n}\n\n\/\/ --------------------------------------\n\/\/ Shading Tools\n\/\/ --------------------------------------\n\/\/ Find initial space position\nvec4 MCol(vec3 p) {\n    float dcut = opCutDispersal(p, .7*vec3(.8,.4,.8)*tOpen),\n          dScn = sdMessage3D(p, gtxt,4.,1.);\n    return vec4(p, dScn >= dcut ? 1. : 2.);\n}\n\n\/\/ Shane - normal + edge\nvec3 normal(vec3 p, vec3 rd, inout float edge, float t) { \n    float eps = 4.5\/mix(450., min(850., iResolution.y), .35),\n          d = map(p);\n#ifdef WITH_EDGE\n    vec3 e = vec3(eps, 0, 0),\n         da = vec3(-2.*d);\n    for(int i = min(iFrame,0); i<3; i++) {\n        for( int j=min(iFrame,0); j<2; j++ )\n            da[i] += map(p + e*float(1-2*j));\n        e = e.zxy;\n    }\n    da = abs(da);\n    edge = da.x + da.y + da.z;\n    edge = smoothstep(0., 1., sqrt(edge\/e.x*2.));\n#endif\n    vec3 n = vec3(0);\n    for( int i=min(iFrame, 0); i<4; i++) {\n        vec3 e = .57735*(2.*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1)) - 1.);\n        n += e*map(p + .001*e);\n    }\n    return normalize(n - max(.0, dot(n,rd))*rd);\n}\n\n\/\/ Box:  https:\/\/www.shadertoy.com\/view\/ld23DV\nbool iBox( vec3 ro, vec3 rd, vec3 sz, inout float tN, inout float tF) {\n    vec3 m = sign(rd)\/max(abs(rd), 1e-8),\n         n = m*ro,\n         k = abs(m)*sz,\n         t1 = -n - k,\n         t2 = -n + k;\n\ttN = max( max( t1.x, t1.y ), t1.z );\n\ttF = min( min( t2.x, t2.y ), t2.z );\n    return !(tN > tF || tF <= 0.0);\n}\n\n\/\/----------------------------------\n\/\/ Texture 3D (Shane)\n\/\/----------------------------------\n\n\/\/ Tri-Planar blending function. Based on an old Nvidia writeup:\n\/\/ GPU Gems 3 - Ryan Geiss: http:\/\/http.developer.nvidia.com\/GPUGems3\/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){  \n    n = max(n*n, .001);\n    n \/= n.x + n.y + n.z;  \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n\n\/\/ Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n\/\/ make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){   \n    const vec2 e = vec2(.001, 0);\n    \/\/ Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    vec3 g = vec3(.299, .587, .114)*m; \/\/ Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(.299, .587, .114)) )\/e.x; \n    g -= n*dot(n, g);\n    return normalize( n + g*bf ); \/\/ Bumped normal. \"bf\" - bump factor.\n}\n\n\n\/\/----------------------------------\n\/\/ Shading\n\/\/----------------------------------\nvec3 render(vec3 ro, vec3 rd, float res, vec3 pos, vec3 n, vec3 cobj, vec3 light, vec3 cback, float spec) {\n    float \n         amb = clamp(.5+.5*n.y, .0, 1.),\n         dif = clamp(dot( n, light ), 0., 1.),\n         pp = clamp(dot(reflect(-light,n), -rd),0.,1.),\n         fre = (.7+.3*dif)*pow( clamp(1.+dot(n,rd),0.,1.), 2.);\n    vec3 brdf = .5*(amb)+ 1.*dif*vec3(1.,.9,.7),\n         sp = 3.*pow(pp,spec)*vec3(1, .6, .2),\n\t     col = cobj*(brdf + sp) + fre*(.5*cobj+.5);\n    return mix(col, vec3(.02,.2,.2),smoothstep(6.,20.,res));\n}\n\nmat3 setCamera(vec3 ro, vec3 ta, float r ) {\n\tvec3 w = normalize(ta-ro),\n         p = vec3(sin(r), cos(r),.0),\n         u = normalize( cross(w,p) ),\n         v =          ( cross(u,w) );\n    return mat3( u, v, w );\n}\n\n\n\/\/ --------------------------------------\n\/\/ Main\n\/\/ --------------------------------------\nvoid mainImage(out vec4 fragColor, vec2 fragCoord ) {\n\n    vec2 r = iResolution.xy, \n         m = iMouse.xy \/ r,\n\t     q = fragCoord.xy\/r.xy;\n \n    tOpen = .4*smoothstep(.6,0.,cos(.3*iTime));\n\n    float a = mix(.3,3.*cos(.4*3.*iTime),.5+.5*cos(.2*iTime))+3.14*m.x;\n    \n    \/\/ camera\t\n    vec3 ta = vec3(0),\n         ro = ta + 2.4*vec3(4.5*cos(a), 3.*cos(.4*iTime) + 4.*m.y, 4.5*sin(a));\n    mat3 ca = setCamera( ro, ta, .1*cos(.123*iTime) );\n  \n    \/\/ ray direction\n    vec3 rd = ca * normalize( vec3((2.*fragCoord-r.xy)\/r.y, 2.5));\n\n    float h = .1, t, tN = 0., tF = 20.;\n    \n    \/\/ Background color\n\tvec3 c = .09*vec3(hash33(q.xyx).x + 1.);\n\n    if (iBox(ro, rd, vec3(4.8,1.4,1.2)*(1.+vec3(1.,2.,3.)*tOpen), tN, tF)) {\t\t\n        t = tN;\/\/ - .02*hash33(q.xyx).x;\n\t\/\/ Ray marching\n        for(int i=min(0,iFrame);i<200;i++) { \n            if (h<1e-3 || t>tF) break;\n            t += h = map(ro + rd*t);\n        }\n    \n        \/\/ light pos\n        vec3 lp =  ro + 3.*vec3(.25, 2, -.1);\n\n        \/\/ Calculate color on point\n        if (t<tF) {\n            vec3 pos = ro + t * rd;\n            float edge = 0.;\n            vec4 txt = MCol(pos); \t\n            vec3 n = normal(pos, rd, edge, t),     \n                 cobj = txt.w<1.5 ? vec3(.7) : 1.5*vec3(.8,.4,.0);\n            if (txt.w<1.5) {\n                n = doBumpMap(iChannel1, txt.xyz*2., n, .01);\n            } else {\n                n = doBumpMap(iChannel2, txt.xyz*2., n, .02);\n            }\n            \/\/ keep in visible side\n            n = normalize(n - max(.0,dot(n,rd))*rd);\n            \/\/ Shading\n            c = render(ro, rd, t, pos, n, cobj, normalize(lp-pos), c, txt.w<1.5 ? 99. : 16.);\n    #ifdef WITH_EDGE\n            c *= 1. - edge*.8;\n    #endif\n        } \n    } \/\/else{\n    \/\/c *= 2.; \n    \/\/}\n    \n    \n    \/\/ post prod\n    c = pow(c, vec3(.75));\n    c = vec3(c* pow(16.*q.x*q.y*(1.-q.x)*(1.-q.y),.7f));\n\tfragColor = vec4(c, t);\t\n}","name":"Image","description":"","type":"image"}]}}