{
 "ver": "0.1",
 "info": {
  "id": "Nl3fW8",
  "date": "0",
  "viewed": 0,
  "name": "sad robot JiPi",
  "description": "...walks forever.\nan attempt at some procedural character animation.\nclick in window to move head.",
  "likes": 0,
  "published": "Private",
  "usePreview": 0,
  "tags": [
   "distancefield",
   "animation"
  ],
  "hasliked": 0,
  "parentid": "XsXGDH",
  "parentname": "sad robot"
 },
 "renderpass": [
  {
   "inputs": [],
   "outputs": [],
   "code": "// sad robot\n// @simesgreen\n\nconst int maxSteps = 64;\nconst float hitThreshold = 0.001;\nconst int shadowSteps = 64;\nconst float PI = 3.14159;\n\n// CSG operations\nfloat _union(float a, float b)\n{\n    return min(a, b);\n}\n\nfloat intersect(float a, float b)\n{\n    return max(a, b);\n}\n\nfloat difference(float a, float b)\n{\n    return max(a, -b);\n}\n\n// transforms\nvec3 rotateX(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    return vec3(p.x, ca*p.y - sa*p.z, sa*p.y + ca*p.z);\n}\n\nvec3 rotateY(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    return vec3(ca*p.x + sa*p.z, p.y, -sa*p.x + ca*p.z);\n}\n\nvec3 rotateZ(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    return vec3(ca*p.x - sa*p.y, sa*p.x + ca*p.y, p.z);\n}\n\nmat3 rotationMat(vec3 v, float angle)\n{\n\tfloat c = cos(angle);\n\tfloat s = sin(angle);\n\t\n\treturn mat3(c + (1.0 - c) * v.x * v.x, (1.0 - c) * v.x * v.y - s * v.z, (1.0 - c) * v.x * v.z + s * v.y,\n\t\t(1.0 - c) * v.x * v.y + s * v.z, c + (1.0 - c) * v.y * v.y, (1.0 - c) * v.y * v.z - s * v.x,\n\t\t(1.0 - c) * v.x * v.z - s * v.y, (1.0 - c) * v.y * v.z + s * v.x, c + (1.0 - c) * v.z * v.z\n\t\t);\n}\n\n// based on gluLookAt\nmat4 lookAt(vec3 eye, vec3 center, vec3 up)\n{\n\tvec3 z = normalize(eye - center);\n\tvec3 y = up;\n\tvec3 x = cross(y, z);\n\ty = cross(z, x);\n\tx = normalize(x);\n\ty = normalize(y);\n\tmat4 rm = mat4(x.x, y.x, z.x, 0.0,\t// 1st column\n\t\t   \t\t   x.y, y.y, z.y, 0.0,\n\t\t           x.z, y.z, z.z, 0.0,\n\t\t\t\t   0.0, 0.0, 0.0, 1.0);\n\tmat4 tm = mat4(1.0);\n\ttm[3] = vec4(-eye, 1.0);\n\treturn rm * tm;\n\t\t   \n}\n\n// primitive functions\n// these all return the distance to the surface from a given point\n\n  // n must be normalized\nfloat sdPlane( vec3 p, vec4 n )\n{\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3  di = abs(p) - b;\n  float mc = max(di.x, max(di.y, di.z));\n  return min(mc,length(max(di,0.0)));\n}\n\nfloat sphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\n// 1d noise\nfloat noise( float p )\n{\n    float i = floor( p );\n    float f = fract( p );\n\tfloat u = f*f*(3.0-2.0*f);\n    return mix( hash( i ), hash( i + 1.0 ), u);\n}\n\nvec3 target = vec3(0.0);\nmat4 headMat;\n\n// distance to scene\nfloat scene(vec3 p)\n{\t\t\n\tfloat t = iTime*1.5;\n\t\n    float d;\t\n    d = sdPlane(p, vec4(0, 1, 0, 1)); \n\n\tp.y -= cos(t*2.0)*0.1;\t// bounce\n\t//p.x += sin(t)*0.1;\n\t\n\t// head\n\tvec3 hp = p - vec3(0.0, 4.0, 0.0);\n\t// rotate head\n\thp = (vec4(hp, 1.0)*headMat).xyz;\n\n\td = _union(d, sdBox(hp, vec3(1.5, 1.0, 1.0)));\n\n\t// eyes\n\tvec3 eyeScale = vec3(1.0);\n\t//eyeScale.y *= 1.0 - pow(noise(t*10.0), 10.0);\t// blink\n\teyeScale.y *= 1.0 - smoothstep(0.8, 1.0, noise(t*5.0));\t// blink\n\td = difference(d, sphere((hp - vec3(0.6, 0.2, 1.0))/eyeScale, 0.15));\n\td = difference(d, sphere((hp - vec3(-0.6, 0.2, 1.0))/eyeScale, 0.15));\n\t\n\t// mouth\n\tif (iMouse.z > 0.0) {\n\t\t// surprised mouth\n\t\td = difference(d, sdBox(hp - vec3(0.0, -0.4, 1.0), vec3(0.2, 0.1, 0.1)));\t\t\n\t} else {\n\t\td = difference(d, sdBox(hp - vec3(0.0, -0.4, 1.0), vec3(0.25, 0.05, 0.1)));\t\t\t\t\n\t}\n\n\t// body\n\tvec3 bp = p;\n\tbp = rotateY(bp, -target.x*0.05);\n\td = _union(d, sdBox(bp - vec3(0.0, 2.0, 0.0), vec3(0.8, 1.0, 0.5)));\n\n\t// arms\n\t//const float arz = -0.1;\n\tfloat arz = -noise(t*0.3);\n\tvec3 a1 = rotateZ(rotateX(bp- vec3(1.2, 2.0+0.7, 0.0), sin(t)*0.75), arz) + vec3(0, 1.0, 0);\n\tvec3 a2 = rotateZ(rotateX(bp- vec3(-1.2, 2.0+0.7, 0.0), sin(t+PI)*0.75), -arz) + vec3(0, 1.0, 0);\n\td = _union(d, sdBox(a1, vec3(0.25, 1.0, 0.25)));\n\td = _union(d, sdBox(a2, vec3(0.25, 1.0, 0.25)));\n\n\t// legs\n\tvec3 l1 = rotateX(p - vec3(0.5, 1.2, 0.0), -sin(t)*0.5) + vec3(0.0, 1.2, 0.0);\n\tvec3 l2 = rotateX(p - vec3(-0.5, 1.2, 0.0), -sin(t+PI)*0.5) + vec3(0.0, 1.2, 0.0);\n\td = _union(d, sdBox(l1, vec3(0.3, 1.0, 0.5)));\n\td = _union(d, sdBox(l2, vec3(0.3, 1.0, 0.5)));\n\t\n    return d;\n}\n\n// calculate scene normal\nvec3 sceneNormal(in vec3 pos )\n{\n    float eps = 0.0001;\n    vec3 n;\n    float d = scene(pos);\n    n.x = scene( vec3(pos.x+eps, pos.y, pos.z) ) - d;\n    n.y = scene( vec3(pos.x, pos.y+eps, pos.z) ) - d;\n    n.z = scene( vec3(pos.x, pos.y, pos.z+eps) ) - d;\n    return normalize(n);\n}\n\n// ambient occlusion approximation\nfloat ambientOcclusion(vec3 p, vec3 n)\n{\n    const int steps = 4;\n    const float delta = 0.5;\n\n    float a = 0.0;\n    float weight = 1.0;\n    for(int i=1; i<=steps; i++) {\n        float d = (float(i) / float(steps)) * delta; \n        a += weight*(d - scene(p + n*d));\n        weight *= 0.5;\n    }\n    return clamp(1.0 - a, 0.0, 1.0);\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat softShadow(vec3 ro, vec3 rd, float mint, float maxt, float k)\n{\n    float dt = (maxt - mint) / float(shadowSteps);\n    float t = mint;\n\tt += hash(ro.z*574854.0 + ro.y*517.0 + ro.x)*0.1;\n    float res = 1.0;\n    for( int i=0; i<shadowSteps; i++ )\n    {\n        float h = scene(ro + rd*t);\n\t\tif (h < hitThreshold) return 0.0;\t// hit\n        res = min(res, k*h/t);\n        //t += h;\n\t\tt += dt;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\n\n// trace ray using sphere tracing\nvec3 trace(vec3 ro, vec3 rd, out bool hit)\n{\n    hit = false;\n    vec3 pos = ro;\n    vec3 hitPos = ro;\n\n    for(int i=0; i<maxSteps; i++)\n    {\n\t\tif (!hit) {\n\t\t\tfloat d = scene(pos);\n\t\t\tif (abs(d) < hitThreshold) {\n\t\t\t\thit = true;\n\t\t\t\thitPos = pos;\n\t\t\t}\n\t\t\tpos += d*rd;\n\t\t}\n    }\n    return pos;\n}\n\n// lighting\nvec3 shade(vec3 pos, vec3 n, vec3 eyePos)\n{\n\t//vec3 color = vec3(0.5);\n\t//const vec3 lightDir = vec3(0.577, 0.577, 0.577);\n    //vec3 v = normalize(eyePos - pos);\n    //vec3 h = normalize(v + lightDir);\n    //float diff = dot(n, lightDir);\n    //diff = max(0.0, diff);\n    //diff = 0.5+0.5*diff;\n\t\n    float ao = ambientOcclusion(pos, n);\n\t//vec3 c = diff*ao*color;\n\t\n\t// skylight\n\tvec3 sky = mix(vec3(0.3, 0.2, 0.0), vec3(0.6, 0.8, 1.0), n.y*0.5+0.5);\n\tvec3 c = sky*0.5*ao;\n\t\n\t// point light\n\tconst vec3 lightPos = vec3(5.0, 5.0, 5.0);\n\tconst vec3 lightColor = vec3(0.5, 0.5, 0.1);\n\t\n\tvec3 l = lightPos - pos;\n\tfloat dist = length(l);\n\tl /= dist;\n\tfloat diff = max(0.0, dot(n, l));\n\t//diff *= 50.0 / (dist*dist);\t// attenutation\n\t\n#if 1\n\tfloat maxt = dist;\n    float shadow = softShadow( pos, l, 0.1, maxt, 5.0 );\n\tdiff *= shadow;\n#endif\n\t\n\tc += diff*lightColor;\n\t\n//\treturn vec3(ao);\n//\treturn n*0.5+0.5;\n\treturn c;\n}\n\nvec3 background(vec3 rd)\n{\n\treturn mix(vec3(0.3, 0.2, 0.0), vec3(0.6, 0.8, 1.0), rd.y*0.5+0.5);\n    //return vec3(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixel = (fragCoord.xy / iResolution.xy)*2.0-1.0;\n\n    // compute ray origin and direction\n    float asp = iResolution.x / iResolution.y;\n    vec3 rd = normalize(vec3(asp*pixel.x, pixel.y, -2.0));\n    vec3 ro = vec3(0.0, 2.0, 8.0);\n\n\tvec2 mouse = iMouse.xy / iResolution.xy;\n\tfloat roty = 0.0; // sin(iTime*0.2);\n\tfloat rotx = 0.0;\n\t/*\n\tif (iMouse.z > 0.0) {\n\t\trotx = -(mouse.y-0.5)*3.0;\n\t\troty = -(mouse.x-0.5)*6.0;\n\t}\n\t*/\n\t\n    rd = rotateX(rd, rotx);\n    ro = rotateX(ro, rotx);\n\t\t\n    rd = rotateY(rd, roty);\n    ro = rotateY(ro, roty);\n\n\tif (iMouse.z > 0.0) {\n\t\t// look at mouse\n\t\ttarget = vec3(mouse*10.0-5.0, -10.0);\n\t\ttarget.x *= asp;\n\t} else {\n\t\ttarget = vec3(noise(iTime*0.5)*10.0-5.0, noise(iTime*0.5+250673.0)*8.0-4.0, -10.0);\n\t}\n\theadMat = lookAt(vec3(0.0, 0.0, 0.0), target, vec3(0.0, 1.0, 0.0));\t\n\t\t\n    // trace ray\n    bool hit;\n    vec3 pos = trace(ro, rd, hit);\n\n    vec3 rgb;\n    if(hit) {\n        // calc normal\n        vec3 n = sceneNormal(pos);\n        // shade\n        rgb = shade(pos, n, ro);\n\n     } else {\n        rgb = background(rd);\n     }\n\t\n    fragColor=vec4(rgb, 1.0);\n}",
   "name": "Image",
   "description": "",
   "type": "image"
  }
 ]
}