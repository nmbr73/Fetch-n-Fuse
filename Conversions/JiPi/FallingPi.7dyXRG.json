{
 "ver": "0.1",
 "info": {
  "id": "7dyXRG",
  "date": "0",
  "viewed": 0,
  "name": "Fork Falling Pi JiPi 332",
  "description": "Falling sand game using shaders. Github repo: https://github.com/Fryer/falling-pixels\nClick and drag while holding any of the following keys to add:\n'No key': Sand -- 'X': Erase -- 'W': Water -- 'L': Lava -- 'B': Bedrock",
  "likes": 0,
  "published": "Private",
  "usePreview": 0,
  "tags": [
   "game",
   "physics"
  ],
  "hasliked": 0,
  "parentid": "3sSyRz",
  "parentname": "Falling Pixels"
 },
 "renderpass": [
  {
   "inputs": [
    {
     "id": "4sf3Rn",
     "filepath": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png",
     "type": "texture",
     "channel": 1,
     "sampler": {
      "filter": "mipmap",
      "wrap": "repeat",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    },
    {
     "id": "XsXGR8",
     "filepath": "/media/previz/buffer01.png",
     "type": "buffer",
     "channel": 0,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    }
   ],
   "outputs": [
    {
     "id": "4dfGRr",
     "channel": 0
    }
   ],
   "code": "// = Falling Pixels =\n// © 2020 Jacob Lindberg\n//-----------------------\n// Main/image buffer:\n// - Performs shading of the state from Buffer B.\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 pos = ivec2(fragCoord);\n    //vec4 pixel = texelFetch(iChannel0, pos, 0);\n    vec4 pixel = texture(iChannel0, (vec2(pos)+0.5)/iResolution.xy);\n    \n    \n    if (pixel.r < 0.5) {\n        // Empty.\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        return;\n    }\n    if (pixel.a > 0.5) {\n        // Lava.\n        vec2 noiseCoordA = fragCoord * vec2(0.2, 1.0) / 64.0;\n        noiseCoordA.x += float(iFrame) * 0.001;\n        vec2 noiseCoordB = fragCoord * vec2(0.2, 1.0) / 64.0;\n        noiseCoordB -= vec2(float(iFrame) * 0.001, 0.5);\n        float noiseA = texture(iChannel1, noiseCoordA).x;\n        float noiseB = texture(iChannel1, noiseCoordB).x;\n        float noise = noiseA * noiseB;\n        fragColor = vec4(0.8, 0.4, 0.0, 1.0);\n        fragColor += vec4(0.1, 0.4, 0.2, 0.0) * noise;\n        return;\n    }\n    if (pixel.b > 0.5) {\n        // Water.\n        ivec2 noiseCoordA = pos + ivec2(iFrame * 23, 0);\n        ivec2 noiseCoordB = pos + ivec2(0, iFrame * 14 + 1);\n        //float noiseA = texelFetch(iChannel1, noiseCoordA % 64, 0).r;\n        float noiseA = texture(iChannel1, (vec2(noiseCoordA % 64)+0.5)/iResolution.xy).x;\n        \n        //float noiseB = texelFetch(iChannel1, noiseCoordB % 64, 0).r;\n        float noiseB = texture(iChannel1, (vec2(noiseCoordB % 64)+0.5)/iResolution.xy).x;\n        \n        float noise = noiseA * noiseB;\n        fragColor = vec4(0.2, 0.6, 1.0, 1.0);\n        if (noise > 0.9) {\n            // Sparkle!\n            fragColor += vec4(0.2, 0.2, 0.0, 0.0) * noise;\n        }\n        return;\n    }\n    if (pixel.y > 0.5) {\n        // Bedrock.\n        vec2 noiseCoord = fragCoord * vec2(0.25, 1.0) / 64.0;\n        float noise = texture(iChannel1, noiseCoord).x;\n        noise = 0.25 + noise * 0.1 + pixel.x * 0.2;\n        fragColor = vec4(vec3(1) * noise, 1.0);\n        return;\n    }\n    // Sand.\n    fragColor = vec4(vec3(1.0, 0.8, 0.4) * pixel.x, 1.0);\n}",
   "name": "Image",
   "description": "",
   "type": "image"
  },
  {
   "inputs": [
    {
     "id": "4sf3Rn",
     "filepath": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png",
     "type": "texture",
     "channel": 1,
     "sampler": {
      "filter": "mipmap",
      "wrap": "repeat",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    },
    {
     "id": "XsXGR8",
     "filepath": "/media/previz/buffer01.png",
     "type": "buffer",
     "channel": 0,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    }
   ],
   "outputs": [
    {
     "id": "4dXGR8",
     "channel": 0
    }
   ],
   "code": "// = Falling Pixels =\n// © 2020 Jacob Lindberg\n//-----------------------\n// Buffer A:\n// - Determines which particle to receive from neighboring pixels.\n// - All movement and most interaction rules are defined here.\n\n#ifdef ORG\nconst ivec2 A = ivec2(0, 1); // Above.\nconst ivec2 B = ivec2(0, -1); // Below.\nconst ivec2 L = ivec2(-1, 0); // Left.\nconst ivec2 R = ivec2(1, 0); // Right.\nconst ivec2 AL = A + L; // Above Left.\nconst ivec2 AR = A + R; // Above Right.\nconst ivec2 BL = B + L; // Below Left.\nconst ivec2 BR = B + R; // Below Right.\n#else\n#define A  ivec2(0, 1) // Above.\n#define B  ivec2(0, -1) // Below.\n#define L  ivec2(-1, 0) // Left.\n#define R  ivec2(1, 0) // Right.\n#define AL  (A + L) // Above Left.\n#define AR  (A + R) // Above Right.\n#define BL  (B + L) // Below Left.\n#define BR  (B + R) // Below Right.\n#endif\n\nvec4 pixel(ivec2 pos) {\n    if (pos.x < 0 || pos.y < 0 || pos.x >= int(iResolution.x) || pos.y >= int(iResolution.y)) {\n        return vec4(0);\n    }\n    //return texelFetch(iChannel0, pos, 0);\n    return texture(iChannel0, (vec2(pos)+0.5)/iResolution.xy);\n}\n\nfloat noise(ivec2 pos) {\n    // 2531 = ClosestPrime(TextureArea * GoldenRatio).\n    int n = iFrame % 4096 * 2531;\n    ivec2 noiseCoord = pos + ivec2(n, n / 64);\n    //return texelFetch(iChannel1, noiseCoord % 64, 0).r;\n    return texture(iChannel1, (vec2((noiseCoord % 64)) + 0.5)/iResolution.xy).x;\n}\n\nivec2 bubble(ivec2 pos, vec4 self) {\n    if (self.g > 0.5 || self.a > 0.5) {\n        // Self is bedrock or lava, can't bubble.\n        return pos;\n    }\n    if (iFrame % 2 == 0) {\n        // Bubble at half speed.\n        return pos;\n    }\n    if (self.b > 0.5) {\n        // Self is water.\n        vec4 above = pixel(pos + A);\n        if (above.r < 0.5 || above.g > 0.5 || above.b > 0.5) {\n            // No sand above, can't bubble.\n            return pos;\n        }\n        if (pos.y > 0 && pixel(pos + B).r < 0.5) {\n            // Might fall, don't bubble.\n            return pos;\n        }\n        if (pixel(pos + L).r < 0.5 || pixel(pos + R).r < 0.5) {\n            // Sand might roll, don't bubble.\n            return pos;\n        }\n        // Bubble up.\n        return pos + A;\n    }\n    // Self is sand.\n    vec4 below = pixel(pos + B);\n    if (below.b < 0.5 || below.a > 0.5) {\n        // No water below, can't bubble.\n        return pos;\n    }\n    if (pos.y > 0 && (pixel(pos + BL).r < 0.5 || pixel(pos + BR).r < 0.5)) {\n        // Might roll, don't bubble.\n        return pos;\n    }\n    if (pos.y > 1 && pixel(pos + B + B).r < 0.5) {\n        // Water might fall, don't bubble.\n        return pos;\n    }\n    // Bubble down.\n    return pos + B;\n}\n\nfloat flowRight(ivec2 pos) {\n    if (pixel(pos + L).b > 0.5 && (pos.y == 0 || pixel(pos + BL).r > 0.5)) {\n        // Left flowing.\n        if (pixel(pos + L + L).r > 0.5) {\n            // Can't flow left, flow right.\n            return noise(pos + L) + 1.0;\n        }\n        // Flow randomly.\n        return noise(pos + L);\n    }\n    return 0.0;\n}\n\nfloat flowLeft(ivec2 pos) {\n    if (pixel(pos + R).b > 0.5 && (pos.y == 0 || pixel(pos + BR).r > 0.5)) {\n        // Right flowing.\n        if (pixel(pos + R + R).r > 0.5) {\n            // Can't flow right, flow left.\n            return noise(pos + R) - 1.0;\n        }\n        // Flow randomly.\n        return noise(pos + R);\n    }\n    return 1.0;\n}\n\nivec2 flow(ivec2 pos) {\n    float rightFlow = flowRight(pos);\n    float leftFlow = flowLeft(pos);\n    if (rightFlow > 0.5 && leftFlow < 0.5) {\n        // Flow contested.\n        if (leftFlow + rightFlow > 1.0) {\n            // Left wins, flow right.\n            return pos + L;\n        }\n        // Right wins, flow left.\n        return pos + R;\n    }\n    if (rightFlow > 0.5) {\n        // Flow right.\n        return pos + L;\n    }\n    if (leftFlow < 0.5) {\n        // Flow left.\n        return pos + R;\n    }\n    return pos;\n}\n\nbool rollRight(ivec2 pos) {\n    vec4 aboveLeft = pixel(pos + AL);\n    if (aboveLeft.g > 0.5 || aboveLeft.b > 0.5) {\n        // Above left is not sand, can't roll.\n        return false;\n    }\n    if (pixel(pos + L).r > 0.5 && aboveLeft.r > 0.5) {\n        // Above left rolling.\n        if (pixel(pos + AL + L).r > 0.5 || pixel(pos + L + L).r > 0.5) {\n            // Can't roll left, roll right.\n            return true;\n        }\n        if (noise(pos + AL) > 0.5) {\n            // Roll right.\n            return true;\n        }\n    }\n    return false;\n}\n\nbool rollLeft(ivec2 pos) {\n    vec4 aboveRight = pixel(pos + AR);\n    if (aboveRight.g > 0.5 || aboveRight.b > 0.5) {\n        // Above right is not sand, can't roll.\n        return false;\n    }\n    if (pixel(pos + R).r > 0.5 && aboveRight.r > 0.5) {\n        // Above right rolling.\n        if (pixel(pos + AR + R).r > 0.5 || pixel(pos + R + R).r > 0.5) {\n            // Can't roll right, roll left.\n            return true;\n        }\n        if (noise(pos + AR) < 0.5) {\n            // Roll left.\n            return true;\n        }\n    }\n    return false;\n}\n\nivec2 roll(ivec2 pos) {\n    bool canRollRight = rollRight(pos);\n    bool canRollLeft = rollLeft(pos);\n    if (canRollRight && canRollLeft) {\n        // Roll contested.\n        if (noise(pos + AL) + noise(pos + AR) > 1.0) {\n            // Left wins, roll right.\n            return pos + AL;\n        }\n        // Right wins, roll left.\n        return pos + AR;\n    }\n    if (canRollRight) {\n        // Roll right.\n        return pos + AL;\n    }\n    if (canRollLeft) {\n        // Roll left.\n        return pos + AR;\n    }\n    return pos;\n}\n\nivec2 receive(ivec2 pos) {\n    vec4 self = pixel(pos);\n    if (self.r > 0.5) {\n        // Self not empty.\n        ivec2 bubblePos = bubble(pos, self);\n        if (bubblePos != pos) {\n            // Receive bubbling.\n            return bubblePos;\n        }\n        // Block.\n        return pos;\n    }\n    vec4 above = pixel(pos + A);\n    if (above.r > 0.5 && above.g < 0.5) {\n        if (pixel(pos + AL).r > 0.5 && pixel(pos + AR).r > 0.5) {\n            // Self contested from roll, let above fall.\n            return pos + A;\n        }\n        if (pixel(pos + L).b > 0.5 && pixel(pos + R).b > 0.5) {\n            // Self contested from flow, let above fall.\n            return pos + A;\n        }\n    }\n    ivec2 rollPos = roll(pos);\n    if (rollPos != pos) {\n        // Receive rolling.\n        return rollPos;\n    }\n    ivec2 flowPos = flow(pos);\n    if (flowPos != pos) {\n        // Receive flowing.\n        return flowPos;\n    }\n    if (above.r > 0.5 && above.g < 0.5) {\n        // Receive falling.\n        return pos + A;\n    }\n    return pos;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 pos = ivec2(fragCoord);\n    ivec2 receivePos = receive(pos);\n    ivec2 offset = receivePos - pos;\n    fragColor = vec4(float(offset.x + 1) / 2.0, float(offset.y + 1) / 2.0, 0.0, 0.0);\n}",
   "name": "Buffer A",
   "description": "",
   "type": "buffer"
  },
  {
   "inputs": [
    {
     "id": "4sf3Rn",
     "filepath": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png",
     "type": "texture",
     "channel": 1,
     "sampler": {
      "filter": "mipmap",
      "wrap": "repeat",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    },
    {
     "id": "4dXGRr",
     "filepath": "/presets/tex00.jpg",
     "type": "keyboard",
     "channel": 2,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    },
    {
     "id": "4dXGR8",
     "filepath": "/media/previz/buffer00.png",
     "type": "buffer",
     "channel": 3,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    },
    {
     "id": "XsXGR8",
     "filepath": "/media/previz/buffer01.png",
     "type": "buffer",
     "channel": 0,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    }
   ],
   "outputs": [
    {
     "id": "XsXGR8",
     "channel": 0
    }
   ],
   "code": "vec4 texelFetchC( sampler2D Channel, ivec2 pos, int xxx)\n{\n    \n    if ( (pos.x) > 0 && (pos.x) < int(iResolution.x) && (pos.y) > 0 && (pos.y) < int(iResolution.y) )\n    {\n        return texture( Channel, (vec2(pos)+10.)/iResolution.xy );\n    }\n\telse\n\t\treturn vec4(0);\n}\n\n\n\n// = Falling Pixels =\n// © 2020 Jacob Lindberg\n//-----------------------\n// Buffer B:\n// - Holds particle state and moves particles.\n// - Destructive particle interaction happens here after movement.\n// - Drives user interaction.\n\nconst ivec2 A = ivec2(0, 1); // Above.\nconst ivec2 B = ivec2(0, -1); // Below.\nconst ivec2 L = ivec2(-1, 0); // Left.\nconst ivec2 R = ivec2(1, 0); // Right.\nconst ivec2 BL = B + L; // Below Left.\nconst ivec2 BR = B + R; // Below Right.\n\nvec4 pixel(ivec2 pos) {\n    if (pos.x < 0 || pos.y < 0 || pos.x >= int(iResolution.x) || pos.y >= int(iResolution.y)) {\n        return vec4(0);\n    }\n    //return texelFetch(iChannel0, pos, 0);\n    return texture(iChannel0, (vec2(pos)+0.5)/iResolution.xy);\n}\n\nfloat noise(ivec2 pos) {\n    // 2531 = ClosestPrime(TextureArea * GoldenRatio).\n    int n = iFrame % 4096 * 2531;\n    ivec2 noiseCoord = pos + ivec2(n, n / 64);\n    //return texelFetch(iChannel1, noiseCoord % 64, 0).r;\n    return texture(iChannel1, (vec2((noiseCoord*16 ))+0.)/iResolution.xy).x;\n}\n\nfloat noiseB(ivec2 pos) {\n    int n = (iFrame + 2048) % 4096 * 2531;\n    ivec2 noiseCoord = pos + ivec2(n, n / 64);\n    //return texelFetch(iChannel1, noiseCoord % 64, 0).r;\n    return texture(iChannel1, (vec2((noiseCoord *16)) + 0.5)/iResolution.xy).x;\n}\n\nivec2 receive(ivec2 pos) {\n    if (pos.y < 0 || pos.y >= int(iResolution.y)) {\n        // Stop at bottom and top.\n        return pos;\n    }\n    if (pos.x < 0) {\n        // Remove at left.\n        return pos + R;\n    }\n    if (pos.x >= int(iResolution.x)) {\n        // Remove at right.\n        return pos + L;\n    }\n    //vec4 offsetColor = texelFetch(iChannel3, pos, 0);\n    vec4 offsetColor = texture(iChannel3, (vec2(pos)+0.5)/iResolution.xy);\n    \n    ivec2 offset = ivec2(int(offsetColor.r * 2.0 + 0.5) - 1, int(offsetColor.g * 2.0 + 0.5) - 1);\n    return pos + offset;\n}\n\nvec4 move(ivec2 pos, vec4 self) {\n    if (receive(pos + B) == pos) { return vec4(0); }\n    if (receive(pos + BL) == pos) { return vec4(0); }\n    if (receive(pos + BR) == pos) { return vec4(0); }\n    if (receive(pos + L) == pos) { return vec4(0); }\n    if (receive(pos + R) == pos) { return vec4(0); }\n    if (receive(pos + A) == pos) { return vec4(0); }\n    return self;\n}\n\nvec4 boil(ivec2 pos, vec4 self) {\n    if (noise(pos) > 0.1) {\n        // Boil slow.\n        return self;\n    }\n    if (pixel(receive(pos + A)).a > 0.5) { return vec4(0); }\n    if (pixel(receive(pos + B)).a > 0.5) { return vec4(0); }\n    if (pixel(receive(pos + L)).a > 0.5) { return vec4(0); }\n    if (pixel(receive(pos + R)).a > 0.5) { return vec4(0); }\n    return self;\n}\n\nvec4 melt(ivec2 pos, vec4 self) {\n    if (noise(pos) > 0.06) {\n        // Melt slow.\n        return self;\n    }\n    if (pixel(receive(pos + B)).a > 0.5) {\n        // Over lava, melt.\n        if (noise(pos) > 0.04) {\n            // Convert some sand into lava.\n            return vec4(1.0, 0.0, 1.0, 1.0);\n        }\n        return vec4(0);\n    }\n    if (noise(pos) > 0.04 && (pixel(receive(pos + BL)).a > 0.5 || pixel(receive(pos + BR)).a > 0.5)) {\n        // Diagonally over lava, melt slower.\n        return vec4(0);\n    }\n    return self;\n}\n\nvec4 freeze(ivec2 pos, vec4 self) {\n    if (noise(pos) > 0.06) {\n        // Freeze slow.\n        return self;\n    }\n    bool shouldFreeze = false;\n    if (\n        (pixel(receive(pos + A)).b > 0.5 && pixel(receive(pos + A)).a < 0.5) ||\n        (pixel(receive(pos + B)).b > 0.5 && pixel(receive(pos + B)).a < 0.5) ||\n        (pixel(receive(pos + L)).b > 0.5 && pixel(receive(pos + L)).a < 0.5) ||\n        (pixel(receive(pos + R)).b > 0.5 && pixel(receive(pos + R)).a < 0.5)\n    ) {\n        // Near water, freeze to sand.\n        float value = 0.75 + 0.25 * noiseB(pos);\n        return  vec4(value, 0.0, 0.0, 0.0);\n    }\n    return self;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 pos = ivec2(fragCoord);\n    if (iMouse.z > 0.5 && distance(iMouse.xy, fragCoord) < 12.0) {\n        // Left mouse button pressed.\n        float value = noise(pos);\n        //if (texelFetch(iChannel2, ivec2(87, 0), 0).r > 0.0) {\n        if (texture(iChannel2, (vec2(87, 0)+0.5)/iResolution.xy).x > 0.0) {\n            // W pressed, add water.\n            value = float(value > 0.5);\n            fragColor = value * vec4(1.0, 0.0, 1.0, 0.0);\n            //return;\n        }\n        else\n        if (texelFetch(iChannel2, ivec2(76, 0), 0).r > 0.0) {\n            // L pressed, add lava.\n            value = float(value > 0.5);\n            fragColor = value * vec4(1.0, 0.0, 1.0, 1.0);\n            //return;\n        }\n        else\n        if (texelFetch(iChannel2, ivec2(66, 0), 0).r > 0.0) {\n            // B pressed, add bedrock.\n            value = 0.75 + value * 0.25;\n            fragColor = vec4(max(0.75, value), 1.0, 0.0, 0.0);\n            //return;\n        }\n        else\n        if (texelFetch(iChannel2, ivec2(88, 0), 0).r > 0.0) {\n            // X pressed, erase.\n            fragColor = vec4(0);\n            //return;\n        }\n        // No key, add sand.\n        value = float(value > 0.5) * (0.5 + 0.5 * value);\n        fragColor = vec4(value, 0.0, 0.0, 0.0);\n        return;\n    }\n    // Receive particle.\n    ivec2 receivePos = receive(pos);\n    fragColor = pixel(receivePos);\n    if (fragColor.a > 0.5) {\n        // Received lava, freeze if near water.\n        fragColor = freeze(pos, fragColor);\n    }\n    if (fragColor.b > 0.5 && fragColor.a < 0.5) {\n        // Received water, boil if near lava.\n        fragColor = boil(pos, fragColor);\n    }\n    if (fragColor.r > 0.5 && fragColor.g < 0.5 && fragColor.b < 0.5 && fragColor.a < 0.5) {\n        // Received sand, melt if near lava.\n        fragColor = melt(pos, fragColor);\n    }\n    if (receivePos == pos) {\n        // Didn't receive from neighbor.\n        if (fragColor.r > 0.5) {\n            // Move.\n            fragColor = move(ivec2(fragCoord), fragColor);\n        }\n    }\n}",
   "name": "Buffer B",
   "description": "",
   "type": "buffer"
  }
 ]
}