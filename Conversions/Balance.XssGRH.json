{"Shader":{"ver":"0.1","info":{"id":"XssGRH","date":"1632346490","viewed":321,"name":"Balance","username":"mare","description":" - sunrise and sunset\n - water with raindrops from the clear sky\n - some strings and sea noise totally unrelated to rain\n - visual overlay to cover initial buffer raw state","likes":17,"published":3,"flags":40,"usePreview":0,"tags":["audio","meditation"],"hasliked":0},"renderpass":[{"inputs":[{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"vec3 yinYang( in vec2 fragCoord )\n{\n    \/\/ some old unpublished shader utilized\n    vec2 uv = fragCoord.xy \/ iResolution.xy;\n\tuv -= vec2( .5,.5 );\n\tfloat aspect = iResolution.x \/ iResolution.y;\n\tuv.x *= aspect;\n\tvec3 col = vec3( 1.0, 1.0, 1.0 );\n\tvec2 offset = vec2( uv.y, -uv.x );\n\tvec2 uv2 = uv + offset * sin( length( uv ) * 20.0 + iTime) * 1.55;\n\tfloat lightness = 1.0 * sin( 10.0 *uv2.x ) * cos( 10.0 * uv2.y );\n\tlightness += 1.0 * cos( 10.0 *uv.x ) * sin( -10.0 * uv.y );\n\tlightness = pow( clamp(lightness, .0, 1.0 ), .45 );\n\tlightness *= 2.0 - 2.9 * dot( uv, uv );\n\treturn col * max( lightness, .0 );\n}\n\nvec3 sky( vec3 ray )\n{\n    float horizonLight = .2 - ray.y;\n    ray.y = max( .0, ray.y );\n    float dayTime = cos( iTime * .05);\n    \n    vec3 moonDir = normalize( vec3( .1, -.2 * dayTime + .1, .9 ) );\n    float moonDot = dot( moonDir, ray );\n    float moon = smoothstep( .996, .997, moonDot );\n    vec3 ret = vec3( .0, .07, .12);\n    ret += moon * vec3( 1.5, .6, .4 );\n    ret += smoothstep( .9, 1.0, moonDot ) * vec3( .1, .0, .0 );\n    float dayTimeN = .5 + .5 * dayTime;\n    vec3 horizonColor =  (1.0 -  dayTimeN) * vec3( .1, .95, .4 ) + dayTimeN * vec3( 1., .3, -.1 );\n    ret += horizonLight * horizonColor ;\n    ret *= 3.0;\n    ret *= clamp( .15 * iTime - .6, .0, 1.0 );\n    \n    float yinYangVal = clamp( iTime, .0, 1.0 );\n    \n    yinYangVal *= max( cos( iTime * .1 ) - .3, .0 );\n    yinYangVal *= yinYangVal * yinYangVal;\n    \n    ret += yinYangVal * yinYang( (ray.xy + vec2(.25, .0)) * iResolution.x * 1.6 );\n    \n    return ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy \/ iResolution.xy;\n\tuv -= vec2( .5,.7 );\n    uv *= .5;\n\tfloat aspect = iResolution.x \/ iResolution.y;\n\tuv.x *= aspect;\n    \n    vec3 ray = vec3( uv.x, uv.y, 1.0 );\n    ray = normalize( ray );\n    \n    if( ray.y >= .0 )\n    {\n        fragColor = vec4( sky(ray), 1.0 );\n        return;\n    }\n    \n    vec2 targetUv = vec2( .5 + ray.x * .07 \/ -ray.y, ray.z * .07 \/ -ray.y );\n    targetUv *= iResolution.y \/ 300.;\n    targetUv.y += sin( iTime * .03 );\n    targetUv.x += cos( iTime * .03 );\n    \n    float tex = texture( iChannel0, fract( targetUv ) ).x - .5;\n    targetUv *= vec2( 1.0 - .502 * tex );\n    targetUv *= 200.0 \/ iResolution.y;\n    \n    vec2 scale = 1. \/ iResolution.xy;\n    vec2 offs = vec2(1.0, 1.0) * scale;\n    \n    tex = texture( iChannel0, fract( targetUv ) ).x;\n    \n    float texL = texture( iChannel0, fract( targetUv - vec2(offs.x, .0) ) ).x;\n    float texD = texture( iChannel0, fract( targetUv - vec2(.0, offs.y) ) ).x;\n    vec3 normal = vec3( tex - texL, .4, tex - texD );\n    normal \/= length( normal );\n    \n    vec3 reflection = normalize( ray - 2. * dot( ray, normal ) * normal );\n    \n    float fresnel = ( 1.0 - 3.0 * dot( normal, reflection ) );\n    fragColor = vec4( sky(reflection) * fresnel, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define TONE(f,i) sin((f)*float(i)*1.424759e-4)\n#define BOOST_SUB(f,fr) -50.0*abs( fract( f\/fr  -.5 ) - .5)\n\n\n#define ATT1(t) max(sin((t)*0.75+2.0),.0)\n#define ATT2(t) max(sin((t)*1.00-2.0),.0)\n#define ATT3(t) max(sin((t)*1.25+2.0),.0)\n#define ATT4(t) max(sin((t)*1.33+4.0),.0)\n\n#define COUNT 1024\n#define COUNT_F 1024.0\n\n#define BOOST \\\n        float \\\n        boost = max( boost1_1 + BOOST_SUB( f,tone1_1 ),.0); \\\n        boost = max( boost1_2 + BOOST_SUB( f,tone1_2 ),boost); \\\n        boost = max( boost1_3 + BOOST_SUB( f,tone1_3 ),boost); \\\n        boost = max( boost1_4 + BOOST_SUB( f,tone1_4 ),boost); \\\n        boost = max( boost2_1 + BOOST_SUB( f,tone2_1 ),boost); \\\n        boost = max( boost2_2 + BOOST_SUB( f,tone2_2 ),boost); \\\n        boost = max( boost2_3 + BOOST_SUB( f,tone2_3 ),boost); \\\n        boost = max( boost2_4 + BOOST_SUB( f,tone2_4 ),boost); \\\n        boost = min( boost, .1 ); \\\n\nfloat ratios [4] = float[4]( 1.0, 1.25, 1.5, .75 );\nvec2 mainSound( int samp, float time )\n{\n    float f = 20.0;\n    float factor = 1.0;\n    float domPhase = time * .25;\n    int index1 = int( floor( ( domPhase + 1.5707963267 ) \/ 6.2831853071 ) ) & 3;\n    int index2 = int( floor( ( domPhase - 1.5707963267 ) \/ 6.2831853071 ) ) & 3;\n    \n    float tone1_1 = 220.0 * ratios[ index2 ];\n    float tone1_2 = 275.0 * ratios[ index2 ];\n    float tone1_3 = 330.0 * ratios[ index2 ];\n    float tone1_4 = 440.0 * ratios[ index2 ];\n    \n    float tone2_1 = 330.0 * ratios[ index1 ];\n    float tone2_2 = 577.5 * ratios[ index1 ];\n    float tone2_3 = 247.5 * ratios[ index1 ];\n    float tone2_4 = 412.5 * ratios[ index1 ];\n    \n    float domFactor = clamp( sin( domPhase ) * 3.0 + .25, .0, 1.0 );\n    float resFactor = clamp( sin( domPhase ) * -3.0 + .25, .0, 1.0 );\n    \n    float lt = time;\n    \n    float boost1_1 = resFactor * ( ATT1(lt) + .3*ATT1(lt - .2 ) + .1*ATT1(lt - .4 ) );\n    float boost1_2 = resFactor * ( ATT2(lt) + .3*ATT2(lt - .2 ) + .1*ATT2(lt - .4 ) );\n    float boost1_3 = resFactor * ( ATT3(lt) + .3*ATT3(lt - .2 ) + .1*ATT3(lt - .4 ) );\n    float boost1_4 = resFactor * ( ATT4(lt) + .3*ATT4(lt - .2 ) + .1*ATT4(lt - .4 ) );\n    float boost2_1 = domFactor * ( ATT1(lt) + .3*ATT1(lt - .2 ) + .1*ATT1(lt - .4 ) );\n    float boost2_2 = domFactor * ( ATT2(lt) + .3*ATT2(lt - .2 ) + .1*ATT2(lt - .4 ) );\n    float boost2_3 = domFactor * ( ATT3(lt) + .3*ATT3(lt - .2 ) + .1*ATT3(lt - .4 ) );\n    float boost2_4 = domFactor * ( ATT4(lt) + .3*ATT4(lt - .2 ) + .1*ATT4(lt - .4 ) );\n    \n    float left = .0;\n    for( int i = 1; i < COUNT; ++i )  \n    {\n        f = 90.0 + ( 7.501 + 2.10 * sin( float(i) ) ) * float( i );\n        BOOST\n        float fc = factor*factor; fc*=factor;\n        left += TONE( f,samp ) * ( min(f\/500.0, 1.0)*fc + boost * 24.0 ) * fc;\n        factor -= 1.0 \/ COUNT_F;  \n    }\n    \n    factor = 1.0;\n    \n    float right = .0;\n    for( int i = 1; i < COUNT; ++i )  \n    {\n        f = 92.0 + ( 5.499 + .010 * sin( float(i) ) ) * float( i );\n        BOOST\n        float fc = factor*factor; fc*=fc;\n        right += TONE( f,samp ) * ( min(f\/500.0, 1.0)*fc + boost * 24.0 ) * fc;\n        factor -= 1.0 \/ COUNT_F;\n    }\n    \n    float rotationPhase = time * .7;\n    float outRight =  sin( rotationPhase ) * left + cos( rotationPhase ) * right;\n    float outLeft =  sin( rotationPhase ) * right + cos( rotationPhase ) * left;\n    float waveValue = .8 + .2 * sin( sin( time ) * 3.0 + 1.5 * time );\n    time -= .5;\n    waveValue *= .8 + .2 * sin( sin( time ) * 3.0 + 1.5 * time );\n    waveValue *= 6.0;\n    \n    return min( time * .2, 1.0) *  ( vec2( outLeft, outRight ) *.8 + vec2( outLeft + outRight ) * .1 )* waveValue \/ COUNT_F;\n}","name":"Sound","description":"","type":"sound"},{"inputs":[{"id":258,"src":"\/media\/previz\/buffer01.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":257,"channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    waterUpd( fragColor, fragCoord, iResolution.xy, iTime, iChannel0 );\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":258,"channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    waterUpd( fragColor, fragCoord, iResolution.xy, iTime, iChannel0 );\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"float moise2(vec2 c, float t)\n{\n\treturn fract(sin(dot(vec2(18.69781,79.98463),fract(c + t))) * 4958.1694);\n}\n\nvoid waterUpd( out vec4 fragColor, in vec2 fragCoord, vec2 resolution, float time, sampler2D sampler )\n{\n    vec2 uv = fragCoord.xy \/ resolution;\n    float val = moise2( uv, floor( time * 4. ) * .1234);\n    float rain = 1.0 - step( val, .9998 );\n    rain *= max( 1.0 - fract( time * 4.) - .7, .0 );\n\n    if( time < 2.0 )\n    {\n        fragColor = vec4( vec3( .5 ), 1.0 );\n        return;\n    }\n    \n    vec2 uv1 = fract( ( fragCoord.xy + vec2( 1., .0 )) \/ resolution );\n    vec2 uv2 = fract( ( fragCoord.xy + vec2( -1., .0 )) \/ resolution );\n    vec2 uv3 = fract( ( fragCoord.xy + vec2( 0., 1.0 )) \/ resolution );\n    vec2 uv4 = fract( ( fragCoord.xy + vec2( 0., -1.0 )) \/ resolution );\n    \n    vec4 inCenter = texture( sampler, uv );\n    float neighbourAvg = \n        texture( sampler, uv1 ).x + \n        texture( sampler, uv2 ).x +\n        texture( sampler, uv3 ).x +\n        texture( sampler, uv4 ).x;\n    float curSpd = inCenter.y - .5;\n    float curAlt = inCenter.x - .5; \n    float spring = neighbourAvg * .25 - .5 - curAlt;\n    spring -= curAlt * .2;\n    curSpd *= .996;\n    curSpd += spring * .32;\n    curSpd += rain * 100.0;\n    curAlt += curSpd * .15;\n    curAlt *= .996;\n    curSpd = clamp( curSpd, -.5, .5 ) + .5;\n    curAlt = clamp( curAlt, -.5, .5 ) + .5;\n    fragColor = vec4( curAlt, curSpd, .0, 1.0 );\n    \n}","name":"Common","description":"","type":"common"}]}}