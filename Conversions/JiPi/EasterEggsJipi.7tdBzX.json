{
 "ver": "0.1",
 "info": {
  "id": "7tdBzX",
  "date": "0",
  "viewed": 0,
  "name": "Easter eggs JiPi",
  "description": "just some dancing easter eggs",
  "likes": 0,
  "published": "Private",
  "usePreview": 0,
  "tags": [
   "texturepatterns"
  ],
  "hasliked": 0,
  "parentid": "sdjGDR",
  "parentname": "Easter eggs"
 },
 "renderpass": [
  {
   "inputs": [
    {
     "id": "4dfGRn",
     "filepath": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg",
     "type": "texture",
     "channel": 1,
     "sampler": {
      "filter": "mipmap",
      "wrap": "repeat",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    },
    {
     "id": "XsXGRr",
     "filepath": "/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3",
     "type": "music",
     "channel": 0,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    }
   ],
   "outputs": [
    {
     "id": "4dfGRr",
     "channel": 0
    }
   ],
   "code": "#define TWO_PI  6.28318530718\n#define PI      3.14159265359\n    \nmat3 ZRotMatrix(in float a)\n{\n    return mat3( cos(a), -sin(a), 0.,\n                 sin(a),  cos(a), 0., \n                 0.,      0.,     1.);\n}\n\nvec3 sdEgg( in vec3 p, in vec3 c, float Zr, in vec3 s)\n{\n    //apply transformation\n    p -= c;\n    p = ZRotMatrix(Zr) * p;\n    p *= s;\n\n    vec3 res = vec3(0.);\n    \n    //compute sdf\n    float f = pow(1.2*dot(p.xz, p.xz), 0.8);\n    p.y += 0.15 * f;\n    res.x = (length(p) - 0.5);\n    \n    //uvs\n    res.yz = vec2( (atan(p.x, p.z)) / (TWO_PI),\n                   (sign(p.y)*acos(dot( normalize(p), normalize(vec3(p.x,0.0,p.z))))) / PI\n                 );\n                 \n    return res;\n}\n\n//------------------------------------------------------------------\n\nvec4 opU( vec4 d1, vec4 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec4 map( in vec3 pos  )\n{\n    vec4 res = vec4( 1e10,0.0,0.0,0.0 );\n    \n    float delay = 4.;\n    float hmov = sin((iChannelTime[0]-delay) * ( iChannelTime[0]>delay ? 6.13 : 0.));\n    float scale = 2.*sin((iChannelTime[0]-delay) * ( iChannelTime[0]>delay ? 24.52 : 0. ));\n    res = opU( res, vec4( sdEgg( pos,vec3(-hmov*0.1,0.62 + scale*0.02,0.),hmov*0.2,vec3(1.+ scale*0.03, 0.8 - scale*0.03, 1.+ scale*0.03)), 2.) );\n    res = opU( res, vec4( sdEgg( pos,vec3(-hmov*0.1-1.5,0.62 + scale*0.02,0.),hmov*0.2,vec3(1.+ scale*0.03, 0.8-scale*0.03, 1.+ scale*0.03)), 3.) );\n    res = opU( res, vec4( sdEgg( pos,vec3(-hmov*0.1+1.5,0.62+ scale*0.02,0.),hmov*0.2,vec3(1.+ scale*0.03, 0.8- scale*0.03, 1.+ scale*0.03)), 4.) );\n    \n    return res;\n}\n\nvec4 raycast( in vec3 ro, in vec3 rd )\n{\n    vec4 res = vec4(-1.,-1.,-1.,-1.);\n\n    float tmax = 20.0;\n\n    float tp1 = (-ro.y)/rd.y;\n    if( tp1>0.0 )\n    {\n        tmax = min( tmax, tp1 );\n        res = vec4( tp1, 0.,0.,1.);\n    }\n    \n     \n    float t = 0.;\n    for( int i=0; i<70 && t<tmax; i++ )\n    {\n        vec4 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec4(t,h.yzw); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd)\n{   \n    float t = 0.1;\n    float tmax = 30.0;\n    float res = 1.0;\n    for(int i=0; i<256; ++i)\n    {\n        vec3 p = ro + rd*t;\n        float d = map(p).x;\n        \n        res = min(res, 8. * d/t);\n        if(d < 0.0001 || t > tmax) break;\n        \n        t+=d;\n    }\n    return clamp(res,0.0,1.0);\n}\n\nvec3 calcNormal( in vec3 p )\n{\n    vec2 e = vec2(0.01,0.0);\n\treturn normalize( vec3( map( p + e.xyy ).x - map( p - e.xyy ).x,\n                            map( p + e.yxy ).x - map( p - e.yxy ).x,\n                            map( p + e.yyx ).x - map( p - e.yyx ).x\n                            ));\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos + h*nor ).x;\n        occ += (h-d)*sca;\n        sca *= 0.8;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n\nfloat triangularSignal(in float x, in float freq, in float amp)\n{\n    return abs((mod(x*freq,2.)-1.)*amp);\n}\n\nvec3 render( in vec3 ro, in vec3 rd)\n{ \n    // background\n    vec3 col = vec3(0.7, 0.7, 0.9) - max(rd.y,0.0)*0.3;\n     \n    vec4 res = raycast(ro,rd);\n    float t = res.x;\n\tfloat m = res.w;\n    vec2 uvs = res.yz;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = (m<1.5) ? vec3(0.0,1.0,0.0) : calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // specular coeff        \n        float ks = 0.;\n        \n        //ground\n        if( m<1.5 )\n        {\n            col = vec3(0.1,0.2,0.3);\n            ks = 0.1;\n        }\n        //yellow egg\n        else if( m<2.5 )\n        {\n            col = vec3(0.4,0.3,0.01);\n            ks = 1.4;\n            \n            col = mix(col, vec3(0.,0.05,0.2), smoothstep(-0.21,-0.2, uvs.y) * smoothstep(-0.12, -0.125, uvs.y));\n            col = mix(col, vec3(0.,0.2,0.2), smoothstep(-0.105,-0.10,uvs.y) * smoothstep(-0.005, -0.01, uvs.y));\n            \n            float redstripefunc = triangularSignal(uvs.x,30.,0.04);\n            float redstripefactor = smoothstep( uvs.y-0.155,uvs.y-0.15, redstripefunc) * smoothstep( uvs.y-0.1, uvs.y-0.105, redstripefunc );\n            col = mix(col, vec3(0.3,0.,0.), redstripefactor);\n            ks = mix(ks, 0.6, redstripefactor);\n            \n            float bluestripefunc = triangularSignal(uvs.x,30.,0.04);\n            float bluestripefactor = smoothstep( uvs.y-0.225, uvs.y-0.22, bluestripefunc) * smoothstep( uvs.y-0.185, uvs.y-0.19, bluestripefunc);\n            col = mix(col, vec3(0.1,0.3,0.5)*0.4, bluestripefactor);\n            ks = mix(ks, 0.6, bluestripefactor);\n                        \n            float pinkdotsfunc = smoothstep(0.5, 0.6,(abs(sin(uvs.x*70.))*sin(uvs.y*55.-0.5)));\n            float pinkdotsfactor = pinkdotsfunc * step(0., uvs.y)*step(uvs.y,0.07);\n            col = mix(col, vec3(0.5,0.4,0.4), pinkdotsfactor );\n            ks = mix(ks, 0.6, pinkdotsfactor);\n            \n            float reddotsfunc = smoothstep(0.5, 0.6,(abs(sin(uvs.x*70.-1.5))*sin(uvs.y*50.-2.)));\n            float reddotsfactor = reddotsfunc * step(-0.1, uvs.y)*step(uvs.y,0.);\n            col = mix(col, vec3(0.5,0.,0.), reddotsfactor);\n            ks = mix(ks, 0.6, reddotsfactor);\n            \n            col = texture(iChannel1, uvs).xyz;\n            \n        }\n        else if( m<3.5 )\n        {\n            ks = 0.8;\n            col = vec3(0.2,0.0,0.3);\n            \n            float gl1 = smoothstep(-0.31,-0.3, uvs.y) * smoothstep(-0.23, -0.24, uvs.y);\n            float gl2 = smoothstep(-0.11,-0.105, uvs.y) * smoothstep(-0.04, -0.045, uvs.y);\n            float gl3 = smoothstep(0.08,0.085, uvs.y) * smoothstep(0.135, 0.13, uvs.y);\n            float gl4 = smoothstep(0.23,0.235, uvs.y) * smoothstep(0.3  , 0.295, uvs.y);\n            float gl5 = smoothstep(0.34,0.345, uvs.y) * smoothstep( 0.365, 0.36, uvs.y);\n            \n            col = mix(col, vec3(0.3),gl1);\n            ks = mix(ks, 0.5, gl1);\n            col = mix(col, vec3(0.3),gl2);\n            ks = mix(ks, 0.5, gl2);\n            col = mix(col, vec3(0.3),gl3);\n            ks = mix(ks, 0.5, gl3);\n            col = mix(col, vec3(0.3),gl4);\n            ks = mix(ks, 0.5, gl4);\n            col = mix(col, vec3(0.5, 0.2, 0.2),gl5);\n            ks = mix(ks, 0.5, gl5);\n            \n            float pinkdotsbot = smoothstep(0.7, 0.8,(sin(uvs.x*30.)*sin(uvs.y*20.-1.5)));\n            float pinkdotsbotfactor = pinkdotsbot * step(-0.2, uvs.y)*step(uvs.y,-0.1);\n            col = mix(col, vec3(0.5, 0.2, 0.2), pinkdotsbotfactor );\n            ks = mix(ks, 0.5, pinkdotsbotfactor);\n            \n            float yellowdotsbot = smoothstep(0.7, 0.8,(sin(uvs.x*30.+3.2)*sin(uvs.y*20.-1.5)));\n            float yellowdotsbotfactor = yellowdotsbot * step(-0.2, uvs.y)*step(uvs.y,-0.1);\n            col = mix(col, vec3(0.6, 0.4, 0.), yellowdotsbotfactor );\n            ks = mix(ks, 0.5, yellowdotsbotfactor);\n            \n            float pinkdotstop = smoothstep(0.7, 0.8,(sin(uvs.x*30.)*sin(uvs.y*20.-2.1)));\n            float pinkdotstopfactor =pinkdotstop * step(0.1, uvs.y)*step(uvs.y,0.3);\n            col = mix(col, vec3(0.5, 0.2, 0.2), pinkdotstopfactor);\n            ks = mix(ks, 0.5, pinkdotstopfactor);\n            \n            float yellowdotstop = smoothstep(0.7, 0.8,(sin(uvs.x*30.+3.2)*sin(uvs.y*20.-2.1)));\n            float yellowdotstopfactor = yellowdotstop * step(0.1, uvs.y)*step(uvs.y,0.3);\n            col = mix(col, vec3(0.6, 0.4, 0.), yellowdotstopfactor);\n            ks = mix(ks, 0.5, yellowdotstopfactor);\n            \n            float pinkwave = sin(uvs.x*50.)*0.04;\n            float pinkwavefactor = smoothstep( uvs.y-0.03, uvs.y-0.025, pinkwave) * smoothstep( uvs.y-0.01, uvs.y-0.015, pinkwave);\n            col = mix(col, vec3(0.5, 0.2, 0.2), pinkwavefactor);\n            ks = mix(ks, 0.5, pinkwavefactor);\n            \n        }\n        else if( m<4.5 )\n        {\n            col = mix(col, vec3(0.7, 0.6, 0.1)*0.4, smoothstep(0.3,0.5,(sin(uvs.x*170.+3.2)*sin(uvs.y*120.-2.1))));\n            ks = 0.8;\n        }\n\n        // lighting taken from iq primitives shader https://www.shadertoy.com/view/Xds3zN\n        float occ = calcAO( pos, nor );\n        \n\t\tvec3 lin = vec3(0.0);\n\n        // sun\n        {\n            vec3  lig = normalize( vec3(0.5, 0.4, 0.5) );\n            vec3  hal = normalize( lig-rd );\n            float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n          \t      dif *= softshadow( pos, lig);\n\t\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0);\n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0-dot(hal,lig),0.0,1.0),5.0);\n            lin += col*2.20*dif*vec3(1.30,1.00,0.70);\n            lin +=     15.00*spe*vec3(1.30,1.00,0.70)*ks;\n            lin *= 0.5;\n        }\n        // sky\n        {\n            float dif = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n                  dif *= occ;\n            float spe = smoothstep( -0.2, 0.2, ref.y );\n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0+dot(nor,rd),0.0,1.0), 5.0 );\n                  spe *= softshadow( pos, ref);\n            lin += col*0.80*dif*vec3(0.40,0.60,1.15);\n            lin +=     2.00*spe*vec3(0.40,0.60,1.30)*ks;\n        }\n        // back\n        {\n        \tfloat dif = clamp( dot( nor, normalize(vec3(0.5,0.0,0.6))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n                  dif *= occ;\n        \tlin += col*1.*dif*vec3(0.1,0.2,0.3);\n        }\n        // sss\n        {\n            float dif = pow(clamp(1.0+dot(nor,rd),0.0,1.0),2.0);\n                  dif *= occ;\n        \tlin += col*0.25*dif*vec3(1.00,1.00,1.00);\n        }\n        \n\t\tcol = lin;\n\n        //horizon\n        col = mix( col, vec3(0.7,0.7,0.9), 1.0-exp( -0.0001*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 scrPos = fragCoord/iResolution.xy;\n\tscrPos = scrPos*2.0 - 1.0;\n    scrPos.x *= iResolution.x / iResolution.y;\n    \n    vec3 ta = vec3( 0., 0.8, 0. );\n    vec3 ro = vec3(0., 1., 3.5);\n    \n    vec3 f = normalize(ta-ro);\n    vec3 r = normalize(cross(f,vec3(0.,1.,0.)));\n    vec3 t = normalize(cross(r,f));\n    vec3 rd = normalize( vec3(scrPos.x*r+scrPos.y*t+f*2.5) );\n     \n    vec3 col = render( ro, rd);\n\n    fragColor = vec4( pow( col, vec3(0.4545)) , 1.0 );\n}",
   "name": "Image",
   "description": "",
   "type": "image"
  }
 ]
}