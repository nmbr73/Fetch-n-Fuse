{"Shader":{"ver":"0.1","info":{"id":"wdcSzH","date":"1642606785","viewed":67,"name":"head0000000","username":"yy2901","description":"raymarch","likes":9,"published":3,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0},"renderpass":[{"inputs":[{"id":26,"src":"\/media\/a\/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","ctype":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":37,"channel":0}],"code":"#define M_NONE -1.0\n#define M_NOISE 1.0\n\nfloat hash(float h) {\n\treturn fract(sin(h) * 43758.5453123);\n}\n\nvec2 hash( vec2 p ){\n\tp = vec2( dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3)));\n\treturn fract(sin(p)*43758.5453);\n}\n\nfloat noise(vec3 x) {\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f * f * (3.0 - 2.0 * f);\n\n\tfloat n = p.x + p.y * 157.0 + 113.0 * p.z;\n\treturn mix(\n\t\t\tmix(mix(hash(n + 0.0), hash(n + 1.0), f.x),\n\t\t\t\t\tmix(hash(n + 157.0), hash(n + 158.0), f.x), f.y),\n\t\t\tmix(mix(hash(n + 113.0), hash(n + 114.0), f.x),\n\t\t\t\t\tmix(hash(n + 270.0), hash(n + 271.0), f.x), f.y), f.z);\n}\n\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n#define OCTAVES 2\nfloat fbm(vec3 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec3 shift = vec3(100);\n\tfor (int i = 0; i < OCTAVES; ++i) {\n\t\tv += a * noise(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\nconst int MAX_MARCHING_STEPS = 256;\nconst float MAX_DIST = 150.0;\nconst float EPSILON = 0.001;\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0)-2.0;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\nfloat sdCapsule( vec3 p, float h, float r )\n{\n    p.y -= clamp( p.y, 0.0, h );\n    return length( p ) - r;\n}\n\nfloat sdCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot((k1-q),k2)\/dot(k2,k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot(ca,ca),dot(cb,cb)) );\n}\n\nfloat opSmI( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)\/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); \n}\n\nfloat opSmU( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)\/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmS( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)\/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nmat3 rotateY(float t) {\n    float c = cos(t);float s = sin(t);\n\treturn mat3(\tvec3(c, 0, s),\n        \t\t\tvec3(0, 1, 0),\n        \t\t\tvec3(-s, 0, c)\t);\n}\n\nmat3 rotateX(float t) {\n    float c = cos(t);float s = sin(t);\n\treturn mat3(\tvec3(1, 0, 0),\n        \t\t\tvec3(0, c, -s),\n        \t\t\tvec3(0, s, c)\t);\n}\n\nmat3 rotateZ(float t) {\n    float c = cos(t);float s = sin(t);\n\treturn mat3(\tvec3(c, -s, 0),\n        \t\t\tvec3(s, c, 0),\n        \t\t\tvec3(0, 0, 1)\t);\n}\n\nmat3 scale(float x,float y,float z){\n    return mat3(\n    vec3(x,0.,0.),vec3(0.,y,0.),vec3(0.,0.,z)\n    );\n}\n\nfloat head(vec3 sP){\n    float s1 = length(sP*scale(1.2,1.0,1.0)-vec3(0.0,0.5,0.0))-0.5;\n    float s2 = length(sP*scale(1.2,1.3,1.2)-vec3(0.0,0.12,0.15))-0.4;\n    float s3 = opSmU(s1,s2,0.2);\n    \/\/float s5 = opSmU(s3,neck,0.1);\n    float s6 = sdCone((sP-vec3(0.,0.25,0.34))*rotateX(-2.1),0.22,0.2,0.0)-0.03;\n    float s7 = opSmU(s3,s6,0.1);\n    float s8 = length(sP-vec3(0.0,-0.08,0.27))-0.2;\n    float s9 = opSmU(s7,s8,0.1);\n    float s10 = length((vec3(abs(sP.x),sP.y,sP.z)-vec3(0.4,0.25,-0.03))*rotateY(0.37)*rotateZ(1341.6)*rotateX(1149.15)*scale(8.0,1.0,1.2))-0.12;\n    float s11 = opSmU(s9,s10,.05);\n    float s12 = length(sP-vec3(0.0,-0.14,0.56))-0.09;\n    float s13 = opSmS(s12,s11,0.1);\n    return s13;\n}\n\nfloat displace(vec3 sP,float geo){\n    float final;\n    if(geo<=0.01){\n        float disp = geo-(0.1*fbm(sP*3.0*rotateY(iTime+12.0*(0.3*(sin(sP.y*1.0+iTime*0.3))+0.6))+vec3(0.,0.,2.0*iTime))-0.195);\n    \tfinal = opSmS(disp,geo,0.3);\n    }else{\n        final = geo;\n    }\n    return final;\n}\n\n\nfloat sceneSDF(vec3 sP) {\n    vec3 sPh=sP*rotateY(noise(vec3(iTime*0.5))-0.5)*rotateX(0.1*noise(vec3(iTime*0.5+123.456))-0.09)*rotateZ(0.1*noise(vec3(iTime*0.5+222.111))-0.05);\n    \n\tfloat head = head(sPh);\n\n    float s4 = sdCapsule(sP-vec3(0.0,-0.5,-0.15),1.0,0.26);\n    float s14 = length(sP-vec3(0.0,-0.7,-0.18))-0.4;\n    float s15 = opSmU(s4,s14,0.1);\n    float s16 = length(vec3((sP.x),sP.y,sP.z)-vec3(0.5,-1.1,-0.18))-0.43;\n    float s17 = opSmU(s15,s16,0.5);\n    float s16n = length(vec3(-(sP.x),sP.y,sP.z)-vec3(0.5,-1.1,-0.18))-0.43;\n    float s18 = opSmU(s17,s16n,0.5);\n    float torso = opSmU(s18,s4,0.1);\n    torso-=0.03*noise(sP*8.0);\n    torso = displace(sP,torso);\n    head-=0.03*noise(sPh*8.0);\n    head = displace(sPh,head);\n    float final=opSmU(torso,head,0.01);\n\n    return final;\n}\n\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection) {\n    float depth;\n    float dd=0.0;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = (sceneSDF(eye + dd * marchingDirection));\n        dd += dist;\n        if (dist<EPSILON) {\n            depth=dd;\n        }else if(dist>MAX_DIST){\n\t\t\treturn dd;\n            break;\n        }\n        \n    }\n    return depth;\n}\n            \nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size \/ 2.0;\n    float z = size.y \/ tan(radians(fieldOfView) \/ 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvec3 eN(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nfloat AO(vec3 p,vec3 n){\n    float ao =0.0;\n    float d;\n    for(int i=1;i<=3;i++){\n        d=3.0*float(i);\n        ao+=max(0.0,(d-sceneSDF(p+n*d))\/d);\n    }\n    return ao;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 dir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0.0, 0.0, 5.0);\n    \/\/dir*=rotateY(iTime*0.5);eye*=rotateY(iTime*0.5);\n    vec3 color=vec3(0.0);\n    float sdf = shortestDistanceToSurface(eye, dir);\n    if(sdf>MAX_DIST || sdf==0.0){\n        fragColor = vec4(0.0);\n        return;\n    }\n    float dist = sdf;\n    vec3 p = eye + dist * dir;\n    vec3 N = eN(p);\n    float occ = 1.0-AO(p,N);\n\n    vec3 ref = (reflect(dir,N));\n    color=(texture(iChannel0,ref).xyz*0.5+vec3(0.5))*occ*(1.0-smoothstep(4.5,6.0,dist));\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}}