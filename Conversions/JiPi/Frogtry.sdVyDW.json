{"Shader":{"ver":"0.1","info":{"id":"sdVyDW","date":"1654893734","viewed":75,"name":"FrogTry","username":"metalfinger","description":"ShaderFrog Test","likes":6,"published":3,"flags":32,"usePreview":0,"tags":["galaxy"],"hasliked":0},"renderpass":[{"inputs":[{"id":15,"src":"\/media\/a\/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":37,"channel":0}],"code":"\/\/ Created by sebastien durand - 08\/2016\n\/\/-------------------------------------------------------------------------------------\n\/\/ Based on \"Dusty nebula 4\" by Duke (https:\/\/www.shadertoy.com\/view\/MsVXWW) \n\/\/ Sliders from IcePrimitives by Bers (https:\/\/www.shadertoy.com\/view\/MscXzn)\n\/\/ License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\/\/-------------------------------------------------------------------------------------\n\n\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n#define pi 3.14159265\n\n\nconst vec4 \n    colCenter = vec4(1.2, 1.5,1.5,.25),\n\tcolEdge = vec4(.1,.1,.2,.5),\n\tcolEdge2 = vec4(.7,.54,.3,.23),\n    colEdge3 = vec4(.6,1.,1.3,.25);\n\nconst float time = 10.;\nvec4 sliderVal;\n\nvec2 min2(vec2 a, vec2 b) {\n    return a.x<b.x ? a  : b;\n} \n\nfloat hash( const in vec3 p ) {\n\tfloat h = dot(p,vec3(127.1,311.7,758.5453123));\t\n    return fract(sin(h)*43758.5453123);\n}\n\n\/\/ [iq] https:\/\/www.shadertoy.com\/view\/4sfGzS\nfloat noiseText(in vec3 x) {\n    vec3 p = floor(x), f = fract(x);\n\tf = f*f*(3.-f-f);\n\tvec2 uv = (p.xy+vec2(37.,17.)*p.z) + f.xy,\n\t     rg = textureLod( iChannel0, (uv+.5)\/256., -100.).yx;\n\treturn mix(rg.x, rg.y, f.z);\n}\n\n\/\/ ratio: ratio of hight\/low frequencies\nfloat fbmdust(in vec3 p, in float ratio) {\n    return mix(noiseText(p*3.), noiseText(p*20.), ratio);\n}\n\nvec2 spiralArm(in vec3 p, in float thickness, in float blurAmout, in float blurStyle) {\n    float dephase = 2.2, loop = 4.;\n    float a = atan(p.x,p.z),  \/\/ angle     \n\t\t  r = length(p.xz), lr = log(r), \/\/ distance to center\n    \t  th = (.1-.25*r), \/\/ thickness according to distance\n    \t  d = fract(.5*(a-lr*loop)\/pi); \/\/apply rotation and scaling.\n    d = (.5\/dephase - abs(d-.5))*2.*pi*r;\n  \td *= (1.-lr)\/thickness;  \/\/ space fct of distance\n    \/\/ Perturb distance field\n    float radialBlur = blurAmout*fbmdust(vec3(r*4.,10.*d,10.-5.*p.y),blurStyle);\n    return vec2(sqrt(d*d+10.*p.y*p.y\/thickness)-th*r*.2-radialBlur);\n}\n\nvec2 dfGalaxy(in vec3 p, in float thickness, in float blurAmout, in float blurStyle) {\n\treturn min2(spiralArm(p,                  thickness, blurAmout, blurStyle),\n    \t\t\tspiralArm(vec3(p.z,p.y,-p.x), thickness, blurAmout, blurStyle));  \n}\n\nvec2 map(in vec3 p) {\n\tR(p.xz, iMouse.x*.008*pi+iTime*.3);\n    return dfGalaxy(p, clamp(10.*sliderVal.x,.9,10.), sliderVal.y, sliderVal.z);\n}\n\n\/\/--------------------------------------------------------------\n\n\/\/ assign color to the media\nvec4 computeColor(in vec3 p, in float density, in float radius, in float id) {\n\t\/\/ color based on density alone, gives impression of occlusion within\n\t\/\/ the media\n\tvec4 result = mix( vec4(1.,.9,.8,1.), vec4(.4,.15,.1,1.), density );\n\t\/\/ color added to the media\n\tresult *= mix( colCenter,\n                  mix(colEdge2, \n                      mix(colEdge, colEdge3, step(.08,id)), step(-.05,id)),\n                  smoothstep(.2,.8,radius) );\n\treturn result;\n}\n\n\/\/ - Ray \/ Shapes Intersection -----------------------\nbool sBox( in vec3 ro, in vec3 rd, in vec3 rad, out float tN, out float tF)  {\n    vec3 m = 1.\/rd, n = m*ro,\n    \tk = abs(m)*rad,\n        t1 = -n - k, t2 = -n + k;\n\ttN = max( max( t1.x, t1.y ), t1.z );\n\ttF = min( min( t2.x, t2.y ), t2.z );\n\treturn !(tN > tF || tF < 0.);\n}\n\nbool sSphere(in vec3 ro, in vec3 rd, in float r, out float tN, out float tF) {\n\tfloat b = dot(rd, ro), d = b*b - dot(ro, ro) + r;\n\tif (d < 0.) return false;\n\ttN = -b - sqrt(d);\n\ttF = -tN-b-b;\n\treturn tF > 0.;\n}\n\n\/\/ ---------------------------------------------------\n\/\/ Bers : https:\/\/www.shadertoy.com\/view\/MscXzn\nvec4 processSliders(in vec2 uv) {\n    sliderVal = texture(iChannel2,vec2(0));\n    if(length(uv.xy)>1.) {\n    \treturn texture(iChannel2,uv.xy\/iResolution.xy);\n    }\n    return vec4(0);\n}\n\n\/\/ ---------------------------------------------------\n\/\/ Based on \"Dusty nebula 4\" by Duke (https:\/\/www.shadertoy.com\/view\/MsVXWW) \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ) {  \n    vec4 cSlider = processSliders(fragCoord);\n\n   \/\/ camera\t   \n    float a = sliderVal.w*pi;\n    vec3 ro = vec3(0., 2.*cos(a), -4.5*sin(a)),\n         ta = vec3(-.2,-.3,0);\n\n    \/\/ camera tx\n    vec3 cw = normalize( ta-ro ),\n     \t cp = vec3( 0., 1., 0. ),\n     \t cu = normalize( cross(cw,cp) ),\n     \t cv = normalize( cross(cu,cw) );\n    vec2 q = (fragCoord.xy)\/iResolution.xy,\n     \t p = -1.+2.*q;\n    p.x *= iResolution.x\/iResolution.y;\n    \n    vec3 rd = normalize( p.x*cu + p.y*cv + 2.5*cw );\n      \n\t\/\/ ld, td: local, total density \n\t\/\/ w: weighting factor\n\tfloat ld=0., td=0., w=0.;\n\n\t\/\/ t: length of the ray\n\t\/\/ d: distance function\n\tfloat d=1., t=0.;\n    \n    const float h = 0.1;\n   \n\tvec4 sum = vec4(0);\n   \n    float min_dist=0.,  max_dist=0.,\n          min_dist2=0., max_dist2=0.;\n    \n    if(sSphere(ro, rd, 4., min_dist, max_dist)) {\n        if (sBox(ro, rd, vec3(4.,1.8,4.), min_dist2, max_dist2)) {\n        \tmin_dist = max(.1,max(min_dist, min_dist2));\n            max_dist = min(max_dist, max_dist2);\n            \n            t = min_dist*step(t,min_dist) + .1*hash(rd+iTime);\n\t\t\t\n            \n            \/\/ raymarch loop\n            vec4 col;        \n            for (int i=0; i<100; i++) {\t \n                vec3 pos = ro + t*rd;\n\n                \/\/ Loop break conditions.\n                if(td > .9 || sum.a > .99 || t > max_dist) break;\n\n                \/\/ evaluate distance function\n                vec2 res = map(pos);\n                d = max(res.x,.01); \n\t\t\t\t\n                \/\/ point light calculations\n                vec3 ldst = pos;\n                ldst.y*=1.6;\n                vec3 ldst2 = pos;\n                ldst2.y*=3.6;\n                float lDist = max(length(ldst),.1), \/\/max(length(ldst), 0.001);\n\t\t\t\t      lDist2 = max(length(ldst2),.1);\n                \/\/ star in center\n                vec3 lightColor = (1.-smoothstep(3.,4.5,lDist*lDist))*\n                    mix(.015*vec3(1.,.5,.25)\/(lDist*lDist),\n                        .02*vec3(.5,.7,1.)\/(lDist2*lDist2), \n                        smoothstep(.1,2.,lDist*lDist));\n                sum.rgb += lightColor; \/\/.015*lightColor\/(lDist*lDist); \/\/ star itself and bloom around the light\n                sum.a += .003\/(lDist*lDist);;\n\n                if (d<h) {\n                    \/\/ compute local density \n                    ld = h - d;\n                    \/\/ compute weighting factor \n                    w = (1. - td) * ld;\n                    \/\/ accumulate density\n                    td += w + 1.\/60.;\n                    \/\/ get color of object (with transparencies)\n                    col = computeColor(pos, td,lDist*2., res.y);\n                    col.a *= td;\n                    \/\/ colour by alpha\n                    col.rgb *= col.a;\n                    \/\/ alpha blend in contribution\n                    sum += col*(1.0 - sum.a);  \n                }\n  \n                \/\/float pitch = t\/iResolution.x;\n                \/\/float dt = max(d * 0.25, .005); \/\/pitch);\n                \/\/ trying to optimize step size near the camera and near the light source\n                t += max(d * .15 * max(min(length(ldst), length(ro)),1.0), 0.005);\n                td += .1\/70.;\n                \/\/t += dt;\n            }\n            \/\/ simple scattering\n            sum *= 1. \/ exp( ld * .2 )*.8 ;  \n            sum = clamp( sum, 0., 1. );\n    \t}\n    }\n        \n\t\/\/ Background color\n    sum.rgb += vec3(clamp(2.*cos(.5*iTime),0.,.4))*(1. - sum.a)*pow(16.0*q.x*q.y*(1.-q.x)*(1.-q.y),.3);  \n \n    \/\/Apply slider overlay\n    fragColor = vec4(mix(sum.xyz,cSlider.rgb,cSlider.a), 1.);\n\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":257,"channel":0}],"code":"\/\/Buffer A : slider management (this is not required)\n\/\/ Bers : https:\/\/www.shadertoy.com\/view\/MscXzn\n\n#define saturate(x) clamp(x,0.0,1.0)\n\nvec4 sliderVal = vec4(0.25,0.22,0,0.31); \/\/Default slider values [0-1]\n\nvoid SLIDER_setValue(float idx, float val)\n{\n    if(idx<0.) return;\n    else if(idx<0.25) sliderVal[0] = saturate(val);\n\telse if(idx<0.50) sliderVal[1] = saturate(val);\n\telse if(idx<0.75) sliderVal[2] = saturate(val);\n\telse if(idx<1.00) sliderVal[3] = saturate(val);\n}\n\nfloat SLIDER_getValue(float idx)\n{\n    if     (idx<0.25) return sliderVal[0];\n    else if(idx<0.50) return sliderVal[1];\n    else if(idx<0.75) return sliderVal[2];\n    else if(idx<1.00) return sliderVal[3];\n\telse return 0.;\n}\n\nvoid SLIDER_init(vec2 mousePos, vec2 cMin, vec2 cMax )\n{\n    vec4 cPingPong = texture(iChannel0,vec2(0));\n    if(length(cPingPong)>0.001)\n        sliderVal = cPingPong;\n        \n    float width = cMax.x-cMin.x;\n    float height = cMax.y-cMin.y;\n    if(mousePos.x>cMin.x && mousePos.x<cMax.x &&\n       mousePos.y>cMin.y && mousePos.y<cMax.y )\n    {\n        float t = (mousePos.y-cMin.y)\/height;\n        t = clamp(t\/0.75-0.125,0.,1.); \/\/25% top\/bottom margins\n\t\tSLIDER_setValue((mousePos.x-cMin.x)\/width, t);\n    }\n}\n\n\/\/Returns the distance from point \"p\" to a given line segment defined by 2 points [a,b]\nfloat UTIL_distanceToLineSeg(vec2 p, vec2 a, vec2 b)\n{\n    \/\/       p\n    \/\/      \/\n    \/\/     \/\n    \/\/    a--e-------b\n    vec2 ap = p-a;\n    vec2 ab = b-a;\n    \/\/Scalar projection of ap in the ab direction = dot(ap,ab)\/|ab| : Amount of ap aligned towards ab\n    \/\/Divided by |ab| again, it becomes normalized along ab length : dot(ap,ab)\/(|ab||ab|) = dot(ap,ab)\/dot(ab,ab)\n    \/\/The clamp provides the line seg limits. e is therefore the \"capped orthogogal projection\", and length(p-e) is dist.\n    vec2 e = a+clamp(dot(ap,ab)\/dot(ab,ab),0.0,1.0)*ab;\n    return length(p-e);\n}\n\n\/\/uv = slider pixel in local space [0-1], t = slider value [0-1], ar = aspect ratio (w\/h)\nvec4 SLIDER_drawSingle(vec2 uv, float t, vec2 ar, bool bHighlighted)\n{\n    const vec3  ITEM_COLOR = vec3(1);\n    const vec3  HIGHLIGHT_COLOR = vec3(0.2,0.7,0.8);\n    const float RAD = 0.05;  \/\/Cursor radius, in local space\n    const float LW  = 0.030; \/\/Line width\n    float aa  = 14.\/iResolution.x; \/\/antialiasing width (smooth transition)\n    vec3 selectionColor = bHighlighted?HIGHLIGHT_COLOR:ITEM_COLOR;\n    vec3 cheapGloss   = 0.8*selectionColor+0.2*smoothstep(-aa,aa,uv.y-t-0.01+0.01*sin(uv.x*12.));\n    vec2 bottomCenter = vec2(0.5,0.0);\n\tvec2 topCenter    = vec2(0.5,1.0);\n    vec2 cursorPos    = vec2(0.5,t);\n    float distBar = UTIL_distanceToLineSeg(uv*ar, bottomCenter*ar, topCenter*ar);\n    float distCur = length((uv-cursorPos)*ar)-RAD;\n    float alphaBar = 1.0-smoothstep(2.0*LW-aa,2.0*LW+aa, distBar);\n    float alphaCur = 1.0-smoothstep(2.0*LW-aa,2.0*LW+aa, distCur);\n    vec4  colorBar = vec4(mix(   vec3(1),vec3(0),smoothstep(LW-aa,LW+aa, distBar)),alphaBar);\n    vec4  colorCur = vec4(mix(cheapGloss,vec3(0),smoothstep(LW-aa,LW+aa, distCur)),alphaCur);\n    return mix(colorBar,colorCur,colorCur.a);\n}\n\n#define withinUnitRect(a) (a.x>=0. && a.x<=1. && a.y>=0. && a.y<=1.0)\nvec4 SLIDER_drawAll(vec2 uv, vec2 cMin, vec2 cMax, vec2 muv)\n{\n    float width = cMax.x-cMin.x;\n    float height = cMax.y-cMin.y;\n    vec2 ar = vec2(0.30,1.0);\n    uv  = (uv -cMin)\/vec2(width,height); \/\/pixel Normalization\n    muv = (muv-cMin)\/vec2(width,height); \/\/mouse Normalization\n    if( withinUnitRect(uv))\n    {\n        float t = SLIDER_getValue(uv.x);\n\t\tbool bHighlight = withinUnitRect(muv) && abs(floor(uv.x*4.0)-floor(muv.x*4.0))<0.01;\n\t\tuv.x = fract(uv.x*4.0); \/\/repeat 4x\n\t\tuv.y = uv.y\/0.75-0.125; \/\/25% margins\n        return SLIDER_drawSingle(vec2(uv.x*2.-.5, uv.y),t,ar,bHighlight);\n    }\n    return vec4(0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 cMinSliders = vec2(0.8,0.80);\n    vec2 cMaxSliders = vec2(1.0,1.0);\n    vec2 uvSliders = fragCoord.xy \/ iResolution.xy;\n    vec2 mousePos = iMouse.xy \/ iResolution.xy;\n    SLIDER_init(mousePos, cMinSliders, cMaxSliders);\n    vec4 cSlider = SLIDER_drawAll(uvSliders,cMinSliders, cMaxSliders, mousePos);\n    \n    if(length(fragCoord.xy-vec2(0,0))<1.) \n        fragColor = sliderVal;\n\telse fragColor = cSlider;\n}","name":"Buffer A","description":"","type":"buffer"}]}}