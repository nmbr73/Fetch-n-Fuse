{"Shader":{"ver":"0.1","info":{"id":"7tSfWV","date":"1652754514","viewed":59,"name":"Taste of Noise 16","username":"leon","description":"Noice noise","likes":2,"published":3,"flags":32,"usePreview":0,"tags":["abstract"],"hasliked":0},"renderpass":[{"inputs":[{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":37,"channel":0}],"code":"\n\/\/ Taste of Noise 16 by Leon Denise 2022-05-17\n\n\/\/ An experiment of lighting with a 3D FBM noise.\n\/\/ Trying to render organic volumes without raymarching.\n\/\/ Clic to display the diffent layers, which are from left to right: \n\/\/ height, normal, noise, glow, lighting and shape\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ coordinates\n    vec2 uv = fragCoord.xy \/ iResolution.xy;\n    \n    \/\/ value from noise buffer A\n    vec3 noise = texture(iChannel0, uv).rgb;\n    float gray = noise.x;\n    \n    \/\/ gradient normal from gray value\n    vec3 unit = vec3(5.\/iResolution.xy,0);\n    vec3 normal = normalize(vec3(\n        TEX(uv + unit.xz)-TEX(uv - unit.xz),\n        TEX(uv - unit.zy)-TEX(uv + unit.zy),\n        gray*gray));\n    \n    vec3 dir = normalize(vec3(0,1,.2)); \/\/ light direction\n    float angle = dot(normal, dir); \/\/ light and surface angle\n    vec3 color = vec3(.2); \/\/ ambient\n    float light = pow(angle*.5+.5,10.);\n    float soft = .5*smoothstep(.0,.2,gray-.75);\n    float glow = .1\/(noise.y*noise.y)*noise.z;\n    vec3 tint = .5+.5*cos(vec3(1,2,3)+length(uv)*3.+iTime+angle); \/\/ iq palette\n    color += vec3(1)*light; \/\/ specular light\n    color += soft; \/\/ soft white\n    color += tint*glow; \/\/ glow rainbow\n    color *= gray; \/\/ shadows\n    \n    \/\/ display layers when clic\n    if (iMouse.z > 0.5)\n    {\n        if (uv.x < .16) color = vec3(gray);\n        else if (uv.x < .33) color = normal*.5+.5;\n        else if (uv.x < .5) color = vec3(1.-noise);\n        else if (uv.x < .66) color = vec3(glow);\n        else if (uv.x < .86) color = vec3(.2+light)*gray;\n        else color = vec3(soft);\n        if (uv.y < .02) color = .5+.5*cos(vec3(1,2,3)+uv.x*3.+iTime);\n    }\n\n    fragColor = vec4(color, 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":40,"src":"\/media\/a\/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","ctype":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":257,"channel":0}],"code":"\n\/\/ The noise animated pass with shape and glow layers\n\nconst float speed = .01;\nconst float scale = 0.08;\nconst float cycle = 1.5;\nconst float falloff = 1.8;\n\n\/\/ transform linear value into cyclic absolute value\nvec3 bend(vec3 v)\n{\n    return abs(sin(v*cycle*6.283+iTime*6.283*speed*10.));\n}\n\n\/\/ fractal brownian motion (layers of multi scale noise)\nvec3 fbm(vec3 p)\n{\n    vec3 result = vec3(0);\n    float amplitude = 0.5;\n    for (float index = 0.; index < 4.; ++index)\n    {\n        result += bend(texture(iChannel0, p\/amplitude).xyz) * amplitude;\n        amplitude \/= falloff;\n    }\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ noise from coordinates\n    vec2 uv = (fragCoord.xy - iResolution.xy \/ 2.)\/iResolution.y;\n    vec3 noise = fbm(vec3(uv, iTime * speed) * scale);\n    \n    \/\/ fade noise with circle\n    noise.x -= .5*smoothstep(.3,0.,abs(length(uv)-.6));\n    \n    \/\/ keyhole shape\n    float shape = 10.;\n    shape = min(shape, max(0.,length(uv-vec2(0,.05))-.07));\n    uv.y += .1;\n    shape = min(shape, max(0., moda(uv*rot(1.57), 3.).r-.05));\n    \n    \/\/ add shape to soft white\n    noise.x += .5*smoothstep(.1,0.,abs(shape-.03));\n    \n    \/\/ add shape to glow\n    noise.y *= smoothstep(.0,.1,abs(shape-.01));\n    \n    \/\/ remove shape\n    float hole = smoothstep(.04,.0,shape+.02);\n    noise.x -= hole*1.9;\n    noise.y += hole;\n    \n    fragColor = vec4(clamp(noise, 0., 1.), 1);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n\/\/ shortcut to sample texture\n#define TEX(uv) texture(iChannel0, uv).r\n\n\/\/ polar domain repetition used for the triangle\nvec2 moda(vec2 p, float repetitions)\n{\n\tfloat angle = 2.*3.14\/repetitions;\n\tfloat a = atan(p.y, p.x) + angle\/2.;\n\ta = mod(a,angle) - angle\/2.;\n\treturn vec2(cos(a), sin(a))*length(p);\n}\n\n\/\/ rotation matrix\nmat2 rot (float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }","name":"Common","description":"","type":"common"}]}}