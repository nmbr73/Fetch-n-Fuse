{"Shader":{"ver":"0.1","info":{"id":"Nl3SWs","date":"1645300347","viewed":44,"name":"Remnant Lost","username":"Dave_Hoskins","description":"Buzzing the crash site on Solar Rock 5.","likes":8,"published":3,"flags":104,"usePreview":0,"tags":["3d","raymarching","raymarch","remnant","lost"],"hasliked":0},"renderpass":[{"inputs":[{"id":30,"src":"\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","ctype":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":28267,"src":"https:\/\/soundcloud.com\/sergenarcissovmusic\/space-ambient?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing","ctype":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":37,"channel":0}],"code":"\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\/\/ https:\/\/www.shadertoy.com\/view\/Nl3SWs\n\n#define USE_TEX_NOISE_DERIVATIVE\n\/\/ Uses a texture to store derivative noise data.\n\/\/ Needs only one texture look up.\n\/\/ We can't set buffer sizes, so the speed up is good not that great,\n\/\/ because there's still an enormous amount of texture cache thrashing.\n\/\/ It really needs a 256x256 buffer.\n\n\/\/ PLEASE DO SELECTABLE BUFFER SIZES GUYS!\n\n#define THRESHOLD .1\n#define FAR 2000.0\n#define SCALE 2.8\n#define MINRAD2 .25\nconst float minRad2 = clamp(MINRAD2, 1.0e-9, 1.0);\nconst float absScalem1 = abs(SCALE - 1.0);\nconst float AbsScaleRaisedTo1mIters = pow(abs(SCALE), float(1-10));\nconst vec3 surfaceColour1 = vec3(.4, .0, 0.);\nconst vec3 surfaceColour2 = vec3(.4, .4, 0.4);\nconst vec3 surfaceColour3 = vec3(.4, 0.1, 0.00);\nconst vec4 scale =vec4(SCALE, SCALE, SCALE, abs(SCALE)) \/ minRad2;\n\nconst vec3 sunLight  = normalize( vec3(  1.1, 0.8,  -0.8 ) );\nconst vec3 sunColour = vec3(1.0, .8, .7);\nconst vec3 cloudColour = vec3(.35, .25, .25);\n\nvec3 cameraPos;\nfloat gTime = 0.0;\n\n\n\/\/-------------------------------------------------------------------------------------------------------\n\n#ifdef USE_TEX_NOISE_DERIVATIVE\n\n\/\/ Uses one texture look up...\nvec3 noiseD(in vec2 x) \n{\n    vec2 f = fract(x);\n\/\/    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n\/\/    vec2 du = 30.*f*f*(f*(f-2.0)+1.);\n    vec2 u = f*f*(3.0-2.0*f);\n    vec2 du = 6.0*f*(1.0-f);\n\n\n    ivec2 p = ivec2(floor(x));\n\tvec4 n = texelFetch(iChannel0, p & TWRAP, 0);\n\n\treturn vec3(n.x + n.y * u.x + n.z * u.y + n.w * u.x*u.y,\n\t\t\t\tdu * (n.yz + n.w*u.yx));\n}\n\n#else\n\n\/\/ iq's original code from 'elevated'...\nvec3 noiseD(in vec2 x )\n{\n    vec2 f = fract(x);\n    \n\/\/    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n\/\/    vec2 du = 30.*f*f*(f*(f-2.0)+1.0);\n    vec2 u = f*f*(3.0-2.0*f);\n    vec2 du = 6.0*f*(1.0-f);\n\n    ivec2 p = ivec2(floor(x));\n    float a = texelFetch(iChannel0, p&TWRAP, 0 ).x;\n\tfloat b = texelFetch(iChannel0, (p+ivec2(1,0))&TWRAP, 0 ).x;\n\tfloat c = texelFetch(iChannel0, (p+ivec2(0,1))&TWRAP, 0 ).x;\n   \tfloat d = texelFetch(iChannel0, (p+ivec2(1,1))&TWRAP, 0 ).x;\n\n\treturn vec3(a + (b-a) * u.x+(c-a) *u.y+(a-b-c+d)*u.x*u.y,\n\t\t\t\tdu*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\n}\n\n#endif\n\n\/\/-------------------------------------------------------------------------------------------------------\n\/\/ Basic 3D noise using texture channel...\nfloat noise( in vec3 p )\n{\n    vec3 f = fract(p);\n    p = floor(p);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel3, (uv+ 0.5)\/256.0, 0.0).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n\/\/-------------------------------------------------------------------------------------------------------\n\n#define ANG2 1.2\n#define ANG3 1.4\nconst mat2 rotMat = mat2(cos(ANG2), sin(ANG3), -sin(ANG3), cos(ANG2)) * 2.1;\n\n\/\/-------------------------------------------------------------------------------------------------------\nfloat terrain( in vec2 p, float z)\n{\n\tp = p*0.0015;\n    vec2  d = vec2(0.0);\n    float a = 0.0, b = 120.0;\n    \n    \/\/ Decrease iteration detail with distance...\n    int iter = 13-int(log2(z*.2+.02));\n    iter = clamp(iter, 2,13);\n    \n\tfor (int i = 0; i < iter; i++)\n\t{\n       vec3 n = noiseD(p);\n        \n        d += n.yz;\n        a += b*n.x\/(1.+dot(d,d));\n\t\tb *= 0.47;\n        p = rotMat*p;\n\t} \n\n\treturn a;\n}\n\n\/\/ Faffin' about...\n#define ANG4 0.785398\n#define ANG5 .785398\nconst mat2 rotRemXZ = mat2(cos(ANG4), sin(ANG4), -sin(ANG4), cos(ANG4));\nconst mat2 rotRemXY = mat2(cos(ANG5), sin(ANG5), -sin(ANG5), cos(ANG5));\nmat3 rot3D;\n\/\/-------------------------------------------------------------------------------------------------------\nfloat mapRemnant(vec3 pos) \n{\n\t\n    pos = pos + vec3(300.,200.,-200);\n\n    pos = rot3D * pos;\n\n\t\n    \/\/pos.zy = rotRemXY * pos.zy;\n    \/\/pos.xz = rotRemXZ * pos.xz;\n\n    vec4 p = vec4(pos*0.006,1);\n\n\tvec4 p0 = p;\n\tfor (int i = 0; i < 8; i++)\n\t{\n\t\tp.xyz = clamp(p.xyz, -1.0, 1.0) * 2.0 - p.xyz;\n\n\t\tfloat r2 = dot(p.xyz, p.xyz);\n\t\tp *= clamp(max(minRad2\/r2, minRad2), 0.0, 1.0);\n\n\t\tp = p*scale + p0;\n\t}\n\tfloat l = ((length(p.xyz) - absScalem1) \/ p.w - AbsScaleRaisedTo1mIters) \/.006;\n\n    return l;\n}\n\nvec3 remnantColour(vec3 pos) \n{\n    pos = pos + vec3(300.,200.,-200);\n\tvec4 p = vec4(pos*0.006,1);\n    p.zy = rotRemXY * p.zy;\n    p.xz = rotRemXZ * p.xz;\n\n\n\tvec4 p0 = p;\n\tfloat trap = 1.0;\n    \n\tfor (int i = 0; i < 6; i++)\n\t{\n        \n\t\tp.xyz = clamp(p.xyz, -1.0, 1.0) * 2.0 - p.xyz;\n\n\t\tfloat r2 = dot(p.xyz, p.xyz);\n\t\tp *= clamp(max(minRad2\/r2, minRad2), 0.0, 1.0);\n\n\t\tp = p*scale + p0;\n\t\ttrap = min(trap, r2);\n\t}\n\t\/\/ |c.x|: log final distance (fractional iteration count)\n\t\/\/ |c.y|: spherical orbit trap at (0,0,0)\n\tvec2 c = clamp(vec2( 0.0001*length(p)-1., sqrt(trap) ), 0.0, 1.0);\n\n    float t = mod(length(pos*.006) - gTime*32., 16.0);\n    vec3 surf = mix( surfaceColour1, vec3(.1, 2., 5.), smoothstep(0.0, .3, t) * smoothstep(0.6, .3, t));\n\treturn mix(mix(surf, surfaceColour2, c.y), surfaceColour3, c.x);\n}\n\n\n\/\/-------------------------------------------------------------------------------------------------------\n\/\/ Grab all sky information for a given ray from camera\nvec3 getSky(in vec3 rd)\n{\n\tfloat sunAmount = max( dot( rd, sunLight), 0.0 );\n\tfloat v = pow(1.0-max(rd.y,0.0),5.);\n\tvec3  sky = mix(vec3(.0, .1, .2), cloudColour, v);\n\tsky = sky + sunColour * pow(sunAmount, 4.0) * .2;\n\tsky = sky + sunColour * pow(sunAmount, 800.0)*5.;\n\treturn clamp(sky, 0.0, 1.0);\n}\n\n\n\/\/-------------------------------------------------------------------------------------------------------\n\/\/ Merge grass into the sky background for correct fog colouring...\nvec3 applyFog( in vec3  rgb, in vec3 sky, in float dis,in vec3 pos, in vec3 dir)\n{\n\tfloat fog = exp(-dis*dis* 0.000001);\n    fog = clamp(fog-smoothstep(80.0, 0.0, pos.y)*.3, 0.0, 1.0);\n    \n\treturn mix(sky, rgb, fog);\n\n}\n\n\n\/\/-------------------------------------------------------------------------------------------------------\n\/\/ Calculate sun light...\nvec3  DoLighting(in vec3 dif, in vec3 pos, in vec3 nor, in vec3 eyeDir, in float dis)\n{\n\tfloat h = dot(sunLight,nor);\n\tvec3 mat = dif * sunColour*(max(h, 0.0)+.04);\n    vec3 ref = reflect(eyeDir, nor);\n    mat += sunColour * pow(max(dot(ref, sunLight), 0.0), 80.0)*.5;\n    \n     \n    return min(mat, 1.0);\n}\n\n\n\/\/-------------------------------------------------------------------------------------------------------\n\/\/ Map the whole scene with two objects...\nfloat map(vec3 p, float z)\n{\n    return  min(p.y-terrain(p.xz, z), mapRemnant(p));\n}\n\n\/\/-------------------------------------------------------------------------------------------------------\n\n\/\/ March the whole scene...\nfloat rayMarch(in vec3 rO, in vec3 rD, in float st)\n{\n    float t = st;\n\tfloat d = 0.;\n\n    float oldT = t;\n    \n    vec3 p;\n\n\tfor(int j = min(0, iFrame); j < 160 && t < FAR; j++)\n\t{\n\t    p = rO + t*rD;\n        d = map(p, t);\n        if (abs(d) < THRESHOLD) break;\n        oldT = t;\n        t += d;\/\/ + t * 0.001; \/\/ Adding the current 't' thins out the Box too much.\n\t}\n \n\treturn t;\n}\n\n\/\/-------------------------------------------------------------------------------------------------------\nvec3 CameraPath( float t )\n{\n    vec2 p = vec2(240.+1200.0 * sin(1.4*t), 800.0 * cos(1.*t) );\n\treturn vec3(p.x,   terrain(p, 9000.)+95.0+cos(gTime*3.-2.7)*50.0, p.y);\n} \n\n\n\/\/-------------------------------------------------------------------------------------------------------\nvec3 getNormal(vec3 p, float dis)\n{\n    dis = dis*2.\/iResolution.y;\n\tvec2 e = vec2(0,clamp(dis*dis, .001, 144.));\n\treturn normalize(map(p, 0.0)-vec3(map(p - e.yxx, 0.0), map(p - e.xyx, 0.0), map(p - e.xxy, 0.0)));\n}\n\n\/\/------------------------------------------------------------------------------\nfloat shadow( in vec3 ro, in vec3 rd, in float dis)\n{\n\tfloat res = 1.0;\n    float t = 20.;\n\tfloat h;\n\t\n    for (int i = 0; i < 25; i++)\n\t{\n        vec3 p =  ro + rd*t;\n\n\t\th = map(p, dis);\n\t\tres = min(.2*h \/ t*t, res);\n\t\tt += h+3.;\n\t}\n    return clamp(res, .2, 1.0);\n}\n\n\n\/\/-------------------------------------------------------------------------------------------------------\nvec3 getDiffuse(vec3 pos, vec3 dir,  vec3 nor, float dis)\n{\n    vec3 dif = vec3(0);\n    if ((pos.y-terrain(pos.xz, dis)) < THRESHOLD)\n    {\n        float n = cos(pos.y*.03+pos.x*.01+.8)*.5+.5;\n    \n        dif = vec3(mix(vec3(.9,.5,.3), vec3(1.0, .8, .7), n));\n        float s = max(0.,nor.y*nor.y);\n        dif = mix(dif, vec3(s*.3, s*.3,.1), clamp(nor.x+nor.z, 0.0, .8));\n     }else\n     {\n         \/\/float n = noise(pos*.3);\n         dif = vec3(.2,0,0);\n         dif = remnantColour(pos);\n     }\n    return dif;\n}\n\n\n\/\/-------------------------------------------------------------------------------------------------------\nvec3 cw, cu, cv;\nvec3 getCamera(vec2 uv)\n{\n    vec3 camTar;\n\tcameraPos = CameraPath(gTime + 0.0);\n\n\tcamTar\t = CameraPath(gTime + .3);\n\n    camTar.y = cameraPos.y;\n\t\n\tfloat roll = .4*sin(gTime+.5);\n\tcw = normalize(camTar-cameraPos);\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\n\tcu = cross(cw,cp);\n\tcv = cross(cu,cw);\n    return normalize(uv.x*cu + uv.y*cv + 1.*cw);;\n}\n\n\n\/\/-------------------------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\tfloat m = (iMouse.x\/iResolution.x)*50.0;\n\tgTime = (iTime*.8+m+403.0)*.1;\n    vec2 xy = fragCoord.xy \/ iResolution.xy;\n\tvec2 uv = (-1.0 + 2.0 * xy) * vec2(iResolution.x\/iResolution.y,1.0);\n\n    rot3D = rotateY(0.785398) * rotateX(0.785398);\n\n    if (abs(xy.y -.5) > .37)\n\t{\n\t\t\/\/ Top and bottom cine-crop - what a waste! :)\n\t\tfragColor=vec4(vec4(0.0));\n\t\treturn;\n\t}\n\n    vec3 dir = getCamera(uv);\n\n\tvec3 col;\n\tfloat dist;\n\n    float st = hash12(uvec2(fragCoord*iTime))*50.;\n\tdist = rayMarch(cameraPos, dir, st);\n    \n    vec3 sky = getSky(dir);\n    \n\tif (dist >= FAR)\n    {\n\t\t\/\/ Completely missed the scene...\n\t\tcol = sky;\n\t}\n\telse\n\t{\n        \/\/ Render the objcets...\n        vec3 pos = cameraPos + dist * dir;\n        vec3 nor = getNormal(pos, dist);\n        vec3 dif = getDiffuse(pos, dir, nor, dist);\n        col = DoLighting(dif, pos, nor,dir, dist);\n        col *= shadow( pos, sunLight, dist);\n        col = applyFog(col, sky, dist, pos, dir);\n\t}\n\n\n    \/\/ My usual Sun flare stuff...\n\tfloat bri = dot(cw, sunLight)*.75;\n\tif (bri > 0.0)\n\t{\n\t\tvec2 sunPos = vec2( dot( sunLight, cu ), dot( sunLight, cv ) );\n\t\tvec2 uvT = uv-sunPos;\n\t\tuvT = uvT*(length(uvT));\n\t\tbri = pow(bri, 6.0)*.8;\n\n\t\t\/\/ glare = the red shifted blob...\n\t\tfloat glare1 = max(dot(normalize(vec3(dir.x, dir.y+.3, dir.z)),sunLight),0.0)*1.4;\n\t\t\/\/ glare2 is the cyan ring...\n\t\tfloat glare2 = max(1.0-length(uvT+sunPos*.5)*4.0, 0.0);\n\t\tuvT = mix (uvT, uv, -2.3);\n\t\t\/\/ glare3 is a purple splodge...\n\t\tfloat glare3 = max(1.0-length(uvT+sunPos*5.0)*1.2, 0.0);\n\n\t\tcol += bri * vec3(1.0, .0, .0)  * pow(glare1, 12.5)*.1;\n\t\tcol += bri * vec3(.2, 1.0, 1.) * pow(glare2, 2.0)*3.;\n\t\tcol += bri * sunColour * pow(glare3, 2.0)*3.5;\n\t}\n    \n    \/\/ Post screen effects...\n    \/\/col = smoothstep(0.0, 1.0, col);\n    \/\/ Contrast...\n    col = col*.3 + (col*col*(3.0-2.0*col))*.7;\n    \/\/ Gamma...\n    col = sqrt(col);\n\t\n\tfragColor=vec4(col,1.0);\n}\n\n\/\/-------------------------------------------------------------------------------------------------------","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":257,"channel":0}],"code":"\/\/ Create derivative noise texture\n\/\/ PLEASE DO SELECTABLE BUFFER SIZES GUYS!\n\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat derivHash(ivec2 q2)\n{\n   uvec2 q = uvec2((q2+10) & TWRAP);  \/\/ ...Seeded and wrapped.\n   float f = hash12(q);\n   return pow(f, 2.)*1.5;\n}\n\n\nvoid mainImage( out vec4 colour, in vec2 coord )\n{\n\n\/\/ Draw it ony once to relavent area...\n\n\/\/ It seems the buffers are also doubled as I need to draw 2 frames...\n  if (iFrame < 2 && coord.x < TSIZE && coord.y < TSIZE)\n  {\n\n    vec4 data, n;\n    ivec2 co = ivec2(floor(coord));\n\n    float a = derivHash(co);\n    float b = derivHash((co+ivec2(1,0)));\n    float c = derivHash((co+ivec2(0,1)));\n    float d = derivHash((co+ivec2(1,1)));\n\n\/\/ Pre-calc all the sums...\n    data.x = a;\t \t\t\n    data.y = b-a; \t\t\t\n    data.z = c-a; \t\t\t\n    data.w = a - b - c + d;\n\n    colour = data;\n  }\n  else discard;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define TSIZE 256.\n#define TWRAP 255\n\n\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UIF (1.0 \/ float(0xfffffffeU))\n\nfloat hash12(uvec2 q)\n{\n\tq *= UI2;\n\tuint n = (q.x ^ q.y) * UI0;\n\treturn float(n) * UIF;\n}\n\nvec2 hash22(vec2 vq)\n{\n    uvec2 q = uvec2(vq);\n\n\tq *= UI2;\n\tq = (q.x ^ q.y) * UI2;\n\treturn vec2(q) * UIF;\n}\n\/\/----------------------------------------------------------------------------------------\nvec2 noise2D( in vec2 n )\n{\n    vec2 p = floor(n);\n    n = fract(n);\n    n = n*n*(3.0-2.0*n);\n    \n    vec2 res = mix(mix( hash22(p), hash22(p+vec2(1.0 ,0.0)),n.x),\n                    mix( hash22(p + vec2(0.0,1.0)), hash22(p + vec2(1.0,1.0)),n.x),n.y);\n    return res;\n}\n\nfloat sMin( float a, float b, float k )\n{\n    \n\tfloat h = clamp(0.5 + 0.5*(b-a)\/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.-h);\n}\n\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n\/\/ Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n\/\/ Rotation matrix around the Z axis.\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[],"code":"\n\/\/----------------------------------------------------------------------------------------\nvec2 mainSound( in int samp, float time )\n{\n    \n\t\/\/ Engine noise...\n    vec2 noi = (noise2D(vec2(time*340.0))-.5)*.5 * noise2D(vec2(time*.3));\n    noi += (noise2D(vec2(time*600.0))-.5)*.5 * noise2D(vec2(time*.2+20.0));\n    noi += (noise2D(vec2(time*40.0))-.5)*.8 *  noise2D(vec2(time*2.+100.0));\n    \n    \n    noi *= smoothstep(0.0, 4.0,time) * smoothstep(180.0, 170.0,time);\n    return noi;\n}","name":"Sound","description":"","type":"sound"}]}}