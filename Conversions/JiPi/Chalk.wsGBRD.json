{"Shader":{"ver":"0.1","info":{"id":"wsGBRD","date":"1606669381","viewed":862,"name":"chalk","username":"flockaroo","description":"chalk drawing on blackboard","likes":31,"published":3,"flags":32,"usePreview":0,"tags":["effect","chalk","npr"],"hasliked":0},"renderpass":[{"inputs":[{"id":30,"src":"\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":258,"src":"\/media\/previz\/buffer01.png","ctype":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":37,"channel":0}],"code":"\/\/ created by florian berger (flockaroo) - 2020\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ trying to resemle some chalk on blackboard hand drawing style\n\n\n#define PI2 6.28318530717959\n#define N(a) ((a).yx*vec2(1,-1))\n#define AngleNum 5\n#define SampNum 24\n\n#define Res0 vec2(textureSize(iChannel0,0).xy)\n#define Res1 vec2(textureSize(iChannel1,0).xy)\n#define Res2 vec2(textureSize(iChannel2,0).xy)\n\n#define Res  iResolution.xy\n\n#define randSamp iChannel1\n#define colorSamp iChannel0\n\n#define zoom 1.\n\n\nvec4  getRand(vec2 pos)\n{\n    return texture(iChannel1,pos\/Res1\/iResolution.y*1200.);\n}\n\n#define UVScale (vec2(Res0.y\/Res0.x,1)\/Res.y)\n\nconst float BlackFill=1.;\nconst float bright=1.1;\nconst float contourStrength=1.;\nconst float reflection=.5;\nconst float reflectStrength=.3;\nconst float reflectSize=.35;\n#define reflectPos (Res*(.2+.15*sin(iTime+vec2(0,2.))))\nconst vec3 paperTint=vec3(1,.85,.9)*.8;\n\n#define OutlineOffs 0.\n\nvec4 getCol(vec2 pos)\n{\n    pos=(pos-.5*Res.xy)*zoom+.5*Res.xy;\n    vec2 r0=texture(iChannel0,.5\/Res).zw;\n    vec2 sc=mix(r0.y\/Res0.y,r0.x\/Res0.x,.5)\/Res;    \/\/ compromise between \"fit all\" and \"fit one\"\n    vec2 uv = pos*sc+.5*(r0\/Res0-Res*sc);\n    uv=clamp(uv,.5\/Res0,1.-.5\/Res0);\n    return (1.-bright*texture(iChannel0,uv).zzzw);\n}\n\nvec2 getGrad(vec2 pos, float eps)\n{\n    pos=(pos-.5*Res.xy)*zoom+.5*Res.xy;\n    vec2 r0=texture(iChannel0,.5\/Res).zw;\n    vec2 sc=mix(r0.y\/Res0.y,r0.x\/Res0.x,.5)\/Res;    \/\/ compromise between \"fit all\" and \"fit one\"\n    vec2 uv = pos*sc+.5*(r0\/Res0-Res*sc);\n    uv=clamp(uv,.5\/Res0,1.-.5\/Res0);\n    return (contourStrength)*texture(iChannel0,uv).xy*r0\/Res.xy;\n}\n\nconst float flicker=1.;\nconst float flickerFreq=10.;\n\nfloat htPattern(vec2 pos, float phase)\n{\n    float pat=0.;\n    float cnt=0.;\n    vec2 offs=vec2(.001,.1)*floor(iTime*flickerFreq)\/10.*flicker;\n    float phaseOffs = 10.*getRand(floor(iTime*flickerFreq)*vec2(.01,.1)).x*flicker;\n    vec2 gr=\/*getGrad(floor(pos\/13.)*13.,1.)+*\/1.01*normalize(pos-.5*Res);\n    for(float ang=0.0;ang<PI2;ang+=PI2\/4.3)\n    {\n        vec2 b=normalize(sin(vec2(0,PI2\/4.) + ang + phase + phaseOffs + 0.6 )*vec2(.5,1.5));\n        vec2 uv=((pos.x-pos.y*pos.y*.0004)*b+(pos.y+pos.x*pos.x*.0004)*N(b))\/Res1*vec2(7,.3)*.3;\n        pat+=.5*texture(iChannel1,uv*.25+offs).x;\n        pat+=1.*texture(iChannel1,uv+offs).x;\n        cnt+=1.5;\n    }\n    return pat\/cnt; \n}\n\nfloat halfTone(float val,vec2 pos, float phase)\n{\n    return smoothstep(.6,1.4,val+htPattern(pos,phase));\n}\n\nconst float BGAlpha=0.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord+0.0*sin(iTime*1.*vec2(1,1.7))*iResolution.y\/400.;\n    vec2 pos0=pos;\n    vec3 col = vec3(0);\n    vec3 col2 = vec3(0);\n    float sum=0.;\n  \tvec2 g0=getGrad(pos,1.);\n  \tfloat dang=PI2\/float(AngleNum);\n    for(int i=0;i<AngleNum;i++)\n    {\n        float ang=dang*float(i)+.1;\n        vec2 v=sin(vec2(PI2\/4.,0)+ang);\n        for(int j=0;j<SampNum;j++)\n        {\n            vec2 dpos  = v.yx*(vec2(1,-1)*float(j)*iResolution.y\/25.\/float(SampNum)+OutlineOffs*Res.x\/15.);\n            vec2 dpos2 = v.xy*(float(j*j)\/float(SampNum*SampNum)*.3\n                               \/\/*(length(100.*g0)) \/\/ higher\/lower gradients get curved\/hatched\n                               +.08)*iResolution.y\/25.;\n\t        vec2 g;\n            float fact=1.;\n            float fact2;\n\n            for(float s=-1.;s<=1.;s+=2.)\n            {\n                vec2 pos2=pos+1.0\/zoom*(s*dpos+dpos2);\n                vec2 pos3=pos+1.0\/zoom*(s*dpos+dpos2).yx*vec2(1,-1)*2.;\n                float ht=1.;\n            \tg=getGrad(pos2,1.)*ht;\n                g*=pow(getRand(pos2*.8*iResolution.y\/1080.).x*2.,4.*sqrt(iResolution.y\/1200.));\n                \n            \tfloat fact3=dot(g,v)-.5*abs(dot(g,v.yx*vec2(1,-1)))\/**(1.-getVal(pos2))*\/;\n            \tfact2=dot(normalize(g+vec2(.0001)),v.yx*vec2(1,-1));\n             \n                fact3=clamp(fact3,0.,0.05);\n                fact2=abs(fact2);\n                \n                fact3*=1.-1.*float(j)\/float(SampNum);\n                fact*=fact3;\n            \tcol += .3*fact3;\n             \tsum+=fact2;\n            }\n          \tcol += 2.*pow(fact,.5);\n        }\n    }\n    col\/=float(SampNum*AngleNum)*.75\/sqrt(iResolution.y);\n    col2\/=sum;\n    col=1.-col*1.2;\n    col*=col*col;\n    \n\n    vec2 s=sin(pos.xy*.1\/sqrt(iResolution.y\/400.));\n    float r=length(pos-iResolution.xy*.5)\/iResolution.x;\n    float vign=1.-r*r*r;\n    vec3 c=getCol(pos).xyz;\n    float bright=dot(getCol(pos).xyz,vec3(.3333));\n    float blackTone=halfTone(bright*1.5+.25,(pos0-Res*.5)*zoom,floor(sqrt(bright)*8.)\/8.*2.7);\n\n    blackTone = mix(1.,     blackTone,BlackFill);\n    float refl=clamp(pow((col.x*(blackTone)),1.),0.,1.);\n    vec3 col3= paperTint;\n    col3*=vec3(col.x)*blackTone;\n    col3+=.1*getRand(pos*.7).xxx;\n    col3*=(1.-.65*texture(iChannel2,fragCoord\/iResolution.xy).xyz);\n    \n\tfragColor = vec4(col3*.9+.2*getRand(pos*.7).xyz-.2*getRand(pos*.7-.6).xyz,1);\n\tfloat reflEnv=clamp((sin(fragCoord.x\/iResolution.x*7.+2.5+1.7*iTime))*(fragCoord.y\/iResolution.y),0.,1.);\n\tvec2 reflp=reflectPos*vec2(1,-1)+vec2(0,iResolution.y); \n\tif(iMouse.x>0.5) reflp=iMouse.xy;\n\treflEnv = exp(-pow(length(reflp-fragCoord)\/iResolution.x\/reflectSize,2.));\n\tfragColor.xyz=1.-fragColor.xyz;\n\tfragColor.xyz+=refl*vec3(.8,.9,1.)*1.1*reflEnv*reflectStrength;\n\tfragColor.w=mix(1.,1.-min(min(fragColor.x,fragColor.y),fragColor.z),BGAlpha);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":30,"src":"\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":36,"src":"\/media\/a\/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","ctype":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":257,"channel":0}],"code":"\/\/ created by florian berger (flockaroo) - 2020\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ trying to resemle some chalk on blackboard hand drawing style\n\n\/\/ this buffer holds the prerendered the gradient\n\n#define Res0 vec2(textureSize(iChannel0,0).xy)\n#define Res1 vec2(textureSize(iChannel1,0).xy)\n\n#define Res  iResolution.xy\n\n#define randSamp iChannel1\n#define colorSamp iChannel0\n\n\nvec4 getRand(vec2 pos)\n{\n    return texture(iChannel1,pos\/Res1\/iResolution.y*1200.);\n}\n\n#define UVScale (vec2(Res0.y\/Res0.x,1)\/Res.y)\n\nvec4 getCol(vec2 pos)\n{\n    vec2 uv=pos\/Res0.xy;\n    uv=clamp(uv,0.5\/Res0,1.-.5\/Res0);\n    vec4 c1=texture(iChannel0,uv);\n    float d=clamp(dot(c1.xyz,vec3(-.5,1.,-.5)),0.0,1.0);\n    vec4 c2=vec4(.5);\n    return min(mix(c1,c2,1.8*d),.7);\n}\n\nvec4 getColHT(vec2 pos)\n{\n \treturn smoothstep(.95,1.05,getCol(pos)+getRand(pos*.2));\n}\n\nfloat getVal(vec2 pos)\n{\n    vec4 c=getCol(pos);\n \treturn dot(c.xyz,vec3(.333));\n}\n\n#define SQR3 1.73205081\nvec2 getGrad(vec2 pos, float eps)\n{\n   \tvec3 d=vec3(eps\/UVScale\/Res0,0);\n    pos-=.33*d.xy;\n    float v0=getVal(pos);\n    return (vec2(getVal(pos+d.xz),getVal(pos+d.zy))-v0)\/d.xy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ResN = Res0;\n    ResN *= min(ResN.y,Res.y)\/ResN.y;\n    ResN *= min(ResN.x,Res.x)\/ResN.x;\n    vec2 fc=fragCoord.xy*Res0\/ResN;\n    fragColor.xy = getGrad(fc,.15);\n    fragColor.z=getVal(fc);\n    if(fragCoord.x<1. && fragCoord.y<1.)\n    fragColor.zw = ResN;\n    if(fragCoord.x>ResN.x || fragCoord.y>ResN.y) \n    {\n        fragColor=vec4(0,0,0,1);\n        \/\/discard;\n    }\n}\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":30,"src":"\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":258,"channel":0}],"code":"\/\/ created by florian berger (flockaroo) - 2020\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ trying to resemle some chalk on blackboard hand drawing style\n\n\nmat2 ROTM(float ang) { return mat2(cos(ang),sin(ang),-sin(ang),cos(ang)); }\n\nvec2 quad01(int idx) { return idx<3?vec2(idx%2,idx\/2):1.-vec2((5-idx)%2,(5-idx)\/2); }\n\nvec4 getRand(int idx) {\n    ivec2 res=textureSize(iChannel0,0);\n    return texelFetch(iChannel0,ivec2(idx%res.x,(idx\/res.x)%res.y),0); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float StrokeLen=1.2;\n    float StrokeW=.4;\n    int NumStrokes=3;\n    int NumBatches=40;\n    \n    vec3 c=vec3(0);\n    \n    for(int i=0;i<NumStrokes*NumBatches;i++){\n    vec2 sc=fragCoord\/iResolution.xy*2.-1.;\n    int strokeIdx=i;\n    int strokeIdx0=strokeIdx;\n    strokeIdx=strokeIdx%NumStrokes;\n    int batchIdx=strokeIdx0\/NumStrokes;\n    float ang=float(batchIdx)*.17+floor(iTime*3.);\n    float dang=(float(strokeIdx%2)-.5)*StrokeW\/StrokeLen*1.2;\n    mat2 m=ROTM(dang);\n    vec2 sc0=(getRand(batchIdx).zw-.5)*2.;\n    sc-=sc0;\n    sc=ROTM(ang)*sc;\n    \/\/sc0=vec2(0);\n    float strokeFact=float(strokeIdx)\/float(NumStrokes)-.5;\n    \/\/float segFact=sc.x\/(StrokeLen*.5);\n    sc+=StrokeW*.8*float(NumStrokes)*vec2(0,.7*strokeFact);\n    sc=ROTM(dang)*sc;\n    vec2 uv=sc\/(vec2(StrokeLen,StrokeW));\n    \/\/uv=m*uv;\n    uv.y+=uv.x*uv.x*1.5;\n    uv+=.5;\n    vec4 r=textureLod(iChannel0,(uv+vec2(0,i))*vec2(.02,1.),1.7);\n    vec3 s;\n    s = clamp(vec3(0) + r.x,0.,1.);\n    s*=mix(exp(-12.*uv.x)+exp(-12.*(1.-uv.x)),1.,.5);\n    float a=1.+r.x;\n    a*=1.-smoothstep(0.85,1.,abs(uv.x-.5)*2.);\n    a*=1.-smoothstep(0.85,1.,abs(uv.y-.5)*2.);\n    a*=.3;\n    a=clamp(a,0.,1.);\n    c=c*(1.-a)+s*a;\n    }\n    \n    fragColor.xyz=c;\n    fragColor.w=1.;\n}\n\n","name":"Buffer B","description":"","type":"buffer"}]}}