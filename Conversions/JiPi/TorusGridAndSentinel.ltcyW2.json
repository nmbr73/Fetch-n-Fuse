{"Shader":{"ver":"0.1","info":{"id":"ltcyW2","date":"1534118766","viewed":1058,"name":"Torus, Grid and Sentinel","username":"emh","description":"Force directed graph layout with help of Z-order sorted particles. 60 FPS on Radeon 7870. Key LEFT arrow to reset. Should work also in full screen after reset but prettier windowed (added blur to mitigate sharpness).","likes":22,"published":3,"flags":48,"usePreview":0,"tags":["graph","sort","physics","force","layout"],"hasliked":0},"renderpass":[{"inputs":[{"id":259,"src":"\/media\/previz\/buffer02.png","ctype":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":260,"src":"\/media\/previz\/buffer03.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":37,"channel":0}],"code":"\/\/ vertical Gaussian blur pass\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixelSize = 1.\/ iChannelResolution[0].xy;\n    vec2 uv = fragCoord.xy * pixelSize;\n\n    float v = pixelSize.y;\n\tvec4 sum = vec4(0.0);\n\tsum += texture(iChannel0, fract(vec2(uv.x, uv.y - 4.0*v)) ) * 0.05;\n\tsum += texture(iChannel0, fract(vec2(uv.x, uv.y - 3.0*v)) ) * 0.09;\n\tsum += texture(iChannel0, fract(vec2(uv.x, uv.y - 2.0*v)) ) * 0.12;\n\tsum += texture(iChannel0, fract(vec2(uv.x, uv.y - 1.0*v)) ) * 0.15;\n\tsum += texture(iChannel0, fract(vec2(uv.x, uv.y + 0.0*v)) ) * 0.16;\n\tsum += texture(iChannel0, fract(vec2(uv.x, uv.y + 1.0*v)) ) * 0.15;\n\tsum += texture(iChannel0, fract(vec2(uv.x, uv.y + 2.0*v)) ) * 0.12;\n\tsum += texture(iChannel0, fract(vec2(uv.x, uv.y + 3.0*v)) ) * 0.09;\n\tsum += texture(iChannel0, fract(vec2(uv.x, uv.y + 4.0*v)) ) * 0.05;\n    \n    fragColor.xyz = sum.xyz\/0.98; \/\/ normalize\n\tfragColor.a = 1.;\n    \n    fragColor = (fragColor + texture(iChannel1, uv)) \/ 2.0;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"precision highp float;\nprecision highp int;\n\n#define mortonBuffer iChannel0\n#define sortedBuffer iChannel0\n#define particleBuffer iChannel0\n#define pixelNearestBuffer iChannel1\n\n\/\/#define maxRes min(vec2(800.0, 450.0), iResolution.xy)\n#define maxRes min(vec2(512.0, 512.0), iResolution.xy)\n\/\/#define maxRes min(vec2(128.0, 128.0), iResolution.xy)\n\/\/#define maxRes min(vec2(512.0, 256.0), iResolution.xy)\n\/\/#define maxRes min(vec2(iResolution.x, 256.0), iResolution.xy)\n\/\/#define maxRes min(vec2(512.0, iResolution.y), iResolution.xy)\n\/\/#define maxRes iResolution.xy\n#define realRes iResolution.xy\n#define powerOfTwoRes vec2(2048.0, 2048.0)\n\/\/#define realRes maxRes\n\/\/#define maxRes iResolution.xy\n\n\/\/ Try this true for more Matrix fun :)\nconst bool justSentinels = false;\n\n\/\/ number of particles will be 2^magicNumberDoNotChange = 64k\n\/\/ I haven't figured out why it seems to work only when this number is 16\nconst int magicNumberDoNotChange = 16;\nconst int MAX_ITER = 12;\nconst int maxBin = 32;\nconst int vec4Count = 1;\n#define PART part\nconst float M_PI = 3.14159265358979323846264338327950288;\n\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 \/ 3.0, 1.0 \/ 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nint getMaxPasses2(vec2 res) {\n    return int(ceil(log2(res.x * res.y)));\n}\n\nstruct mPartitionData {\n    int partitionCount;\n    int maxIndex;\n    int particlesPerPartition;\n    int index;\n    int partitionIndex;\n    int offset;\n    int pastIndex;\n    int futureIndex;\n    ivec2 futureCoord;\n    vec4 futureParticle;\n    bool overflow;\n};\n    \nvec2 extractPosition(vec4 data) {\n    return data.yz;\n}\n\n\/\/ BEGIN QUALITY HASHES\n\nuint baseHash(uvec2 p)\n{\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\n\n\/\/---------------------2D input---------------------\n\nfloat hash12(uvec2 x)\n{\n    uint n = baseHash(x);\n    return float(n)*(1.0\/float(0xffffffffU));\n}\n\nvec2 hash22(uvec2 x)\n{\n    uint n = baseHash(x);\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU))\/float(0x7fffffff);\n}\n\nvec3 hash32(uvec2 x)\n{\n    uint n = baseHash(x);\n    uvec3 rz = uvec3(n, n*16807U, n*48271U);\n    return vec3(rz & uvec3(0x7fffffffU))\/float(0x7fffffff);\n}\n\nvec4 hash42(uvec2 x)\n{\n    uint n = baseHash(x);\n    uvec4 rz = uvec4(n, n*16807U, n*48271U, n*69621U); \/\/see: http:\/\/random.mat.sbg.ac.at\/results\/karl\/server\/node4.html\n    return vec4(rz & uvec4(0x7fffffffU))\/float(0x7fffffff);\n}\n\n\/\/--------------------------------------------------\n\n\n\/\/Example taking an arbitrary float value as input\n\/*\n\tThis is only possible since the hash quality is high enough so that\n\tfloored float input doesn't break the process when the raw bits are used\n*\/\nvec4 hash42(vec2 x)\n{\n    uint n = baseHash(floatBitsToUint(x));\n    uvec4 rz = uvec4(n, n*16807U, n*48271U, n*69621U);\n    return vec4(rz & uvec4(0x7fffffffU))\/float(0x7fffffff);\n}\n\n\/\/ END QUALITY HASHES\n\n\nfloat hash( uvec2 x )\n{\n    uvec2 q = 1103515245U * ( (x>>1U) ^ (x.yx   ) );\n    uint  n = 1103515245U * ( (q.x  ) ^ (q.y>>3U) );\n    return float(n) * (1.0\/float(0xffffffffU));\n}\n\nvec2 getRes(vec2 res) {\n    \/\/return vec2(exp2(ceil(log2(max(res.x, res.y)))));\n    return powerOfTwoRes;\n}\n\nint toIndexCol(in vec2 fragCoord, in vec2 resolution, inout vec3 col) {\n    int xl = int(fragCoord.x);\n    int yl = int(fragCoord.y);\n    ivec2 res = ivec2(resolution);\n    int div2 = 1;\n    \/*\n    for (int i = 0; i < MAX_ITER; i++) {\n        res \/= 2;\n        div2 *= 2;\n        if (res.x == 0 && res.y == 0) break;\n    }\n    res = ivec2(div2);\n\t*\/\n    int index = 0;\n    int div = 1;\n    div2 = 1;\n    bool colorDone = false;\n    for (int i = 0; i < MAX_ITER; i++) {\n        ivec2 rest = res % 2;\n        res \/= 2;\n        if (res.x == 0 && res.y == 0) break;\n        div *= 4;\n        div2 *= 2;\n        int x = int(xl >= res.x);\n        int y = int(yl >= res.y);\n        xl -= x * res.x;\n        yl -= y * res.y;\n        \/\/res += x * rest.x;\n        \/\/res += y * rest.y;\n        int thisIndex = y * 2 + x;\n        index = index * 4 + thisIndex;\n\n        if (!colorDone) {\n            vec2 uv = vec2(xl, yl) \/ vec2(res);\n            vec2 center = vec2(0.5);\n            float d = distance(uv, center);\n            float r = float(d < 0.25);\n            bool border = d > 0.25 - 0.02 \/ float(div2) && d < 0.25;\n            if (border) {\n                colorDone = true;\n            } else {\n            \tcol = vec3(float(int(col) ^ int(r)));\n            }\n        }\n    }\n    \/\/return res.x * res.y - index - 1;\n    return index;\n}\n\nint toIndexFull(in vec2 fragCoord, in vec2 resolution) {\n    vec3 col = vec3(0.0);\n    int index = toIndexCol(fragCoord, resolution, col);\n    \/\/index += 1;\n    return index;\n}\n\nivec2 fromIndexFull(in int index, in vec2 resolution) {\n    \/\/index -= 1;\n    ivec2 fc = ivec2(0);\n    int div = 1;\n    ivec2 div2 = ivec2(1);\n    ivec2 res = ivec2(resolution);\n    \/\/index = res.x * res.y - index - 1;\n    for (int i = 0; i < MAX_ITER; i++) {\n        res \/= 2;\n        \/\/int rx = res.x % 2 == 0 ? 2 : 1;\n        \/\/int ry = res.y % 2 == 0 ? 2 : 1;\n\n        int thisIndex = index % 4;\n        fc.x += div2.x * (thisIndex % 2);\n        fc.y += div2.y * (thisIndex \/ 2);\n        index = index \/ 4;\n\n        div2 *= 2;\n        if (index == 0) break;\n    }\n    return fc;\n}\n\nivec2 fromLinear(in int index, in vec2 resolution) {\n    \/\/index -= 1;\n    return ivec2(index % int(resolution.x), index \/ int(resolution.x));\n}\n\nint toLinear(in vec2 fragCoord, in vec2 resolution) {\n    int index = int(fragCoord.x) + int(fragCoord.y) * int(resolution.x);\n    \/\/index += 1;\n    return index;\n}\n\n#define toIndex(a) toIndex2(mortonBuffer, a, realRes)\nint toIndex2(in sampler2D channel, in vec2 fragCoord, in vec2 res) {\n    ivec2 fc = ivec2(fragCoord * res);\n    vec4 index = texelFetch(channel, fc, 0);\n    return int(index.w);\n}\n\nvec2 getPosition(sampler2D channel, int index, vec2 res) {\n    ivec2 fc = fromLinear(index, res);\n    vec4 data = texelFetch(channel, fc, 0);\n    return fract(extractPosition(data));\n}\n\nint maxLinear(vec2 res) {\n    return int(exp2(floor(log2(float(toLinear(res - 1.0, res))))));\n}\n\nbool isLinearValid(in int index, vec2 iResolution) {\n    vec2 res = iResolution.xy;\n    \/\/return true;\n\treturn index < maxLinear(iResolution);\n}\n\nbool isValid(in vec2 fragCoord, vec2 iResolution) {\n    vec2 res = iResolution.xy;\n    return isLinearValid(toLinear(fragCoord, res), iResolution);\n}\n\n#define getPartitionData(a, b, c) getPartitionData2(a, b, c, realRes)\nmPartitionData getPartitionData2(sampler2D channel, vec2 fragCoord, vec2 res, vec2 rRes) {\n    \/\/fragCoord = fragCoord \/ rRes * res;\n    mPartitionData mRet;\n    \/\/int maxPasses = getMaxPasses(res);\n    \/\/mRet.partitionCount = int(exp2(ceil(log2(float(maxPasses)))));\n    mRet.partitionCount = magicNumberDoNotChange;\n    \/\/mRet.maxIndex = toLinear(res - 1.0, res);\n    mRet.maxIndex = maxLinear(res);\n    mRet.particlesPerPartition = mRet.maxIndex \/ mRet.partitionCount;\n    mRet.index = toLinear(fragCoord, res);\n    mRet.partitionIndex = mRet.index \/ mRet.particlesPerPartition;\n    mRet.offset = mRet.index % mRet.particlesPerPartition;\n    mRet.futureIndex = mRet.index - mRet.particlesPerPartition;\n    mRet.futureCoord = fromLinear(mRet.futureIndex, res);\n    mRet.futureParticle = texelFetch(channel, mRet.futureCoord, 0);\n    mRet.pastIndex = mRet.index + mRet.particlesPerPartition;\n    mRet.overflow = mRet.index >= mRet.maxIndex;\n    \n    \/\/(mRet.partitionIndex - 1) * mRet.particlesPerPartition + mRet.offset;\n\n\n    return mRet;\n}\n\nint getMaxPartition(mPartitionData pd) {\n    \/\/ TODO: optimize \/ hardcode\n    int k = 0;\n    for (int i = 0; i <= pd.partitionCount; i++) {\n        int n = 1 << i;\n\t\tif (2 * n > pd.particlesPerPartition || pd.particlesPerPartition % n != 0) break;\n        k = i;\n    }\n    return k + 1;\n    \/\/return k;\n}\n\nstruct mRet {\n    int dIndex;\n    int Am;\n    vec4 vi;\n    vec4 v;\n    vec2 pos;\n    bool valid;\n};\n\n#define getMD(a, b, c) getMD2(particleBuffer, mortonBuffer, a, b, c, realRes)\nmRet getMD2(sampler2D channel, sampler2D mchannel, int part, int m, vec2 res, vec2 rRes) {\n    vec2 fc = vec2(fromLinear(m, res));\n    vec4 v = texelFetch(channel, ivec2(fc), 0);\n    vec2 pos = extractPosition(v);\n    int Am = toIndex2(mchannel, pos, rRes);\n    int maxIndex = toLinear(res - 1.0, res);\n    bool valid = m >= 0 && m <= maxIndex && isLinearValid(m, res);\n    \/\/valid = true;\n    return mRet(m, Am, vec4(0.0), v, pos, valid);\n}\n\n#define getM(a, b, c) getM2(sortedBuffer, particleBuffer, mortonBuffer, a, b, c, realRes)\nmRet getM2(sampler2D channel, sampler2D pchannel, sampler2D mchannel, int part, int m, vec2 res, vec2 rRes) {\n    vec2 fc = vec2(fromLinear(m, res));\n    vec4 v = texelFetch(channel, ivec2(fc), 0);\n    mRet ret2 = getMD2(pchannel, mchannel, part, int(v[part]), res, rRes);\n    int maxIndex = toLinear(res - 1.0, res);\n    bool valid = m >= 0 && m <= maxIndex && isLinearValid(m, res);\n    \/\/valid = true;\n    return mRet(int(v[part]), ret2.Am, v, ret2.v, ret2.pos, valid && ret2.valid);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":33,"src":"\/presets\/tex00.jpg","ctype":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":257,"channel":0}],"code":"\/\/ Resources:\n\/\/ https:\/\/www.ics.uci.edu\/~goodrich\/pubs\/skip-journal.pdf\n\/\/ Sorting with GPUs: A Survey: https:\/\/arxiv.org\/pdf\/1709.02520.pdf\n\n\/\/ Practice JavaScript implementation: http:\/\/jsbin.com\/zeyiraw\/\n\n\/\/ https:\/\/www.shadertoy.com\/view\/XlcGD8\n\/\/ https:\/\/developer.nvidia.com\/gpugems\/GPUGems2\/gpugems2_chapter46.html\n\/\/ https:\/\/stackoverflow.com\/questions\/26093629\/glsl-odd-even-merge-sort\n\/\/ https:\/\/bl.ocks.org\/zz85\/cafa1b8b3098b5a40e918487422d47f6\n\n#define resetPressed (texelFetch(iChannel1, ivec2(KEY_LEFT,1),0 ).x > 0.5)\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nint extractIndex(vec4 v, int part) {\n    return int(v[PART]);\n}\n\nint getIndex(int part, mRet A, vec2 res) {\t\n    return A.Am;\n}\n\nbool compare(int part, mRet A, mRet B, vec2 res) {\n    return getIndex(part, A, res) < getIndex(part, B, res);\n}\n\nbool cutValid(int part, int n1, int n2, int astart, int bstart, int to, int m2, int x, vec2 res) {\n    int apos = m2 - 1;\n    bool aValid = apos >= 0 && apos < n1;\n    int bpos = to - m2 - 1;\n    bool bValid = bpos >= 0 && bpos < n2;\n\n    mRet Amret = getM(part, astart + apos, res);\n    mRet Bmret = getM(part, bstart + bpos, res);\n\n    int cv11 = getIndex(part, Amret, res);\n    int cv12 = getIndex(part, Bmret, res);\n    return (\n        aValid && bValid && apos >= 0 && bpos >= 0 ? max(cv11, cv12) <= x\n        : bValid && apos < 0 && bpos >= 0 ? cv12 <= x\n        : aValid && apos >= 0 && bpos < 0 ? cv11 <= x\n        : Amret.valid && Bmret.valid);\n}\n\nbool cutCValid(int part, int n1, int n2, int astart, int bstart, int to, int bm2, int x, vec2 res) {\n    int apos = to - bm2 - 1;\n    int bpos = bm2 - 1;\n    bool aValid = apos >= 0 && apos < n1;\n    bool bValid = bpos >= 0 && bpos < n2;\n\n    mRet Amret = getM(part, astart + apos, res);\n    mRet Bmret = getM(part, bstart + bpos, res);\n\tint cvc11 = getIndex(part, Amret, res);\n    int cvc12 = getIndex(part, Bmret, res);\n    return (\n    \taValid && bValid && apos >= 0 && bpos >= 0 ? max(cvc11, cvc12) <= x\n        : bValid && apos < 0 && bpos >= 0 ? cvc12 <= x\n        : aValid && apos >= 0 && bpos < 0 ? cvc11 <= x\n        : Amret.valid && Bmret.valid);\n}\n\nmRet checkIndex(int part, int n1, int n2, int astart, int bstart, int to, int apos, vec2 res) {\n    bool aValid = apos >= 0 && apos < n1;\n    int bpos = to - apos;\n    bool bValid = bpos >= 0 && bpos < n2;\n\n    mRet Amret = getM(part, astart + apos, res);\n    mRet Bmret = getM(part, bstart + bpos, res);\n\n    int candA = getIndex(part, Amret, res);\n    bool candAv = cutValid(part, n1, n2, astart, bstart, to, apos, candA, res) && aValid;\n    Amret.valid = Amret.valid && candAv;\n\n    int candB = getIndex(part, Bmret, res);\n    bool candBv = cutCValid(part, n1, n2, astart, bstart, to, bpos, candB, res) && bValid;\n    Bmret.valid = Bmret.valid && candBv;\n\n    if (candAv && candBv) {\n        if (candA < candB) {\n            return Amret;\n        } else {\n            return Bmret;\n        }\n    } else if (candAv) {\n        return Amret;\n    }\n    return Bmret;\n}\n\nmRet binarySearchForMergeSlim(\n    int part,\n    int targetOffset, int n1, int n2, vec2 res,\n    int astart, int bstart) {\n\n    int L1 = min(max(targetOffset + 1 - n1, 0), n1 - 1);\n    int R1 = min(targetOffset + 1, n1);\n    int L2 = min(max(targetOffset + 1 - n2, 0), n2 - 1);\n    int R2 = min(targetOffset + 1, n2);\n\n    int OL1 = L1;\n    int OR2 = R2;\n\n    int i = 0;\n\n    mRet ret;\n\n    bool bValid = true;\n\n    for (i = 0; i < maxBin && L1 < R1 && (L2 < R2 || !bValid); i++) {\n        int m = (L1 + R1) \/ 2 + (L1 + R1) % 2;\n        int bm = targetOffset - m;\n        int apos = m;\n        bool aValid = apos >= 0 && apos < n1;\n        int bpos = bm;\n        bValid = bpos >= 0 && bpos < n2;\n\n        mRet Amret = getM(part, astart + apos, res);\n        aValid = aValid && Amret.valid;\n        mRet Bmret = getM(part, bstart + bpos, res);\n        bValid = bValid && Bmret.valid;\n\n        bool comparison = compare(part, Amret, Bmret, res) && aValid && bValid;\n        bool inUpperHalf = comparison;\n\n        \/\/ m + 1 to R1\n        L1 = inUpperHalf ? m : L1;\n        \/\/ L1 to m\n        R1 = !inUpperHalf ? m - 1 : R1;\n        \/\/ bm + 1 to R2\n        L2 = !inUpperHalf ? bm : L2;\n        \/\/ L2 to bm\n        R2 = inUpperHalf ? bm : R2;\n    }\n    mRet error = mRet(-1, -1, vec4(-1.0), vec4(-1.0), vec2(-1.0), false);\n    \/\/mRet error = mRet(-1, vec4(-1.0), false);\n\n    int apos = L1;\n    int bpos = targetOffset - L1;\n    bValid = bpos >= 0 && bpos < n2;\n\n    mRet AL1ret = getM(part, astart + apos, res);\n    mRet BL1ret = getM(part, bstart + bpos, res);\n    \/\/return AL1ret;\n\n    \/\/ XXX: AL1ret and BL1ret should be valid I hope\n    int m2 = getIndex(part, AL1ret, res) < getIndex(part, BL1ret, res) && bValid ? L1 + 1 : L1;\n    int bm2 = OR2 - (m2 - OL1);\n    bool bm2Valid = bm2 >= 0 && bm2 < n2;\n    bool bm2Min1Valid = bm2 - 1 >= 0 && bm2 - 1 < n2;\n\n    int to = targetOffset;\n\n    mRet cand1 = checkIndex(part, n1, n2, astart, bstart, to, m2, res);\n    mRet cand2 = checkIndex(part, n1, n2, astart, bstart, to, bm2, res);\n    cand2.valid = cand2.valid && bm2Valid;\n    mRet cand3 = checkIndex(part, n1, n2, astart, bstart, to, m2 - 1, res);\n    mRet cand4 = checkIndex(part, n1, n2, astart, bstart, to, bm2 - 1, res);\n    cand4.valid = cand4.valid && bm2Min1Valid;\n\n    ret = cand1;\n    if (cand2.valid && (compare(part, cand2, ret, res) || !ret.valid)) {\n        ret = cand2;\n    }\n    if (cand3.valid && (compare(part, cand3, ret, res) || !ret.valid)) {\n        ret = cand3;\n    }\n    if (cand4.valid && (compare(part, cand4, ret, res) || !ret.valid)) {\n        ret = cand4;\n    }\n    mRet AnMin1 = getM(part, astart + n1 - 1, res);\n    mRet BtoMinN = getM(part, bstart + to - n1, res);\n    mRet BnMin1 = getM(part, bstart + n2 - 1, res);\n    mRet AtoMinN = getM(part, astart + to - n2, res);\n    if (targetOffset >= n1 && compare(part, AnMin1, BtoMinN, res) && BtoMinN.valid) {\n        ret = BtoMinN;\n    }\n    if (targetOffset >= n2 && compare(part, BnMin1, AtoMinN, res) && AtoMinN.valid) {\n        ret = AtoMinN;\n    }\n\n    if (i >= maxBin - 1) {\n        ret = error;\n    }\n    return ret;\n}\n\nstruct mcData {\n    int pass;\n    int n;\n    bool overflow;\n    int index;\n    int base;\n    int astart;\n    int bstart;\n    int targetOffset;\n};\n\nmcData getMCData(int part,mPartitionData pd) {\n    mcData ret;\n    ret.pass = max(0, pd.partitionIndex - 1);\n    ret.n = (1 << ret.pass);\n    ret.overflow = 2 * ret.n > pd.particlesPerPartition || pd.particlesPerPartition % ret.n != 0;\n    ret.index = pd.index - pd.particlesPerPartition;\n    ret.base = ret.index - ret.index % (2 * ret.n);\n    ret.astart = ret.base;\n    ret.bstart = ret.base + ret.n;\n    ret.targetOffset = ret.index - ret.base;\n    return ret;\n}\n\nvec4 mergeSort(in vec2 fragCoord) {\n    vec4 fragColor = vec4(0.0);\n    vec2 res = maxRes;\n    mPartitionData pd = getPartitionData(sortedBuffer, fragCoord, res);\n\n    \/\/fragColor.x = texelFetch(sortedBuffer, ivec2(fragCoord), 0).x;\n\n    bool overflow = false;\n    for (int part = 0; part < vec4Count; part++) {\n        mcData ret = getMCData(PART, pd);\n    \toverflow = overflow || ret.overflow;\n        fragColor[PART] = binarySearchForMergeSlim(\n            PART, ret.targetOffset, ret.n, ret.n,\n            res, ret.astart, ret.bstart).vi[PART];\n    }\n    if (pd.partitionIndex + 1 < pd.partitionCount) {\n        fragColor.x += float(pd.particlesPerPartition);\n    }\n\n    if (overflow) {\n        \/\/fragColor.x = pd.futureParticle.x;\n        fragColor.x = 0.0;\n        return fragColor;\n    }\n\n    if (pd.partitionIndex == 0) {\n        fragColor.x = float(pd.index);\n        fragColor.x += float(pd.particlesPerPartition);\n    }\n\n    return fragColor;\n}\n\n\n\n\n\n\/\/ BEGIN PARTICLES\n\nconst float E = 1.0e-10;\n\nvec2 transformPos(vec2 pos) {\n    pos = (pos - 0.5) * 4.0 + 0.5;\n    pos = mod(pos, 1.0);\n    return pos;\n}\n\nvec2 getSpring(vec2 res, vec4 particle, vec2 pos) {\n    vec2 dv = particle.xy - pos;\n    float l = length(dv);\n    float k = 0.1;\n    float s = sign(k - l);\n    vec2 dvn = dv \/ (E + l);\n    l = min(abs(k - l), l);\n    \n    float SPRING_COEFF = 1.0e2;\n    float SPRING_LENGTH = 0.001;\n    float X = abs(SPRING_LENGTH - l);\n    float F_spring = SPRING_COEFF * X;\n    \n    if (l >= SPRING_LENGTH) {\n    \tdv = dvn * SPRING_LENGTH;\n    }\n    \n    \n    vec2 a = vec2(0.0);\n    \n    \/\/ Spring force\n    a += -dv * F_spring;\n    \n    return a;\n}\n\nvec2 getGravity(vec2 res, vec4 particle, vec2 pos) {\n    \/\/ Anti-gravity\n    float MIN_DIST = 0.01;\n    float G = 5.0e-1;\n    float m = 1.0 \/ (MIN_DIST * MIN_DIST);\n    vec2 dvg = particle.xy - pos.xy; \n    float l2 = length(dvg);\n    vec2 dvgn = dvg \/ l2;\n    \n    vec2 a = G * dvg \/ (MIN_DIST + m * l2 * l2);\n    \n    return a;\n}\n\nvec4 updateParticle(in vec4 particle, vec2 a) {\n    vec2 v = particle.xy - particle.zw;\n    \n    v += a;\n    v *= 0.5;\n    \n    if (particle.x + v.x < 0.0 || particle.x + v.x >= 1.0) {\n        v.x = -v.x;\n        v *= 0.5;\n    }\n    if (particle.y + v.y < 0.0 || particle.y + v.y >= 1.0) {\n        v.y = -v.y;\n        v *= 0.5;\n    }\n    \n    float maxSpeed = 0.01;\n    v = length(v) > maxSpeed ? maxSpeed * v \/ length(v) : v;\n    \n    particle.zw = particle.xy;\n    particle.xy += v;\n        \n    return particle;\n}\n\nvec4 computeParticles(in vec2 fragCoord )\n{\n    vec4 fragColor = vec4(0.0);\n    vec2 res = maxRes;\n    mPartitionData pd = getPartitionData(particleBuffer, fragCoord, res);\n    \n    if (iFrame == 0 || resetPressed) {\n        fragColor = vec4(0.0);\n        \n        vec2 particle = vec2(0.0);\n        if (pd.partitionIndex == 0) {\n            \/\/ position\n            vec2 fc = vec2(fromLinear(pd.index, res));\n            vec4 data = hash42(fc);\n            particle = transformPos(data.xy);\n        } else {\n            \/\/ velocity\n            vec2 fc = vec2(fromLinear(pd.futureIndex, res));\n            vec4 data = hash42(fc);\n\n            vec2 pos = transformPos(data.xy);\n            vec2 vel = 10.0 * (data.zw - 0.5) \/ res;\n            float maxSpeed = 1.0;\n            vel = length(vel) > maxSpeed ? maxSpeed * vel \/ length(vel) : vel;\n            vel = vec2(0.0);\n            vec2 oldPos = pos - vel;\n            particle = oldPos;\n        }\n\n        if (pd.overflow) {\n            particle = vec2(0.0);            \n        }\n        \n        fragColor.yz = particle;\n        \n        return fragColor;\n    }\n    \n    vec4 particle1 = vec4(0.0);\n    particle1.xy = getPosition(particleBuffer, pd.index, res);\n    particle1.zw = getPosition(particleBuffer, pd.pastIndex, res);\n    \n    const int k = 16;\n    const int k2 = 4;\n    int w = int(sqrt(float(k)));\n    vec2 a1 = vec2(0.0);\n    vec2 a2 = vec2(0.0);\n    int torusCount = int(pow(2.0, float(int(iTime \/ 4.0) % 10)));\n    int particlesPerTorus = pd.particlesPerPartition \/ torusCount;\n    int wp = int(sqrt(float(particlesPerTorus)));\n    int torus = pd.index \/ particlesPerTorus;\n    for (int i = 0; i < k; i++) {\n        {\n            int index = pd.index % particlesPerTorus;\n            vec2 fc = vec2(fromLinear(index, vec2(wp)));\n            vec2 offset = vec2(i % w - w \/ 2, i \/ w - w \/ 2);\n            if (torus % 3 == 0 && !justSentinels) {\n                \/\/ Torus\n                fc = fc + offset;\n            \tfc = mod(fc, vec2(wp));\n            } else if (torus % 3 == 1 && !justSentinels) {\n                \/\/ Cloth\n                fc = fc + offset;\n            \tfc = clamp(fc, vec2(0.0), vec2(wp));\n            } else {\n                \/\/ Sentinel\n                offset.x = -1.0;\n                offset.y = 0.0;\n                fc = fc + offset;\n                fc = clamp(fc, vec2(0.0), vec2(wp));\n                if (index % wp == 0) {\n                    fc = vec2(0.0);\n                }\n            }\n            int j = toLinear(fc, vec2(wp)) + pd.index - index;\n            vec2 p2 = getPosition(particleBuffer, j, res);\n            a1 += getSpring(res, particle1, p2.xy) \/ float(w);\n        }\n        for (int i2 = 0; i2 < k2; i2++) {\n            int w = int(sqrt(float(k)));\n            int index = pd.index % particlesPerTorus;\n            int j =\n                int(float(particlesPerTorus) * \n                    hash(uvec2(fragCoord + float(i * k + i2) * vec2(13.0, 29.0) * vec2(iFrame))));\n            j += pd.index - index;\n            vec2 p2 = getPosition(particleBuffer, j, res);\n            a1 += getGravity(res, particle1, p2.xy) \/ float(w * k2);\n        }\n    }\n    \n    vec2 updatedParticle = updateParticle(particle1, a1).xy;\n\t\n    fragColor.yz = pd.partitionIndex == 0 ? updatedParticle.xy : extractPosition(pd.futureParticle);\n    fragColor.yz = pd.overflow ? vec2(0.0) : fragColor.yz;\n    \n    return fragColor;\n}\n\n\/\/ END PARTICLES\n\n\nfloat computeZOrder(in vec2 fragCoord) {\n    vec2 res = realRes;\n    vec2 pres = getRes(res);\n    vec2 fc = fragCoord \/ res * pres;\n    int index = toIndexFull(fc, pres);\n    return float(index);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \/*\n    int maxLinear = toLinear(res - 1.0, res);\n    if (frag\n\t*\/\n    if (iFrame == 0 || resetPressed) {\n        fragColor.xyz = vec3(0.0);\n        fragColor.w = computeZOrder(fragCoord);\n    } else {\n        fragColor.w = texelFetch(mortonBuffer, ivec2(fragCoord), 0).w;\n    }\n    vec2 res = maxRes;\n    if (fragCoord.x >= res.x || fragCoord.y >= res.y) {\n        \/\/discard;\n        return;\n    }\n    fragColor.x = mergeSort(fragCoord).x;\n    fragColor.yz = computeParticles(fragCoord).yz;\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":258,"src":"\/media\/previz\/buffer01.png","ctype":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":258,"channel":0}],"code":"int binarySearchLeftMost(int part, int T, vec2 res, vec2 fragCoord) {\n    mPartitionData pd = getPartitionData(sortedBuffer, fragCoord, res);\n    int n = pd.particlesPerPartition;\n    int maxPartition = getMaxPartition(pd);\n    int L = maxPartition * n;\n    int R = L + n;\n\n    int i = 0;\n    for (i = 0; i < maxBin && L < R; i++) {\n        int m = (L + R) \/ 2;\n        int Am = getM(part, m, res).Am;\n        L = Am < T ? m + 1 : L;\n        R = Am >= T ? m : R;\n    }\n    int ret = i < maxBin - 1 ? L : -1;\n    return ret;\n}\n\nint binarySearchRightMost(int part, int T, vec2 res, vec2 fragCoord) {\n    mPartitionData pd = getPartitionData(sortedBuffer, fragCoord, res);\n    int n = pd.particlesPerPartition;\n    int maxPartition = getMaxPartition(pd);\n    int L = maxPartition * n;\n    int R = L + n;\n\n    int i = 0;\n    for (i = 0; i < maxBin && L < R; i++) {\n        int m = (L + R) \/ 2;\n        int Am = getM(part, m, res).Am;\n        L = Am <= T ? m + 1 : L;\n        R = Am > T ? m : R;\n    }\n    int ret = i < maxBin - 1 ? L - 1 : -1;\n    return ret;\n}\n\nfloat doDistance(int part, in vec2 fragCoord, vec2 colorUV) {\n    vec2 res = maxRes;\n    \/\/vec2 oc = fragCoord \/ realRes * res;\n    vec2 oc = fragCoord;\n\n    int uvIndex = toIndex(colorUV);\n    int index3 = binarySearchLeftMost(part, uvIndex, res, oc);\n    int index4 = binarySearchRightMost(part, uvIndex, res, oc);\n\n    mRet mret = getM(part, index3, res);\n    int foundIndex = mret.Am;\n    vec4 v = mret.v;\n    float d = distance(colorUV, mret.pos);\n\n    int j = 0;\n    int a = min(index3, index4);\n    int b = max(index3, index4);\n    int maxIter = 10;\n    int retIndex = -1;\n    for (int j = 0; j < maxIter; j++) {\n        int i = a + j - maxIter \/ 2;\n        mRet mret = getM(part, i, res);\n        int foundIndex = mret.Am;\n        vec4 v = mret.v;\n        float d2 = distance(colorUV, mret.pos);\n        if (d2 < d) {\n            d = d2;\n            retIndex = i;\n        }\n    }\n\n    return float(retIndex);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \/\/fragCoord = floor(fragCoord \/ iResolution.xy * maxRes);\n    \n    vec2 res = maxRes;\n    \/\/ TODO: try +0.5\n    vec2 colorUV = (fragCoord + 0.0) \/ realRes;\n    \n\tvec4 old = texelFetch(pixelNearestBuffer, ivec2(fragCoord), 0);\n\n    for (int part = 0; part < vec4Count; part++) {\n    \tfloat oldIndex = old[part];\n\n        mRet mret1 = getM(part, int(oldIndex), res);\n        float d2 = distance(colorUV, mret1.pos);\n\n        float index = doDistance(part, fragCoord, colorUV);\n\n        mRet mret2 = getM(part, int(index), res);\n\n        float d3 = distance(colorUV, mret2.pos);\n\n        index = d3 < d2 ? index : oldIndex;\n\n        fragColor[PART] = index;\n    }\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":258,"src":"\/media\/previz\/buffer01.png","ctype":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":259,"channel":0}],"code":"\/\/ Fork of \"Z Particle Sort Pipeline\" by emh. https:\/\/shadertoy.com\/view\/Mtdyzs\n\/\/ 2018-08-09 11:43:19\n\nvoid lookup(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 res = maxRes;\n    int k = 1;\n    float mul = 1.0;\n    const float MAX = 1.0e10;\n    float rd = 0.0;\n    float mind = MAX;\n    vec2 colorUV = (fragCoord + 0.0) \/ realRes;\n    vec3 color = vec3(1.0);\n    int minIndex = -1;\n    bool firstHalf = true;\n    mPartitionData pd = getPartitionData(particleBuffer, fragCoord, res);\n\n    vec4 indexAndVelNearest = texelFetch(pixelNearestBuffer, ivec2(fragCoord), 0);\n\n    for (int dx = -k; dx <= k; dx++) {\n        for (int dy = -k; dy <= k; dy++) {\n            vec2 delta = vec2(dx, dy);\n            \/\/vec2 delta2 = vec2(sign(float(dx)) * exp2(abs(float(dx))), sign(float(dy)) * exp2(abs(float(dy))));\n\n            ivec2 fc = ivec2(fragCoord + mul * delta);\n            vec4 indexAndVel = texelFetch(pixelNearestBuffer, fc, 0);\n\n            for (int part = 0; part < vec4Count; part++) {\n                int i = int(indexAndVel[part]);\n                mRet iret = getM(part, i, res);\n                vec2 newPos = iret.pos;\n                \/\/vec2 newPos = vec2(fc) \/ realRes;\n                float d = distance(colorUV, newPos);\n                if (i >= 0 && d < mind) {\n                    minIndex = iret.dIndex;\n                    firstHalf = part == 0;\n                }\n                \/\/mind = i < 0 ? mind : min(d, mind);\n                mind = min(d, mind);\n                \/\/float f = 0.00005  \/ d;\n                float f = d;\n                rd = i < 0 ? rd : (d < (float(k) \/ realRes.x) ? f + rd : rd);\n                if (i >= 0 && (d < (float(k) \/ realRes.x))) {\n                    float h = float(iret.dIndex % pd.particlesPerPartition) \/ float(pd.particlesPerPartition);\n                    color = hsv2rgb(vec3(h, 1.0, 1.0));\n                    color = mix(vec3(1.0), color, d * iResolution.x \/ 10.0);\n                \t\/\/fragColor += clamp(0.01 * vec4(color, 1.0) * vec4(1.0 \/ (d * realRes.x)), 0.0, 1.0);\n                }\n            }\n        }\n    }\n\n    float h = float(minIndex % pd.particlesPerPartition) \/ float(pd.particlesPerPartition);\n    color = hsv2rgb(vec3(h, 1.0, 1.0));\n    color = mix(vec3(1.0), color, 100.0 * mind);\n\n    float size = minIndex >= 0 ? float(minIndex % 10 + 1) : 1.0;\n\n    float brightness = 1.0;\n    \/\/fragColor += clamp(brightness * vec4(color, 1.0) * vec4(1.0 \/ (mind * 1000.0)), 0.0, 1.0);\n    fragColor += clamp(brightness * vec4(color, 1.0) * vec4(1.0 \/ (mind * realRes.x)), 0.0, 1.0);\n    \/\/fragColor += clamp(brightness * vec4(color, 1.0) * vec4(1.0 \/ (rd * realRes.x)), 0.0, 1.0);\n    \/\/fragColor = vec4(1.0 * rd);\n}\n\nvoid debug(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 v0 = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec4 v1 = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    vec4 v2 = texelFetch(iChannel2, ivec2(fragCoord), 0);\n    vec4 v3 = texelFetch(iChannel3, ivec2(fragCoord), 0);\n    \/\/float val = float(int(v.w) % 1000) \/ 1000.0;\n    float val = float(int(v0.x) % 10000) \/ 10000.0;\n    fragColor = vec4(val);\n    \/\/fragColor.rb = v0.yz;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \/\/debug(fragColor, fragCoord);\n    lookup(fragColor, fragCoord);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":259,"src":"\/media\/previz\/buffer02.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":260,"channel":0}],"code":"\/\/ horizontal Gaussian blur pass\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixelSize = 1.\/ iChannelResolution[0].xy;\n    vec2 uv = fragCoord.xy * pixelSize;\n    \n    float h = pixelSize.x;\n\tvec4 sum = vec4(0.0);\n\tsum += texture(iChannel0, fract(vec2(uv.x - 4.0*h, uv.y)) ) * 0.05;\n\tsum += texture(iChannel0, fract(vec2(uv.x - 3.0*h, uv.y)) ) * 0.09;\n\tsum += texture(iChannel0, fract(vec2(uv.x - 2.0*h, uv.y)) ) * 0.12;\n\tsum += texture(iChannel0, fract(vec2(uv.x - 1.0*h, uv.y)) ) * 0.15;\n\tsum += texture(iChannel0, fract(vec2(uv.x + 0.0*h, uv.y)) ) * 0.16;\n\tsum += texture(iChannel0, fract(vec2(uv.x + 1.0*h, uv.y)) ) * 0.15;\n\tsum += texture(iChannel0, fract(vec2(uv.x + 2.0*h, uv.y)) ) * 0.12;\n\tsum += texture(iChannel0, fract(vec2(uv.x + 3.0*h, uv.y)) ) * 0.09;\n\tsum += texture(iChannel0, fract(vec2(uv.x + 4.0*h, uv.y)) ) * 0.05;\n    \n    fragColor.xyz = sum.xyz\/0.98; \/\/ normalize\n\tfragColor.a = 1.;\n    \n    \/\/fragColor = texture(iChannel0, uv);\n}","name":"Buffer D","description":"","type":"buffer"}]}}