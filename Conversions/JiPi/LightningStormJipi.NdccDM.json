{
 "ver": "0.1",
 "info": {
  "id": "NdccDM",
  "date": "0",
  "viewed": 0,
  "name": "LIGHTNING Storm JiPi",
  "description": "Use mouse to move camera around.",
  "likes": 0,
  "published": "Private",
  "usePreview": 0,
  "tags": [
   "cloud",
   "volumetric",
   "bloom",
   "lightning",
   "storm",
   "electricity",
   "thunder",
   "bolt"
  ],
  "hasliked": 0,
  "parentid": "sd3cDN",
  "parentname": "Fork LIGHTNING Storm LenoC 619"
 },
 "renderpass": [
  {
   "inputs": [
    {
     "id": "4dXGR8",
     "filepath": "/media/previz/buffer00.png",
     "type": "buffer",
     "channel": 0,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    },
    {
     "id": "XsBSR3",
     "filepath": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png",
     "type": "texture",
     "channel": 1,
     "sampler": {
      "filter": "mipmap",
      "wrap": "repeat",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    }
   ],
   "outputs": [
    {
     "id": "4dfGRr",
     "channel": 0
    }
   ],
   "code": "//\tRay marched lightning with a volumetric cloud.\n//\n//\tThe bolts are capped cylinders which are offset by Perlin noise FBM and animated in time \n//\tto look like electrical discharges. The glow is achieved by accumulating distance based \n//\tglow along view rays. Internal flashes are additional ambient terms in the cloud lighting.\n//\n//\tSee https://www.shadertoy.com/view/3sffzj for cloud.\n\nconst vec3 sunLightColour = vec3(1.0);\nconst vec3 skyColour = vec3(0);\nconst vec3 horizonColour = vec3(1, 0.9, 0.8);\n\n//---------------------- Lightning ----------------------\nconst int MAX_STEPS = 32;\nconst float MIN_DIST = 0.1;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 1e-4;\n\nconst vec3 boltColour = vec3(0.3, 0.6, 1.0);\n\nconst float strikeFrequency = 0.1;\n//The speed and duration of the bolts. The speed and frequency are linked\nfloat speed = 0.25;\n\nconst float internalFrequency = 0.5;\n//Movement speed of lightning inside the cloud\nconst float internalSpeed = .5;\n\n//Locations of the three bolts\nvec2 bolt0 = vec2(1e10);\nvec2 bolt1 = vec2(1e10);\nvec2 bolt2 = vec2(1e10);\n\n//------------------------ Cloud ------------------------\nconst float CLOUD_START = 20.0;\nconst float CLOUD_HEIGHT = 20.0;\nconst float CLOUD_END = CLOUD_START + CLOUD_HEIGHT;\n//For size of AABB\nconst float CLOUD_EXTENT = 20.0;\n\nconst int STEPS_PRIMARY = 24;\nconst int STEPS_LIGHT = 6;\n\n//Offset the sample point by blue noise every frame to get rid of banding\n#define DITHERING\nconst float goldenRatio = 1.61803398875;\n\nconst vec3 minCorner = vec3(-CLOUD_EXTENT, CLOUD_START, -CLOUD_EXTENT);\nconst vec3 maxCorner = vec3(CLOUD_EXTENT, CLOUD_END, CLOUD_EXTENT);\n\nconst float power = 6.0;\nconst float densityMultiplier = 6.5;\n\nvec3 rayDirection(float fieldOfView, vec2 fragCoord) {\n    vec2 xy = fragCoord - iResolution.xy / 2.0;\n    float z = (0.5 * iResolution.y) / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n//https://www.geertarien.com/blog/2017/07/30/breakdown-of-the-lookAt-function-in-OpenGL/\nmat3 lookAt(vec3 camera, vec3 targetDir, vec3 up){\n    vec3 zaxis = normalize(targetDir);    \n    vec3 xaxis = normalize(cross(zaxis, up));\n    vec3 yaxis = cross(xaxis, zaxis);\n\n    return mat3(xaxis, yaxis, -zaxis);\n}\n\n//https://www.shadertoy.com/view/3s3GDn\nfloat getGlow(float dist, float radius, float intensity){\n    dist = max(dist, 1e-6);\n    return pow(radius/dist, intensity);\t\n}\n\n//---------------------------- 1D Perlin noise ----------------------------\n//Used to shape lightning bolts\n//https://www.shadertoy.com/view/lt3BWM\n\n#define HASHSCALE 0.1031\n\nfloat hash(float p){\n    vec3 p3  = fract(vec3(p) * HASHSCALE);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat fade(float t) { return t*t*t*(t*(6.*t-15.)+10.); }\n\nfloat grad(float hash, float p){\n    int i = int(1e4*hash);\n    return (i & 1) == 0 ? p : -p;\n}\n\nfloat perlinNoise1D(float p){\n    float pi = floor(p), pf = p - pi, w = fade(pf);\n    return mix(grad(hash(pi), pf), grad(hash(pi + 1.0), pf - 1.0), w) * 2.0;\n}\n\n//---------------------------- 3D Perlin noise ----------------------------\n//Used to shape cloud\n\n//https://www.shadertoy.com/view/4djSRW\nvec3 hash33(vec3 p3){\n    p3 = fract(p3 * vec3(.1031,.11369,.13787));\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\nfloat perlinNoise3D(vec3 p){\n    vec3 pi = floor(p);\n    vec3 pf = p - pi;\n\n    vec3 w = pf * pf * (3.0 - 2.0 * pf);\n\n    return \tmix(\n        mix(\n            mix(dot(pf - vec3(0, 0, 0), hash33(pi + vec3(0, 0, 0))), \n                dot(pf - vec3(1, 0, 0), hash33(pi + vec3(1, 0, 0))),\n                w.x),\n            mix(dot(pf - vec3(0, 0, 1), hash33(pi + vec3(0, 0, 1))), \n                dot(pf - vec3(1, 0, 1), hash33(pi + vec3(1, 0, 1))),\n                w.x),\n            w.z),\n        mix(\n            mix(dot(pf - vec3(0, 1, 0), hash33(pi + vec3(0, 1, 0))), \n                dot(pf - vec3(1, 1, 0), hash33(pi + vec3(1, 1, 0))),\n                w.x),\n            mix(dot(pf - vec3(0, 1, 1), hash33(pi + vec3(0, 1, 1))), \n                dot(pf - vec3(1, 1, 1), hash33(pi + vec3(1, 1, 1))),\n                w.x),\n            w.z),\n        w.y);\n}\n\n//---------------------------- Distance ---------------------------\n\nbool intersectPlane(vec3 n, vec3 p, vec3 org, vec3 dir, out float t){ \n    //Assuming vectors are all normalized\n    float denom = dot(n, dir); \n    if(denom > 1e-6) { \n        t = dot(p - org, n) / denom; \n        return (t >= 0.0); \n    } \n \n    return false; \n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r ){\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat fbm(float pos, int octaves){\n    if(pos < 0.0){\n        return 0.0;\n    }\n    float total = 0.0;\n    float frequency = 0.2;\n    float amplitude = 1.0;\n    for(int i = 0; i < octaves; i++){\n        if(i > 2){\n            pos += 0.5*iTime * 25.0;\n        }\n        total += perlinNoise1D(pos * frequency) * amplitude;\n        amplitude *= 0.5;\n        frequency *= 2.0;\n    }\n    return total;\n}\n\nfloat getSDF(vec3 p) {\n\n    float dist = 1e10;\n\n    //Shift everything to start at the cloud\n    p.y -= CLOUD_START;\n\n    //The counter of a bolt in a series\n    float t = 0.0;\n    //The offset of the series\n    float shift = 0.0;\n\n    //Number of noise levels for FBM\n    int octaves = 4;\n    //Scale of the y coordinate as noise input. Controls the smoothness of the bolt\n    float scale = 0.5;\n    //Offset to give simultaneous bolts different shapes\n    float shapeOffset = 15.2;\n    //Fraction of the total bolt length 0->1\n    float progress;\n\n    //The fraction of the lifetime of the bolt it takes for it to descend.\n    //The bolt persists in full form for 1.0-descentDuration fraction of the total period.\n    float descentDuration = 0.5;\n\n    //Spatial range of the bolt\n    float range = CLOUD_EXTENT*0.4;\n    float boltLength = CLOUD_START*0.5;\n    //Bolt thickness\n    float radius = 0.01;\n    //xz: the shape of the bolt\n    //y:  progress used as bolt length and positioning\n    vec3 offset;\n    vec2 location;\n\n    float time;\n\n    for(int i = 0; i < 3; i++){\n\n        shapeOffset *= 2.0;\n        shift = fract(shift + 0.25);\n        time = iTime * 25.0 * speed + shift;\n        t = floor(time)+1.0;\n        \n        //Reset the position of the iteration bolt\n        if(i == 0){\n        \tbolt0 = vec2(1e10);\n        }\n        if(i == 1){\n        \tbolt1 = vec2(1e10);\n        }\n        if(i == 2){\n        \tbolt2 = vec2(1e10);\n        }\n\n        //Bolts strike randomly\n        if(hash(float(i)+t*0.026) > strikeFrequency){\n            continue;\n        }\n        location = 2.0*vec2(hash(t+float(i)+0.43), hash(t+float(i)+0.3))-1.0;\n        location *= range;\n        progress = clamp(fract(time)/descentDuration, 0.0, 1.0);\n        \n        //Briefly increase the radius of the bolt the moment it makes contact\n        if(progress > 0.95 && fract(time) - descentDuration < 0.1){\n            radius = 0.1;\n        }else{\n            radius = 0.01;\n        }\n        progress *= boltLength;\n        offset = vec3(location.x+fbm(shapeOffset+t*0.2+(scale*p.y), octaves), \n                      progress, \n                      location.y+fbm(shapeOffset+t*0.12-(scale*p.y), octaves));\n        \n        //Store the xz location of the iteration bolt\n        //Raymarching translations are reversed so invert the sign\n        if(i == 0){\n        \tbolt0 = -location.xy;\n        }\n        if(i == 1){\n        \tbolt1 = -location.xy;\n        }\n        if(i == 2){\n        \tbolt2 = -location.xy;\n        }\n        dist = min(dist, sdCappedCylinder(p+offset, radius, progress));\n    }\n\n    return dist;\n}\n\nfloat distanceToScene(vec3 cameraPos, vec3 rayDir, float start, float end, out vec3 glow) {\n\n    float depth = start;\n    float dist;\n    \n    for (int i = 0; i < MAX_STEPS; i++) {\n\n        vec3 p = cameraPos + depth * rayDir;\n        //Warping the cylinder breaks the shape. Reduce step size to avoid this.\n        dist = 0.5*getSDF(p);\n        //Accumulate the glow along the view ray.\n        glow += getGlow(dist, 0.01, 0.8) * boltColour;\n\n        if (dist < EPSILON){\n            return depth;\n        }\n\n        depth += dist;\n\n        if (depth >= end){ \n            return end; \n        }\n    }\n\n    return end;\n}\n\nvec3 getSkyColour(vec3 rayDir){\n    if(rayDir.y < 0.0){\n        return vec3(0.025);\n    }\n\n    return mix(horizonColour, skyColour, pow(rayDir.y, 0.03));\n}\n\n\n//---------------------------- Cloud shape ----------------------------\n\n//https://gist.github.com/DomNomNom/46bb1ce47f68d255fd5d\n//Compute the near and far intersections using the slab method.\n//No intersection if tNear > tFar.\nvec2 intersectAABB(vec3 rayOrigin, vec3 rayDir, vec3 boxMin, vec3 boxMax) {\n    vec3 tMin = (boxMin - rayOrigin) / rayDir;\n    vec3 tMax = (boxMax - rayOrigin) / rayDir;\n    vec3 t1 = min(tMin, tMax);\n    vec3 t2 = max(tMin, tMax);\n    float tNear = max(max(t1.x, t1.y), t1.z);\n    float tFar = min(min(t2.x, t2.y), t2.z);\n    return vec2(tNear, tFar);\n}\n\nbool insideAABB(vec3 p){\n    float eps = 1e-4;\n    return  (p.x > minCorner.x-eps) && (p.y > minCorner.y-eps) && (p.z > minCorner.z-eps) && \n        (p.x < maxCorner.x+eps) && (p.y < maxCorner.y+eps) && (p.z < maxCorner.z+eps);\n}\n\nbool getCloudIntersection(vec3 org, vec3 dir, out float distToStart, out float totalDistance){\n    vec2 intersections = intersectAABB(org, dir, minCorner, maxCorner);\n\n    if(insideAABB(org)){\n        intersections.x = 1e-4;\n    }\n\n    distToStart = intersections.x;\n    totalDistance = intersections.y - intersections.x;\n    return intersections.x > 0.0 && (intersections.x < intersections.y);\n}\n\nfloat saturate(float x){\n    return clamp(x, 0.0, 1.0);\n}\n\nfloat remap(float x, float low1, float high1, float low2, float high2){\n    return low2 + (x - low1) * (high2 - low2) / (high1 - low1);\n}\n\nfloat getNoise(vec3 pos, float speed){\n    return 0.5+0.5*(perlinNoise3D(speed*iTime * 25.0+pos));\n}\n\nfloat clouds(vec3 p, out float cloudHeight){\n\t    \n\t//Model an anvil cloud with two flipped hemispheres\n    \n    cloudHeight = saturate((p.y - CLOUD_START)/(CLOUD_END-CLOUD_START));\n\n    float bottom = 1.0-saturate(length(p.xz)/(1.25*CLOUD_EXTENT));\n    \n    //Round top and bottom edges\n    bottom *= saturate(remap(cloudHeight, 0.25*bottom, 1.0, 1.0, 0.0)) \n        \t* saturate(remap(cloudHeight, 0.0, 0.175, 0.45, 1.0));\n\n    //Subtract coarse noise\n    bottom = saturate(remap(bottom, 0.5*getNoise(0.25*p, 0.05), 1.0, 0.0, 1.0));\n    //Subtract fine noise\n    bottom = saturate(remap(bottom, 0.15*getNoise(1.0*p, 0.2), 1.0, 0.0, 1.0));\n\n    float top = 1.0-saturate(length(p.xz)/(1.5*CLOUD_EXTENT));\n    \n    //Round top and bottom edges\n    top *= saturate(remap(1.0-cloudHeight, 0.25*top, 1.0, 1.0, 0.0)) \n        * saturate(remap(1.0-cloudHeight, 0.0, 0.175, 0.45, 1.0));\n    \n    //Subtract coarse noise\n    top = saturate(remap(top, 0.5*getNoise(0.25*p, 0.05), 1.0, 0.0, 1.0));\n    //Subtract fine noise\n    top = saturate(remap(top, 0.15*getNoise(1.0*p, 0.2), 1.0, 0.0, 1.0));\n\n    return (bottom+top)*densityMultiplier;\n}\n\n//---------------------------- Cloud lighting ----------------------------\n\nfloat HenyeyGreenstein(float g, float costh){\n    return (1.0/(4.0 * 3.1415))  * ((1.0 - g * g) / pow(1.0 + g*g - 2.0*g*costh, 1.5));\n}\n\n//Get the amount of light that reaches a sample point.\nfloat lightRay(vec3 org, vec3 p, float phaseFunction, float mu, vec3 sunDirection){\n    float lightRayDistance = CLOUD_EXTENT*0.75;\n    float distToStart = 0.0;\n\n    getCloudIntersection(p, sunDirection, distToStart, lightRayDistance);\n\n    float stepL = lightRayDistance/float(STEPS_LIGHT);\n\n    float lightRayDensity = 0.0;\n\n    float cloudHeight = 0.0;\n\n    //Collect total density along light ray.\n    for(int j = 0; j < STEPS_LIGHT; j++){\n        //Reduce density of clouds when looking towards the sun for more luminous clouds.\n        lightRayDensity += mix(1.0, 0.75, mu) * \n            clouds(p + sunDirection * float(j) * stepL, cloudHeight);\n    }\n\n    //Multiple scattering approximation from Nubis presentation credited to Wrenninge et al. \n    //Introduce another weaker Beer-Lambert function.\n    float beersLaw = max(exp(-stepL * lightRayDensity), \n                         exp(-stepL * lightRayDensity * 0.2) * 0.75);\n\n    //Return product of Beer's law and powder effect depending on the \n    //view direction angle with the light direction.\n    return mix(beersLaw * 2.0 * (1.0-(exp(-stepL*lightRayDensity*2.0))), beersLaw, mu);\n}\n\nvec3 hash31(float p){\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n//Get the colour along the main view ray.\nvec3 mainRay(vec3 org, vec3 dir, vec3 sunDirection, \n             out float totalTransmittance, float mu, vec3 sunLightColour, float offset,\n             inout float d){\n\n    //Variable to track transmittance along view ray. \n    //Assume clear sky and attenuate light when encountering clouds.\n    totalTransmittance = 1.0;\n\n    //Default to black.\n    vec3 colour = vec3(0.0);\n\n    //The distance at which to start ray marching.\n    float distToStart = 0.0;\n\n    //The length of the intersection.\n    float totalDistance = 0.0;\n\n    //Determine if ray intersects bounding volume.\n    //Set ray parameters in the cloud layer.\n    bool renderClouds = getCloudIntersection(org, dir, distToStart, totalDistance);\n\n    if(!renderClouds){\n        return colour;\n    }\n\n    //Sampling step size.\n    float stepS = totalDistance / float(STEPS_PRIMARY); \n\n    //Offset the starting point by blue noise.\n    distToStart += stepS * offset;\n\n    //Track distance to sample point.\n    float dist = distToStart;\n\n    //Initialise sampling point.\n    vec3 p = org + dist * dir;\n\n    //Combine backward and forward scattering to have details in all directions.\n    float phaseFunction = mix(HenyeyGreenstein(-0.3, mu), HenyeyGreenstein(0.3, mu), 0.7);\n\n    vec3 sunLight = sunLightColour * power;\n\n    for(int i = 0; i < STEPS_PRIMARY; i++){\n\n        //Normalised height for shaping and ambient lighting weighting.\n        float cloudHeight;\n\n        //Get density and cloud height at sample point\n        float density = clouds(p, cloudHeight);\n\n        //Scattering and absorption coefficients.\n        float sigmaS = 1.0;\n        float sigmaA = 0.0;\n\n        //Extinction coefficient.\n        float sigmaE = sigmaS + sigmaA;\n\n        float sampleSigmaS = sigmaS * density;\n        float sampleSigmaE = sigmaE * density;\n\n        //If there is a cloud at the sample point\n        if(density > 0.0 ){\n            //Store closest distance to the cloud\n            d = min(d, dist);\n            \n            //Internal lightning is additional ambient source that flickers and moves around\n            //Get random position in the core of the cloud\n            vec3 source = vec3(0, CLOUD_START + CLOUD_HEIGHT * 0.5, 0) + \n                \t\t (2.0*hash31(floor(iTime * 25.0*internalSpeed))-1.0) * CLOUD_EXTENT * 0.25;\n            //Distance to the source position\n            float prox = length(p - source);\n            //Vary size for flicker\n            float size = sin(45.0*fract(iTime * 25.0))+5.0;\n            //Get distance based glow\n            vec3 internal = getGlow(prox, size, 3.2) * boltColour;\n            //Internal lightning occurs randomly\n            if(hash(floor(iTime * 25.0)) > internalFrequency){\n            \tinternal = vec3(0);\n            }\n            \n            //Add ambient source at bottom of cloud where lightning bolts exit\n            size = 3.0;\n            float h = 0.9*CLOUD_START;\n            prox = length(p - vec3(bolt0.x, h, bolt0.y));\n            internal += getGlow(prox, size, 2.2) * boltColour;\n            \n            prox = length(p - vec3(bolt1.x, h, bolt1.y));\n            internal += getGlow(prox, size, 2.2) * boltColour;\n            \n            prox = length(p - vec3(bolt2.x, h, bolt2.y));\n            internal += getGlow(prox, size, 2.2) * boltColour;\n            \n            //Combine lightning and height based ambient light\n            vec3 ambient = internal + sunLightColour * mix((0.05), (0.125), cloudHeight);\n\n            //Amount of sunlight that reaches the sample point through the cloud \n            //is the combination of ambient light and attenuated direct light.\n            vec3 luminance = ambient + sunLight * phaseFunction * \n                \t\t\t lightRay(org, p, phaseFunction, mu, sunDirection);\n\n            //Scale light contribution by density of the cloud.\n            luminance *= sampleSigmaS;\n\n            //Beer-Lambert.\n            float transmittance = exp(-sampleSigmaE * stepS);\n\n            //Better energy conserving integration\n            //\"From Physically based sky, atmosphere and cloud rendering in Frostbite\" 5.6\n            //by Sebastian Hillaire.\n            colour += \n                totalTransmittance * (luminance - luminance * transmittance) / sampleSigmaE; \n\n            //Attenuate the amount of light that reaches the camera.\n            totalTransmittance *= transmittance;  \n\n            //If ray combined transmittance is close to 0, nothing beyond this sample \n            //point is visible, so break early.\n            if(totalTransmittance <= 0.01){\n                totalTransmittance = 0.0;\n                break;\n            }\n        }\n\n        dist += stepS;\n\n        //Step along ray.\n        p = org + dir * dist;\n    }\n\n    return colour;\n}\n\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x){\n    return clamp((x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n\n    //----------------- Define a camera -----------------\n\n    vec3 rayDir = rayDirection(40.0, fragCoord);\n\n    vec3 cameraPos = texelFetch(iChannel0, ivec2(0.5, 1.5), 0).xyz;\n\n    vec3 targetDir = vec3(0,20,0) - cameraPos;\n\n    vec3 up = vec3(0.0, 1.0, 0.0);\n\n    //Get the view matrix from the camera orientation\n    mat3 viewMatrix = lookAt(cameraPos, targetDir, up);\n\n    //Transform the ray to point in the correct direction\n    rayDir = normalize(viewMatrix * rayDir);\n\n    //---------------------------------------------------\n\n    float offset = 0.0;\n\n    #ifdef DITHERING\n\n        //From https://blog.demofox.org/2020/05/10/ray-marching-fog-with-blue-noise/\n        //Get blue noise for the fragment.\n        float blueNoise = texture(iChannel1, fragCoord / 1024.0).r;\n        offset = fract(blueNoise + float(iFrame%32) * goldenRatio);\n    \n    #endif\n    \n    //Lightning. Set bolt positions and accumulate glow.\n    vec3 glow = vec3(0);\n    float dist = distanceToScene(cameraPos, rayDir, MIN_DIST, MAX_DIST, glow);\n    \n    //Cloud\n    float totalTransmittance = 1.0;\n    float exposure = 0.5;\n    vec3 sunDirection = normalize(vec3(1));\n    float mu = 0.5+0.5*dot(rayDir, sunDirection);\n    //Distance to cloud.\n    float d = 1e10;\n    vec3 colour = exposure * mainRay(cameraPos, rayDir, sunDirection, totalTransmittance,\n                                     mu, sunLightColour, offset, d); \n\n    vec3 background = getSkyColour(rayDir);\n\t//Draw sun\n    background += sunLightColour * 0.2*getGlow(1.0-mu, 0.001, 0.55);\n    \n    //Distance to plane at cloud bottom limit\n\tfloat t = 1e10;\n    bool hitsPlane = intersectPlane(vec3(0, -1, 0), vec3(0, CLOUD_START, 0.0), cameraPos,\n                                    rayDir, t);\n    \n    //t is distance to the plane below which lightning bolts occur, d is distance to the cloud\n    //If lightning is behind cloud, add it to the background and draw the cloud in front.\n    if(t >= d){\n        background += glow;\n    }\n\n    colour += background * totalTransmittance;\n    \n    //If lightning is in front of the cloud, add it last. As the glow has no depth data, \n    //don't display it if above the bottom limit plane to avoid mixing error.\n    if((t < d && hitsPlane) || cameraPos.y < CLOUD_START){\n        colour += glow;\n    }\n\n    //Tonemapping\n    colour = ACESFilm(colour);\n\n    //Gamma correction 1.0/2.2 = 0.4545...\n    colour = pow(colour, vec3(0.4545));\n    \n    // Output to screen\n    fragColor = vec4(colour, 1.0);\n}",
   "name": "Image",
   "description": "",
   "type": "image"
  },
  {
   "inputs": [
    {
     "id": "4dXGR8",
     "filepath": "/media/previz/buffer00.png",
     "type": "buffer",
     "channel": 0,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    }
   ],
   "outputs": [
    {
     "id": "4dXGR8",
     "channel": 0
    }
   ],
   "code": "//Track mouse movement and resolution change between frames and set camera position.\n\n#define PI 3.14159\n#define EPS 1e-4\n#define CAMERA_DIST 65.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    //Work with just the first four pixels.\n    if((fragCoord.x == 0.5) && (fragCoord.y < 4.0)){\n        \n        vec4 oldMouse = texelFetch(iChannel0, ivec2(0.5), 0).xyzw;\n        vec4 mouse = (iMouse / iResolution.xyxy); \n        vec4 newMouse = vec4(0);\n\n        float mouseDownLastFrame = texelFetch(iChannel0, ivec2(0.5, 3.5), 0).x;\n        \n        //If mouse button is down and was down last frame\n        if(iMouse.z > 0.0 && mouseDownLastFrame > 0.0){\n            \n            //Difference between mouse position last frame and now.\n            vec2 mouseMove = mouse.xy-oldMouse.zw;\n            newMouse = vec4(oldMouse.xy + vec2(5.0, 3.0)*mouseMove, mouse.xy);\n        }else{\n            newMouse = vec4(oldMouse.xy, mouse.xy);\n        }\n        newMouse.x = mod(newMouse.x, 2.0*PI);\n        newMouse.y = min(0.99, max(-0.99, newMouse.y));\n\n        //Store mouse data in the first pixel of Buffer B.\n        if(fragCoord == vec2(0.5, 0.5)){\n            //Set value at first frames\n            if(iFrame < 5){\n                newMouse = vec4(-0.0, -0.05, 0.0, 0.0);\n            }\n            fragColor = vec4(newMouse);\n        }\n\n        //Store camera position in the second pixel of Buffer B.\n        if(fragCoord == vec2(0.5, 1.5)){\n            //Set camera position from mouse information.\n            vec3 cameraPos = CAMERA_DIST * vec3(sin(newMouse.x), -sin(newMouse.y), -cos(newMouse.x));\n            fragColor = vec4(cameraPos, 1.0);\n        }\n        \n        //Store resolution change data in the third pixel of Buffer B.\n        if(fragCoord == vec2(0.5, 2.5)){\n            float resolutionChangeFlag = 0.0;\n            //The resolution last frame.\n            vec2 oldResolution = texelFetch(iChannel0, ivec2(0.5, 2.5), 0).yz;\n            \n            if(iResolution.xy != oldResolution){\n            \tresolutionChangeFlag = 1.0;\n            }\n            \n        \tfragColor = vec4(resolutionChangeFlag, iResolution.xy, 1.0);\n        }\n           \n        //Store whether the mouse button is down in the fourth pixel of Buffer A\n        if(fragCoord == vec2(0.5, 3.5)){\n            if(iMouse.z > 0.0){\n            \tfragColor = vec4(vec3(1.0), 1.0);\n            }else{\n            \tfragColor = vec4(vec3(0.0), 1.0);\n            }\n        }\n        \n    }\n}",
   "name": "Buffer A",
   "description": "",
   "type": "buffer"
  }
 ]
}