{
 "ver": "0.1",
 "info": {
  "id": "Nl2fDm",
  "date": "0",
  "viewed": 0,
  "name": "My dark land JiPi",
  "description": "Too big shader. Sorry for that !\nwill add credits soon (many thanks to Shane and BigWigs)\nSorry if not compiled here it is just just (integrated intel video board)",
  "likes": 0,
  "published": "Private",
  "usePreview": 0,
  "tags": [
   "landscape",
   "sad",
   "scene",
   "human",
   "run"
  ],
  "hasliked": 0,
  "parentid": "ll2BWm",
  "parentname": "My dark land"
 },
 "renderpass": [
  {
   "inputs": [
    {
     "id": "4dXGR8",
     "filepath": "/media/previz/buffer00.png",
     "type": "buffer",
     "channel": 0,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    },
    {
     "id": "XsXGR8",
     "filepath": "/media/previz/buffer01.png",
     "type": "buffer",
     "channel": 1,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    },
    {
     "id": "lsSXzm",
     "filepath": "https://soundcloud.com/tavi230/armand-amar-inanna",
     "type": "musicstream",
     "channel": 3,
     "sampler": {
      "filter": "linear",
      "wrap": "clamp",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 0
    }
   ],
   "outputs": [
    {
     "id": "4dfGRr",
     "channel": 0
    }
   ],
   "code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = mix(texture(iChannel0, fragCoord/iResolution.xy),\n                    texture(iChannel1, fragCoord/iResolution.xy), smoothstep(31., 30., iTime) /* smoothstep(200., 199., iTime)*/);\n}",
   "name": "Image",
   "description": "",
   "type": "image"
  },
  {
   "inputs": [
    {
     "id": "XsXGRn",
     "filepath": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg",
     "type": "texture",
     "channel": 2,
     "sampler": {
      "filter": "mipmap",
      "wrap": "repeat",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    },
    {
     "id": "Xsf3zn",
     "filepath": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
     "type": "texture",
     "channel": 0,
     "sampler": {
      "filter": "mipmap",
      "wrap": "repeat",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    },
    {
     "id": "4sf3Rr",
     "filepath": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png",
     "type": "texture",
     "channel": 1,
     "sampler": {
      "filter": "mipmap",
      "wrap": "repeat",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    }
   ],
   "outputs": [
    {
     "id": "4dXGR8",
     "channel": 0
    }
   ],
   "code": "//-----------------------------------------------------\n// Created by sebastien durand - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n#define WITH_AO\n#define WITH_REFLECTION\n#define WITH_FACE\n\n// Isosurface Renderer\n#define g_traceLimit 64\n#define g_traceSize .002\n\n\n#define MAX_DIST 192.\n#define RUN_STEP 120.\n\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\nfloat gTime;\nmat2 rotHead;\n\nvec3 gLightPos = vec3(2, 1, 6);\nconst vec3 gStaticPos = vec3(-95.,8.83,-121.7); //vec3(-95.5,12.8,-123);\n\n\n//\t[Shane] Combustible Clouds\n//\t------------------\n\n// Hash function. This particular one probably doesn't disperse things quite \n// as nicely as some of the others around, but it's compact, and seems to work.\n//\nvec3 hash33(vec3 p){ \n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n); \n}\n\n// IQ's texture lookup noise... in obfuscated form. There's less writing, so\n// that makes it faster. That's how optimization works, right? :) Seriously,\n// though, refer to IQ's original for the proper function.\n// \n// By the way, you could replace this with the non-textured version, and the\n// shader should run at almost the same efficiency.\nfloat n3D( in vec3 p ){\n    vec3 i = floor(p); p -= i; p *= p*(3. - 2.*p);\n\tp.xy = texture(iChannel0, (p.xy + i.xy + vec2(37, 17)*i.z + .5)/256., -100.).yx;\n\treturn mix(p.x, p.y, p.z);\n}\n\n// Basic low quality noise consisting of three layers of rotated, mutated \n// trigonometric functions. Needs work, but sufficient for this example.\nfloat trigNoise3D(in vec3 p){ \n    float res = 0., sum = 0.;\n    // IQ's cheap, texture-lookup noise function. Very efficient, but still \n    // a little too processor intensive for multiple layer usage in a largish \n    // \"for loop\" setup. Therefore, just one layer is being used here.\n    float n = n3D(p*8.);// + iTime*2.);\n    // Two sinusoidal layers. I'm pretty sure you could get rid of one of \n    // the swizzles (I have a feeling the GPU doesn't like them as much), \n    // which I'll try to do later.\n    \n    vec3 t = sin(p.yzx*3.14159265 + cos(p.zxy*3.14159265+1.57/2.))*0.5 + 0.5;\n    p = p*1.5 + (t - 1.5); //  + iTime*0.1\n    res += (dot(t, vec3(0.333)));\n\n    t = sin(p.yzx*3.14159265 + cos(p.zxy*3.14159265+1.57/2.))*0.5 + 0.5;\n    res += (dot(t, vec3(0.333)))*0.7071;    \n\t \n\treturn ((res/1.7071))*0.85 + n*0.15;\n}\n\nvec4 clouds(in vec3 ro, in vec3 rd, in float tend) {\n\t//rd = rd.zyx;\n    // Ray origin. Moving along the Z-axis.\n    //vec3 ro = vec3(0, 0, iTime*.02);\n\n    // Placing a light in front of the viewer and up a little. You could just make the \n    // light directional and be done with it, but giving it some point-like qualities \n    // makes it a little more interesting. You could also rotate it in sync with the \n    // camera, like a light beam from a flying vehicle.\n    vec3 lp = gLightPos;\n    //lp.xz = lp.xz*rM;\n    //lp += ro;\n    // The ray is effectively marching through discontinuous slices of noise, so at certain\n    // angles, you can see the separation. A bit of randomization can mask that, to a degree.\n    // At the end of the day, it's not a perfect process. Note, the ray is deliberately left \n    // unnormalized... if that's a word.\n    //\n    // Randomizing the direction.\n    //rd = (rd + (hash33(rd.zyx)*0.004-0.002)); \n    // Randomizing the length also. \n    //rd *= (1. + fract(sin(dot(vec3(7, 157, 113), rd.zyx))*43758.5453)*0.04-0.02);  \n    \n    //rd = rd*.5 + normalize(rd)*.5;    \n    \n    // Some more randomization, to be used for color based jittering inside the loop.\n    vec3 rnd = hash33(rd + 311.);\n\n    // Local density, total density, and weighting factor.\n    float lDe = 0., td = 0., w = 0.;\n\n    // Closest surface distance, and total ray distance travelled.\n    float d = 1., t = dot(rnd, vec3(.08));\n\n    // Distance threshold. Higher numbers give thicker clouds, but fill up the screen too much.    \n    const float h = .5;\n\n\n    // Initializing the scene color to black, and declaring the surface position vector.\n    vec3 col = vec3(0), sp;\n\n\n    // Particle surface normal.\n    //\n    // Here's my hacky reasoning. I'd imagine you're going to hit the particle front on, so the normal\n    // would just be the opposite of the unit direction ray. However particles are particles, so there'd\n    // be some randomness attached... Yeah, I'm not buying it either. :)\n    vec3 sn = normalize(hash33(rd.yxz)*.03-rd);\n\n    // Raymarching loop.\n    for (int i=0; i<48; i++) {\n\n        // Loop break conditions. Seems to work, but let me\n        // know if I've overlooked something.\n        if((td>1.) || d<.001*t || t>80. || t>tend) break;\n\n        sp = ro + rd*t; // Current ray position.\n        d = trigNoise3D(sp*.75); // Closest distance to the surface... particle.\n\n        // If we get within a certain distance, \"h,\" of the surface, accumulate some surface values.\n        // The \"step\" function is a branchless way to do an if statement, in case you're wondering.\n        //\n        // Values further away have less influence on the total. When you accumulate layers, you'll\n        // usually need some kind of weighting algorithm based on some identifying factor - in this\n        // case, it's distance. This is one of many ways to do it. In fact, you'll see variations on \n        // the following lines all over the place.\n        //\n        lDe = (h - d) * step(d, h); \n        w = (1. - td) * lDe;   \n\n        // Use the weighting factor to accumulate density. How you do this is up to you. \n        td += w*w*8. + 1./60.; //w*w*5. + 1./50.;\n        //td += w*.4 + 1./45.; // Looks cleaner, but a little washed out.\n\n\n        // Point light calculations.\n        vec3 ld = lp-sp; // Direction vector from the surface to the light position.\n        float lDist = max(length(ld), 0.001); // Distance from the surface to the light.\n        ld/=lDist; // Normalizing the directional light vector.\n\n        // Using the light distance to perform some falloff.\n        float atten = 1./(1. + lDist*0.1 + lDist*lDist*.03);\n\n        // Ok, these don't entirely correlate with tracing through transparent particles,\n        // but they add a little anglular based highlighting in order to fake proper lighting...\n        // if that makes any sense. I wouldn't be surprised if the specular term isn't needed,\n        // or could be taken outside the loop.\n        float diff = max(dot(sn, ld ), 0.);\n        float spec = pow(max(dot( reflect(-ld, sn), -rd ), 0.), 4.);\n\n        // Accumulating the color. Note that I'm only adding a scalar value, in this case,\n        // but you can add color combinations.\n        col += w*(1.+ diff*.5 + spec*.5)*atten;\n        // Optional extra: Color-based jittering. Roughens up the grey clouds that hit the camera lens.\n        col += (fract(rnd*289. + t*40001.) - .5)*.02;;\n\n        // Try this instead, to see what it looks like without the fake contrasting. Obviously,\n        // much faster.\n        //col += w*atten*1.25;\n\n\n        // Enforce minimum stepsize. This is probably the most important part of the procedure.\n        // It reminds me a little of of the soft shadows routine.\n        t +=  max(d*.5, .02); //\n        // t += 0.2; // t += d*0.5;// These also work, but don't seem as efficient.\n\n    }\n    \n    col = max(col, 0.);\n\n    \n    // Adding a bit of a firey tinge to the cloud value.\n    col = mix(pow(vec3(1.3, 1, 1)*col, vec3(1, 2, 10)), col, dot(cos(rd*6. +sin(rd.yzx*6.)), vec3(.333))*.2+.8);\n \n    // Using the light position to produce a blueish sky and sun. Pretty standard.\n    vec3 sky = vec3(.6, .8, 1.)*min((1.5+rd.y*.5)/2., 1.); \t\n    sky = mix(vec3(1, 1, .9), vec3(.31, .42, .53), rd.y*0.5 + 0.5);\n    \n    float sun = clamp(dot(normalize(lp-ro), rd), 0.0, 1.0);\n   \n    // Combining the clouds, sky and sun to produce the final color.\n    sky += vec3(1, .3, .05)*pow(sun, 5.)*.25; \n    sky += vec3(1, .4, .05)*pow(sun, 16.)*.35; \t\n    col = mix(col, sky, smoothstep(0., 25., t));\n \tcol += vec3(1, .6, .05)*pow(sun, 16.)*.25; \t\n \n    // Done.\n    return vec4(col, clamp(0.,1.,td));\n    \n}\n\n\n// standard       - https://www.shadertoy.com/view/4sjGzc\n\n//---------------------------------------------------------------------\n//    Animation\n//---------------------------------------------------------------------\n\n//const float hipz = 8.;\n// WALK -----\n\n//                       Contact           Down               Pass               Up      \n\nvec3 shoulder1, elbow1, wrist1, head,\n     shoulder2, elbow2, wrist2;\nvec3 foot1, ankle1, knee1, hip1,\n     foot2, ankle2, knee2, hip2;\nvec3 v2Foot1, v2Foot12, v2Foot2, v2Foot22, v3Foot1, v3Foot2;\nvec3 v1Hand1, v2Hand1, v3Hand1,\n     v1Hand2, v2Hand2, v3Hand2;\n\n\n\n\n//---------------------------------------------------------------------\n//    HASH functions (iq)\n//---------------------------------------------------------------------\n\nfloat hash( float n ) { return fract(sin(n)*43758.5453123); }\n\n// mix noise for alive animation, full source\nvec4 hash4( vec4 n ) { return fract(sin(n)*1399763.5453123); }\nvec3 hash3( vec3 n ) { return fract(sin(n)*1399763.5453123); }\n\n\n\n//---------------------------------------------------------------------\n//    Geometry\n//---------------------------------------------------------------------\n\n// Distance from ray to point\nfloat distanceRayPoint(vec3 ro, vec3 rd, vec3 p, out float h) {\n    h = dot(p-ro,rd);\n    return length(p-ro-rd*h);\n}\n\n\n//---------------------------------------------------------------------\n//   Modeling Primitives\n//   [Inigo Quilez] https://iquilezles.org/articles/distfunctions\n//---------------------------------------------------------------------\n\nbool cube(vec3 ro, vec3 rd, vec3 sz, out float tn, out float tf) { //, out vec3 n) {\n\tvec3 m = 1./rd,\n         k = abs(m)*sz,\n         a = -m*ro-k*.5, \n         b = a+k;\n//\tn = -sign(rd)*step(a.yzx,a)*step(b.zxy,b);\n    tn = max(max(a.x,a.y),a.z);\n    tf = min(min(b.x,b.y),b.z); \n\treturn /*tn>0. &&*/ tn<tf;\n}\n\n\nfloat sdCap(in vec3 p, in vec3 a, in vec3 b, in float r ) {\n    vec3 pa = p - a, ba = b - a;\n    return length(pa - ba*clamp( dot(pa,ba)/dot(ba,ba), 0., 1. ) ) - r;\n}\n\nfloat sdCapsule(in vec3 p, in vec3 a, in vec3 b, in float r0, in float r1 ) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0., 1.);\n    return length( pa - ba*h ) - mix(r0,r1,h);\n}\n\nfloat sdCap2(in vec3 p, in vec3 a, in vec3 b, in float r1, in float r2) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba), 0., 1. );\n    return length(pa - ba*h) - mix(r1,r2,h*h*h);\n}\n\nfloat udRoundBox(in vec3 p, in vec3 b, in float r ) {\n  return length(max(abs(p)-b,0.))-r;\n}\n\n//https://www.shadertoy.com/view/Xs3GRB\nfloat fCylinder(in vec3 p, in float r, in float height) {\n\treturn max(length(p.xz) - r, abs(p.y) - height);\n}\n\nfloat sdPlane(in vec3 p, in vec3 n) {  // n must be normalized\n  return dot(p,n);\n}\n\nfloat smin(in float a, in float b, in float k ) {\n    float h = clamp( .5+.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.-h);\n}\n\n// Smooth maximum, based on the function above.\nfloat smaxP(float a, float b, float s){\n    \n    float h = clamp( 0.5 + 0.5*(a-b)/s, 0., 1.);\n    return mix(b, a, h) + h*(1.0-h)*s;\n}\n\n// hg_sdf : http://mercury.sexy/hg_sdf/\nfloat fOpEngrave(float a, float b, float r) {\n\treturn max(a, (a + r - abs(b))*0.7071); //sqrt(.5));\n}\n\nfloat fOpIntersectionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r + a,r + b), vec2(0));\n\treturn min(-r, max (a, b)) + length(u);\n}\n\n\nfloat sdEllipsoid( in vec3 p, in vec3 r) {\n    return (length(p/r ) - 1.) * min(min(r.x,r.y),r.z);\n}\n\n\nfloat fOpDifferenceRound (float a, float b, float r) {\n\treturn fOpIntersectionRound(a, -b, r);\n}\n\n\n//---------------------------------------------------------------------\n//    Man + Ground distance field \n//---------------------------------------------------------------------\n\n// The canyon, complete with hills, gorges and tunnels. I would have liked to provide a far\n// more interesting scene, but had to keep things simple in order to accommodate slower machines.\nfloat mapGround(in vec3 p){\n    float tx = .2*(cos(p.x*.03))*(textureLod(iChannel1, p.xz/16. + p.xy/80., 0.0).x);\n    vec3 q = p*0.25;\n#ifdef IS_RUNNING\n    float h = tx + .5*(dot(sin(q)*cos(q.yzx), vec3(.222))) + dot(sin(q*1.3)*cos(q.yzx*1.4), vec3(.111));\n    float d = p.y + smin(0.,smoothstep(.2,3., abs(p.z))*(h)*9.,.2);\n#else\n    float h = tx + .5*(dot(sin(q)*cos(q.yzx), vec3(.222))) + dot(sin(q*1.3)*cos(q.yzx*1.4), vec3(.111)) - .5*(textureLod(iChannel1, q.xz/80. + q.xz/102., 0.0).x)\n        - .5*smoothstep(18., 0., length(p.xz-gStaticPos.xz))\n        + .5*smoothstep(130., 0., length(p.xz- gStaticPos.xz - vec2(120,50)));\n\tfloat d = p.y + smin(0., h*9., .2);\n#endif\n    return d; \n}\n\n// capsule with bump in the middle -> use for neck\nfloat sdCapsule2(in vec3 p,in vec3 a,in vec3 b, in float r0,in float r1,in float bump) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba), 0., 1. );\n    float dd = bump*sin(3.14*h);  // Little adaptation\n    return length(pa - ba*h) - mix(r0,r1,h)*(1.+dd); \n}\n\n\nconst vec3 g_nozePos = vec3(0,-.28+.04,.47+.08);\nconst vec3 g_eyePos = vec3(.14,-.14,.29);\nconst float g_eyeSize = .09;\nmat2   g_eyeRot;\nconst mat2 ma = rot(-.5);\nconst mat2 mb = rot(-.15);\nconst mat2 mc = rot(-.6);\n\nfloat smax(in float a, in float b, in float k) {\n    return log(exp(a/k)+exp(b/k))*k;\n}\n\n\nfloat mapHead(in vec3 p0) {\n    vec3 p = p0;\n    float d = MAX_DIST;\n   \n// Skull modeling -------------------------\n    d = sdEllipsoid(p-vec3(0,.05,.0), vec3(.39,.48,.46));\t\t\t\t  \n    d = smin(d, sdEllipsoid(p-vec3(0.,.1,-.15), vec3(.42,.4,.4)),.1);     \n    d = smin(d, udRoundBox(p-vec3(0,-.28,.2), vec3(.07,.05,.05),.05),.4); // Basic jaw \n\n// Neck -----------------------------------\n //   d = smin(d, dNeck, .05);\n\n// Symetrie -------------------------------\n    p.x = abs(p.x);\n\n// Eye hole \n    d = smax(d, -sdEllipsoid(p-vec3(.12,-.16,.48), vec3(.09,.06,.09)), .07);\n\n// Noze ------------------------------------\n    const float animNoze = 0.;\n    d = smin(d, max(-(length(p-vec3(.032,-.325,.45))-.028),   // Noze hole\n                    smin(length(p-vec3(.043,-.29+.015*animNoze,.434))-.01,  // Nostrils\n                    sdCapsule(p, vec3(0,-.13,.39), vec3(0,-.28+.008*animNoze,.47), .01,.04), .05)) // Bridge of the nose\n            ,.065); \n   \n// Mouth -----------------------------------    \n    d = smin(d, length(p- vec3(.22,-.34,.08)), .17); // Jaw\n    d = smin(d, sdCapsule(p, vec3(.16,-.35,.2), vec3(-.16,-.35,.2), .06,.06), .15); // Cheeks\n   \n    d = smin(d, max(-length(p.xz-vec2(0,.427))+.015,  \t// Line under the noze\n        \t\tmax(-p.y-.41+.008*animNoze,   \t\t\t\t\t\t// Upper lip\n                    sdEllipsoid(p- vec3(0,-.34,.37), vec3(.08,.15,.05)))), // Mouth bump\n             .032);\n\n// Chin -----------------------------------  \n    d = smin(d, length(p- vec3(0,-.5,.26)), .2);   // Chin\n    d = smin(d, length(p- vec3(0,-.44,.15)), .25); // Under chin \n  \n// Eyelid ---------------------------------\n\tvec3 p_eye1 = p - g_eyePos;\n    p_eye1.xz *= mb;\n    \n    vec3 p_eye2 = p_eye1;\n    float d_eye = length(p_eye1) - g_eyeSize*1.;\n          \n\tp_eye1.yz *= g_eyeRot;\n\tp_eye2.zy *= mc;\n    \n    float d1 = min(max(-p_eye1.y,d_eye - .01),\n                   max(p_eye2.y,d_eye - .005));\n\n    d = smin(d,d1,.01);\n\treturn d; \n}\n\nfloat mapLegs(const in vec3 pos){    \n    // Leg 1\n    float d = max(min(sdCap2(pos, foot1, ankle1, .1,.15),\n                      sdCap2(pos, ankle1, knee1, .165,.105)),\n\t\t\t\t  -sdPlane(pos-ankle1+v2Foot1*.1, v2Foot12));\n    // Leg 2\n\td = min(d,max(min(sdCap2(pos, foot2, ankle2, .1,.15),\n                      sdCap2(pos, ankle2, knee2, .165,.105)),\n\t\t\t\t  -sdPlane(pos-ankle2+v2Foot2*.1, v2Foot22)));\n \n    d = fOpEngrave(d, min(min(sdCap(pos-ankle1, -.1*v3Foot1, .1*v3Foot1, .12), \n                              sdCap(pos-ankle2, -.1*v3Foot2, .1*v3Foot2, .12)), \n                          min(length(pos - knee1),length(pos - knee2))-.11), .015);\n    \n    d = min(d, sdCap2(pos,  hip1, knee1, .12, .075));\n    return min(d, sdCap2(pos, hip2, knee2, .12, .075));\n}\n\nfloat mapGirl(const in vec3 pos){\n    vec3 \n         ep0 = mix(shoulder1,shoulder2,.5),\n         ha0 = mix(hip1,hip2,.5),\n         h1 = head + vec3(.0,-.24-.05,0),\n         h2 = head + vec3(.0,.15-.05,0),\n         hn = normalize(h1-h2),\n         a = mix(ha0,ep0,.15), b = mix(ha0,ep0,.75);\n    \n    vec3 posRot = pos; // - head; \n    posRot.xz = (posRot.xz - head.xz) * rotHead + head.xz;\n   // posRot.xz = (posRot.xz) * rotHead;\n    \n    float d = mapLegs(pos);\n\n    // Head\n    float scaleHead = 1.75;\n    vec3 pHead = (posRot - head) + vec3(.02, .04, 0);\n    pHead = pHead.zyx*scaleHead;\n    float dHead = mapHead(pHead)/scaleHead;\n    d = min(d, dHead);\n\n\t// Eye\n    pHead.x = abs(pHead.x);\n    vec3 p_eye = pHead-g_eyePos;\n    p_eye.xz *= ma;  \n\tfloat dEye = (length(p_eye) - g_eyeSize)/scaleHead;\n    d = min(d, dEye);\n        \n    // Arms\n    d = min(d, sdCapsule2(pos, shoulder1, elbow1, .054,.051,.5));\n    d = min(d, sdCapsule2(pos, shoulder2, elbow2, .054,.051,.5));\n    float dArm = sdCap2(pos, elbow1, wrist1-.01*v1Hand1, .09, .055);\n    dArm = min(dArm,  sdCap2(pos, elbow2, wrist2-.01*v1Hand2, .09, .055));\n    dArm = fOpEngrave(dArm, \n                      min(min(length(pos - wrist2), length(pos - wrist1)),\n                          min(length(pos - elbow2), length(pos - elbow1))) - .1,.008);\n\n    \n    // Neck and Shoulders\n    d = smin(d, min(sdCapsule2(pos+vec3(.03,0,0), mix(shoulder1, shoulder2,.1),mix(shoulder1, shoulder2,.9),.08, .08,.6),\n                    sdCap(pos,ep0-vec3(.03,0,0), head-vec3(.08,.1,0), .09)), .12);\n    \n    // Torso\n\td = smin(d, min(sdCap2(pos, a+vec3(0,0,.03), b-vec3(0,0,.04), .19,.22),sdCap2(pos, a-vec3(0,0,.03), b+vec3(0,0,.04), .19,.22)),.18);\n    \n\t// Fingers 1\n    vec3 c = wrist1-v3Hand1*.03;\n    float d2 = sdCap(pos, c-v1Hand1*.06+v2Hand1*.03+v3Hand1*.06, wrist1+.09*(v2Hand1+v1Hand1+v3Hand1), .02);\n    d2 = min(d2, sdCap(pos, c, wrist1+.18*(v1Hand1+v2Hand1*.2), .016));\n    d2 = min(d2, sdCap(pos, c-v2Hand1*.01, wrist1+.2*(v1Hand1-v2Hand1*.2), .017));\n    d2 = min(d2, sdCap(pos, c-v2Hand1*.02, wrist1+.18*(v1Hand1-v2Hand1*.5), .016));\n    d2 = min(d2, sdCap(pos, c-v2Hand1*.04, wrist1+.15*(v1Hand1-v2Hand1*.8), .014));\n    \n\t// Fingers 2     \n    c = wrist2-v3Hand2*.03;\n    d2 = min(d2, sdCap(pos, c-v1Hand2*.06+v2Hand2*.03+v3Hand2*.06, wrist2+.09*(v2Hand2+v1Hand2+v3Hand2), .02));\n    d2 = min(d2, sdCap(pos, c, wrist2+.18*(v1Hand2+v2Hand2*.2), .016));\n    d2 = min(d2, sdCap(pos, c-v2Hand2*.01, wrist2+.2*(v1Hand2-v2Hand2*.2), .017));\n    d2 = min(d2, sdCap(pos, c-v2Hand2*.02, wrist2+.18*(v1Hand2-v2Hand2*.5), .016));\n    d2 = min(d2, sdCap(pos, c-v2Hand2*.04, wrist2+.15*(v1Hand2-v2Hand2*.8), .014));\n\n\n    d = min(d, smin(d2, dArm, .12));\n   \n    // Short\n    float dShort = min(sdCap(pos, hip1+vec3(-.03,0,0), mix(hip1, knee1,.25), .13), \n                       sdCap(pos, hip2+vec3(-.03,0,0), mix(hip2, knee2,.25), .13));                    \n    // TODO ca serait plus cool de bouger avec les hanches mais il faut recuperer une base fixee sur les hanches\n    dShort = smin(dShort, mix(d, sdCap(pos, a, ha0+vec3(0,.1,0), .22),.5),.1);\n    d = min(d, dShort);\n\n   // Casque\n\tfloat dHelmet;\n    posRot += vec3(.03,.02,0);\n    dHelmet = max(sdPlane(posRot-h1+hn*.07, hn), mix(dHead, sdCap2(posRot, h1-vec3(.23,0,0), h2-vec3(0,.05,0),.28,.36),.5));\n    dHelmet = max(-fCylinder(posRot-h1-vec3(.2,0,0), .18,.3), dHelmet); \n\n    dHelmet = fOpEngrave(dHelmet, sdCap(posRot-h2, -vec3(0,.1,1), -vec3(0,.1,-1), .1),.015);\n   \n\td = min(d, dHelmet);\n//\td = min(d, mapGround(pos));\n            \n    return min(d2,d);\n}\n\n\n//---------------------------------------------------------------------\n//    Girl colors \n//---------------------------------------------------------------------\n#define min2(a, b) (a.x<b.x?a:b)\n#define max2(a, b) (a.x>b.x?a:b)\n\n#define ID_MAN 100.\n#define ID_GROUND 90.\n#define ID_GLOVE 106. \n#define ID_HELMET 107.\n#define ID_FOOT 108.\n#define ID_SHORT 110.\n#define ID_LEG  201.\n#define ID_SKIN 202.\n#define ID_ARM  203.\n#define ID_TORSO 204.\n#define ID_EYE 205.\n\nconst vec3 COLOR_SKIN = vec3(.6,.43,.3);\nconst vec3 COLOR_ARMOR = vec3(.14,.79,.7);\nconst vec3 COLOR_CLOTHES2 = vec3(.14,.79,.7);\nconst vec3 COLOR_CLOTHES = vec3(.66,.94,.91);\n \n\n\n\n#ifdef WITH_FACE\n\n//---------------------------------------------------------------------\n//   Draw face\n//   \"Smiley Tutorial\" by Martijn Steinrucken aka BigWings - 2017\n//---------------------------------------------------------------------\n// This Smiley is part of my ShaderToy Tutorial series on YouTube:\n// Part 1 - Creating the Smiley - https://www.youtube.com/watch?v=ZlNnrpM0TRg\n// Part 2 - Animating the Smiley - https://www.youtube.com/watch?v=vlD_KOrzGDc&t=83s\n//---------------------------------------------------------------------\n\n\n#define S(a, b, t) smoothstep(a, b, t)\n#define B(a, b, blur, t) S(a-blur, a+blur, t)*S(b+blur, b-blur, t)\n#define sat(x) clamp(x, 0., 1.)\n\nfloat remap01(float a, float b, float t) {\n\treturn sat((t-a)/(b-a));\n}\n\nfloat remap(float a, float b, float c, float d, float t) {\n\treturn sat((t-a)/(b-a)) * (d-c) + c;\n}\n\nvec2 within(vec2 uv, vec4 rect) {\n\treturn (uv-rect.xy)/(rect.zw-rect.xy);\n}\n\nvec4 Brow(vec2 uv, float smile) {\n    float offs = mix(.2, 0., smile);\n    uv.y += offs;\n    \n    float y = uv.y;\n    uv.y += uv.x*mix(.5, .8, smile)-mix(.1, .3, smile);\n    uv.x -= mix(.0, .1, smile);\n    uv -= .5;\n    \n    vec4 col = vec4(0.);\n    \n    float blur = .1;\n    \n   \tfloat d1 = length(uv);\n    float s1 = S(.45, .45-blur, d1);\n    float d2 = length(uv-vec2(.1, -.2)*.7);\n    float s2 = S(.5, .5-blur, d2);\n    \n    float browMask = sat(s1-s2);\n    \n    float colMask = remap01(.7, .8, y)*.75;\n    colMask *= S(.6, .9, browMask);\n    colMask *= smile;\n    vec4 browCol = vec4(.04, .02, .02, 1.); //mix(vec4(.4, .2, .2, 1.), vec4(1., .75, .5, 1.), colMask); \n   \n    uv.y += .15-offs*.5;\n    blur += mix(.0, .1, smile);\n    d1 = length(uv);\n    s1 = S(.45, .45-blur, d1);\n    d2 = length(uv-vec2(.1, -.2)*.7);\n    s2 = S(.5, .5-blur, d2);\n    float shadowMask = sat(s1-s2);\n    \n    col = mix(col, vec4(0.,0.,0.,1.), S(.0, 1., shadowMask)*.5);\n    \n    col = mix(col, browCol, S(.2, .4, browMask));\n    \n    return col;\n}\n\nvec4 Mouth(vec2 uv, float smile) {\n    uv -= .5;\n\tvec4 col = vec4(.5, .18, .05, 1.);\n    \n    uv.y *= 1.5;\n    uv.y -= uv.x*uv.x*2.*smile;\n    \n    uv.x *= mix(2.5, 1., smile);\n    \n    float d = length(uv);\n    col.a = S(.5, .48, d);\n    \n    vec2 tUv = uv;\n    tUv.y += (abs(uv.x)*.5+.1)*(1.-smile);\n    float td = length(tUv-vec2(0., .6));\n    \n    vec3 toothCol = vec3(1.)*S(.6, .35, d);\n    col.rgb = mix(col.rgb, toothCol, S(.4, .37, td));\n    \n    td = length(uv+vec2(0., .5));\n    col.rgb = mix(col.rgb, vec3(1., .5, .5), S(.5, .2, td));\n    return col;\n}\n\nvec4 drawFace(vec3 pos) {\n    pos -= head;\n    pos.y += .05;\n    pos.xz *= rotHead;\n\tvec4 col = vec4(COLOR_SKIN, ID_SKIN);\n\tif (pos.x < 0.) return col;\n    vec2 uv = pos.zy*2.8;\n\tfloat side = sign(uv.x);\n\tuv.x = abs(uv.x);\n      float d = length(uv-vec2(.28, -.42));\n    float cheek = S(.2,.01, d)*.4;\n    cheek *= S(.17, .16, d);\n    col.rgb = mix(col.rgb, vec3(1., .1, .1), cheek);\n\tvec4 mouth = Mouth(within(uv, vec4(-.27, -.72, .27, -.60)), .5);\n\tcol = mix(col, mouth, mouth.a);\n\tvec4 brow = Brow(within(uv, vec4(.06, -.14, .51, .06)), 0.);\n\tcol = mix(col, brow, brow.a);\n    return vec4(col.rgb, ID_SKIN);\n}\n\n\n\nvec4 drawEye(in vec3 p) {\n    vec3 posRot = p; // - head; \n    posRot.xz = (posRot.xz - head.xz) * rotHead + head.xz;\n    \n    float scaleHead = 1.75;\n    vec3 pHead = (posRot-head) + vec3(.02, .04, 0);\n    pHead = pHead.zyx*scaleHead;\n\n\t// Eye\n    vec3 p_eye = pHead-g_eyePos;\n    vec3 g_eyePosloc = g_eyePos;\n    g_eyePosloc.x *= sign(pHead.x);\n   \tvec3 pe = pHead - g_eyePosloc;\n\n   \n    float a = .2*sin(2.*iTime)*cos(.01*iTime);//clamp(atan(-dir.x, dir.z), -.6,.6), \n    float ca = cos(a), sa = sin(a);\n    pe.xz *= mat2(ca, sa, -sa, ca);\n\n    float b = .2;//.1+.1*sin(iTime*.1);//clamp(atan(-dir.y, dir.z), -.3,.3), \n    float cb = cos(b), sb = sin(b);\n    pe.yz *= mat2(cb, sb, -sb, cb);\n    \n    float d = length(pe.xy);\n    vec3 col = mix(vec3(0), mix(vec3(.88,.41,.0), mix(vec3(0),vec3(1.5),\n                   .5+.5*smoothstep(.0405,.0415,d)), smoothstep(.04,.041,d)), smoothstep(.02,.025,d));\n\n    return vec4(col,ID_EYE);\n}\n\nfloat sdFish(vec3 o) {\n    vec2 p = (o - (shoulder1 + shoulder2)*.5).zy + vec2(.04,.17);\n    p *= 2.;\n      \n    float dsub = min(length(p-vec2(.8,.0)) - .45, length(p-vec2(-.14,.05)) - .11);  \n    p.y = abs(p.y);\n    float d = length(p-vec2(.0,-.15)) - .3;\n    d = min(d, length(p-vec2(.56,-.15)) - .3);\n    d = max(d, -dsub);\n    return (1.-smoothstep(.05,.06,d));\n}\n\n#endif    \n\n// -----------------------------------------\n\n\nvec4 getColor(float id, vec3 pos) {\n    //return id != ID_TORSO && id <= ID_SHORT ? vec4(.3,.3,.7,id) : vec4(.5,.5,1,id);\n\treturn \t.3+.7*(\n\t\t\tid == ID_LEG ? vec4(COLOR_CLOTHES, ID_LEG) :\n#ifdef WITH_FACE        \n\t\t\tid == ID_EYE ? drawEye(pos) :\n\t\t\tid == ID_SKIN ?\tdrawFace(pos) : \n\t\t\tid == ID_TORSO ? vec4(mix(COLOR_CLOTHES,vec3(0),sdFish(pos)), ID_TORSO) :\n#else                  \n         \tid == ID_EYE ?\tvec4(1,1,1, ID_EYE) :\n         \tid == ID_SKIN ?\tvec4(COLOR_SKIN, ID_SKIN) :\n\t\t\tid == ID_TORSO ? vec4(COLOR_CLOTHES, ID_TORSO) :\n#endif\n\t\t\tid == ID_ARM ? vec4(COLOR_SKIN, ID_ARM) :\n\t\t\tid == ID_SHORT ? vec4(COLOR_CLOTHES2, ID_SHORT) :\n//        \tid == ID_FOOT ? vec4(COLOR_ARMOR, id) :\n//\t\t\tid == ID_GLOVE ? vec4(COLOR_ARMOR, ID_GLOVE) :\n//\t\t\tid == ID_HELMET ? vec4(COLOR_ARMOR, ID_HELMET) :\n//\t\t\tid == ID_GROUND ? vec4(textureLod(iChannel2, pos.xz*.1,1.).rgb, ID_GROUND) :\n    \t\tvec4(COLOR_ARMOR, id));\n}\n\n\nfloat mapColor(in vec3 pos) {\n    vec3 \n         ep0 = mix(shoulder1,shoulder2,.5),\n         ha0 = mix(hip1,hip2,.5),\n         h1 = head + vec3(.0,-.29,0),\n         h2 = head + vec3(.0,.1,0),\n         hn = vec3(0,-1,0),//normalize(h1-h2),\n         a = mix(ha0,ep0,.15), b = mix(ha0,ep0,.79);\n    vec3 posRot = pos; \n    posRot.xz = (posRot.xz - h1.xz) * rotHead + h1.xz;\n    \n    // Leg 1\n    float d = max(min(sdCap2(pos, foot1, ankle1, .1,.15),\n                      sdCap2(pos, ankle1, knee1, .165,.105)),\n\t\t\t\t  -sdPlane(pos-ankle1+v2Foot1*.1, v2Foot12));\n    // Leg 2\n\td = min(d,max(min(sdCap2(pos, foot2, ankle2, .1,.15),\n                      sdCap2(pos, ankle2, knee2, .165,.105)),\n\t\t\t\t  -sdPlane(pos-ankle2+v2Foot2*.1, v2Foot22)));                          \n    \n    vec2 dd;\n    dd = min2(vec2(d, ID_FOOT), \n              vec2(min(sdCap2(pos, hip1, knee1, .12, .075),\n    \t\t\t\t   sdCap2(pos, hip2,  knee2, .12, .075)), ID_LEG));\n\n    // Head\n    float scaleHead = 1.75;\n    vec3 pHead = (posRot - head) + vec3(.02, .04, 0);\n    pHead = pHead.zyx*scaleHead;\n    float dHead = mapHead(pHead)/scaleHead;\n   // d = min(d, dHead);\n\n\t// Eye\n    pHead.x = abs(pHead.x);\n    vec3 p_eye = pHead-g_eyePos;\n    p_eye.xz *= ma;  \n    \n\tfloat dEye = (length(p_eye) - g_eyeSize)/scaleHead;\n    dd = min2(dd, vec2(dEye,ID_EYE));\n\n    dd = min2(dd, vec2(min(dHead,             \n\t\t\t\t\t\tsdCap(pos, ep0-vec3(.03,0,0), head-vec3(.08,.1,0), .1)), ID_SKIN));  // neck           \n    \n    // Arms\n    dd = min2(dd, vec2(min(sdCap2(pos, shoulder1, elbow1, .054,.051), sdCap2(pos, shoulder2, elbow2, .054,.051)), ID_LEG));\n    \n\t// Fingers 1\n    vec3 c = wrist1-v3Hand1*.03;\n    float d2 = sdCap(pos, c-v1Hand1*.06+v2Hand1*.03+v3Hand1*.06, wrist1+.09*(v2Hand1+v1Hand1+v3Hand1), .02);\n    d2 = min(d2, sdCap(pos, c, wrist1+.18*(v1Hand1+v2Hand1*.2), .016));\n    d2 = min(d2, sdCap(pos, c-v2Hand1*.01, wrist1+.2*(v1Hand1-v2Hand1*.2), .017));\n    d2 = min(d2, sdCap(pos, c-v2Hand1*.02, wrist1+.18*(v1Hand1-v2Hand1*.5), .016));\n    d2 = min(d2, sdCap(pos, c-v2Hand1*.04, wrist1+.15*(v1Hand1-v2Hand1*.8), .014));\n    \n\t// Fingers 2     \n    c = wrist2-v3Hand2*.03;\n    d2 = min(d2, sdCap(pos, c-v1Hand2*.06+v2Hand2*.03+v3Hand2*.06, wrist2+.09*(v2Hand2+v1Hand2+v3Hand2), .02));\n    d2 = min(d2, sdCap(pos, c, wrist2+.18*(v1Hand2+v2Hand2*.2), .016));\n    d2 = min(d2, sdCap(pos, c-v2Hand2*.01, wrist2+.2*(v1Hand2-v2Hand2*.2), .017));\n    d2 = min(d2, sdCap(pos, c-v2Hand2*.02, wrist2+.18*(v1Hand2-v2Hand2*.5), .016));\n    d2 = min(d2, sdCap(pos, c-v2Hand2*.04, wrist2+.15*(v1Hand2-v2Hand2*.8), .014));\n\n    d2 = min(d2, min(sdCap2(pos, elbow1, wrist1-.01*v1Hand1, .09, .055),  \n                     sdCap2(pos, elbow2, wrist2-.01*v1Hand2, .09, .055)));\n    dd = min2(dd, vec2(d2, ID_GLOVE));\n  \n    \n    \n    \n    \n    // Torso\n    dd = min2(dd, vec2(smin(sdCapsule2(pos+vec3(.03,0,0), mix(shoulder1, shoulder2,.1),mix(shoulder1, shoulder2,.9),.08, .08,.6), \n                           min(sdCap2(pos, a+vec3(0,0,.03), b-vec3(0,0,.04), .19,.22),sdCap2(pos, a-vec3(0,0,.03), b+vec3(0,0,.04), .19,.22)),.18), ID_TORSO));\n  \n    // Short\n    float dShort = min(sdCap(pos, hip1, mix(hip1,knee1,.3), .12), \n                       sdCap(pos, hip2, mix(hip2,knee2,.3), .12));                    \n    dd = min2(dd, vec2(min(dShort, mix(dd.x, sdCap(pos, a, ha0, .22),.75)), ID_SHORT));\n\n    // Casque\n\tfloat dHelmet;\n    posRot += vec3(.03,.02,0);\n    dHelmet = max(sdPlane(posRot-h1+hn*.08, hn), mix(dHead, sdCap2(posRot, h1-vec3(.23,0,0), head+vec3(0,.05,0),.28,.36),.5));\n    dHelmet = max(-fCylinder(posRot-h1-vec3(.2,0,0), .18,.3), dHelmet); \n    dd = min2(dd, vec2(dHelmet, ID_HELMET));\n\n    return dd.y;\n}\n\n//---------------------------------------------------------------------\n//   Ray marching scene if ray intersect bbox\n//---------------------------------------------------------------------\n              \nfloat logBisectTrace(in vec3 ro, in vec3 rd){\n\n    float t = 0., told = 0., mid, dn;\n    float d = mapGround(rd*t + ro);\n    float sgn = sign(d);\n#ifdef IS_RUNNING\n    for (int i=0; i<64; i++){\n#else        \n    for (int i=0; i<92; i++){\n#endif\n        // If the threshold is crossed with no detection, use the bisection method.\n        // Also, break for the usual reasons. Note that there's only one \"break\"\n        // statement in the loop. I heard GPUs like that... but who knows?\n        if (sign(d) != sgn || d < 0.001 || t > MAX_DIST) break;\n        told = t;\n        // Branchless version of the following:      \n        t += step(d, 1.)*(log(abs(d) + 1.1) - d) + d;\n        //t += log(abs(d) + 1.1);\n        //t += d;//step(-1., -d)*(d - d*.5) + d*.5;\n        d = mapGround(rd*t + ro);\n    }\n    // If a threshold was crossed without a solution, use the bisection method.\n    if (sign(d) != sgn){\n        // Based on suggestions from CeeJayDK, with some minor changes.\n        dn = sign(mapGround(rd*told + ro));\n        vec2 iv = vec2(told, t); // Near, Far\n        // 6 iterations seems to be more than enough, for most cases...\n        // but there's an early exit, so I've added a couple more.\n        for (int ii=0; ii<8; ii++){ \n            //Evaluate midpoint\n            mid = dot(iv, vec2(.5));\n            float d = mapGround(rd*mid + ro);\n            if (abs(d) < 0.001)break;\n            // Suggestion from movAX13h - Shadertoy is one of those rare\n            // sites with helpful commenters. :)\n            // Set mid to near or far, depending on which side we're on.\n            iv = mix(vec2(iv.x, mid), vec2(mid, iv.y), step(0.0, d*dn));\n        }\n\n        t = mid; \n        \n    }\n    \n    //if (abs(d) < PRECISION) t += d;\n\n    return min(t, MAX_DIST);\n}\n\nvec2 Trace(in vec3 pos, in vec3 ray, in float start, in float end ) {\n    // Trace if in bbox\n    float t=start, h, tn=start, tf=end;\n    float tGround = logBisectTrace(pos, ray);\n\n   // start = max(start, );\n    end = min(tGround, end);\n    \n    if (cube(pos-head-vec3(.1,-1.,0), ray, vec3(1.2, 1.7,.7)*2.,  tn, tf)) {\n        end = min(tf, end);\n        t = max(tn, start);// - .3*hash33(pos+ray).x;\n        for( int i=0; i < g_traceLimit; i++) {\n\t\t\tif (t > end) break;\n            h = mapGirl( pos+t*ray );\n            if (h < g_traceSize) {\n                return vec2(t+h, mapColor(pos+t*ray));\n            }\n            t += h;\n        }\n        if (t < end) return vec2(t, mapColor(pos+t*ray)); \n    } \n    \n    return tGround < MAX_DIST ?  vec2(tGround, ID_GROUND) : vec2(MAX_DIST, 0.);\n}\n\n//---------------------------------------------------------------------\n//   Soft shadows\n//---------------------------------------------------------------------\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n    n = max(n*n, 0.001);\n    n /= (n.x + n.y + n.z );  \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n\nfloat getGrey(vec3 p){ return dot(p, vec3(0.299, 0.587, 0.114)); }\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total.\nvec3 doBumpMap( sampler2D tex, in vec3 p, in vec3 nor, float bumpfactor){\n    const float eps = 0.001;\n    vec3 grad = vec3( getGrey(tex3D(tex, vec3(p.x-eps, p.y, p.z), nor)),\n                      getGrey(tex3D(tex, vec3(p.x, p.y-eps, p.z), nor)),\n                      getGrey(tex3D(tex, vec3(p.x, p.y, p.z-eps), nor)));\n    grad = (grad - getGrey(tex3D(tex,  p , nor)))/eps; \n    grad -= nor*dot(nor, grad);                  \n    return normalize( nor + grad*bumpfactor );\n}\n\n\n//---------------------------------------------------------------------\n//   Soft shadows\n//---------------------------------------------------------------------\n\n#ifdef WITH_SHADOW\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax ) {\n\tfloat h, res = 1., t = mint;\n    for(int i=0; i<24; i++) {\n\t\th = map( ro + rd*t );\n        res = min( res, 8.*h/t );\n        t += clamp( h, .05, .2 );\n        if( h<.01 || t>tmax ) break;\n    }\n    return clamp(res, 0., 1.);\n}\n#endif\n\n//---------------------------------------------------------------------\n//   Ambiant occlusion\n//---------------------------------------------------------------------\n\n#ifdef WITH_AO\nfloat calcAO( in vec3 pos, in vec3 nor ){\n\tfloat dd, hr, sca = 1., totao = 0.;\n    vec3 aopos; \n    for( int aoi=0; aoi<5; aoi++ ) {\n        hr = .01 + .05*float(aoi);\n        aopos =  nor * hr + pos;\n        totao += -(mapGirl( aopos )-hr)*sca;\n        sca *= .75;\n    }\n    return clamp(1. - 4.*totao, 0., 1.);\n}\nfloat calcAOGround( in vec3 pos, in vec3 nor ){\n\tfloat dd, hr, sca = 1., totao = 0.;\n    vec3 aopos; \n    for( int aoi=0; aoi<5; aoi++ ) {\n        hr = .01 + .05*float(aoi);\n        aopos =  nor * hr + pos;\n        totao += -(min(mapGround(aopos),mapLegs(aopos))-hr)*sca;\n        sca *= .75;\n    }\n    return clamp(1. - 4.*totao, 0., 1.);\n}\n#endif\n\n\n//---------------------------------------------------------------------\n//   Shading\n//   Adapted from Shane / Iq\n//---------------------------------------------------------------------\n\nvec3 shading( in vec3 sp, in vec3 rd, in vec3 sn, in vec3 col, in float id, out float reflexion){\n    \n    vec3 general = vec3(240,198,157)/256.,\n    \t back = vec3(63,56,46)/256.;\n    vec3 ref = reflect( rd, sn );\n\n    // lighitng   \n#ifdef WITH_AO\n    float occ = id == ID_GROUND ? calcAOGround( sp, sn ) : calcAO( sp, sn );\n#else\n    float occ = 1.;\n#endif\n    vec3  ld = normalize( gLightPos );\n    vec3  hal = normalize( rd - ld);\n    float amb = .15; //clamp( .5+.5*sn.y, 0., 1. );\n    float dif = clamp( dot( sn, ld ), 0., 1. );\n    float bac = clamp( dot( sn, normalize(vec3(-ld.x,0.,-ld.z))), 0., 1. );//*clamp( 1.-sp.y,0.,1.);\n    float dom = smoothstep( -.1, .1, ref.y );\n    float fre = pow( clamp(1.+dot(sn,rd),0.,1.), 2. );\n\n    reflexion = fre*occ;\n    \n#ifdef WITH_SHADOW\n    dif *= calcSoftshadow( sp, ld, .05, 2. );\n#endif\n    \n    float spe =  pow( clamp( dot( sn, -hal ), 0., 1. ), id >= ID_SHORT ? 10. : 164.) * dif * (.04 + .96*pow( clamp(1.+dot(hal,rd),0.,1.), 50. ));\n\n    vec3 lin = vec3(0.0);\n    lin += .80*dif*general/*vec3(1.00,0.80,0.55)*/*(.3+.7*occ);\n    lin += .40*amb*occ*general;//vec3(0.40,0.60,1.00);\n   // lin += .15*dom*occ*general;//vec3(0.40,0.60,1.00)*occ;\n    lin += .15*bac*back/*vec3(0.25,0.25,0.25)*/*occ;\n   // lin += .25*fre*vec3(1.00,1.00,1.00)*occ;\n   \n    col = col*lin;\n    col += (id == ID_EYE ? 10. : id >= ID_SHORT ? .3 : 1.)*spe*vec3(1.00,0.90,0.70);\n    \n    return col;\n}\n\n\n\n//---------------------------------------------------------------------\n//   Calculate normal\n//   From TekF \n//---------------------------------------------------------------------\nvec3 Normal(in vec3 pos, in vec3 ray, in float t) {\n\tfloat pitch = .1 * t / iResolution.x;   \n\tpitch = max( pitch, .002 );\n\tvec2 d = vec2(-1,1) * pitch;\n\n\tvec3 p0 = pos+d.xxx, // tetrahedral offsets\n\t     p1 = pos+d.xyy,\n\t     p2 = pos+d.yxy,\n\t     p3 = pos+d.yyx;\n\n \tfloat f0 = mapGirl(p0), f1 = mapGirl(p1), f2 = mapGirl(p2),\tf3 = mapGirl(p3);\n\tvec3 grad = p0*f0+p1*f1+p2*f2+p3*f3 - pos*(f0+f1+f2+f3);\n //   return normalize(grad);\n\t// prevent normals pointing away from camera (caused by precision errors)\n\treturn normalize(grad - max(.0,dot (grad,ray ))*ray);\n}\n\nvec3 NormalGround(in vec3 pos, in vec3 ray, in float t) {\n\tfloat pitch = .2 * t / iResolution.x;   \n\tpitch = max( pitch, .005 );\n\tvec2 d = vec2(-1,1) * pitch;\n\n\tvec3 p0 = pos+d.xxx, // tetrahedral offsets\n\t     p1 = pos+d.xyy,\n\t     p2 = pos+d.yxy,\n\t     p3 = pos+d.yyx;\n\n \tfloat f0 = mapGround(p0), f1 = mapGround(p1), f2 = mapGround(p2), f3 = mapGround(p3);\n\tvec3 grad = p0*f0+p1*f1+p2*f2+p3*f3 - pos*(f0+f1+f2+f3);\n //   return normalize(grad);\n\t// prevent normals pointing away from camera (caused by precision errors)\n\treturn normalize(grad - max(.0,dot (grad,ray ))*ray);\n}\n\n\n\n//---------------------------------------------------------------------\n//   Camera\n//---------------------------------------------------------------------\n\nmat3 setCamera(in vec3 ro, in vec3 ta, in float cr) {\n\tvec3 cw = normalize(ta-ro),\n\t\t cp = vec3(sin(cr), cos(cr), 0.),\n\t\t cu = normalize( cross(cw,cp) ),\n\t\t cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\n//---------------------------------------------------------------------\n//   Entry point\n//---------------------------------------------------------------------\n\n\n// Interpolate pos of articulations\nvec3 getPos(vec3 p, int it, float kt, float z, float dx) {\n\treturn .02*vec3(p.x + dx, 150.-p.y, p.z*z);\n}\n    \n    \nvoid initLookingPosition(int idPlanet) {\n\tconst int it = 6;\n\tconst float kt = 0.;\n\n\tvec3 delta = gStaticPos;\n\n\tfloat dx = 0.;\n\tfloat mv = .5*cos(3.*iTime);\n\t\t\n        \n\thead = delta + getPos(vec3(85+94,20,0), it, kt, 1., dx);\n\n\tshoulder1 = delta +getPos(vec3(85+91,43,16), it, kt, -1., dx) + .02*vec3(-5,0,0);\n\telbow1 = delta +getPos(vec3(85+91,73,25), it, kt, -1., dx);\n\twrist1 = delta +getPos(vec3(85+88,103,25), it, kt, -1., dx) + .02*vec3(18,22,7);\n\n\tfoot1 = delta +getPos(vec3(182,150,10), it, kt, 1., dx)  + .02*vec3(54,54,4);\n\tankle1 = delta +getPos(vec3(164,146,5), it, kt, 1., dx) + .02*vec3(56,42,8);\n\tknee1 = delta + getPos(vec3(167,118,7), it, kt, 1., dx) + .02*vec3(30,42,12);\n\thip1 = delta +getPos(vec3(168,91,8), it, kt, 1., dx) + .02;\n\n\tshoulder2 = delta +getPos(vec3(85+91,43,16), it, kt, 1., dx) + .02*vec3(-5,0,0);\n\telbow2 = delta +getPos(vec3(85+91,73,25), it, kt, 1., dx) + .02*vec3(4,5,0);\n\twrist2 = delta +getPos(vec3(85+88,103,25), it, kt, 1., dx) + .02*vec3(23,29,-20);\n\n\tfoot2 = delta +getPos(vec3(182,150,10), it, kt, -1., dx) + .02*vec3(56,52,-8);\n\tankle2 = delta +getPos(vec3(164,146,5), it, kt, -1., dx) + .02*vec3(64,38,-8);\n\tknee2 = delta +getPos(vec3(167,118,7), it, kt, -1., dx) + .02*vec3(32,28,-8);\n\thip2 = delta +getPos(vec3(168,91,8), it, kt, -1., dx)  + .02;\n}\n\nvec4 render(in vec3 ro, in vec3 rd, out vec3 roRef, out vec3 rdRef) {\n\tfloat t = MAX_DIST, traceStart = 0., traceEnd = MAX_DIST;\n\n    // Render ------------------------\n\tvec3 col;\n    vec4 colClouds = vec4(0);\n    vec2 tScene = Trace(ro, rd, traceStart, t);\n    \n    if (tScene.x > MAX_DIST-5.) {\n\t\tcolClouds = clouds(vec3(0), rd, t);\n    }\n\n\tfloat reflection = 0.;\n\t\n    roRef = ro;\n    rdRef = rd;\n    \n\tif (tScene.x < MAX_DIST) {\n       \n\t\tvec3 pos = ro + rd*tScene.x;\n        float id = tScene.y;\n\t\tvec3 sn, sceneColor, rnd = hash33(rd + 311.);\n\n        if (id == ID_GROUND) {\n            sn = NormalGround(pos, rd, tScene.x);\n\t\t\tsn = doBumpMap(iChannel2, pos/3., sn, .035/(1. + tScene.x/MAX_DIST)); \n\t\t\tsceneColor = mix(vec3(.5,.45,.4), vec3(.12), clamp(0.,1.,2.*pos.y))+(fract(rnd*289. + tScene.x*41.) - .5)*.03;    \n        } else {\n\t\t\tsn = Normal(pos, rd, tScene.x);\n            if (id == ID_HELMET) {\n                vec3 posRot = pos; \n    \t\t\tposRot.xz = (posRot.xz-head.xz) * rotHead;\n            \tsn = doBumpMap(iChannel2, posRot/16.+.5, sn, .0004/(1. + tScene.x/MAX_DIST)); \n            }\n\t\t\tvec4 sceneColor4 = getColor(id, pos);\n\t\t\tid = sceneColor4.w;\n\t\t\tsceneColor = sceneColor4.rgb;\n        }\n\t\t\n        rdRef = reflect(rd,sn);\n\t\troRef = pos + rdRef*.1;\n        \n        float reflexion;\n        \n\t\t// Shading\n\t\tcol = shading(pos, rd, sn, sceneColor, id, reflexion);\n\t\treflection = ID_GROUND==id && pos.y<.2 ? .9 : (reflexion)*.2;\n\n\t\t// Fog\n\t\tcol = mix(col, colClouds.rgb, smoothstep(MAX_DIST-5., MAX_DIST, tScene.x));\n        col += (fract(rnd*289. + tScene.x*40001.) - .5)*.05;\n        float f = MAX_DIST*.3;\n        vec3 fogColor = vec3(.87,.85,1);\n        col = mix( .2*fogColor, col, exp2(-tScene.x*fogColor/f) );\n\t\t\n    } else {\n\t\tcol = colClouds.rgb;\n\t}\n\n\treturn vec4(col, reflection);\n}\n\n\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    if (iTime<30.) discard;\n\n   \n    gTime = iTime*8.;\n   \n    rotHead = rot(.6*(sin(.05*gTime)*cos(.001*gTime+1.11)));\n        \n    // Animation\n    int it = int(floor(gTime));\n    float kt = fract(gTime);\n\n    // - init man position -----------------------------------\n    initLookingPosition(0);\n    const float a_eyeClose = .55, a_eyeOpen = -.3;\n    const float t_openEye = 3., t_rotDown = 10., t_closeEye = 1.;\n    \n    // - Eye blink -------------------------------------------\n    float time = iTime;\n    float a_PaupieresCligne = mix(a_eyeOpen,a_eyeClose, hash(floor(time*10.))>.98?2.*abs(fract(20.*time)-.5):0.);    \n    float a_Paupieres = mix(a_eyeClose, .2, smoothstep(t_openEye, t_openEye+3., time));    \n    a_Paupieres = mix(a_Paupieres, a_PaupieresCligne, smoothstep(t_rotDown, t_rotDown+1., time));\n\n    g_eyeRot = rot(a_Paupieres);\n    \n// Init base vectors --------------------------------------------\n\n  // Foot1 flat part - vector base linked to leg 1\n    v2Foot1 = normalize(knee1 - ankle1);\n\tvec3 v1Foot1 = normalize(ankle1 - foot1-v2Foot1*.1);\n\tv3Foot1 = cross(v1Foot1,v2Foot1);\n\tv2Foot12 = -cross(v1Foot1, v3Foot1);\n\n    v2Foot2 = normalize(knee2 - ankle2);\n    vec3 v1Foot2 = normalize(ankle2 - foot2-v2Foot2*.1);\n\tv3Foot2 = cross(v1Foot2,v2Foot2);\n    v2Foot22 = -cross(v1Foot2, v3Foot2); \n\n\t// Arm 1\n    v1Hand1 = normalize(wrist1-elbow1);\n    v3Hand1 = -normalize(cross(v1Hand1,normalize(wrist1-shoulder1)));\n    v2Hand1 = -cross(v1Hand1,v3Hand1);\n    v3Hand1 = v3Hand1;          \n\n    v1Hand2 = normalize(wrist2-elbow2);\n    v3Hand2 = -normalize(cross(v1Hand2,normalize(wrist2-shoulder2)));\n    v2Hand2 = -cross(v1Hand2,v3Hand2);\n    v3Hand2 = -v3Hand2; \n\n// --------------------------------------------------------------\n\n    vec2 m = iMouse.xy/iResolution.y - .5;\n\n\tfloat traceStart = .2;\n\n    vec3 ro, rd;\n  \tvec2 q;\n    \n// - Camera -----------------------------------------\n    \n\tq = (fragCoord.xy)/iResolution.xy;\n\tvec2 p = -1. + 2.*q;\n\tp.x *= iResolution.x/iResolution.y;\n\n\n\t\n    time = iTime - 40. - 30.;\n    float dist =  mix(30.,2.,smoothstep(0.,20.,time)) + mix(0.,60., smoothstep(130.,240.,time));\n\n    vec3 ta = head + vec3(dist*.1,-.05,0);\n    ro = ta + dist*vec3(cos(.1*time/* + 6.28*m.x*/), mix(.02,-.13,smoothstep(20.,60.,time)), sin(.1*time/* + 6.28*m.x*/));\n\t   \n\n\t// camera-to-world transformation\n\tmat3 ca = setCamera(ro, ta, 0.0);\n\n\t// ray direction\n\trd = ca * normalize( vec3(p.xy,mix(3.5,4.5,smoothstep(0.,20.,time))));\n\n// ---------------------------------------------------\n    vec3 roRef, rdRef;\n\tvec4 col = render(ro, rd, roRef, rdRef);\n\n#ifdef WITH_REFLECTION\n\t\tvec3 roRef2, rdRef2;\n\t\tcol.rgb = col.rgb*(1.- col.w) + col.w*clouds(vec3(0), rdRef, MAX_DIST).rgb;\n#endif\n\n// Post processing stuff --------------------\n\n\t// Gamma\n     col.rgb = pow(col.rgb, vec3(0.6545) );\n\n    // Vigneting\n    col.rgb *= pow(16.*q.x*q.y*(1.-q.x)*(1.-q.y), .15); \n    \n\tfragColor = col;\n}\n\n",
   "name": "Buffer A",
   "description": "",
   "type": "buffer"
  },
  {
   "inputs": [
    {
     "id": "XsXGRn",
     "filepath": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg",
     "type": "texture",
     "channel": 2,
     "sampler": {
      "filter": "mipmap",
      "wrap": "repeat",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    },
    {
     "id": "Xsf3zn",
     "filepath": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
     "type": "texture",
     "channel": 0,
     "sampler": {
      "filter": "mipmap",
      "wrap": "repeat",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    },
    {
     "id": "4sf3Rr",
     "filepath": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png",
     "type": "texture",
     "channel": 1,
     "sampler": {
      "filter": "mipmap",
      "wrap": "repeat",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    }
   ],
   "outputs": [
    {
     "id": "XsXGR8",
     "channel": 0
    }
   ],
   "code": "//-----------------------------------------------------\n// Created by sebastien durand - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n#define IS_RUNNING\n\n//#define WITH_SHADOW\n#define WITH_AO\n\n\n#ifndef IS_RUNNING\n  #define WITH_REFLECTION\n \n#endif\n #define WITH_FACE\n// Isosurface Renderer\n#define g_traceLimit 48\n#define g_traceSize .002\n\n\n#define MAX_DIST 64.\n#define RUN_STEP 110.\n\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\n\n\nconst vec3 gStaticPos = vec3(-95.,8.83,-121.7); //vec3(-95.5,12.8,-123);\n\nconst vec3 g_nozePos = vec3(0,-.28+.04,.55);\nconst vec3 g_eyePos = vec3(.14,-.14,.29);\nconst float g_eyeSize = .09;\nconst mat2 ma = rot(-.5);\nconst mat2 mb = rot(-.15);\nconst mat2 mc = rot(-.6);\n\n\n\n\nfloat gTime;\nmat2 rotHead, g_eyeRot;\nvec3 gLightPos = vec3(2, 1, 6);\n\n\n\n//\t[Shane] Combustible Clouds\n//\t------------------\n\n// Hash function. This particular one probably doesn't disperse things quite \n// as nicely as some of the others around, but it's compact, and seems to work.\n//\nvec3 hash33(vec3 p){ \n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n); \n}\n\n// IQ's texture lookup noise... in obfuscated form. There's less writing, so\n// that makes it faster. That's how optimization works, right? :) Seriously,\n// though, refer to IQ's original for the proper function.\n// \n// By the way, you could replace this with the non-textured version, and the\n// shader should run at almost the same efficiency.\nfloat n3D( in vec3 p ){\n    vec3 i = floor(p); p -= i; p *= p*(3. - 2.*p);\n\tp.xy = texture(iChannel0, (p.xy + i.xy + vec2(37, 17)*i.z + .5)/256., -100.).yx;\n\treturn mix(p.x, p.y, p.z);\n}\n\n// Basic low quality noise consisting of three layers of rotated, mutated \n// trigonometric functions. Needs work, but sufficient for this example.\nfloat trigNoise3D(in vec3 p){ \n    float res = 0., sum = 0.;\n    float n = n3D(p*8.);\n    vec3 t = sin(p.yzx*3.14159265 + cos(p.zxy*3.14159265+1.57/2.))*0.5 + 0.5;\n    p = p*1.5 + (t - 1.5); //  + iTime*0.1\n    res += (dot(t, vec3(0.333)));\n    t = sin(p.yzx*3.14159265 + cos(p.zxy*3.14159265+1.57/2.))*0.5 + 0.5;\n    res += (dot(t, vec3(0.333)))*0.7071;    \n\treturn ((res/1.7071))*0.85 + n*0.15;\n}\n\nvec4 clouds(in vec3 ro, in vec3 rd, in float tend) {\n    vec3 lp = gLightPos;\n    vec3 rnd = hash33(rd + 311.);\n    float lDe = 0., td = 0., w = 0.;\n    float d = 1., t = dot(rnd, vec3(.08));\n    const float h = .5;\n    vec3 col = vec3(0), sp;\n    vec3 sn = normalize(hash33(rd.yxz)*.03-rd);\n\n    // Raymarching loop.\n    for (int i=0; i<48; i++) {\n        if((td>1.) || d<.001*t || t>70. || t>tend) break;\n\n        sp = ro + rd*t; // Current ray position.\n        d = trigNoise3D(sp*.75); // Closest distance to the surface... particle.\n        lDe = (h - d) * step(d, h); \n        w = (1. - td) * lDe;   \n        td += w*w*8. + 1./60.; //w*w*5. + 1./50.;\n        vec3 ld = lp-sp; // Direction vector from the surface to the light position.\n        float lDist = max(length(ld), 0.001); // Distance from the surface to the light.\n        ld/=lDist; // Normalizing the directional light vector.\n        float atten = 1./(1. + lDist*0.1 + lDist*lDist*.03);\n        float diff = max(dot(sn, ld ), 0.);\n        float spec = pow(max(dot( reflect(-ld, sn), -rd ), 0.), 4.);\n        col += w*(1.+ diff*.5 + spec*.5)*atten;\n        col += (fract(rnd*289. + t*41.) - .5)*.02;;\n        t +=  max(d*.5, .02); //\n    }\n    \n    col = max(col, 0.);\n    col = mix(pow(vec3(1.3, 1, 1)*col, vec3(1, 2, 10)), col, dot(cos(rd*6. +sin(rd.yzx*6.)), vec3(.333))*.2+.8);\n    vec3 sky = vec3(.6, .8, 1.)*min((1.5+rd.y*.5)/2., 1.); \t\n    sky = mix(vec3(1, 1, .9), vec3(.31, .42, .53), rd.y*0.5 + 0.5);\n    \n    float sun = clamp(dot(normalize(lp-ro), rd), 0.0, 1.0);\n   \n    // Combining the clouds, sky and sun to produce the final color.\n    sky += vec3(1, .3, .05)*pow(sun, 5.)*.25; \n    sky += vec3(1, .4, .05)*pow(sun, 16.)*.35; \t\n    col = mix(col, sky, smoothstep(0., 25., t));\n \tcol += vec3(1, .6, .05)*pow(sun, 16.)*.25; \t\n \n    // Done.\n    return vec4(col, clamp(0.,1.,td));    \n}\n\n\n// standard       - https://www.shadertoy.com/view/4sjGzc\n\n//---------------------------------------------------------------------\n//    Animation\n//---------------------------------------------------------------------\n// RUN ------\n//                       Contact           Down               Pass               Up      \n\nvec3[9] HEAD2 = vec3[9]( vec3(67,17,0),    vec3(184,23,0),     vec3(279,18,0),     vec3(375,14,0), vec3(67,17,0),    vec3(184,23,0),     vec3(279,18,0),   vec3(375,14,0),   vec3(67,17,0));\nvec3[9] SHOULDER2 = vec3[9](vec3(60,38,16), vec3(178,46,16),    vec3(273,41,16),    vec3(369,38,16), vec3(67,42,16),    vec3(182,49,16), vec3(273,41,16), vec3(369,38,16), vec3(60,38,16));\nvec3[9] ELBOW2 = vec3[9]( vec3(36,43,25),   vec3(155,58,25), vec3(262,64,25), vec3(371,61,25), vec3(75,62,25),   vec3(186,72,25), vec3(273,67,25), vec3(355,55,25), vec3(36,43,25));\nvec3[9] WRIST2 = vec3[9](vec3(24,60,20),  vec3(148,77,20), vec3(271,84,25), vec3(391,68,25), vec3(93,54,10),  vec3(206,67,20), vec3(291,77,25), vec3(360,80,20), vec3(24,60,20));\nvec3[9] HIP2 = vec3[9](vec3(55,76,8.),  vec3(171,84,8.),   vec3(264,79,8.),   vec3(360,77,8.),  vec3(50,78,8.), vec3(171,84,8.),  vec3(264,79,8.),  vec3(360,77,8.), vec3(55,76,8.));\nvec3[9] KNEE2 = vec3[9]( vec3(73,102,7), vec3(188,111,8),  vec3(267,112,10), vec3(358,107,10),  vec3(41,105,7), vec3(169,115,7),  vec3(279,108,7),  vec3(386,99,7), vec3(73,102,7));\nvec3[9] ANKLE2=vec3[9](vec3(89,131,5),   vec3(175,142,6),   vec3(255,142,10),  vec3(340,135,10),  vec3(7,108,5), vec3(138,114,5),  vec3(250,115,5),  vec3(372,126,5), vec3(89,131,5));\nvec3[9] FOOT2 = vec3[9](  vec3(104,127,10), vec3(191,144,10),  vec3(270,144,10),  vec3(350,144,10),  vec3(3,122,10),vec3(131,126,10), vec3(246,129,10), vec3(382,136,10), vec3(104,127,10));\n\nvec3 shoulder1, elbow1, wrist1, head, shoulder2, elbow2, wrist2;\nvec3 foot1, ankle1, knee1, hip1, foot2, ankle2, knee2, hip2;\nvec3 v2Foot1, v2Foot12, v2Foot2, v2Foot22, v3Foot1, v3Foot2;\nvec3 v1Hand1, v2Hand1, v3Hand1, v1Hand2, v2Hand2, v3Hand2;\n\n\n// Interpolate pos of articulations when running\n// TODO: standardize arrays to fusion with getPos\nvec3 getPos2(vec3 arr[9], int it0, float kt, float z) {\n    int it = it0 % 8;\n    \n    vec3 p0 = arr[it], p1 = arr[it+1];\n    p0.x -= float(it%4)*80. - (it>3?RUN_STEP:0.);\n    p1.x -= float((it+1)%4)*80. - (it>2?RUN_STEP:0.) - (it>6?RUN_STEP:0.);\n    \n    vec3 p = mix(p0, p1, /*smoothstep(0.,1.,*/kt/*)*/);\n    if (z<0.) p.x += -RUN_STEP;\n    \n    p.x += float(it0/8)*RUN_STEP*2.;\n    return .02*vec3(p.x, 144.-p.y, p.z*z);\n}\n\n\n//---------------------------------------------------------------------\n//    HASH functions (iq)\n//---------------------------------------------------------------------\n\nfloat hash( float n ) { return fract(sin(n)*43758.5453123); }\n\n// mix noise for alive animation, full source\nvec4 hash4( vec4 n ) { return fract(sin(n)*1399763.5453123); }\nvec3 hash3( vec3 n ) { return fract(sin(n)*1399763.5453123); }\n\n\n//---------------------------------------------------------------------\n//   Modeling Primitives\n//   [Inigo Quilez] https://iquilezles.org/articles/distfunctions\n//---------------------------------------------------------------------\n\nbool cube(vec3 ro, vec3 rd, vec3 sz, out float tn, out float tf) { \n\tvec3 m = 1./rd,\n         k = abs(m)*sz,\n         a = -m*ro-k*.5, \n         b = a+k;\n    tn = max(max(a.x,a.y),a.z);\n    tf = min(min(b.x,b.y),b.z); \n\treturn tn>0. && tn<tf;\n}\n\n\nfloat sdCap(in vec3 p, in vec3 a, in vec3 b, in float r ) {\n    vec3 pa = p - a, ba = b - a;\n    return length(pa - ba*clamp( dot(pa,ba)/dot(ba,ba), 0., 1. ) ) - r;\n}\n\nfloat sdCapsule(in vec3 p, in vec3 a, in vec3 b, in float r0, in float r1 ) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0., 1.);\n    return length( pa - ba*h ) - mix(r0,r1,h);\n}\n\nfloat sdCap2(in vec3 p, in vec3 a, in vec3 b, in float r1, in float r2) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba), 0., 1. );\n    return length(pa - ba*h) - mix(r1,r2,h*h*h);\n}\n\nfloat udRoundBox(in vec3 p, in vec3 b, in float r ) {\n  return length(max(abs(p)-b,0.))-r;\n}\n\n//https://www.shadertoy.com/view/Xs3GRB\nfloat fCylinder(in vec3 p, in float r, in float height) {\n\treturn max(length(p.xz) - r, abs(p.y) - height);\n}\n\nfloat sdPlane(in vec3 p, in vec3 n) {  // n must be normalized\n  return dot(p,n);\n}\n\nfloat smin(in float a, in float b, in float k ) {\n    float h = clamp( .5+.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.-h);\n}\n\n// Smooth maximum, based on the function above.\nfloat smaxP(float a, float b, float s){\n    \n    float h = clamp( 0.5 + 0.5*(a-b)/s, 0., 1.);\n    return mix(b, a, h) + h*(1.0-h)*s;\n}\n\n// hg_sdf : http://mercury.sexy/hg_sdf/\nfloat fOpEngrave(float a, float b, float r) {\n\treturn max(a, (a + r - abs(b))*0.7071); //sqrt(.5));\n}\n\nfloat fOpIntersectionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r + a,r + b), vec2(0));\n\treturn min(-r, max (a, b)) + length(u);\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r) {\n    return (length(p/r ) - 1.) * min(min(r.x,r.y),r.z);\n}\n\n\nfloat fOpDifferenceRound (float a, float b, float r) {\n\treturn fOpIntersectionRound(a, -b, r);\n}\n\n\n//---------------------------------------------------------------------\n//    Man + Ground distance field \n//---------------------------------------------------------------------\n\n// The canyon, complete with hills, gorges and tunnels. I would have liked to provide a far\n// more interesting scene, but had to keep things simple in order to accommodate slower machines.\nfloat mapGround(in vec3 p){\n    float tx = -.2*(textureLod(iChannel1, p.xz/16. + p.xy/80., 0.0).x);\n    vec3 q = p*0.25;\n\n    float h = tx + .2+.5*(dot(sin(q)*cos(q.yzx), vec3(.222))) + dot(sin(q*1.3)*cos(q.yzx*1.4), vec3(.111));\n    float d = p.y + smin(0.,smoothstep(.2,3., abs(p.z))*(-h)*6.,.2);\n\n    return d; \n}\n\n// capsule with bump in the middle -> use for neck\nfloat sdCapsule2(in vec3 p,in vec3 a,in vec3 b, in float r0,in float r1,in float bump) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba), 0., 1. );\n    float dd = bump*sin(3.14*h);  // Little adaptation\n    return length(pa - ba*h) - mix(r0,r1,h)*(1.+dd); \n}\n\n\nfloat smax(in float a, in float b, in float k) {\n    return log(exp(a/k)+exp(b/k))*k;\n}\n\n\nfloat mapHead(in vec3 p) {\n    float d;\n   \n// Skull modeling -------------------------\n    d = sdEllipsoid(p-vec3(0,.05,.0), vec3(.39,.48,.46));\t\t\t\t  \n    d = smin(d, sdEllipsoid(p-vec3(0.,.1,-.15), vec3(.42,.4,.4)),.1);     \n    d = smin(d, udRoundBox(p-vec3(0,-.28,.2), vec3(.07,.05,.05),.05),.4); // Basic jaw \n\n// Symetrie -------------------------------\n    p.x = abs(p.x);\n\n// Eye hole \n    d = smax(d, -sdEllipsoid(p-vec3(.12,-.16,.48), vec3(.09,.06,.09)), .07);\n\n// Noze ------------------------------------\n    d = smin(d, max(-(length(p-vec3(.032,-.325,.45))-.028),   // Noze hole\n                    smin(length(p-vec3(.043,-.29,.434))-.01,  // Nostrils\n                    sdCapsule(p, vec3(0,-.13,.39), vec3(0,-.28,.47), .01,.04), .05)) // Bridge of the nose\n            ,.065); \n   \n// Mouth -----------------------------------    \n    d = smin(d, length(p- vec3(.22,-.34,.08)), .17); // Jaw\n    d = smin(d, sdCapsule(p, vec3(.16,-.35,.2), vec3(-.16,-.35,.2), .06,.06), .15); // Cheeks\n   \n    d = smin(d, max(-length(p.xz-vec2(0,.427))+.015,  \t// Line under the noze\n        \t\tmax(-p.y-.41,   \t\t\t\t\t\t// Upper lip\n                    sdEllipsoid(p- vec3(0,-.34,.37), vec3(.08,.15,.05)))), // Mouth bump\n             .032);\n\n// Chin -----------------------------------  \n    d = smin(d, length(p- vec3(0,-.5,.26)), .2);   // Chin\n    d = smin(d, length(p- vec3(0,-.44,.15)), .25); // Under chin \n  \n    //d = smin(d, sdCapsule(p, vec3(.24,-.1,.33), vec3(.08,-.05,.46), .0,.01), .11); // Eyebrow \n    \n// Eyelid ---------------------------------\n\tvec3 p_eye1 = p - g_eyePos;\n    p_eye1.xz *= mb;\n    \n    vec3 p_eye2 = p_eye1;\n    float d_eye = length(p_eye1) - g_eyeSize*1.;\n          \n\tp_eye1.yz *= g_eyeRot;\n\tp_eye2.zy *= mc;\n    \n    float d1 = min(max(-p_eye1.y,d_eye - .01),\n                   max(p_eye2.y,d_eye - .005));\n\n    d = smin(d,d1,.01);\n\treturn d; \n}\n\n\n\nfloat mapLegs(const in vec3 pos){    \n    // Leg 1\n    float d = max(min(sdCap2(pos, foot1, ankle1, .1,.15),\n                      sdCap2(pos, ankle1, knee1, .165,.105)),\n\t\t\t\t  -sdPlane(pos-ankle1+v2Foot1*.1, v2Foot12));\n    // Leg 2\n\td = min(d,max(min(sdCap2(pos, foot2, ankle2, .1,.15),\n                      sdCap2(pos, ankle2, knee2, .165,.105)),\n\t\t\t\t  -sdPlane(pos-ankle2+v2Foot2*.1, v2Foot22)));\n \n    d = fOpEngrave(d, min(min(sdCap(pos-ankle1, -.1*v3Foot1, .1*v3Foot1, .12), \n                              sdCap(pos-ankle2, -.1*v3Foot2, .1*v3Foot2, .12)), \n                          min(length(pos - knee1),length(pos - knee2))-.11), .015);\n    \n    d = min(d, sdCap2(pos,  hip1, knee1, .12, .075));\n    return min(d, sdCap2(pos, hip2, knee2, .12, .075));\n}\n\nfloat mapGirl(const in vec3 pos){\n    vec3 \n         ep0 = mix(shoulder1,shoulder2,.5),\n         ha0 = mix(hip1,hip2,.5),\n         h1 = head + vec3(.0,-.24-.05,0),\n         h2 = head + vec3(.0,.15-.05,0),\n         hn = normalize(h1-h2),\n         a = mix(ha0,ep0,.15), b = mix(ha0,ep0,.75);\n    \n    vec3 posRot = pos; // - head; \n    posRot.xz = (posRot.xz - head.xz) * rotHead + head.xz;\n   // posRot.xz = (posRot.xz) * rotHead;\n    \n    float d = mapLegs(pos);\n\n    // Head\n    float scaleHead = 1.75;\n    vec3 pHead = (posRot - head) + vec3(.02, .04, 0);\n    pHead = pHead.zyx*scaleHead;\n    float dHead = mapHead(pHead)/scaleHead;\n    d = min(d, dHead);\n\n\t// Eye\n    pHead.x = abs(pHead.x);\n    vec3 p_eye = pHead-g_eyePos;\n    p_eye.xz *= ma;  \n\tfloat dEye = (length(p_eye) - g_eyeSize)/scaleHead;\n    d = min(d, dEye);\n        \n    // Arms\n    d = min(d, sdCapsule2(pos, shoulder1, elbow1, .054,.051,.5));\n    d = min(d, sdCapsule2(pos, shoulder2, elbow2, .054,.051,.5));\n    float dArm = sdCap2(pos, elbow1, wrist1-.01*v1Hand1, .09, .055);\n    dArm = min(dArm,  sdCap2(pos, elbow2, wrist2-.01*v1Hand2, .09, .055));\n    dArm = fOpEngrave(dArm, \n                      min(min(length(pos - wrist2), length(pos - wrist1)),\n                          min(length(pos - elbow2), length(pos - elbow1))) - .1,.008);\n\n    \n    // Neck and Shoulders\n    d = smin(d, min(sdCapsule2(pos+vec3(.03,0,0), mix(shoulder1, shoulder2,.1),mix(shoulder1, shoulder2,.9),.08, .08,.6),\n                    sdCap(pos,ep0-vec3(.03,0,0), head-vec3(.08,.1,0), .09)), .06);\n    \n    // Torso\n\td = smin(d, min(sdCap2(pos, a+vec3(0,0,.03), b-vec3(0,0,.04), .19,.22),sdCap2(pos, a-vec3(0,0,.03), b+vec3(0,0,.04), .19,.22)),.18);\n    \n\t// Fingers 1\n    vec3 c = wrist1-v3Hand1*.03;\n    float d2 = sdCap(pos, c-v1Hand1*.06+v2Hand1*.03+v3Hand1*.06, wrist1+.09*(v2Hand1+v1Hand1+v3Hand1), .02);\n    d2 = min(d2, sdCap(pos, c, wrist1+.18*(v1Hand1+v2Hand1*.2), .016));\n    d2 = min(d2, sdCap(pos, c-v2Hand1*.01, wrist1+.2*(v1Hand1-v2Hand1*.2), .017));\n    d2 = min(d2, sdCap(pos, c-v2Hand1*.02, wrist1+.18*(v1Hand1-v2Hand1*.5), .016));\n    d2 = min(d2, sdCap(pos, c-v2Hand1*.04, wrist1+.15*(v1Hand1-v2Hand1*.8), .014));\n    \n\t// Fingers 2     \n    c = wrist2-v3Hand2*.03;\n    d2 = min(d2, sdCap(pos, c-v1Hand2*.06+v2Hand2*.03+v3Hand2*.06, wrist2+.09*(v2Hand2+v1Hand2+v3Hand2), .02));\n    d2 = min(d2, sdCap(pos, c, wrist2+.18*(v1Hand2+v2Hand2*.2), .016));\n    d2 = min(d2, sdCap(pos, c-v2Hand2*.01, wrist2+.2*(v1Hand2-v2Hand2*.2), .017));\n    d2 = min(d2, sdCap(pos, c-v2Hand2*.02, wrist2+.18*(v1Hand2-v2Hand2*.5), .016));\n    d2 = min(d2, sdCap(pos, c-v2Hand2*.04, wrist2+.15*(v1Hand2-v2Hand2*.8), .014));\n\n\n    d = min(d, smin(d2, dArm, .05));\n   \n    // Base corps\n    // v2 = normalize(a - b);\n   // vec3 v3 = normalize(cross(vec3(1,0,0),v2));\n   // vec3 v1 = cross(v3, v2);\n    \n    // Short\n    float dShort = min(sdCap(pos, hip1+vec3(-.03,0,0), mix(hip1, knee1,.25), .13), \n                       sdCap(pos, hip2+vec3(-.03,0,0), mix(hip2, knee2,.25), .13));                    \n    // TODO ca serait plus cool de bouger avec les hanches mais il faut recuperer une base fixee sur les hanches\n    dShort = smin(dShort, mix(d, sdCap(pos, a, ha0+vec3(0,.1,0), .22),.5),.1);\n    d = min(d, dShort);\n\n   // Casque\n\tfloat dHelmet;\n    posRot += vec3(.03,.02,0);\n    dHelmet = max(sdPlane(posRot-h1+hn*.07, hn), mix(dHead, sdCap2(posRot, h1-vec3(.23,0,0), h2-vec3(0,.05,0),.28,.36),.5));\n    dHelmet = max(-fCylinder(posRot-h1-vec3(.2,0,0), .18,.3), dHelmet); \n    dHelmet = fOpEngrave(dHelmet, sdCap(posRot-h2, -vec3(0,.1,1), -vec3(0,.1,-1), .1),.015);\n   \n\td = min(d, dHelmet);\n//\td = min(d, mapGround(pos));\n            \n    return min(d2,d);\n}\n\n\n//---------------------------------------------------------------------\n//    Girl colors \n//---------------------------------------------------------------------\n#define min2(a, b) (a.x<b.x?a:b)\n#define max2(a, b) (a.x>b.x?a:b)\n\n#define ID_MAN 100.\n#define ID_GROUND 90.\n#define ID_GLOVE 106. \n#define ID_HELMET 107.\n#define ID_FOOT 108.\n#define ID_SHORT 110.\n#define ID_LEG  201.\n#define ID_SKIN 202.\n#define ID_ARM  203.\n#define ID_TORSO 204.\n#define ID_EYE 205.\n\n\nconst vec3 COLOR_SKIN = vec3(.6,.43,.3);\nconst vec3 COLOR_ARMOR = vec3(.14,.79,.7);\nconst vec3 COLOR_CLOTHES2 = vec3(.14,.79,.7);\nconst vec3 COLOR_CLOTHES = vec3(.66,.94,.91);\n\n\n\nvec4 drawEye(in vec3 p) {\n    vec3 posRot = p; // - head; \n    posRot.xz = (posRot.xz - head.xz) * rotHead + head.xz;\n    \n    float scaleHead = 1.75;\n    vec3 pHead = (posRot-head) + vec3(.02, .04, 0);\n    pHead = pHead.zyx*scaleHead;\n\n\t// Eye\n    vec3 p_eye = pHead-g_eyePos;\n    vec3 g_eyePosloc = g_eyePos;\n    g_eyePosloc.x *= sign(pHead.x);\n   \tvec3 pe = pHead - g_eyePosloc;\n\n   \n    float a = .2*sin(2.*iTime)*cos(.01*iTime);//clamp(atan(-dir.x, dir.z), -.6,.6), \n    float ca = cos(a), sa = sin(a);\n    pe.xz *= mat2(ca, sa, -sa, ca);\n\n    float b = .2;//.1+.1*sin(iTime*.1);//clamp(atan(-dir.y, dir.z), -.3,.3), \n    float cb = cos(b), sb = sin(b);\n    pe.yz *= mat2(cb, sb, -sb, cb);\n    \n    float d = length(pe.xy);\n    vec3 col = mix(vec3(0), mix(vec3(.88,.41,.0), mix(vec3(0),vec3(1.5),\n                   .5+.5*smoothstep(.0405,.0415,d)), smoothstep(.04,.041,d)), smoothstep(.02,.025,d));\n   // float d2 = smoothstep(.03,.04,length(pe.xy));\n    return vec4(col,ID_EYE);\n}\n\nfloat sdFish(vec3 o) {\n    vec2 p = (o - (shoulder1 + shoulder2)*.5).zy + vec2(.04,.17);\n    p *= 2.;\n    float dsub = min(length(p-vec2(.8,.0)) - .45, length(p-vec2(-.14,.05)) - .11);  \n    p.y = abs(p.y);\n    float d = length(p-vec2(.0,-.15)) - .3;\n    d = min(d, length(p-vec2(.56,-.15)) - .3);\n    d = max(d, -dsub);\n    return (1.-smoothstep(.05,.06,d));\n}\n\n           \n// -----------------------------------------\n\n\nvec4 getColor(float id, vec3 pos) {\n\treturn \t.3+.7*(id == ID_FOOT ? vec4(COLOR_ARMOR, id) :\n\t\t\tid == ID_LEG ? vec4(COLOR_CLOTHES, ID_LEG) :\n\t\t\tid == ID_EYE ? drawEye(pos) :\n         \tid == ID_SKIN ?\tvec4(COLOR_SKIN, ID_SKIN) :\n            id == ID_TORSO ? vec4(mix(COLOR_CLOTHES,vec3(0),sdFish(pos)), ID_TORSO) :\n\t\t\tid == ID_ARM ? vec4(COLOR_SKIN, ID_ARM) :\n\t\t\tid == ID_SHORT ? vec4(COLOR_CLOTHES2, ID_SHORT) :\n    \t\tvec4(COLOR_ARMOR, id));\n}\n\n\nfloat mapColor(in vec3 pos) {\n    vec3 \n         ep0 = mix(shoulder1,shoulder2,.5),\n         ha0 = mix(hip1,hip2,.5),\n         h1 = head + vec3(.0,-.24-.05,0),\n         h2 = head + vec3(.0,.15-.05,0),\n         hn = normalize(h1-h2),\n         a = mix(ha0,ep0,.15), b = mix(ha0,ep0,.79);\n    vec3 posRot = pos; \n    posRot.xz = (posRot.xz - h1.xz) * rotHead + h1.xz;\n    \n    // Leg 1\n    float d = max(min(sdCap2(pos, foot1, ankle1, .1,.15),\n                      sdCap2(pos, ankle1, knee1, .165,.105)),\n\t\t\t\t  -sdPlane(pos-ankle1+v2Foot1*.1, v2Foot12));\n    // Leg 2\n\td = min(d,max(min(sdCap2(pos, foot2, ankle2, .1,.15),\n                      sdCap2(pos, ankle2, knee2, .165,.105)),\n\t\t\t\t  -sdPlane(pos-ankle2+v2Foot2*.1, v2Foot22)));                          \n    \n    vec2 dd;\n    dd = min2(vec2(d, ID_FOOT), \n              vec2(min(sdCap(pos, knee1, hip1, .075),\n    \t\t\t\t   sdCap(pos, knee2, hip2, .075)), ID_LEG));\n\n    // Head\n    float scaleHead = 1.75;\n    vec3 pHead = (posRot - head) + vec3(.02, .04, 0);\n    pHead = pHead.zyx*scaleHead;\n    float dHead = mapHead(pHead)/scaleHead;\n    d = min(d, dHead);\n\n\t// Eye\n    pHead.x = abs(pHead.x);\n    vec3 p_eye = pHead-g_eyePos;\n    p_eye.xz *= ma;  \n\n    \n\tfloat dEye = (length(p_eye) - g_eyeSize)/scaleHead;\n    dd = min2(dd, vec2(dEye,ID_EYE));\n\n  //  d = min(d, dHead);\n    dd = min2(dd, vec2(min(dHead,               // chin\n\t\t\t\t\t\tsdCap(pos, ep0-vec3(.03,0,0), head-vec3(.08,.1,0), .1)), ID_SKIN));  // neck           \n    // Arms\n    dd = min2(dd, vec2(min(sdCap(pos, shoulder2, elbow2, .05), sdCap(pos, shoulder1, elbow1, .05)), ID_LEG));\n    \n\t// Fingers 1\n    vec3 c = wrist1-v3Hand1*.03;\n    float d2 = sdCap(pos, c-v1Hand1*.06+v2Hand1*.03+v3Hand1*.06, wrist1+.09*(v2Hand1+v1Hand1+v3Hand1), .02);\n    d2 = min(d2, sdCap(pos, c, wrist1+.18*(v1Hand1+v2Hand1*.2), .016));\n    d2 = min(d2, sdCap(pos, c-v2Hand1*.01, wrist1+.2*(v1Hand1-v2Hand1*.2), .017));\n    d2 = min(d2, sdCap(pos, c-v2Hand1*.02, wrist1+.18*(v1Hand1-v2Hand1*.5), .016));\n    d2 = min(d2, sdCap(pos, c-v2Hand1*.04, wrist1+.15*(v1Hand1-v2Hand1*.8), .014));\n    \n\t// Fingers 2     \n    c = wrist2-v3Hand2*.03;\n    d2 = min(d2, sdCap(pos, c-v1Hand2*.06+v2Hand2*.03+v3Hand2*.06, wrist2+.09*(v2Hand2+v1Hand2+v3Hand2), .02));\n    d2 = min(d2, sdCap(pos, c, wrist2+.18*(v1Hand2+v2Hand2*.2), .016));\n    d2 = min(d2, sdCap(pos, c-v2Hand2*.01, wrist2+.2*(v1Hand2-v2Hand2*.2), .017));\n    d2 = min(d2, sdCap(pos, c-v2Hand2*.02, wrist2+.18*(v1Hand2-v2Hand2*.5), .016));\n    d2 = min(d2, sdCap(pos, c-v2Hand2*.04, wrist2+.15*(v1Hand2-v2Hand2*.8), .014));\n\n    d2 = min(d2, min(sdCap2(pos, elbow1, wrist1-.01*v1Hand1, .09, .055),  \n                     sdCap2(pos, elbow2, wrist2-.01*v1Hand2, .09, .055)));\n    dd = min2(dd, vec2(d2, ID_GLOVE));\n           \n    // Torso\n    dd = min2(dd, vec2(min(sdCap(pos, shoulder1, shoulder2, .1), \n                           sdCap2(pos, a, b, .19,.22)), ID_TORSO));\n  \n    // Short\n    float dShort = min(sdCap(pos, hip1, mix(hip1,knee1,.3), .12), \n                       sdCap(pos, hip2, mix(hip2,knee2,.3), .12));                    \n    dd = min2(dd, vec2(min(dShort, mix(dd.x, sdCap(pos, a, ha0, .22),.75)), ID_SHORT));\n\n    // Casque\n\tfloat dHelmet;\n    posRot += vec3(.03,.02,0);\n    dHelmet = max(sdPlane(posRot-h1+hn*.08, hn), mix(dHead, sdCap2(posRot, h1-vec3(.23,0,0), h2-vec3(0,.05,0),.28,.36),.5));\n    dHelmet = max(-fCylinder(posRot-h1-vec3(.2,0,0), .18,.3), dHelmet); \n    dd = min2(dd, vec2(dHelmet, ID_HELMET));\n\n    return dd.y;\n}\n\n//---------------------------------------------------------------------\n//   Ray marching scene if ray intersect bbox\n//---------------------------------------------------------------------\n              \nfloat logBisectTrace(in vec3 ro, in vec3 rd){\n\n    float t = 0., told = 0., mid, dn;\n    float d = mapGround(rd*t + ro);\n    float sgn = sign(d);\n#ifdef IS_RUNNING\n    for (int i=0; i<64; i++){\n#else        \n    for (int i=0; i<92; i++){\n#endif\n        // If the threshold is crossed with no detection, use the bisection method.\n        // Also, break for the usual reasons. Note that there's only one \"break\"\n        // statement in the loop. I heard GPUs like that... but who knows?\n        if (sign(d) != sgn || d < 0.001 || t > MAX_DIST) break;\n        told = t;\n        // Branchless version of the following:      \n        t += step(d, 1.)*(log(abs(d) + 1.1) - d) + d;\n        //t += log(abs(d) + 1.1);\n        //t += d;//step(-1., -d)*(d - d*.5) + d*.5;\n        d = mapGround(rd*t + ro);\n    }\n    // If a threshold was crossed without a solution, use the bisection method.\n    if (sign(d) != sgn){\n        // Based on suggestions from CeeJayDK, with some minor changes.\n        dn = sign(mapGround(rd*told + ro));\n        vec2 iv = vec2(told, t); // Near, Far\n        // 6 iterations seems to be more than enough, for most cases...\n        // but there's an early exit, so I've added a couple more.\n        for (int ii=0; ii<8; ii++){ \n            //Evaluate midpoint\n            mid = dot(iv, vec2(.5));\n            float d = mapGround(rd*mid + ro);\n            if (abs(d) < 0.001)break;\n            // Suggestion from movAX13h - Shadertoy is one of those rare\n            // sites with helpful commenters. :)\n            // Set mid to near or far, depending on which side we're on.\n            iv = mix(vec2(iv.x, mid), vec2(mid, iv.y), step(0.0, d*dn));\n        }\n\n        t = mid; \n        \n    }\n    \n    //if (abs(d) < PRECISION) t += d;\n\n    return min(t, MAX_DIST);\n}\n\nvec2 Trace(in vec3 pos, in vec3 ray, in float start, in float end ) {\n    // Trace if in bbox\n    float t=start, h, tn=start, tf=end;\n    float tGround = logBisectTrace(pos, ray);\n\n   // start = max(start, );\n    end = min(tGround, end);\n    \n    if (cube(pos-head-vec3(-.1,-1.,0), ray, vec3(1.2, 1.7,.7)*2.,  tn, tf)) {\n        end = min(tf, end);\n        t = max(tn, start);// - .3*hash33(pos+ray).x;\n        for( int i=0; i < g_traceLimit; i++) {\n\t\t\tif (t > end) break;\n            h = mapGirl( pos+t*ray );\n            if (h < g_traceSize) {\n                return vec2(t+h, mapColor(pos+t*ray));\n            }\n            t += h;\n        }\n        if (t < end) return vec2(t, mapColor(pos+t*ray)); \n    } \n    \n    return tGround < MAX_DIST ?  vec2(tGround, ID_GROUND) : vec2(MAX_DIST, 0.);\n}\n\n//---------------------------------------------------------------------\n//   Soft shadows\n//---------------------------------------------------------------------\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n    n = max(n*n, 0.001);\n    n /= (n.x + n.y + n.z );  \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n\nfloat getGrey(vec3 p){ return dot(p, vec3(0.299, 0.587, 0.114)); }\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total.\nvec3 doBumpMap( sampler2D tex, in vec3 p, in vec3 nor, float bumpfactor){\n    const float eps = 0.001;\n    vec3 grad = vec3( getGrey(tex3D(tex, vec3(p.x-eps, p.y, p.z), nor)),\n                      getGrey(tex3D(tex, vec3(p.x, p.y-eps, p.z), nor)),\n                      getGrey(tex3D(tex, vec3(p.x, p.y, p.z-eps), nor)));\n    grad = (grad - getGrey(tex3D(tex,  p , nor)))/eps; \n    grad -= nor*dot(nor, grad);                  \n    return normalize( nor + grad*bumpfactor );\n}\n\n\n//---------------------------------------------------------------------\n//   Soft shadows\n//---------------------------------------------------------------------\n\n#ifdef WITH_SHADOW\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax ) {\n\tfloat h, res = 1., t = mint;\n    for(int i=0; i<24; i++) {\n\t\th = map( ro + rd*t );\n        res = min( res, 8.*h/t );\n        t += clamp( h, .05, .2 );\n        if( h<.01 || t>tmax ) break;\n    }\n    return clamp(res, 0., 1.);\n}\n#endif\n\n//---------------------------------------------------------------------\n//   Ambiant occlusion\n//---------------------------------------------------------------------\n\n#ifdef WITH_AO\nfloat calcAO( in vec3 pos, in vec3 nor ){\n\tfloat dd, hr, sca = 1., totao = 0.;\n    vec3 aopos; \n    for( int aoi=0; aoi<5; aoi++ ) {\n        hr = .01 + .05*float(aoi);\n        aopos =  nor * hr + pos;\n        totao += -(mapGirl( aopos )-hr)*sca;\n        sca *= .75;\n    }\n    return clamp(1. - 4.*totao, 0., 1.);\n}\nfloat calcAOGround( in vec3 pos, in vec3 nor ){\n\tfloat dd, hr, sca = 1., totao = 0.;\n    vec3 aopos; \n    for( int aoi=0; aoi<5; aoi++ ) {\n        hr = .01 + .05*float(aoi);\n        aopos =  nor * hr + pos;\n        totao += -(min(mapGround(aopos),mapLegs(aopos))-hr)*sca;\n        sca *= .75;\n    }\n    return clamp(1. - 4.*totao, 0., 1.);\n}\n#endif\n\n\n//---------------------------------------------------------------------\n//   Shading\n//   Adapted from Shane / Iq\n//---------------------------------------------------------------------\n\nvec3 shading( in vec3 sp, in vec3 rd, in vec3 sn, in vec3 col, in float id, out float reflexion){\n    \n    vec3 general = vec3(240,198,157)/256.,\n    \t back = vec3(63,56,46)/256.;\n    vec3 ref = reflect( rd, sn );\n\n    // lighitng   \n#ifdef WITH_AO\n    float occ = id == ID_GROUND ? calcAOGround( sp, sn ) : calcAO( sp, sn );\n#else\n    float occ = 1.;\n#endif\n    vec3  ld = normalize( gLightPos );\n    vec3  hal = normalize( rd - ld);\n    float amb = .15; //clamp( .5+.5*sn.y, 0., 1. );\n    float dif = clamp( dot( sn, ld ), 0., 1. );\n    float bac = clamp( dot( sn, normalize(vec3(-ld.x,0.,-ld.z))), 0., 1. );//*clamp( 1.-sp.y,0.,1.);\n    float dom = smoothstep( -.1, .1, ref.y );\n    float fre = pow( clamp(1.+dot(sn,rd),0.,1.), 2. );\n\n    reflexion = fre*occ;\n    \n#ifdef WITH_SHADOW\n    dif *= calcSoftshadow( sp, ld, .05, 2. );\n#endif\n    \n    float spe =  pow( clamp( dot( sn, -hal ), 0., 1. ), id >= ID_SHORT ? 10. : 164.) * dif * (.04 + .96*pow( clamp(1.+dot(hal,rd),0.,1.), 50. ));\n\n    vec3 lin = vec3(0.0);\n    lin += .80*dif*general/*vec3(1.00,0.80,0.55)*/*(.3+.7*occ);\n    lin += .40*amb*occ*general;//vec3(0.40,0.60,1.00);\n   // lin += .15*dom*occ*general;//vec3(0.40,0.60,1.00)*occ;\n    lin += .15*bac*back/*vec3(0.25,0.25,0.25)*/*occ;\n   // lin += .25*fre*vec3(1.00,1.00,1.00)*occ;\n   \n    col = col*lin;\n    col += (id == ID_EYE ? 10. : id >= ID_SHORT ? .3 : 1.)*spe*vec3(1.00,0.90,0.70);\n    \n    return col;\n}\n\n\n\n//---------------------------------------------------------------------\n//   Calculate normal\n//   From TekF \n//---------------------------------------------------------------------\nvec3 Normal(in vec3 pos, in vec3 ray, in float t) {\n\tfloat pitch = .1 * t / iResolution.x;   \n\tpitch = max( pitch, .002 );\n\tvec2 d = vec2(-1,1) * pitch;\n\n\tvec3 p0 = pos+d.xxx, // tetrahedral offsets\n\t     p1 = pos+d.xyy,\n\t     p2 = pos+d.yxy,\n\t     p3 = pos+d.yyx;\n\n \tfloat f0 = mapGirl(p0), f1 = mapGirl(p1), f2 = mapGirl(p2),\tf3 = mapGirl(p3);\n\tvec3 grad = p0*f0+p1*f1+p2*f2+p3*f3 - pos*(f0+f1+f2+f3);\n //   return normalize(grad);\n\t// prevent normals pointing away from camera (caused by precision errors)\n\treturn normalize(grad - max(.0,dot (grad,ray ))*ray);\n}\n\nvec3 NormalGround(in vec3 pos, in vec3 ray, in float t) {\n\tfloat pitch = .2 * t / iResolution.x;   \n\tpitch = max( pitch, .005 );\n\tvec2 d = vec2(-1,1) * pitch;\n\n\tvec3 p0 = pos+d.xxx, // tetrahedral offsets\n\t     p1 = pos+d.xyy,\n\t     p2 = pos+d.yxy,\n\t     p3 = pos+d.yyx;\n\n \tfloat f0 = mapGround(p0), f1 = mapGround(p1), f2 = mapGround(p2), f3 = mapGround(p3);\n\tvec3 grad = p0*f0+p1*f1+p2*f2+p3*f3 - pos*(f0+f1+f2+f3);\n //   return normalize(grad);\n\t// prevent normals pointing away from camera (caused by precision errors)\n\treturn normalize(grad - max(.0,dot (grad,ray ))*ray);\n}\n\n\n\n//---------------------------------------------------------------------\n//   Camera\n//---------------------------------------------------------------------\n\nmat3 setCamera(in vec3 ro, in vec3 ta, in float cr) {\n\tvec3 cw = normalize(ta-ro),\n\t\t cp = vec3(sin(cr), cos(cr), 0.),\n\t\t cu = normalize( cross(cw,cp) ),\n\t\t cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\n//---------------------------------------------------------------------\n//   Entry point\n//---------------------------------------------------------------------\n\n\n    \nvoid initRunningPosition(int it, float kt) {\n\thead = getPos2(HEAD2, it, kt, 1.);\n\n\tshoulder1 = getPos2(SHOULDER2, it, kt, 1.);\n\telbow1 = getPos2(ELBOW2, it, kt, 1.);\n\twrist1 = getPos2(WRIST2, it, kt, 1.);\n\n\tfoot1 = getPos2(FOOT2, it, kt, 1.);\n\tankle1 = getPos2(ANKLE2, it, kt, 1.);\n\tknee1 = getPos2(KNEE2, it, kt, 1.);\n\thip1 = getPos2(HIP2, it, kt, 1.);\n\n\tshoulder2 = getPos2(SHOULDER2, it+4, kt, -1.);\n\telbow2 = getPos2(ELBOW2, it+4, kt, -1.);\n\twrist2 = getPos2(WRIST2, it+4, kt, -1.);\n\n\tfoot2 = getPos2(FOOT2, it+4, kt, -1.);\n\tankle2 = getPos2(ANKLE2, it+4, kt, -1.);\n\tknee2 = getPos2(KNEE2, it+4, kt, -1.);\n\thip2 = getPos2(HIP2, it+4, kt, -1.);\n}\n\n\n\nvec4 render(in vec3 ro, in vec3 rd, out vec3 roRef, out vec3 rdRef) {\n\tfloat t = MAX_DIST, traceStart = 0., traceEnd = MAX_DIST;\n\n    // Render ------------------------\n\tvec3 col;\n    vec4 colClouds = vec4(0);\n    vec2 tScene = Trace(ro, rd, traceStart, t);\n    \n    if (tScene.x > MAX_DIST-5.) {\n\t\tcolClouds = clouds(vec3(0), rd, t);\n    }\n\n\tfloat reflection = 0.;\n\t\n    roRef = ro;\n    rdRef = rd;\n    \n\tif (tScene.x < MAX_DIST) {\n       \n\t\tvec3 pos = ro + rd*tScene.x;\n        float id = tScene.y;\n\t\tvec3 sn, sceneColor, rnd = hash33(rd + 311.);\n\n        if (id == ID_GROUND) {\n            sn = NormalGround(pos, rd, tScene.x);\n\t\t\tsn = doBumpMap(iChannel2, pos/4., sn, .025/(1. + tScene.x/MAX_DIST)); \n\t\t\tsceneColor = mix(1.2*vec3(.5,.45,.4), vec3(.12), clamp(0.,1.,2.*pos.y))+(fract(rnd*289. + tScene.x*41.) - .5)*.03;    \n        } else {\n\t\t\tsn = Normal(pos, rd, tScene.x);\n   #ifndef IS_RUNNING\n            if (id == ID_HELMET) {\n                vec3 posRot = pos; \n    \t\t\tposRot.xz = (posRot.xz-head.xz) * rotHead;\n            \tsn = doBumpMap(iChannel2, posRot/16.+.5, sn, .0004/(1. + tScene.x/MAX_DIST)); \n            }\n   #endif         \n\t\t\tvec4 sceneColor4 = getColor(id, pos);\n\t\t\tid = sceneColor4.w;\n\t\t\tsceneColor = sceneColor4.rgb;\n        }\n\t\t\n        rdRef = reflect(rd,sn);\n\t\troRef = pos + rdRef*.1;\n        \n        float reflexion;\n        \n\t\t// Shading\n\t\tcol = shading(pos, rd, sn, sceneColor, id, reflexion);\n\t\treflection = ID_GROUND==id && pos.y<.2 ? .9 : (reflexion)*.2;\n\n\t\t// Fog\n\t\tcol = mix(col, colClouds.rgb, smoothstep(MAX_DIST-5., MAX_DIST, tScene.x));\n        col += (fract(rnd*289. + tScene.x*4001.) - .5)*.05;\n        float f = MAX_DIST*.3;\n        vec3 fogColor = vec3(.87,.85,1);\n        col = mix( .2*fogColor, col, exp2(-tScene.x*fogColor/f) );\n\t\t\n    } else {\n\t\tcol = colClouds.rgb;\n\t}\n\n\treturn vec4(col, reflection);\n}\n\n\n\nconst float\n    a_eyeClose = .55, \n    a_eyeOpen = -.3;\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    if (iTime>31.) discard;\n    \n    gTime = iTime*8.+.1;\n   \n    rotHead = rot(.6*(sin(.05*gTime)*cos(.001*gTime+1.11)));\n        \n    // Animation\n    int it = int(floor(gTime));\n    float kt = fract(gTime);\n\n#ifdef IS_RUNNING\n//    drawHand = false;\n    const bool isRunning = true; //cos(iTime*.2)>0.;;\n#else\n//    drawHand = true;\n    const bool isRunning = false;\n#endif\n\n    // - init man position -----------------------------------\n    \n#ifdef IS_RUNNING\n  //  if (isRunning) {\n\t\tinitRunningPosition(it, kt);\n  //  } else {\n//\t\tinitWalkingPosition(it, kt);\n  //  }\n#else\n\tinitLookingPosition(0);\n#endif\n\n//    const float t_openEye = 3., t_rotDown = 10., t_closeEye = 1.;\n    // - Eye blink -------------------------------------------\n    float time = iTime;\n/*    float a_PaupieresCligne = mix(a_eyeOpen,a_eyeClose, hash(floor(time*10.))>.98?2.*abs(fract(20.*time)-.5):0.);    \n    float a_Paupieres = mix(a_eyeClose, .2, smoothstep(t_openEye, t_openEye+3., time));    \n    a_Paupieres = mix(a_Paupieres, a_PaupieresCligne, smoothstep(t_rotDown, t_rotDown+1., time));\n   // a_Paupieres = mix(a_Paupieres, a_eyeClose, smoothstep(t_closeEye, t_closeEye+3., time));\n*/\n    g_eyeRot = rot(-.3);\n    \n// Init base vectors --------------------------------------------\n\n  // Foot1 flat part - vector base linked to leg 1\n    v2Foot1 = normalize(knee1 - ankle1);\n\tvec3 v1Foot1 = normalize(ankle1 - foot1-v2Foot1*.1);\n\tv3Foot1 = cross(v1Foot1,v2Foot1);\n\tv2Foot12 = -cross(v1Foot1, v3Foot1);\n\n    v2Foot2 = normalize(knee2 - ankle2);\n    vec3 v1Foot2 = normalize(ankle2 - foot2-v2Foot2*.1);\n\tv3Foot2 = cross(v1Foot2,v2Foot2);\n    v2Foot22 = -cross(v1Foot2, v3Foot2); \n\n\t// Arm 1\n    v1Hand1 = normalize(wrist1-elbow1);\n    v3Hand1 = -normalize(cross(v1Hand1,normalize(wrist1-shoulder1)));\n    v2Hand1 = -cross(v1Hand1,v3Hand1);\n    v3Hand1 = isRunning ? -v3Hand1 : v3Hand1;          \n   // if (drawHand) {\n    \t\n   // }\n\t// Arm 2\n    v1Hand2 = normalize(wrist2-elbow2);\n    v3Hand2 = -normalize(cross(v1Hand2,normalize(wrist2-shoulder2)));\n    v2Hand2 = -cross(v1Hand2,v3Hand2);\n    v3Hand2 = isRunning ? v3Hand2 : -v3Hand2; \n//vec3 tmp = v2Hand2; v2Hand2 = -v3Hand2; v3Hand2 = tmp;\n// --------------------------------------------------------------\n\n    vec2 m = iMouse.xy/iResolution.y - .5;\n\n\tfloat traceStart = .2;\n\n    vec3 ro, rd;\n  \tvec2 q;\n    \n// - Camera -----------------------------------------\n    \n\tq = (fragCoord.xy)/iResolution.xy;\n\tvec2 p = -1. + 2.*q;\n\tp.x *= iResolution.x/iResolution.y;\n\n    time = iTime - 35.;\n    \n    vec3 ta = vec3(mix(hip1.x,gTime*.58,.75), 1.4, 0.);\n\tro = ta + 11.*vec3(cos(-.2*time),.07,sin(-.2*time));\n\tro.y = max(0.01, ro.y);\n\n    // camera-to-world transformation\n\tmat3 ca = setCamera(ro, ta, 0.0);\n\n\t// ray direction\n\trd = ca * normalize( vec3(p.xy, 3.5) );\n\n// ---------------------------------------------------\n    vec3 roRef, rdRef;\n\tvec4 col = render(ro, rd, roRef, rdRef);\n\n// Post processing stuff --------------------\n\n    // Teinte\n  // col.rgb = .2*length(col.rgb)*vec3(1,.5,0)+.8*col.rgb;\n\n\t// Gamma\n     col.rgb = pow(col.rgb, vec3(0.6545) );\n\n    // Vigneting\n    col.rgb *= pow(16.*q.x*q.y*(1.-q.x)*(1.-q.y), .15); \n    \n\tfragColor = col;\n}\n\n",
   "name": "Buffer B",
   "description": "",
   "type": "buffer"
  }
 ]
}