{
 "ver": "0.1",
 "info": {
  "id": "fd2fRw",
  "date": "0",
  "viewed": 0,
  "name": "Glass and Bubble JiPi 424",
  "description": "Well, this is only a test, but since it looks pretty, I decided to publish it! ;)\nUse the mouse to move around.\nComments and suggestions are welcome!",
  "likes": 0,
  "published": "Private",
  "usePreview": 0,
  "tags": [
   "test",
   "reflection",
   "waves",
   "refraction",
   "glass",
   "bubble",
   "bump",
   "gold"
  ],
  "hasliked": 0,
  "parentid": "XdVSRV",
  "parentname": "Glass and Gold Bubble"
 },
 "renderpass": [
  {
   "inputs": [
    {
     "id": "XsfGzn",
     "filepath": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg",
     "type": "cubemap",
     "channel": 0,
     "sampler": {
      "filter": "mipmap",
      "wrap": "clamp",
      "vflip": "false",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    }
   ],
   "outputs": [
    {
     "id": "4dfGRr",
     "channel": 0
    }
   ],
   "code": "/*\n\"Glass and Gold Bubble\" by Emmanuel Keller aka Tambako - June 2016\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nContact: tamby@tambako.ch\n*/\n\n#define pi 3.14159265359\n\n// Switches, you can play with them!\n#define bumped_glass\n//#define thick_bottom\n#define show_gold\n#define specular\n#define reflections\n\n//#define antialias\n\nstruct Lamp\n{\n  \tvec3 position;\n  \tvec3 color;\n  \tfloat intensity;\n  \tfloat attenuation;\n};\n    \nstruct TransMat\n{\n    vec3 col_vol;\n    vec3 col_dif;\n    vec3 col_fil;\n    vec3 col_dev;\n    float specint;\n    float specshin;\n    float ior;\n};\n\nstruct RenderData\n{\n  \tvec3 col;\n  \tvec3 pos;\n  \tvec3 norm;\n  \tint objnr;\n};\n   \n// Every object of the scene has its ID\n#define SKY_OBJ        0\n#define BUBBLE_OBJ     1\n\nLamp lamps[2];\n\n// Campera options\nvec3 campos = vec3(0., -0., 10.);\nvec3 camtarget = vec3(0., 0., 0.);\nvec3 camdir = vec3(0., 0., 0.);\nfloat fov = 6.;\n\n// Ambient light\nconst vec3 ambientColor = vec3(0.3);\nconst float ambientint = 0.025;\n\n// Gold options\nconst vec3 goldColor = vec3(1.1, 0.91, 0.52);\nconst vec3 goldColor2 = vec3(1.1, 1.07, 0.88);\nconst vec3 goldColor3 = vec3(1.02, 0.82, 0.55);\nconst float goldRef = 0.99;\n\n// Tracing options\nconst float normdelta = 0.001;\nconst float maxdist = 40.;\nconst int nbref = 7;\n\n// Glass perameters\nconst float bubbleRadius = 1.2;\nconst float bubbleThickness = 0.001;\nconst float bumpFactor = 0.014;\n\n// Antialias. Change from 1 to 2 or more AT YOUR OWN RISK! It may CRASH your browser while compiling!\nconst float aawidth = 0.8;\nconst int aasamples = 2;\n\nTransMat glassMat;\n\nvoid init()\n{\n    lamps[0] = Lamp(vec3(-5., 3., -5.), vec3(1., 1., 1.), 1.5, 0.01);\n    lamps[1] = Lamp(vec3(1.5, 4., 2.), vec3(0.7, 0.8, 1.), 1.7, 0.01);\n    \n    glassMat = TransMat(vec3(0.96, 0.99, 0.96),\n                        vec3(0.01, 0.02, 0.02),\n                        vec3(1.),\n                        vec3(0.3, 0.5, 0.9),\n                        0.4,\n                        45.,\n                        1.47);\n}\n\n// Union operation from iq\nvec2 opU(vec2 d1, vec2 d2)\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 rotateVec(vec2 vect, float angle)\n{\n    vec2 rv;\n    rv.x = vect.x*cos(angle) - vect.y*sin(angle);\n    rv.y = vect.x*sin(angle) + vect.y*cos(angle);\n    return rv;\n}\n\n// 1D hash function\nfloat hash(float n)\n{\n    return fract(sin(n)*753.5453123);\n}\n\n// From https://www.shadertoy.com/view/4sfGzS\nfloat noise(vec3 x)\n{\n    //x.x = mod(x.x, 0.4);\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix(hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix(hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix(hash(n+113.0), hash(n+114.0),f.x),\n                   mix(hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\nfloat bubblePattern(vec3 pos)\n{\n    return noise(normalize(pos)*2.5);\n}\n\nfloat goldValue(vec3 pos)\n{\n    #ifdef show_gold\n    pos+= 0.04*noise(pos*26.7);\n    return smoothstep(0.63, 0.64, bubblePattern(pos));\n    #else\n    return 0.;\n    #endif\n}\n\nfloat bubbleBump(vec3 pos)\n{\n    #ifdef bumped_glass\n    float wf = 65. + 15.*sin(iTime*0.08);\n    float bp = bubblePattern(pos);\n    float sa = smoothstep(0.1, 0.2, bp)*smoothstep(0.8, 0.65, bp);\n    return sa*sin(bp*wf);\n    #else\n    return 0.;\n    #endif\n}\n\nfloat map_bubble(vec3 pos)\n{\n   #ifdef thick_bottom\n   float bubbleThickness2 = bubbleThickness*(1. + 500.*smoothstep(-0.25, -0.4, pos.y/bubbleRadius));\n   #else\n   float bubbleThickness2 = bubbleThickness;\n   #endif\n    \n   float outside = length(pos) - bubbleRadius;\n   outside-= bumpFactor*bubbleBump(pos);\n   float inside = length(pos) - bubbleRadius + bubbleThickness2;\n   inside-= bumpFactor*bubbleBump(pos);\n   float df = max(outside, -inside);\n    \n   //df = max(df, pos.z);\n   return df;\n}\n\nvec2 map(vec3 pos, bool inside)\n{\n    float bubble = map_bubble(pos);\n    if (inside) bubble*=-1.;\n    vec2 res = vec2(bubble, BUBBLE_OBJ);\n    \n    return res;\n}\n\n// Main tracing function\nvec2 trace(vec3 cam, vec3 ray, float maxdist, bool inside) \n{\n    float t = 0.1;\n    float objnr = 0.;\n    vec3 pos;\n    float dist;\n    float dist2;\n    \n  \tfor (int i = 0; i < 128; ++i)\n    {\n    \tpos = ray*t + cam;\n        vec2 res = map(pos, inside);\n        dist = res.x;\n        if (dist>maxdist || abs(dist)<0.002)\n            break;\n        t+= dist*0.43;\n        objnr = abs(res.y);\n  \t}\n  \treturn vec2(t, objnr);\n}\n\n// From https://www.shadertoy.com/view/MstGDM\n// Here the texture maping is only used for the normal, not the raymarching, so it's a kind of bump mapping. Much faster\nvec3 getNormal(vec3 pos, float e, bool inside)\n{  \n    vec2 q = vec2(0, e);\n    return normalize(vec3(map(pos + q.yxx, inside).x - map(pos - q.yxx, inside).x,\n                          map(pos + q.xyx, inside).x - map(pos - q.xyx, inside).x,\n                          map(pos + q.xxy, inside).x - map(pos - q.xxy, inside).x));\n}\n\n// Gets the color of the sky\nvec3 sky_color(vec3 ray)\n{ \n    return texture(iChannel0, ray).rgb;\n}\n\nvec3 getGoldColor(vec3 pos)\n{\n    pos+= 0.4*noise(pos*24.);\n    float t = noise(pos*30.);\n    vec3 col = mix(goldColor, goldColor2, smoothstep(0.55, 0.95, t));\n    col = mix(col, goldColor3, smoothstep(0.45, 0.25, t));\n    return col;\n}\n\nvec3 getBubbleColor(vec3 pos)\n{\n\treturn mix(glassMat.col_dif, getGoldColor(pos), pow(goldValue(pos), 4.));\n}\n  \n// Combines the colors\nvec3 getColor(vec3 norm, vec3 pos, int objnr, vec3 ray)\n{\n   return objnr==BUBBLE_OBJ?getBubbleColor(pos):sky_color(ray);\n}\n\n// Fresnel reflectance factor through Schlick's approximation: https://en.wikipedia.org/wiki/Schlick's_approximation\nfloat fresnel(vec3 ray, vec3 norm, float n2)\n{\n   float n1 = 1.; // air\n   float angle = acos(-dot(ray, norm));\n   float r0 = dot((n1-n2)/(n1+n2), (n1-n2)/(n1+n2));\n   float r = r0 + (1. - r0)*pow(1. - cos(angle), 5.);\n   return clamp(r, 0., 0.8);\n}\n\n// Shading of the objects pro lamp\nvec3 lampShading(Lamp lamp, vec3 norm, vec3 pos, vec3 ocol, int objnr, int lampnr)\n{   \n    vec3 pl = normalize(lamp.position - pos);\n    float dlp = distance(lamp.position, pos);\n    vec3 pli = pl/pow(1. + lamp.attenuation*dlp, 2.);\n    float dnp = dot(norm, pli);\n      \n    // Diffuse shading\n    vec3 col;\n    col = ocol*lamp.color*lamp.intensity*smoothstep(-0.1, 1., dnp); //clamp(dnp, 0., 1.);\n    \n    // Specular shading\n    #ifdef specular\n\n    float specint = glassMat.specint;\n    float specshin = glassMat.specshin;  \n    //if (dot(norm, lamp.position - pos) > 0.0)\n        col+= lamp.color*lamp.intensity*specint*pow(max(0.0, dot(reflect(pl, norm), normalize(pos - campos))), specshin);\n    #endif\n    \n    // Softshadow\n    #ifdef shadow\n    col*= shi*softshadow(pos, normalize(lamp.position - pos), shf, 100.) + 1. - shi;\n    #endif\n    \n    return col;\n}\n\n// Shading of the objects over all lamps\nvec3 lampsShading(vec3 norm, vec3 pos, vec3 ocol, int objnr)\n{\n    vec3 col = vec3(0.);\n    for (int l=0; l<2; l++) // lamps.length()\n        col+= lampShading(lamps[l], norm, pos, ocol, objnr, l);\n    \n    return col;\n}\n\n// From https://www.shadertoy.com/view/lsSXzD, modified\nvec3 GetCameraRayDir(vec2 vWindow, vec3 vCameraDir, float fov)\n{\n\tvec3 vForward = normalize(vCameraDir);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n    \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * fov);\n\n\treturn vDir;\n}\n\n// Sets the position of the camera with the mouse and calculates its direction\nconst float axm = 4.;\nconst float aym = 1.5;\nvoid setCamera()\n{\n   vec2 iMouse2;\n   if (iMouse.x==0. && iMouse.y==0.)\n      iMouse2 = vec2(0.5, 0.5);\n   else\n      iMouse2 = iMouse.xy/iResolution.xy;\n   \n   campos = vec3(8.5, 0., 0.);\n   campos.xy = rotateVec(campos.xy, -iMouse2.y*aym + aym*0.5);\n   campos.yz = rotateVec(campos.yz, -iMouse2.y*aym + aym*0.5);\n   campos.xz = rotateVec(campos.xz, -iMouse2.x*axm);\n\n   camtarget = vec3(0.);\n   camdir = camtarget - campos;   \n}\n\n// Tracing and rendering a ray\nRenderData trace0(vec3 tpos, vec3 ray, float maxdist, bool inside)\n{\n    vec2 tr = trace(tpos, ray, maxdist, inside);\n    float tx = tr.x;\n    int objnr = int(tr.y);\n    vec3 col;\n    vec3 pos = tpos + tx*ray;\n    vec3 norm;\n    \n    if (tx<maxdist*0.95)\n    {\n        norm = getNormal(pos, normdelta, inside);\n        col = getColor(norm, pos, objnr, ray);\n      \n        // Shading\n        col = ambientColor*ambientint + lampsShading(norm, pos, col, objnr);\n    }\n    else\n    {\n        objnr = SKY_OBJ;\n        col = vec3(0.);\n    }\n    return RenderData(col, pos, norm, objnr);\n}\n\nvec3 getGlassAbsColor(float dist, vec3 color)\n{\n    return pow(color, vec3(0.1 + pow(dist*8., 2.)));\n}\n\n// Main render function with reflections and refractions\nvec4 render(vec2 fragCoord)\n{   \n  \tvec2 uv = fragCoord.xy / iResolution.xy; \n  \tuv = uv*2.0 - 1.0;\n  \tuv.x*= iResolution.x / iResolution.y;\n\n  \tvec3 ray = GetCameraRayDir(uv, camdir, fov);\n  \tRenderData traceinf = trace0(campos, ray, maxdist, false);\n  \tvec3 col = traceinf.col;\n  \tbool inside = false;\n  \tfloat cior = glassMat.ior;\n  \tvec3 glassf = vec3(1.);\n    vec3 refray;\n\n    glassf = vec3(1.);\n\n    for (int i=0; i<nbref; i++)\n    {\n        if (traceinf.objnr==BUBBLE_OBJ)\n        {\t \n            float gv = glassf.r*goldValue(traceinf.pos);\n            #ifdef reflections\n            refray = reflect(ray, traceinf.norm);\n            float rf = fresnel(ray, traceinf.norm, glassMat.ior); \n            vec3 colGl = mix(col, sky_color(refray), rf*glassf);\n            vec3 colGo = mix(col, getGoldColor(traceinf.pos)*sky_color(refray), goldRef);\n          \n            if (!inside)\n            {\n            \tcol = mix(colGl, colGo, gv);\n            \tglassf*= (1. - gv)*(1.- rf);\n            }\n            #endif\n            \n            cior = inside?1./glassMat.ior:glassMat.ior;\n\n            vec3 ray_r = refract(ray, traceinf.norm, 1./cior);\n            if (length(ray_r)!=0.)\n                inside = !inside;\n            else\n                ray_r = reflect(ray, traceinf.norm);            \n\n            vec3 pos = traceinf.pos;\n\n            traceinf = trace0(pos, ray_r, 20., inside);\n            if (inside)\n                glassf*= getGlassAbsColor(distance(pos, traceinf.pos), glassMat.col_vol);\n            glassf*= glassMat.col_fil;\n            \n            col+= clamp(traceinf.col*glassf, 0., 1.);\n\n            ray = ray_r;\n\n        }\n        if (traceinf.objnr==SKY_OBJ)\n        {\n            col+= sky_color(ray)*glassf;\n            break;\n        }\n    }\n  \treturn vec4(col, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{   \n    init();\n    setCamera();\n    \n    // Antialiasing.\n    #ifdef antialias\n    vec4 vs = vec4(0.);\n    for (int j=0;j<aasamples ;j++)\n    {\n       float oy = float(j)*aawidth/max(float(aasamples-1), 1.);\n       for (int i=0;i<aasamples ;i++)\n       {\n          float ox = float(i)*aawidth/max(float(aasamples-1), 1.);\n          vs+= render(fragCoord + vec2(ox, oy));\n       }\n    }\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = vs/vec4(aasamples*aasamples);\n    #else\n    fragColor = render(fragCoord);\n    #endif\n}",
   "name": "Image",
   "description": "",
   "type": "image"
  }
 ]
}