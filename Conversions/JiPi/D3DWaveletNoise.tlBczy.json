{"Shader":{"ver":"0.1","info":{"id":"tlBczy","date":"1594676976","viewed":772,"name":"3D Wavelet Noise","username":"blackle","description":"An attempt to generalize https:\/\/www.shadertoy.com\/view\/wsBfzK to 3 dimensions and distort an SDF.","likes":35,"published":3,"flags":0,"usePreview":1,"tags":["noise"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"id":37,"channel":0}],"code":"\/\/CC0 1.0 Universal https:\/\/creativecommons.org\/publicdomain\/zero\/1.0\/\n\/\/To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat WaveletNoise(vec3 p, float z, float k) {\n    \/\/ https:\/\/www.shadertoy.com\/view\/wsBfzK\n    float d=0.,s=1.,m=0., a;\n    for(float i=0.; i<5.; i++) {\n        vec3 q = p*s, g=fract(floor(q)*vec3(123.34,233.53,314.15));\n    \tg += dot(g, g+23.234);\n\t\ta = fract(g.x*g.y)*1e3 +z*(mod(g.x+g.y, 2.)-1.); \/\/ add vorticity\n        q = (fract(q)-.5);\n        \/\/random rotation in 3d. the +.1 is to fix the rare case that g == vec3(0)\n        \/\/https:\/\/suricrasia.online\/demoscene\/functions\/#rndrot\n        q = erot(q, normalize(tan(g+.1)), a);\n        d += sin(q.x*10.+z)*smoothstep(.25, .0, dot(q,q))\/s;\n        p = erot(p,normalize(vec3(-1,1,0)),atan(sqrt(2.)))+i; \/\/rotate along the magic angle\n        m += 1.\/s;\n        s *= k; \n    }\n    return d\/m;\n}\n\nfloat super(vec3 p) {\n    return sqrt(length(p*p));\n}\n\nfloat box(vec3 p, vec3 d) {\n    vec3 q = abs(p)-d;\n    return super(max(q,0.))+min(0.,max(q.x,max(q.y,q.z)));\n}\n\nvec3 distorted_p;\nfloat scene(vec3 p) {\n    \/\/different noise for each dimension\n    p.x += WaveletNoise(p\/2., iTime*3., 1.15)*.3;\n    p.y += WaveletNoise(p\/2.+10., iTime*3., 1.15)*.3;\n    p.z += WaveletNoise(p\/2.+20., iTime*3., 1.15)*.3;\n    distorted_p = p;\n    return box(p,vec3(1))-.3;\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.001);\n    return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)\/iResolution.y;\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)\/iResolution.y;\n\n    vec3 cam = normalize(vec3(1.2,uv));\n    vec3 init = vec3(-7.,0,0);\n    \n    float yrot = 0.5;\n    float zrot = iTime*.2;\n    if (iMouse.z > 0.) {\n        yrot += -4.*mouse.y;\n        zrot = 4.*mouse.x;\n    }\n    cam = erot(cam, vec3(0,1,0), yrot);\n    init = erot(init, vec3(0,1,0), yrot);\n    cam = erot(cam, vec3(0,0,1), zrot);\n    init = erot(init, vec3(0,0,1), zrot);\n    \n    vec3 p = init;\n    bool hit = false;\n    for (int i = 0; i < 250 && !hit; i++) {\n        float dist = scene(p);\n        hit = dist*dist < 1e-6;\n        p+=dist*cam*.9;\n        if (distance(p,init)>50.) break;\n    }\n    vec3 local_coords = distorted_p;\n    vec3 n = norm(p);\n    vec3 r = reflect(cam,n);\n    float ss = smoothstep(-.05,.05,scene(p+vec3(.05)\/sqrt(3.)));\n    float tex = WaveletNoise(local_coords*3., 0., 1.5)+.5;\n    float diff = mix(length(sin(n*2.)*0.5+0.5)\/sqrt(3.),ss,.7)+.1;\n    float spec = length(sin(r*4.)*0.5+0.5)\/sqrt(3.);\n    float specpow = mix(3.,10.,tex);\n    float frens = 1.-pow(dot(cam,n),2.)*0.98;\n    vec3 col = vec3(0.7,0.2,0.4)*diff + pow(spec,specpow)*frens;\n    float bgdot = length(sin(cam*3.5)*0.4+0.6)\/sqrt(3.);\n    vec3 bg = vec3(.2,.2,.3) * bgdot + pow(bgdot, 10.)*2.;\n    fragColor.xyz = hit ? col : bg;\n    fragColor = sqrt(fragColor);\n    fragColor *= 1.- dot(uv,uv)*.6;\n}","name":"Image","description":"","type":"image"}]}}