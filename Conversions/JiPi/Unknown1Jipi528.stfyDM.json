{
 "ver": "0.1",
 "info": {
  "id": "stfyDM",
  "date": "0",
  "viewed": 0,
  "name": "Unknown1 JiPi 528",
  "description": "Video Version : https://www.youtube.com/watch?v=VS3-slsPuVc",
  "likes": 0,
  "published": "Private",
  "usePreview": 0,
  "tags": [
   "eyes"
  ],
  "hasliked": 0,
  "parentid": "stlyW4",
  "parentname": "Unknown1"
 },
 "renderpass": [
  {
   "inputs": [],
   "outputs": [
    {
     "id": "4dfGRr",
     "channel": 0
    }
   ],
   "code": "#define int2 vec2\n#define float2 vec2\n#define int3 vec3\n#define float3 vec3\n#define int4 vec4\n#define float4 vec4\n#define frac fract\n#define float2x2 mat2\n#define float3x3 mat3\n#define saturate(x) clamp(x,0.,1.)\n#define lerp mix\n#define CurrentTime (iTime)\n#define sincos(x,s,c) s = sin(x),c = cos(x)\n#define mul(x,y) (x*y)\n#define atan2 atan\n#define fmod mod\n\nconst float PId2 = 1.57079632f;\nconst float PI = 3.141592653f;\nconst float PI2 = 6.2831853f;\nconst float MaxDist = 100.f;\nconst float SurfaceDist = 0.0001f;\n\n#define RayMarching(origin, dir, distFunc, iter, res, more) {\\\n    float hitDist = 0.f;\\\n    float mat = 0.f;\\\n    for (int i = 0;i < iter; ++i){\\\n        float3 ray = origin + hitDist * dir;\\\n        float2 curr = distFunc(ray);\\\n        if (hitDist > MaxDist || curr.x < SurfaceDist)\\\n            break;\\\n        {more;}\\\n        mat = curr.y;\\\n        hitDist += curr.x;}\\\n    res = float2(hitDist, mat);}\n\n#define GetNormal(ray, distFunc, res) {\\\n    float2 k = float2(1.f, -1.f);\\\n    res = normalize(k.xyy * distFunc(ray + k.xyy * SurfaceDist).x +\\\n                     k.yyx * distFunc(ray + k.yyx * SurfaceDist).x +\\\n                     k.yxy * distFunc(ray + k.yxy * SurfaceDist).x +\\\n                     k.xxx * distFunc(ray + k.xxx * SurfaceDist).x);}\n\nfloat3x3 viewMatrix(float3 look)\n{\n    float3 right = normalize(cross(float3(0.f, 1.f, 0.f), look));\n    float3 up = cross(look, right);\n    return float3x3(right, up, look);\n}\n\nfloat2 minX(float2 a, float2 b)\n{\n    return a.x < b.x ? a : b;\n}\n\nfloat min3(float a, float b, float c)\n{\n    return min(a, min(b, c));\n}\n\nfloat min4(float a, float b, float c, float d)\n{\n    return min(min3(a, b, c), d);\n}\n\nfloat2 hash(float2 p)\n{\n    p = float2(dot(p, float2(127.1f, 311.7f)), dot(p, float2(269.5f, 183.3f)));\n    return 2.f * frac(sin(p) * 43758.5453123f) - 1.f;\n}\n\nfloat3 hash(float3 p)\n{\n    p = float3(dot(p, float3(127.1f, 311.7f, 74.7f)), dot(p, float3(269.5f, 183.3f, 246.1f)), dot(p, float3(113.5f, 271.9f, 124.6f)));\n    return 2.f * frac(sin(p) * 43758.5453123) - 1.f;\n}\n\nfloat sdf3dSphere(float3 _point, float4 sphere)\n{\n    return length(_point - sphere.xyz) - sphere.w;\n}\n\nfloat sdf3dInfPlane(float3 _point, float3 plane, float3 planeNormal)\n{\n    return dot((_point - plane), planeNormal);\n}\n\nfloat sdf3dInfCylinder(float3 _point, float4 cylinder, float3 cylinderDirection)\n{\n    _point -= cylinder.xyz;\n    return length(_point - dot(_point, cylinderDirection) * cylinderDirection) - cylinder.w;\n}\n\nfloat simplexNoise(float3 p)\n{\n    float k1 = 0.333333f;\n    float k2 = 0.166667f;\n    \n    int3 idx = floor(p + (p.x + p.y + p.z) * k1);\n    float3 a = p - (float3(idx) - float(idx.x + idx.y + idx.z) * k2);\n    \n    int3 tb1Arr[8] = vec3[8]\n    ( int3(0, 0, 1), int3(0, 1, 0), int3( 0), int3(0, 1, 0), int3(0, 0, 1), int3( 0), int3(1, 0, 0), int3(1, 0, 0) );\n    int3 tb2Arr[8] = vec3[8]\n    ( int3(0, 1, 1), int3(0, 1, 1), int3( 0), int3(1, 1, 0), int3(1, 0, 1), int3( 0), int3(1, 0, 1), int3(1, 1, 0) );\n    \n    uint tbIdx = (uint(a.x > a.y) << 2) | (uint(a.x > a.z) << 1) | uint(a.y > a.z);\n    \n    int3 tb1 = tb1Arr[tbIdx], tb2 = tb2Arr[tbIdx];\n    \n    float3 b = a - tb1 + k2;\n    float3 c = a - tb2 + k2 * 2.f;\n    float3 d = a - 1.f + k2 * 3.f;\n    \n    float4 kernel = max(0.5f - float4(dot(a, a), dot(b, b), dot(c, c), dot(d, d)), 0.f);\n    kernel *= kernel;\n    kernel *= kernel;\n    float4 noise = kernel * float4(dot(a, hash(idx)), dot(b, hash(idx + tb1)), dot(c, hash(idx + tb2)), dot(d, hash(idx + 1.f)));\n    \n    return dot(vec4(52.f), noise);\n}\n\nfloat simplexVoronoi(float3 p, float m)\n{\n    float k1 = 0.333333f;\n    float k2 = 0.166667f;\n    \n    int3 idx = floor(p + (p.x + p.y + p.z) * k1);\n    float3 a = p - (float3(idx) - float(idx.x + idx.y + idx.z) * k2);\n    \n    int3 tb1Arr[8] = vec3[8]\n    ( int3(0, 0, 1), int3(0, 1, 0), int3( 0), int3(0, 1, 0), int3(0, 0, 1), int3( 0), int3(1, 0, 0), int3(1, 0, 0) );\n    int3 tb2Arr[8] = vec3[8]\n    ( int3(0, 1, 1), int3(0, 1, 1), int3( 0), int3(1, 1, 0), int3(1, 0, 1), int3( 0), int3(1, 0, 1), int3(1, 1, 0) );\n    \n    uint tbIdx = (uint(a.x > a.y) << 2) | (uint(a.x > a.z) << 1) | uint(a.y > a.z);\n    \n    int3 tb1 = tb1Arr[tbIdx], tb2 = tb2Arr[tbIdx];\n    \n    float g = 0.1f;\n    float3 offA = sin(hash(idx) * 425.551f + m) * g;\n    float3 offB = sin(hash(idx + tb1) * 425.551f + m) * g + tb1 - k2;    \n    float3 offC = sin(hash(idx + tb2) * 425.551f + m) * g + tb2 - k2 * 2.f;\n    float3 offD = sin(hash(idx + 1.f) * 425.551f + m) * g + 1.f - k2 * 3.f;\n    \n    float dist = min4(sdf3dSphere(a, float4(offA, 0.01f)), sdf3dSphere(a, float4(offB, 0.01f)),\n    sdf3dSphere(a, float4(offC, 0.01f)), sdf3dSphere(a, float4(offD, 0.01f)));\n    \n    return smoothstep(0.f, 1.f, dist);\n}\n\n\nfloat smin(float a, float b, float k)\n{\n    float h = max(k - abs(a - b), 0.f) / k;\n    return min(a, b) - h * h * h * k * (1.f / 6.f);\n}\n\nfloat segment(float3 _point, float4 A, float4 B)\n{\n    float3 ab = B.xyz - A.xyz;\n    float3 ap = _point - A.xyz;\n    float t = saturate(dot(ap, ab) / dot(ab, ab));\n    return length(ap - t * ab) - lerp(A.w, B.w, t);\n}\n\nfloat2 Dist3(float3 p)\n{\n    float time = CurrentTime;\n    float rad = 6.f;\n    float3 tunnel = p;\n    tunnel.z += time * 2.5f + 10.f;\n    tunnel.x -= cos(tunnel.z * 0.2f);\n    tunnel.y -= sin(tunnel.z * 0.5f);\n\n    float nos = simplexNoise(tunnel * 0.6f + simplexNoise(tunnel)) * 0.3f + 0.3f;\n    float2 d = float2(-sdf3dInfCylinder(tunnel, float4(0.f, 0.f, 0.f, rad), float3(0.f, 0.f, 1.f)) - nos, 0.f);\n    {\n        float3 hand = tunnel;\n        float hAta = atan2(hand.y, hand.x) + PI2;\n        float2 hHash = hash(vec2(floor((hAta * 12.f) / PI2)));\n        hand.z = fmod(hand.z + hHash.y + hHash.x, PI2);\n        float hTheta = fmod(hAta, PI2 / 12.f);\n        float hLen = length(hand.xy);\n        sincos(hTheta, hand.y, hand.x);\n        hand.xy *= hLen;\n\n        hand.x += sin(time * 2.5f + hHash.x * 32.125f) * 1.5f;\n        hand.y -= 1.f;\n        float handDist = segment(hand, float4(rad + 0.5f, 0.65f, PI2, 0.3f), float4(rad - 0.4f, 0.5f, PI2, 0.1f));\n        handDist = smin(handDist, sdf3dSphere(hand, float4(rad - 0.6f, 0.5f, PI2, 0.2f)), 0.8f);\n        float fingerEnd = PI2 - sin(time * 6.f - hand.y * hand.x * 0.5f + hHash.y * 34.123f) * 0.25f - 0.25f;\n        handDist = smin(handDist, segment(hand, float4(rad - 0.9f, 0.5f, PI2, 0.09f), float4(rad - 1.25f, 0.5f, fingerEnd, 0.07f)), 0.2f);\n        handDist = smin(handDist, segment(hand, float4(rad - 0.8f, 0.3f, PI2, 0.07f), float4(rad - 1.2f, 0.25f, fingerEnd, 0.07f)), 0.2f);\n        handDist = smin(handDist, segment(hand, float4(rad - 0.5f, 0.25f, PI2, 0.09f), float4(rad - 0.85f, 0.1f, fingerEnd, 0.075f)), 0.1f);\n        handDist = smin(handDist, segment(hand, float4(rad - 0.8f, 0.65f, PI2, 0.08f), float4(rad - 1.1f, 0.7f, fingerEnd, 0.06f)), 0.1f);\n        handDist = smin(handDist, segment(hand, float4(rad - 0.6f, 0.75f, PI2, 0.07f), float4(rad - 0.9f, 0.85f, fingerEnd, 0.045f)), 0.1f);\n        d.x = smin(d.x, handDist, 0.8f);\n    }\n    \n    {\n        float3 eye = tunnel;\n        float eAta = atan2(eye.y, eye.x) + PI2;\n        float2 eHash = hash(vec2(floor((eAta * 6.f) / PI2))) * 0.5f + 0.5f;\n        eye.z = fmod(eye.z + eHash.y + eHash.x, PI2);\n        float eTheta = fmod(eAta, PI2 / 6.f);\n        float eLen = length(eye.xy);\n        sincos(eTheta, eye.y, eye.x);\n        eye.xy *= eLen;\n        \n        float4 ball = float4(rad - max(1.f - eHash.x, 0.f), 1.5f, PI + eHash.y, eHash.x + 0.3f);\n        float4 pupil = float4(rad - max(1.f - eHash.x, 0.f) - 0.37f, 1.5f, PI + eHash.y, eHash.x);\n        float3 eyeDir = pupil.xyz - ball.xyz;\n        float eyeLen = length(eyeDir);\n        float eyeTime = fmod(time, 10.f);\n        eyeDir.y -= smoothstep(0.f, 0.2f, eyeTime) * (1.f - smoothstep(5.5f, 5.7f, eyeTime)) * 0.3f;\n        eyeDir.z -= smoothstep(3.f, 3.2f, eyeTime) * (1.f - smoothstep(8.5f, 8.7f, eyeTime)) * 0.4f;\n        eyeDir = normalize(eyeDir);\n        pupil.xyz = ball.xyz + eyeDir * eyeLen;\n        \n        float eyeDist = sdf3dSphere(eye, ball);\n        eyeDist = smin(eyeDist, sdf3dSphere(eye, pupil), 0.01f);\n        d.x = smin(d.x, eyeDist, 0.4f);\n    }\n  \n    return d * 0.3f;\n}\n\nfloat3 Dist3Color(float3 p, float3 rayOrigin, float3 rayDir)\n{\n    float time = CurrentTime;\n    float rad = 6.f;\n    float3 tunnel = p;\n    tunnel.z += time * 2.5f + 10.f;\n    tunnel.x -= cos(tunnel.z * 0.2f);\n    tunnel.y -= sin(tunnel.z * 0.5f);\n\n    float nos = simplexNoise(tunnel * 0.6f + simplexNoise(tunnel)) * 0.3f + 0.3f;\n    float2 d = float2(-sdf3dInfCylinder(tunnel, float4(0.f, 0.f, 0.f, rad), float3(0.f, 0.f, 1.f)) - nos, 0.f);    \n    \n    float3 hand = tunnel;\n    float hAta = atan2(hand.y, hand.x) + PI2;\n    float2 hHash = hash(vec2(floor((hAta * 12.f) / PI2)));\n    hand.z = fmod(hand.z + hHash.y + hHash.x, PI2);\n    float hTheta = fmod(hAta, PI2 / 12.f);\n    float hLen = length(hand.xy);\n    sincos(hTheta, hand.y, hand.x);\n    hand.xy *= hLen;\n\n    hand.x += sin(time * 2.5f + hHash.x * 32.125f) * 1.5f;\n    hand.y -= 1.f;\n    float handDist = segment(hand, float4(rad + 0.5f, 0.65f, PI2, 0.3f), float4(rad - 0.4f, 0.5f, PI2, 0.1f));\n    handDist = smin(handDist, sdf3dSphere(hand, float4(rad - 0.6f, 0.5f, PI2, 0.2f)), 0.8f);\n    float fingerEnd = PI2 - sin(time * 6.f - hand.y * hand.x * 0.5f + hHash.y * 34.123f) * 0.25f - 0.25f;\n    handDist = smin(handDist, segment(hand, float4(rad - 0.9f, 0.5f, PI2, 0.09f), float4(rad - 1.25f, 0.5f, fingerEnd, 0.07f)), 0.2f);\n    handDist = smin(handDist, segment(hand, float4(rad - 0.8f, 0.3f, PI2, 0.07f), float4(rad - 1.2f, 0.25f, fingerEnd, 0.07f)), 0.2f);\n    handDist = smin(handDist, segment(hand, float4(rad - 0.5f, 0.25f, PI2, 0.09f), float4(rad - 0.85f, 0.1f, fingerEnd, 0.075f)), 0.1f);\n    handDist = smin(handDist, segment(hand, float4(rad - 0.8f, 0.65f, PI2, 0.08f), float4(rad - 1.1f, 0.7f, fingerEnd, 0.06f)), 0.1f);\n    handDist = smin(handDist, segment(hand, float4(rad - 0.6f, 0.75f, PI2, 0.07f), float4(rad - 0.9f, 0.85f, fingerEnd, 0.045f)), 0.1f);\n    d = minX(d, float2(handDist, 1.f));\n    \n    \n    float3 eye = tunnel;\n    float eAta =atan2(eye.y, eye.x) + PI2;\n    float2 eHash = hash(vec2(floor((eAta * 6.f) / PI2))) * 0.5f + 0.5f;\n    eye.z = fmod(eye.z + eHash.y + eHash.x, PI2);\n    float eTheta = fmod(eAta, PI2 / 6.f);\n    float eLen = length(eye.xy);\n    sincos(eTheta, eye.y, eye.x);\n    eye.xy *= eLen;\n        \n    float4 ball = float4(rad - max(1.f - eHash.x, 0.f), 1.5f, PI + eHash.y, eHash.x + 0.3f);\n    float4 pupil = float4(rad - max(1.f - eHash.x, 0.f) - 0.37f, 1.5f, PI + eHash.y, eHash.x);\n    float3 eyeDir = pupil.xyz - ball.xyz;\n    float eyeLen = length(eyeDir);\n    float eyeTime = fmod(time, 10.f);\n    eyeDir.y -= smoothstep(0.f, 0.2f, eyeTime) * (1.f - smoothstep(5.5f, 5.7f, eyeTime)) * 0.3f;\n    eyeDir.z -= smoothstep(3.f, 3.2f, eyeTime) * (1.f - smoothstep(8.5f, 8.7f, eyeTime)) * 0.4f;\n    eyeDir = normalize(eyeDir);\n    pupil.xyz = ball.xyz + eyeDir * eyeLen;\n        \n    d = minX(d, float2(sdf3dSphere(eye, ball), 2.f));\n    d = minX(d, float2(sdf3dSphere(eye, pupil), 3.f));\n       \n    float3 normal;\n    GetNormal(p, Dist3, normal);\n    float3 toLight = rayOrigin - p;\n    float lightLen = length(toLight);\n    toLight /= lightLen;\n    float3 spotDir = normalize(rayOrigin - float3(cos(time * 0.6f) * 3.f, sin(time * 0.5f) * 2.f, 0.f));\n    float spotPow = pow(max(dot(toLight, spotDir), 0.f), 4.f);\n    float intensity = spotPow * max(dot(toLight, normal), 0.f) * (1.f - lightLen / 35.f);\n\n    float3 color = vec3(0.f);\n    \n    if (intensity > 0.f)\n    {\n        intensity = pow(intensity + 0.4f, 6.f);\n        float3 halfVec = (normalize(rayOrigin) + toLight) * 0.5f;\n        float roughReflect = max(dot(normal, halfVec), 0.f) * spotPow;\n        float fresnel = max(dot(-rayDir, normal), 0.f);\n        \n        if (d.y == 0.f)\n        {\n            color = float3(1.f, nos, 0.3f)*2.f;\n            color += roughReflect * float3(1.f, 0.8f, 0.8f);\n            color += roughReflect > 0.9f ? 1.f : 0.f;\n            color += pow(1.f - fresnel + 0.3f, 16.f) * (1.f - float3(1.f, 0.8f, 0.8f));\n        }\n        else if (d.y == 1.f)\n        {\n            color = lerp(float3(0.98431f, 0.80784f, 0.69412f) * pow(1.f - simplexVoronoi(hand * float3(5.f, 3.f, 1.f), 0.f), 4.f),\n                float3(1.f, nos, 0.3f), pow(hand.x * 0.15f, 4.f));\n        }\n        else if (d.y == 2.f)\n        {\n            float x = pow(eye.x * 0.18f, 8.f);\n            color = lerp(vec3(2.f), float3(2.f, nos , 0.2f), x);\n            color.r += simplexVoronoi(eye * float3(8.f, 8.f, 1.f), 0.f) > 0.55f ? 1.f : 0.f;\n            color += pow(1.f - fresnel + 0.35f, 16.f) * float3(1.f, nos + 0.3f, 0.6f);\n            color += roughReflect;\n        }\n        else if (d.y == 3.f)\n        {\n            float pd = max(dot(eyeDir, normalize(eye - pupil.xyz)), 0.f);\n            float pupilIntensity = 1.f - pow(pd, 16.f);\n            color = float3(nos, 0.2f, 1.5f) * pupilIntensity * (simplexVoronoi(eye * nos*6.f, 0.f) + 0.2f) * 2.f;\n            color += roughReflect * pupilIntensity * float3(nos+0.3f, 0.2f, 1.f);\n            color += roughReflect > 0.965f ? roughReflect : 0.f;\n            color.r += saturate(smoothstep(0.f, 0.4f, pupilIntensity) - pupilIntensity);\n            color *= pow(pd, 4.f);\n            color *= 2.f;\n        }\n        float shd = 1.f;\n        float distSum = 0.05f;\n        float3 ro = p + 0.15f * normal;\n        for (int i = 0; i < 10; i++)\n        {\n            float curr = Dist3(ro + toLight * distSum).x;\n            shd = min(6.f * curr / distSum, shd);\n            distSum += curr;\n        }\n        intensity *= max(shd, 0.4f);\n    }\n       \n    return color * intensity;\n}\n\nfloat2 spotShaftDist1(float3 p)\n{\n    float time = CurrentTime;\n\n    float3 B = float3(cos(time * 0.6f) * 3.f, sin(time * 0.5f) * 2.f, 0.f);\n    float3 A = float3(0.f, 0.f, -9.f); \n    \n    time = time * 2.5f + 10.f;\n    A.x -= cos(time * 0.2f);\n    A.y -= sin(time * 0.5f);\n    A.y -= 1.f;\n\n    float3 ab = B.xyz - A.xyz;\n    float3 ap = p - A.xyz;\n    float t = saturate(dot(ap, ab) / dot(ab, ab));\n    \n    return float2(length(ap - t * ab) + 0.06f, sqrt(1.f - t) * pow(max(dot(normalize(ab), normalize(ap)), 0.f), 32.f));\n}\n\nvoid spotShaft(inout float4 sum, float2 d)\n{\n    float4 col = vec4(0.f);\n    col = lerp(vec4(0.f), vec4(2.f), d.y);\n       \n    col.rgb *= col.a;\n    sum = sum + (1.f - sum.a) * col;\n}\n\nfloat4 Unknown(vec2 uv)\n{\n    float4 color = float4(0.f, 0.f, 0.f, 0.f);\n \n    float3 rayTarget = float3(0.f, 0.f, 0.f);\n    float3 rayOrigin = float3(0.f, 0.f, -9.f);\n    float time = CurrentTime;\n    time = time * 2.5f + 10.f;\n    rayOrigin.x -= cos(time * 0.2f);\n    rayOrigin.y -= sin(time * 0.5f);\n    float3 rayDir = normalize(float3(uv, 1.f));\n    rayDir = mul(rayDir, viewMatrix(normalize(rayTarget - rayOrigin)));\n    \n    float2 march;\n    RayMarching(rayOrigin, rayDir, Dist3, 60, march, 0);\n    float3 p = rayOrigin + rayDir * march.x;\n\n    color.rgb = Dist3Color(p, rayOrigin, rayDir);\n        \n    float4 shaft = vec4(0.f);\n    RayMarching(rayOrigin, rayDir, spotShaftDist1, 15, float2 d, spotShaft(shaft, curr));\n    color.rgb += shaft.rgb * float3(1.f, 0.75f, 0.85f) * 0.5f;\n    \n    color.a = 1.f;\n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 TexC = 2.f*(fragCoord.xy/iResolution.xy)-1.f;\n    TexC.x *= iResolution.x/iResolution.y;\n\n    fragColor = Unknown(TexC);\n}",
   "name": "Image",
   "description": "",
   "type": "image"
  }
 ]
}