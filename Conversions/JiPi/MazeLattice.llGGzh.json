{"Shader":{"ver":"0.1","info":{"id":"llGGzh","date":"1473945929","viewed":5408,"name":"Maze Lattice","username":"Shane","description":"Applying a geometric pattern and edging to Fizzer's infinite, maze-like lattice structure.","likes":125,"published":3,"flags":0,"usePreview":0,"tags":["3d","random","truchet","edge","bump","tech","maze","hexagonal"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"id":37,"channel":0}],"code":"\/*\n\n    Maze Lattice\n    ------------\n\n\tApplying a geometric pattern and edging to Fizzer's maze lattice. I'm not sure what he technically \n\tcalls it, but it has a lattice feel, and as he infers in his article, it's a 3D structure with \n\tmaze-like qualities. Either way, I particularly like it because it's cleverly constructed, interesting \n\tlooking, and very cheap to produce. Basically, it's one of those distance fields that gives you your \n\tmoney's worth. :)\n\n\tThe only interesting thing here is the distance field equation that contains the maze-like lattice. I've \n\tgiven a rough explanation behind its construction, but it's much better to read Fizzer's well explained \n\tarticle, which I've provided a link to below.\n\n\tThe geometric surfacing pattern is a 2D hexagonal Truchet design, which is applied to each of the flat \n    face sections in accordance to the surface normal orientation. It's a standard way to apply 2D patterns \n\tto a cuboid-based surface, and is contained in the \"texFaces\" function.\n\n\tI used an edging algorithm to obtain the edges, which involves extra distance function and bump calls. \n\tI've since thought of a better way to make that happen which will cut down on cost and complexity, so \n\tI'll apply that in due course.\n\n\tAnyway, I have a reflection\\refraction version, based on the same surface that I'll release later.\n\t\n\tDistance field based on the article accompanying the following:\n\tMaze Explorer - fizzer\n    https:\/\/www.shadertoy.com\/view\/XsdGzM\n\n\tAccompanying article is here:\n\tImplicit Maze-Like Patterns\n    http:\/\/amietia.com\/slashmaze.html\n\n\tTruchet shaders:\n\n    hexagonal truchet ( 352 ) - FabriceNeyret2\n    https:\/\/www.shadertoy.com\/view\/Xdt3D8\n \n    hexagonal tiling - mattz\n    https:\/\/www.shadertoy.com\/view\/4d2GzV\n    \n\n\n*\/\n\n\/\/ Maximum ray distance.\n#define FAR 40.\n\n\/\/ I love this distance field. So elegant, and I can thank Fizzer for coming up with it.\n\/\/ The idea is about as simple as it gets. Break space into octahedrons then use each\n\/\/ otahedral cell to obtain a unique ID. Use that ID to render a randomly oriented square \n\/\/ tube and you're done.\n\/\/\n\/\/ I've done a little trimming and shuffling, which probably confuses things slightly. \n\/\/ Either way, it's worth reading the following article for a much clearer explanation:\n\/\/\n\/\/ Implicit Maze-Like Patterns - Fizzer\n\/\/ http:\/\/amietia.com\/slashmaze.html\n\/\/\nfloat map(in vec3 p) {\n    \n    \n   \/\/ Cubes, for a simpler, more orderly scene.\n   \/\/p = abs(fract(p) - .5);    \n   \/\/return max(max(p.x, p.y), p.z) - .225;\n   \n   \/\/ Unique identifier for the cube, but needs to be converted to a unique ID\n   \/\/ for the nearest octahedron. The extra \".5\" is to save a couple of \n   \/\/ of calculations. See below.\n   vec3 ip = floor(p) + .5;\n    \n   p -= ip; \/\/ Break space into cubes. Equivalent to: fract(p) - .5.\n    \n   \/\/ Stepping trick used to identify faces in a cube. The center of the cube face also\n   \/\/ happens to be the center of the nearest octahedron, so that works out rather well. \n   \/\/ The result needs to be factored a little (see the hash line), but it basically  \n   \/\/ provides a unique octahedral ID. Fizzer provided a visual of this, which is easier \n   \/\/ to understand, and worth taking a look at.\n   vec3 q = abs(p); \n   q = step(q.yzx, q.xyz)*step(q.zxy, q.xyz)*sign(p); \/\/ Used for cube mapping also.\n   \n   \/\/ Put the ID into a hash function to produce a unique random number. Reusing \"q\" to\n   \/\/ save declaring a float. Don't know if it's faster, but it looks neater, I guess.\n   q.x = fract(sin(dot(ip + q*.5, vec3(111.67, 147.31, 27.53)))*43758.5453);\n    \n   \/\/ Use the random number to orient a square tube in one of three random axial\n   \/\/ directions... See Fizzer's article explanation. It's better. :) By the way, it's\n   \/\/ possible to rewrite this in \"step\" form, but I don't know if it's quicker, so I'll\n   \/\/ leave it as is for now.\n   p.xy = abs(q.x>.333 ? q.x>.666 ? p.xz : p.yz : p.xy);\n   return max(p.x, p.y) - .2;   \n\n}\n\n\/\/ Very basic raymarching equation. I thought I might need to use something more sophisticated,\n\/\/ but it turns out that this structure raymarches reasonably well. Not all surfaces do.\nfloat trace(vec3 ro, vec3 rd){\n\n    float t = 0.0;\n    for(int i=0; i< 72; i++){\n        float d = map(ro + rd*t);\n        if (abs(d) < 0.002*(t*.125 + 1.) || t>FAR) break;\n        t += d;\n    } \n    return min(t, FAR);\n}\n\n\/\/ The reflections are pretty subtle, so not much effort is being put into them. Only a few iterations.\nfloat refTrace(vec3 ro, vec3 rd){\n\n    float t = 0.0;\n    for(int i=0; i< 16; i++){\n        float d = map(ro + rd*t);\n        if (abs(d) < 0.005*(t*.25 + 1.) || t>FAR) break;\n        t += d;\n    } \n    return t;\n}\n\n\/\/ The normal function with some edge detection rolled into it. Sometimes, it's possible to get away\n\/\/ with six taps, but we need a bit of epsilon value variance here, so there's an extra six.\nvec3 normal(in vec3 p, inout float edge) { \n\t\n    vec2 e = vec2(.034, 0); \/\/ Larger epsilon for greater sample spread, thus thicker edges.\n\n    \/\/ Take some distance function measurements from either side of the hit point on all three axes.\n\tfloat d1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\tfloat d3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\tfloat d5 = map(p + e.yyx), d6 = map(p - e.yyx);\n\tfloat d = map(p)*2.;\t\/\/ The hit point itself - Doubled to cut down on calculations. See below.\n     \n    \/\/ Edges - Take a geometry measurement from either side of the hit point. Average them, then see how\n    \/\/ much the value differs from the hit point itself. Do this for X, Y and Z directions. Here, the sum\n    \/\/ is used for the overall difference, but there are other ways. Note that it's mainly sharp surface \n    \/\/ curves that register a discernible difference.\n    edge = abs(d1 + d2 - d) + abs(d3 + d4 - d) + abs(d5 + d6 - d);\n    \/\/edge = max(max(abs(d1 + d2 - d), abs(d3 + d4 - d)), abs(d5 + d6 - d)); \/\/ Etc.\n    \n    \n    \/\/ Once you have an edge value, it needs to normalized, and smoothed if possible. How you \n    \/\/ do that is up to you. This is what I came up with for now, but I might tweak it later.\n    \/\/\n    edge = smoothstep(0., 1., sqrt(edge\/e.x*8.));\n    \n    \/\/ Curvature. All this, just to take out the inner edges.\n    float crv = (d1 + d2 + d3 + d4 + d5 + d6 - d*3.)\/e.x;;\n    \/\/crv = clamp(crv*32., 0., 1.);\n    if (crv<0.) edge = 0.; \/\/ Comment out to see what it does.\n\n\t\n    \/\/ Redoing the calculations for the normal with a more precise epsilon value. If you can roll the \n    \/\/ edge and normal into one, it saves a lot of map calls. Unfortunately, we want wide edges, so\n    \/\/ there are six more, making 12 map calls in all. Ouch! :)\n    e = vec2(.005, 0);\n\td1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\td3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\td5 = map(p + e.yyx), d6 = map(p - e.yyx); \n    \n    \/\/ Return the normal.\n    \/\/ Standard, normalized gradient mearsurement.\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n\n\/\/ Ambient occlusion, for that self shadowed look.\n\/\/ XT95 came up with this particular version. Very nice.\n\/\/\n\/\/ Hemispherical SDF AO - https:\/\/www.shadertoy.com\/view\/4sdGWN\n\/\/ Alien Cocoons - https:\/\/www.shadertoy.com\/view\/MsdGz2\nfloat calcAO( in vec3 p, in vec3 n )\n{\n    \n\tfloat ao = 0.0, l;\n\tconst float nbIte = 12.0;\n\tconst float falloff = 1.;\n    \n    const float maxDist = 1.;\n    for( float i=1.; i< nbIte+.5; i++ ){\n    \n        l = (i + fract(cos(i)*45758.5453))*.5\/nbIte*maxDist;\n        ao += (l - map( p + n*l ))\/ pow(1. + l, falloff);\n    }\n\t\n    return clamp( 1. - ao*2.\/nbIte, 0., 1.);\n}\n\n\n\/\/ Cheap shadows are hard. In fact, I'd almost say, shadowing repeat objects - in a setting like this - with limited \n\/\/ iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, float k){\n\n    \/\/ More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 16; \n    \n    vec3 rd = (lp-ro); \/\/ Unnormalized direction ray.\n\n    float shade = 1.0;\n    float dist = 0.05;    \n    float end = max(length(rd), 0.001);\n    float stepDist = end\/float(maxIterationsShad);\n    \n    rd \/= end;\n\n    \/\/ Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    \/\/ number to give a decent shadow is the best one to choose. \n    for (int i=0; i<maxIterationsShad; i++){\n\n        float h = map(ro + rd*dist);\n        \/\/shade = min(shade, k*h\/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k*h\/dist)); \/\/ Subtle difference. Thanks to IQ for this tidbit.\n        \/\/dist += min( h, stepDist ); \/\/ So many options here: dist += clamp( h, 0.0005, 0.2 ), etc.\n        dist += clamp(h, 0.02, 0.25);\n        \n        \/\/ Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0.001 || dist > end) break; \n    }\n\n    \/\/ I've added 0.5 to the final shade value, which lightens the shadow a bit. It's a preference thing.\n    return min(max(shade, 0.) + 0.3, 1.0); \n}\n\n\n\/\/ Simple hexagonal truchet patten. This is based on something Fabrice and Mattz did.\n\/\/\n\/\/ hexagonal truchet ( 352 ) - FabriceNeyret2\n\/\/ https:\/\/www.shadertoy.com\/view\/Xdt3D8\n\/\/\n\/\/ hexagonal tiling - mattz\n\/\/ https:\/\/www.shadertoy.com\/view\/4d2GzV\nfloat hexTruchet(in vec2 p) { \n    \n    p *= 6.;\n    \n\t\/\/ Hexagonal coordinates.\n    vec2 h = vec2(p.x + p.y*.577350269, p.y*1.154700538);\n    \n    \/\/ Closest hexagon center.\n    vec2 f = fract(h); h -= f;\n    float c = fract((h.x + h.y)\/3.);\n    h =  c<.666 ?   c<.333 ?  h  :  h + 1.  :  h  + step(f.yx, f); \n\n    p -= vec2(h.x - h.y*.5, h.y*.8660254);\n    \n    \/\/ Rotate (flip, in this case) random hexagons. Otherwise, you'd hava a bunch of circles only.\n    \/\/ Note that \"h\" is unique to each hexagon, so we can use it as the random ID.\n    c = fract(cos(dot(h, vec2(41.13, 289.57)))*43758.5453); \/\/ Reusing \"c.\"\n    p -= p*step(c, .5)*2.; \/\/ Equivalent to: if (c<.5) p *= -1.;\n    \n    \/\/ Minimum squared distance to neighbors. Taking the square root after comparing, for speed.\n    \/\/ Three partitions need to be checked due to the flipping process.\n    p -= vec2(-1, 0);\n    c = dot(p, p); \/\/ Reusing \"c\" again.\n    p -= vec2(1.5, .8660254);\n    c = min(c, dot(p, p));\n    p -= vec2(0, -1.73205);\n    c = min(c, dot(p, p));\n    \n    return sqrt(c);\n    \n    \/\/ Wrapping the values - or folding the values over (abs(c-.5)*2., cos(c*6.283*1.), etc) - to produce \n    \/\/ the nicely lined-up, wavy patterns. I\"m perfoming this step in the \"map\" function. It has to do \n    \/\/ with coloring and so forth.\n    \/\/c = sqrt(c);\n    \/\/c = cos(c*6.283*2.) + cos(c*6.283*4.);\n    \/\/return (clamp(c*.6+.5, 0., 1.));\n\n}\n\n\/\/ Bumping the faces.\nfloat bumpFunc(vec3 p, vec3 n){\n    \n    \/\/ Mapping the 3D object position to the 2D UV coordinate of one of three\n    \/\/ orientations, which are determined by the dominant normal axis.    \n    n = abs(n);\n    p.xy = n.x>.5? p.yz : n.y>.5? p.xz : p.xy; \n    \n    \/\/ Wavy, 70s looking, hexagonal Truchet pattern.\n    vec2 sc = (cos(hexTruchet(p.xy)*6.283*vec2(2, 4)));\n    return clamp(dot(sc, vec2(.6)) + .5, 0., 1.);\n\n}\n\n\/\/ Standard function-based bump mapping function.\nvec3 bumpMap(in vec3 p, in vec3 n, float bumpfactor){\n    \n    const vec2 e = vec2(0.002, 0);\n    float ref = bumpFunc(p, n);                 \n    vec3 grad = (vec3(bumpFunc(p - e.xyy, n),\n                      bumpFunc(p - e.yxy, n),\n                      bumpFunc(p - e.yyx, n) )-ref)\/e.x;                     \n          \n    grad -= n*dot(n, grad);          \n                      \n    return normalize( n + grad*bumpfactor );\n\t\n}\n\n\/\/ Bumping the edges with some block partitions. Made up on the spot. \nfloat bumpFunc2(vec3 p, vec3 n){\n    \n    \/\/ Partition space to produce some smooth blocks.\n    p = abs(fract(p*3.) - .5);\n    float c = max(max(p.x, p.y), p.z);\n    \n    return 1. - smoothstep(0., .025, c - .47);\n    \n}\n\n\/\/ A second function-based bump mapping function. Used for\n\/\/ the edging. Messy, but probably faster... probably. :)\nvec3 bumpMap2(in vec3 p, in vec3 n, float bumpfactor){\n    \n    const vec2 e = vec2(0.002, 0);\n    float ref = bumpFunc2(p, n);                 \n    vec3 grad = (vec3(bumpFunc2(p - e.xyy, n),\n                      bumpFunc2(p - e.yxy, n),\n                      bumpFunc2(p - e.yyx, n) )-ref)\/e.x;                     \n          \n    grad -= n*dot(n, grad);          \n                      \n    return normalize( n + grad*bumpfactor );\n\t\n}\n\n\/\/ Cheap and nasty 2D smooth noise function with inbuilt hash function - based on IQ's \n\/\/ original. Very trimmed down. In fact, I probably went a little overboard. I think it \n\/\/ might also degrade with large time values. I'll swap it for something more robust later.\nfloat n2D(vec2 p) {\n\n\tvec2 i = floor(p); p -= i; p *= p*(3. - p*2.);  \n    \n\treturn dot(mat2(fract(sin(vec4(0, 41, 289, 330) + dot(i, vec2(41, 289)))*43758.5453))*\n                vec2(1. - p.y, p.y), vec2(1. - p.x, p.x) );\n\n}\n\n\/\/ Texturing the sides with a 70s looking hexagonal Truchet pattern.\nvec3 texFaces(in vec3 p, in vec3 n){\n    \n    \/\/ Use the normal to determine the face. Dominant \"n.z,\" then use the XY plane, etc.\n    n = abs(n);\n    p.xy = n.x>.5? p.yz : n.y>.5? p.xz : p.xy; \n\n    \/\/ Some fBm noise based bluish red coloring.\n    n = mix(vec3(.3, .1, .02), vec3(.35, .5, .65), n2D(p.xy*8.)*.66 + n2D(p.xy*16.)*.34);\n    n *= n2D(p.xy*512.)*1.2 + 1.4;\n    \n    \/\/n =  n*.3 + min(n.zyx*vec3(1.3, .6, .2)*.75, 1.)*.7;\n   \n    \/\/ Overlaying with the hexagonal Truchet pattern.\n    vec2 sc = (cos(hexTruchet(p.xy)*6.283*vec2(2, 4)));\n    n *= clamp(dot(sc, vec2(.6))+.5, 0., 1.)*.95 + .05;\n    \n    return min(n, 1.);\n\n}\n\n\/\/ Terxturing the edges with something subtle.\nvec3 texEdges(in vec3 p, in vec3 n){\n    \n    float bf = bumpFunc2(p, n); \/\/ Bump function.\n    \n    \/\/ 2D face selection.\n    n = abs(n);\n    p.xy = n.x>.5? p.yz : n.y>.5? p.xz : p.xy; \n\n    \/\/ Mixing color with some fBm noise.\n    n = mix(vec3(.3, .1, .02), vec3(.35, .5, .65), n2D(p.xy*8.)*.66 + n2D(p.xy*16.)*.34);\n    n *= n2D(p.xy*512.)*.85 + .15; \n    \n    \/\/ More coloring.\n    n = min((n + .35)*vec3(1.05, 1, .9), 1.);\n    \n    \/\/ Running the bump function over the top for some extra depth.\n    n *= bf*.75+.25;\n    \n    return n;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    \n    \/\/ Unit direction ray vector: Note the absence of a divide term. I came across\n    \/\/ this via a comment Shadertoy user \"coyote\" made. I'm pretty happy with this.\n    vec3 rd = vec3(2.*fragCoord - iResolution.xy, iResolution.y);\n    \n    \/\/ Barrel distortion;\n    rd = normalize(vec3(rd.xy, sqrt(max(rd.z*rd.z - dot(rd.xy, rd.xy)*.2, 0.))));\n    \n    \/\/ Rotating the ray with Fabrice's cost cuttting matrix. I'm still pretty happy with this also. :)\n    vec2 m = sin(vec2(1.57079632, 0) + iTime\/4.);\n    rd.xy = rd.xy*mat2(m.xy, -m.y, m.x);\n    rd.xz = rd.xz*mat2(m.xy, -m.y, m.x);\n    \n    \/\/ Ray origin: Sending it along the Z-axis.\n    vec3 ro = vec3(0, 0, iTime);\n    \/\/ Alternate: Set off in the YZ direction. Note the \".5.\" It's an old lattice trick.\n    \/\/vec3 ro = vec3(0, iTime\/2. + .5, iTime\/2.);\n    \n    vec3 lp = ro + vec3(.2, 1., .3); \/\/ Light, near the ray origin.\n    \n    \/\/ Set the initial scene color to black.\n    vec3 col = vec3(0);\n\n    \n    float t = trace(ro, rd); \/\/ Raymarch.\n    \n    \/\/ Normally, you'd only light up the scene if the distance is less than the outer boundary.\n    \/\/ However, in this case, since most rays hit, I'm clamping to the far distance, and doing\n    \/\/ the few extra calculations. The payoff (I hope) is not having a heap of nested code.\n    \/\/ Whether that results in more speed, or not, I couldn't really say, but I'd imagine you'd\n    \/\/ receive a slight gain... maybe. If the scene were more open, you wouldn't do this.\n    \/\/if(t<FAR){\n        \n        float edge;\n        vec3 sp = ro + rd*t; \/\/ Surface position.\n        vec3 sn = normal(sp, edge); \/\/ Surface normal.\n\n    \t\/\/ Saving a copy of the unbumped normal, since the texture routine require it.\n    \t\/\/ I found that out the hard way. :)\n        vec3 svn = sn;\n\t\t\n    \t\/\/ Bump mapping the faces and edges. The bump factor is reduced with distance\n    \t\/\/ to lessen artifacts.\n        if(edge<.001) sn = bumpMap(sp, sn, .01\/(1. + t*.25));\n        else sn = bumpMap2(sp, sn, .03\/(1. + t*.25));\n\n        vec3 ref = reflect(rd, sn); \/\/ Reflected ray.\n\n        vec3 oCol = texFaces(sp, svn); \/\/ Texture color at the surface point.\n        if(edge>.001) oCol = texEdges(sp, svn);\n\n\n        float sh = softShadow(sp, lp, 16.); \/\/ Soft shadows.\n        float ao = calcAO(sp, sn); \/\/ Self shadows. Not too much.\n\n        vec3 ld = lp - sp; \/\/ Light direction.\n        float lDist = max(length(ld), 0.001); \/\/ Light to surface distance.\n        ld \/= lDist; \/\/ Normalizing the light direction vector.\n\n        float diff = max(dot(ld, sn), 0.); \/\/ Diffuse component.\n        float spec = pow(max(dot(reflect(-ld, sn), -rd), 0.), 32.); \/\/ Specular.\n\n        float atten = 1.25\/(1.0 + lDist*0.1 + lDist*lDist*.05); \/\/ Attenuation.\n\n\n\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/ Cheap reflection: Not entirely accurate, but the reflections are pretty subtle, so not much \n        \/\/ effort is being put in.\n        \/\/\n        float rt = refTrace(sp + ref*0.1, ref); \/\/ Raymarch from \"sp\" in the reflected direction.\n        float rEdge;\n        vec3 rsp = sp + ref*rt; \/\/ Reflected surface hit point.\n        vec3 rsn = normal(rsp, rEdge); \/\/ Normal at the reflected surface.\n        \/\/rsn = bumpMap(rsp, rsn, .005); \/\/ We're skipping the reflection bump to save some calculations.\n\n        vec3 rCol = texFaces(rsp, rsn); \/\/ Texel at \"rsp.\"    \n        if(rEdge>.001)rCol = texEdges(rsp, rsn); \/\/ Reflection edges.\n\n        float rDiff = max(dot(rsn, normalize(lp-rsp)), 0.); \/\/ Diffuse light at \"rsp.\"\n        float rSpec = pow(max(dot(reflect(-normalize(lp-rsp), rsn), -ref), 0.), 8.); \/\/ Diffuse light at \"rsp.\"\n        float rlDist = length(lp - rsp);\n        \/\/ Reflected color. Not entirely accurate, but close enough. \n        rCol = (rCol*(rDiff*1. + vec3(.45, .4, .3)) + vec3(1., .6, .2)*rSpec*2.);\n        rCol *= 1.25\/(1.0 + rlDist*0.1 + rlDist*rlDist*.05);    \n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\n        \/\/ Combining the elements above to light and color the scene.\n        col = oCol*(diff*1. + vec3(.45, .4, .3)) + vec3(1., .6, .2)*spec*2.;\n\n\n        \/\/ Adding the reflection to the edges and faces. Technically, there should be less on the faces,\n        \/\/ but after all that trouble, I thought I'd bump it up a bit. :)\n        if(edge<.001) col += rCol*.2;\n        else col += rCol*.35;\n        \/\/ Alternate way to mix in the reflection. Sometimes, it's preferable, but not here.\n        \/\/if(edge<.001) col = mix(col, rCol, .35)*1.4;\n        \/\/else col = mix(col, rCol, .5)*1.4;\n\n\n        \/\/ Shading the scene color and clamping. By the way, we're letting the color go beyond the maximum to\n        \/\/ let the structure subtly glow a bit... Not really natural, but it looks a little shinier.\n        col = min(col*atten*sh*ao, 1.);\n    \n    \/\/}\n    \n    \/\/ Mixing in some hazy bluish orange background.\n    vec3 bg = mix(vec3(.5, .7, 1).zyx, vec3(1, .7, .3).zyx, -rd.y*.35 + .35);\n    col = mix(col, bg, smoothstep(0., FAR-25., t));\/\/min(bg.zyx*vec3(1.3, .6, .2)*1.5, 1.)\n    \n    \/\/ Postprocesing - A subtle vignette with a bit of warm coloring... I wanted to warm the atmosphere up\n    \/\/ a bit. Uncomment it, if you want to see the bluer -possibly more natural looking - unprocessed version.\n    vec2 uv = fragCoord\/iResolution.xy;\n    float vig = pow(16.*uv.x*uv.y*(1.-uv.x)*(1.-uv.y), 0.125);\n    col *= vec3(1.2, 1.1, .85)*vig;\n\n    \/\/ Rough gamma correction.\n\tfragColor = vec4(sqrt(clamp(col, 0., 1.)), 1.0);\n    \n}","name":"Image","description":"","type":"image"}]}}