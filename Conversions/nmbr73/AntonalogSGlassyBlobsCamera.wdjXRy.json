{"Shader":{"ver":"0.1","info":{"id":"wdjXRy","date":"1554272638","viewed":461,"name":"Antonalog's Glassy Blobs &camera","username":"MacSlow","description":"Antonalog's original is here https:\/\/www.shadertoy.com\/view\/lslGRS. I added an arc-ball like camera movement... love those bubbly glass metaballs and wanted to move around them. Use the mouse to orbit around the 'flubber' :)","likes":10,"published":3,"flags":0,"usePreview":0,"tags":["3d","metaballs","camera","glass"],"hasliked":0},"renderpass":[{"inputs":[{"id":24,"src":"\/media\/a\/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","ctype":"cubemap","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":37,"channel":0}],"code":"\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\n\/\/ \"Antonalog's Glassy Blobs with camera\" - I took Antonalog's Glassy Blobs\n\/\/ shader (https:\/\/www.shadertoy.com\/view\/lslGRS) and added trackball- or\n\/\/ arcball-like camera control to it.\n\/\/\n\/\/ Copyright 2019 Mirco M\u00fcller\n\/\/\n\/\/ Author(s):\n\/\/   Mirco \"MacSlow\" M\u00fcller <macslow@gmail.com>\n\/\/\n\/\/ This program is free software: you can redistribute it and\/or modify it\n\/\/ under the terms of the GNU General Public License version 3, as published\n\/\/ by the Free Software Foundation.\n\/\/\n\/\/ This program is distributed in the hope that it will be useful, but\n\/\/ WITHOUT ANY WARRANTY; without even the implied warranties of\n\/\/ MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n\/\/ PURPOSE.  See the GNU General Public License for more details.\n\/\/\n\/\/ You should have received a copy of the GNU General Public License along\n\/\/ with this program.  If not, see <http:\/\/www.gnu.org\/licenses\/>.\n\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n#define DO_BLOBS(DO) vec4 b; b=vec4(-0.38 + 0.25*sin(iTime+0.00), -0.60 + 0.25*cos(iTime+0.00), -0.67, 0.17); DO; b=vec4(-0.33 + 0.25*sin(iTime+1.00), -0.59 + 0.25*cos(iTime+1.00), 0.02, 0.19); DO; b=vec4(-0.33 + 0.25*sin(iTime+2.00), -0.42 + 0.25*cos(iTime+2.00), 0.48, 0.12); DO; b=vec4(-0.50 + 0.25*sin(iTime+3.00), -0.18 + 0.25*cos(iTime+3.00), -0.30, 0.15); DO; b=vec4(-0.57 + 0.25*sin(iTime+4.00), 0.09 + 0.25*cos(iTime+4.00), 0.14, 0.16); DO; b=vec4(-0.58 + 0.25*sin(iTime+5.00), -0.13 + 0.25*cos(iTime+5.00), 0.58, 0.12); DO; b=vec4(-0.48 + 0.25*sin(iTime+6.00), 0.67 + 0.25*cos(iTime+6.00), -0.66, 0.13); DO; b=vec4(-0.37 + 0.25*sin(iTime+7.00), 0.43 + 0.25*cos(iTime+7.00), -0.16, 0.18); DO; b=vec4(-0.49 + 0.25*sin(iTime+8.00), 0.41 + 0.25*cos(iTime+8.00), 0.62, 0.16); DO; b=vec4(0.19 + 0.25*sin(iTime+9.00), -0.64 + 0.25*cos(iTime+9.00), -0.47, 0.18); DO; b=vec4(0.19 + 0.25*sin(iTime+10.00), -0.43 + 0.25*cos(iTime+10.00), -0.04, 0.13); DO; b=vec4(-0.01 + 0.25*sin(iTime+11.00), -0.40 + 0.25*cos(iTime+11.00), 0.39, 0.11); DO; b=vec4(-0.12 + 0.25*sin(iTime+12.00), -0.06 + 0.25*cos(iTime+12.00), -0.70, 0.12); DO; b=vec4(0.08 + 0.25*sin(iTime+13.00), 0.18 + 0.25*cos(iTime+13.00), 0.07, 0.15); DO; b=vec4(-0.15 + 0.25*sin(iTime+14.00), -0.12 + 0.25*cos(iTime+14.00), 0.51, 0.19); DO; b=vec4(0.09 + 0.25*sin(iTime+15.00), 0.57 + 0.25*cos(iTime+15.00), -0.48, 0.10); DO; b=vec4(0.12 + 0.25*sin(iTime+16.00), 0.64 + 0.25*cos(iTime+16.00), 0.19, 0.14); DO; b=vec4(-0.11 + 0.25*sin(iTime+17.00), 0.67 + 0.25*cos(iTime+17.00), 0.42, 0.20); DO; b=vec4(0.55 + 0.25*sin(iTime+18.00), -0.69 + 0.25*cos(iTime+18.00), -0.35, 0.18); DO; b=vec4(0.33 + 0.25*sin(iTime+19.00), -0.49 + 0.25*cos(iTime+19.00), -0.03, 0.17); DO; b=vec4(0.35 + 0.25*sin(iTime+20.00), -0.66 + 0.25*cos(iTime+20.00), 0.55, 0.15); DO; b=vec4(0.51 + 0.25*sin(iTime+21.00), -0.12 + 0.25*cos(iTime+21.00), -0.66, 0.14); DO; b=vec4(0.48 + 0.25*sin(iTime+22.00), -0.08 + 0.25*cos(iTime+22.00), -0.12, 0.11); DO; b=vec4(0.50 + 0.25*sin(iTime+23.00), 0.15 + 0.25*cos(iTime+23.00), 0.60, 0.16); DO; b=vec4(0.59 + 0.25*sin(iTime+24.00), 0.43 + 0.25*cos(iTime+24.00), -0.52, 0.11); DO; b=vec4(0.50 + 0.25*sin(iTime+25.00), 0.66 + 0.25*cos(iTime+25.00), 0.15, 0.18); DO; b=vec4(0.35 + 0.25*sin(iTime+26.00), 0.44 + 0.25*cos(iTime+26.00), 0.37, 0.14); DO; \n\nvec2 Q(float a, float b, float c)\n{\n\tfloat d = b*b-4.0*a*c;\n\tif (d < 0.0) return vec2(1e10,-1e10);\n\td=sqrt(d);\t\n\tfloat oo2a = 0.5\/a;\n\tfloat n = (-b-d)*oo2a;\n\tfloat x = (-b+d)*oo2a;\n\/\/\treturn vec2( min(n,x), max(n,x) );\n\treturn vec2( n,x );\n}\n\nvec2 SphereT(vec3 P, vec3 V, vec3 A, float R)\n{\n\treturn Q(dot(V,V),2.0*(dot(P,V)-(dot(A,V))),dot(A,A)+dot(P,P)-R*R-(2.0*(dot(A,P))));\n}\n\nvec2 NearestBlobBound(vec3 P, vec3 V, float r)\n{\n\tvec2 t = vec2(1e10,-1e10);\n\tvec2 s;\n\tDO_BLOBS( s=SphereT(P,V,b.xyz,r*b.w); t.x=min(t.x,s.x); t.y=max(t.y,s.y) )\n\treturn t;\n}\n\nfloat k = 10.0;\n\nfloat sdf(vec3 x)\n{\n\t\/\/http:\/\/www.johndcook.com\/blog\/2010\/01\/13\/soft-maximum\/\n\tfloat sum = 0.0;\n\tDO_BLOBS( sum += exp( k*(b.w - length(x-b.xyz)) ) )\n\treturn log( sum ) \/ k;\t\n}\n\nvec3 BlobNor(vec3 x)\n{\n\tvec3 sum=vec3(0.0,0.0,0.0);\n\n\tfloat w;\n\tvec3 n;\n\tfloat L;\n\tvec3 v;\n\tDO_BLOBS( v=x-b.xyz; L=length(v); n=v*(1.0\/L); w = exp(k*(b.w - L)); sum += w*n );\n\treturn normalize( sum );\t\n\t\n}\n\nvec3 ss_nor(vec3 X)\n{\n\treturn normalize(cross(dFdx(X),dFdy(X)));\n}\nvec3 ss_grad(vec3 X)\n{\n\treturn cross(dFdx(X),dFdy(X));\n}\n\nfloat shlick(vec3 N, vec3 V)\n{\n\tfloat f = dot(-V,N);\n\tf = 1.0-f;\t\n\tfloat ff = f;\n\tf *= f;\t\t\/\/2\n\/\/\tf *= f;\t\t\/\/4\n\/\/\tf *= ff;\t\/\/5\n\tfloat r0 = 0.075;\n\tf = r0 + (1.0-r0)*f;\n\treturn f;\n}\n\nvec3 Transmittance(vec3 color, float T)\n{\n\treturn -log(color)\/T;\n}\n\nvec3 Filter(float thick, vec3 trans)\n{\n\tfloat conc = 0.6;\n\treturn exp( -trans * conc * thick );\n}\n\n\/\/ --- addition-start by MacSlow ----------\nvec3 cam (vec2 uv, vec3 ro, vec3 aim, float zoom)\n{\n    vec3 f = normalize (aim - ro);\n    vec3 wu = vec3 (.0, 1., .0);\n    vec3 r = normalize (cross (wu, f));\n    vec3 u = normalize (cross (f, r));\n    vec3 c = ro + f*zoom;\n    return normalize (c + r*uv.x + u*uv.y - ro);\n}\n\/\/ --- addition-end by MacSlow ----------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 P, V;\n\n\t\/\/ --- addition-start by MacSlow ----------\n    float r = 2.5;\n    float azimuthAngle = ((iMouse.x \/ iResolution.x) * 2. - 1.) * 179.;\n    float elevationAngle = ((iMouse.y \/ iResolution.y) * 2. - 1.) * 79.;\n    float x = r*cos (radians (azimuthAngle));\n    float y = r*sin (radians (elevationAngle));\n    float z = r*sin (radians (azimuthAngle));\n    P = vec3(x, y, z);\n    vec3 aim = vec3 (.0);\n    vec2 uv = fragCoord.xy\/iResolution.xy;\n    vec2 uvRaw = uv;\n    uv = uv*2. - 1.;\n    uv.x *= iResolution.x\/iResolution.y;\n    V = cam (uv, P, aim, 1.75);\n\t\/\/ --- addition-end by MacSlow ----------\n\t\n\tfloat overb = 1.5;\n\t\n\tvec3 bg = texture(iChannel1,V).xyz * overb;\n\tvec3 bg_V = V;\n\tvec2 bound=NearestBlobBound(P, V, 2.0);\n\tfloat t = bound.x;\n\t\n\tvec3 trans=Transmittance(vec3(0.3,0.7,0.1), 1.0);\n\t\n\tif (t < 1e10)\n\t{\n\t\tint steps=0;\n\t\tfloat d = -1e10;\n\t\tfloat old_d = -1e10;\n\t\tvec3 X;\n\n\t\tfloat inside=0.0;\n\t\tfloat last_surface_t=0.0;\n\t\n\t\tfloat thick=0.0;\n\t\t#define STEPS\t64\n\t\tfloat t_step = (bound.y-bound.x)*(1.0\/float(STEPS));\n\t\t\n\t\tvec3 c = vec3(0.0,0.0,0.0);\n\t\t\n\t\tfloat last_f=0.0;\n\t\t\n\t\tvec3 filter_col = vec3(1.0);\n\t\t\n\t\tfloat blocked=0.0;\n\t\t\n\t\tfor (int i=0; i<STEPS; i++)\n\t\t{\t\t\t\n\t\t\tX = P+V*t;\n\t\t\td = sdf(X);\n\t\t\n\t\t\tif (d * old_d < 0.0)\t\/\/a crossing\n\t\t\t{\n\t\t\t\tinside = 1.0 - inside;\n\t\t\t\tfloat int_t = mix(t-t_step,t,abs(old_d)\/(abs(d)+abs(old_d)));\n\t\t\t\t\t\t\t\t\/\/t-d; \n\t\t\t\t\t\t\t\/\/0.5*(t-t_step-old_d + t-d);\t\n\t\t\t\n\t\t\t\tvec3 int_X = P+V*int_t;\n\t\t\t\tvec3 N = BlobNor(int_X);\t\t\t\t\n\t\n\t\t\t\tif (inside < 0.5)\t\/\/just came out\n\t\t\t\t{\n\t\t\t\t\tfloat this_thick = (int_t - last_surface_t);\n\t\t\t\t\tfilter_col *= Filter(this_thick,trans) * (1.0-last_f);\n\t\t\t\t\t\n\t\t\t\t\tthick += this_thick;\n\t\t\t\t\t\n\t\t\t\t\/\/\tV = bg_V = normalize( refract(bg_V,N,0.995) );\n\t\t\t\t}\n\t\t\t\telse\t\/\/just went in\n\t\t\t\t{\t\t\n\t\t\t\t\tfloat f = shlick(N,V);\n\t\t\t\t\tlast_f = f;\n\t\t\t\t\t\n\t\t\t\t\tvec3 refV = reflect(V,N);\n\t\t\t\t\tvec3 ref = f*texture(iChannel1,refV).xyz; \n\t\t\t\t\t\n\t\t\t\t\tvec2 blocker=NearestBlobBound(int_X, refV, 1.0);\n\t\t\t\t\tif (blocker.x > 0.01 && blocker.x < 1e5) \n\t\t\t\t\t{\n\t\t\t\t\t\tblocked = blocker.y-blocker.x;\n\t\t\t\t\t\tref *= blocked;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tc += ref * filter_col;\n\n\t\t\t\t\tV = bg_V = normalize( refract(bg_V,N,0.995) );\n\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tlast_surface_t = int_t;\n\t\t\t}\t\t\t\n\t\t\t\t\t\t\n\t\t\t\/\/stop if grad is pointing away from view ray...\n\t\t\t\/\/saves steps but introduces some nasty artifacts on some cards\n\t\/*\t\tvec3 G=-ss_grad(X);\n\t\t\tif (dot(G,V) < 0.0) \n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}*\/\n\t\t\t\n\t\t\n\t\t\/\/\tt -= d;\t\t\n\t\t\tt += t_step;\n\t\t\t\n\t\t\told_d = d;\n\t\t\t\n\t\t\tsteps++;\n\t\t}\n\t\t\t\t\n\/\/\t\tfloat S = float(steps)\/64.0; \/\/\/8.0;\n\t\/\/\tfragColor = vec4(S,S,S,1.0);\n\t\t\t\t\n\t\/\/\tfragColor = vec4(vec3(thick),1.0);\n\t\t\n\t\/\/\tc += Filter(thick,trans)*bg;\n\t\tvec3 ref_bg = texture(iChannel1,bg_V).xyz  * overb;\n\t\tc += filter_col * ref_bg;\n\t\/\/\tc += (1.0-thick)*bg;\n\n\t\tfragColor = vec4(c,1.0);\n\t\t\n\t\/\/\tfragColor = vec4(vec3(last_f),1.0);\n\t\/\/\tfragColor = vec4(vec3(blocked),1.0);\n\t}\n\telse\n\t{\n\t\tfragColor = vec4(bg,1.0);\n\t}\n\n\t\/\/ --- addition-start by MacSlow ----------\n    fragColor.rgb *= 1. - .7*length (uvRaw*2. - 1.);\n    fragColor = pow (fragColor, vec4 (1.\/2.2));\n    \/\/ --- addition-end by MacSlow ----------\n\n}\n","name":"Image","description":"","type":"image"}]}}