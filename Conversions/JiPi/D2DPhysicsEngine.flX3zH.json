{"Shader":{"ver":"0.1","info":{"id":"flX3zH","date":"1621584833","viewed":307,"name":"2D physics engine","username":"mdb","description":"simple 2D physics engine with circles\n\ncould be upgrade with some kind of k-tree to check collisions faster","likes":6,"published":3,"flags":32,"usePreview":0,"tags":["physicsengine"],"hasliked":0},"renderpass":[{"inputs":[{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":37,"channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord\/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x\/iResolution.y;\n    uv += 0.5;\n\n    vec3 col = vec3(0.1);\n    \n    col = vec3(0.1);\n    float touch = 0.0;;\n    vec3 col2 = vec3(0.0, 0.0, 0.5);\n    for(int i = 0; i < entity; i++){\n        vec4 ball = getData(i, iChannel0);\n        if (ballRadius*ballRadius*1.8 > dot(uv - ball.xy, uv - ball.xy)) {\n            touch += 1.0;\n            col2.xy = mix(col2.xy, normalize(ball.zw)*0.5 + 0.5, 1.0\/touch);\n        }\n    }\n    if(touch != 0.0){\n        col = col2;\n    }\n    \n\n\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":257,"channel":0}],"code":"#define highp float\n\n\/\/ from https:\/\/gamedevelopment.tutsplus.com\/tutorials\/how-to-create-a-custom-2d-physics-engine-the-basics-and-impulse-resolution--gamedev-6331\nstruct Circle\n{\n  vec2 position;\n  vec2 velocity;\n};\n\nbool intersect(Circle A, Circle B){\n    return dot(A.position - B.position, A.position - B.position) <= 4.0*ballRadius*ballRadius;\n}\n\nvoid ResolveCollision(inout Circle A, Circle B, vec2 normal, bool wall)\n{\n  \/\/ Calculate relative velocity\n  vec2 rv = B.velocity - A.velocity;\n \n  \/\/ Calculate relative velocity in terms of the normal direction\n  float velAlongNormal = dot(rv, normal);\n \n  \/\/ Do not resolve if velocities are separating\n  if(velAlongNormal > 0.0)\n    return;\n \n  \/\/ Calculate impulse scalar\n  float j = - 0.5 * (1.0 +  restitution) * velAlongNormal;\n  \n  if(wall) j *= 2.0;\n  \n  \/\/ Apply impulse\n  A.velocity -= j * normal;\n  return;\n}\n\nvoid PositionalCorrection(inout Circle A, Circle B, vec2 normal, float penetrationDepth, bool wall)\n{\n  const float percent = 0.1;\n  vec2 correction = 0.5 * penetrationDepth * percent * normal;\n  if(wall) correction *= 2.0;\n  \n  A.position -= correction;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int idx = int(fragCoord.x) + int(fragCoord.y)*int(texDimX);\n    if( idx >= entity || fragCoord.x >= float(texDimX)){\n        fragColor = vec4(0.0);\n        return;\n    }\n    if( iFrame < 6 ){\n        float y;\n        float x = 0.1 + modf(float(idx)*0.03, y)*0.8;\n        fragColor = vec4(x, 0.2 + y*0.025, 0.0, -0.9);\n        return;    \n    }\n    vec4 a = getData(idx, iChannel0);\n    Circle A = Circle(a.xy, a.zw);\n    \n    for(int i = 0; i < entity; i++){\n        if(i != idx){\n            vec4 raw = getData(i, iChannel0);\n            Circle B = Circle(raw.xy, raw.zw);\n            if(intersect(A, B)){\n                vec2 normal = normalize(B.position - A.position);\n                ResolveCollision(A, B, normal, false);\n                \n                float depth = distance(A.position, B.position) - 2.0 * ballRadius;\n                PositionalCorrection(A, B, -normal, depth, false);\n                \n            }\n        }\n    }\n    \n    \/\/collition with walls\n    Circle Bfake =  Circle(vec2(0.0), vec2(0.0));\n    \n    if(A.position.x + ballRadius >= 1.0){\n        ResolveCollision(A, Bfake, vec2(1.0, 0.0), true);\n        float depth = A.position.x + ballRadius - 1.0;\n        PositionalCorrection(A, Bfake, vec2(1.0, 0.0), depth, true);\n    }\n    if(A.position.x - ballRadius <= 0.0){\n        ResolveCollision(A, Bfake, vec2(-1.0, 0.0), true);\n        float depth = -(A.position.x - ballRadius);\n        PositionalCorrection(A, Bfake, vec2(-1.0, 0.0), depth, true);\n    }\n        \n    if(A.position.y + ballRadius >= 1.0){\n        ResolveCollision(A, Bfake, vec2(0.0, 1.0), true);\n        float depth = A.position.y + ballRadius - 1.0;\n        PositionalCorrection(A, Bfake, vec2(0.0, 1.0), depth, true);\n    }\n    if(A.position.y - ballRadius <= 0.0){\n        ResolveCollision(A, Bfake, vec2(0.0, -1.0), true);\n        float depth = -(A.position.y - ballRadius);\n        PositionalCorrection(A, Bfake, vec2(0.0, -1.0), depth, true);\n    }\n    \n    \n    \n    float dt = min(iTimeDelta, maxdt);\n    A.velocity += vec2(0.0, -gravity) * dt;\n    A.position += A.velocity * dt;\n    \n    if(mod(float(iFrame), 700.0)<=0.01)A.velocity = vec2(-(A.position.x - 0.5)*2.0, 3.0);\n    \n    \n    fragColor = vec4(A.position, A.velocity);\n}\n\n\n\n\n\n\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define entity 1632\n#define maxdt 0.002\n#define gravity 9.81\n\n#define ballRadius 0.01\n#define ballMass 0.8\n#define restitution 0.7\nconst float invMass = 1.0\/ballMass;\n\n#define texDimX 420\nvec4 getData(int i, sampler2D tex){\n    ivec2 coord = ivec2(i % texDimX, i \/ texDimX);\n    return texelFetch(tex, coord, 0);\n}\n","name":"Common","description":"","type":"common"}]}}