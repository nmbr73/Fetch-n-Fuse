{"Shader":{"ver":"0.1","info":{"id":"ftlcDr","date":"1647843878","viewed":32,"name":"Finite Element Calculus","username":"microwerx","description":"Click on the image to change the operator performed (from left: 1st: vector field (RGB), 2nd: scalar field, 3rd: Gradient, 4th: Divergence, 5th: Laplacian, 6th: Laplacian Sign, 7th: Curl, 8th: Curl Length, 9th: Curl Vorticity).","likes":0,"published":3,"flags":2,"usePreview":0,"tags":["gradient","curl","nyancat","laplacian","laplace","divergence","vorticity"],"hasliked":0},"renderpass":[{"inputs":[{"id":11,"src":"\/media\/a\/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","ctype":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":14,"src":"\/media\/a\/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","ctype":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":31,"src":"\/presets\/webcam.png","ctype":"webcam","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":37,"channel":0}],"code":"const float dx = 1.0;\nconst float dy = 1.0;\nconst float dz = 1.0;\nconst vec2 PosX = vec2( 1.0,  0.0); \/\/  1,  0,  0\nconst vec2 NegX = vec2(-1.0,  0.0); \/\/ -1,  0,  0\nconst vec2 PosY = vec2( 0.0,  1.0); \/\/  0,  1,  0\nconst vec2 NegY = vec2( 0.0, -1.0); \/\/  0, -1,  0\nconst vec2 PosZ = vec2( 0.0,  0.0); \/\/  0,  0,  1\nconst vec2 NegZ = vec2( 0.0,  0.0); \/\/  0,  0, -1\nconst vec2 Zero = vec2( 0.0,  0.0); \/\/  0,  0,  0\nconst int ALL_FIELDS = 0;\nconst int VECTOR_FIELD = 1;               \/\/ Original RGB.\nconst int SCALAR_FIELD = 2;               \/\/ Average of RGB.\nconst int GRADIENT_OF_SCALAR_FIELD = 3;   \/\/ Produces a vector field.\nconst int DIVERGENCE_OF_VECTOR_FIELD = 4; \/\/ Produces a scalar field.\nconst int LAPLACIAN_OF_SCALAR_FIELD = 5;  \/\/ Produces a scalar field.\nconst int LAPLACIAN_OF_SCALAR_FIELD_SIGN = 6; \/\/ Colors the Laplacian.\nconst int CURL_OF_VECTOR_FIELD = 7;           \/\/ Produces a vector field.\nconst int CURL_OF_VECTOR_FIELD_LENGTH = 8;    \/\/ Produces a scalar field.\nconst int CURL_OF_VECTOR_FIELD_VORTICITY = 9;      \/\/ Colors the Curl.\nconst float NUM_CHOICES = 10.0;\n\n\/\/ Pick a combo of the following.\nconst bool USE_WEBCAM = false;\nconst bool USE_NYANCAT = true;\nconst bool USE_VIDEO = true;\nconst bool USE_BUFFER_A = false;\n\nvec3 v(vec2 ij, vec2 offset) {\n    vec2 uv = (ij + offset) \/ iResolution.xy;\n    vec3 col = vec3(0.0);\n    float count = 0.0;\n\n    if (USE_VIDEO) {\n        col += texture(iChannel0, uv).rgb;\n        count++;\n    }\n        \n    if (USE_WEBCAM) {\n        col += texture(iChannel1, uv).rgb;\n        count++;\n    }\n        \n    if (USE_NYANCAT) {\n        vec2 uv2 = vec2(-0.15 + uv.x + 0.4 * sin(iTime), uv.y + 0.1 * cos(iTime));\n        \/\/ Add the nyan cat sprite: https:\/\/www.shadertoy.com\/view\/lsX3Rr\n        vec2 uvNyan = (uv2  - vec2(0.25, 0.15)) \/ (vec2(0.7,0.5) - vec2(0.5, 0.15));\n        uvNyan = clamp(uvNyan, 0.0, 1.0);\n        float ofx = floor(mod(iTime*15.0, 6.0));\n        float ww = 40.0\/256.0;\n        uvNyan = vec2(clamp(uvNyan.x*ww + ofx*ww, 0.0, 1.0 ), uvNyan.y);\n        vec4 texel = texture(iChannel2, uvNyan);\n        if (texel.a > 0.5) {\n            col = texel.rgb;\n            count = 1.0;\n        }\n    }\n    \n    if (USE_BUFFER_A) {\n        col += texture(iChannel3, uv).rgb;\n        count++;\n    }\n        \n    return col\/count;\n}\n\nfloat f(vec2 ij, vec2 offset) {\n    vec3 col = v(ij, offset);\n    return (col.x + col.y + col.z) \/ 3.0;\n}\n\nvec3 gradient(vec2 ij) {\n    float dfdx = 0.5 \/ dx * (f(ij, PosX) - f(ij, NegX));\n    float dfdy = 0.5 \/ dy * (f(ij, PosY) - f(ij, NegY));\n    float dfdz = 0.5 \/ dz * (f(ij, PosZ) - f(ij, NegZ));\n    return vec3(dfdx, dfdy, dfdz);\n}\n\nfloat divergence(vec2 ij) {\n    float dfdx = 0.5 \/ dx * (f(ij, PosX) - f(ij, NegX));\n    float dfdy = 0.5 \/ dy * (f(ij, PosY) - f(ij, NegY));\n    float dfdz = 0.5 \/ dz * (f(ij, PosZ) - f(ij, NegZ));\n    return dfdx + dfdy + dfdz;\n}\n\nvec3 curl(vec2 ij) {\n    float dvzdy = 0.5 \/ dy * (v(ij, PosY).z - v(ij, NegY).z);\n    float dvydz = 0.5 \/ dz * (v(ij, PosZ).y - v(ij, NegZ).y);\n    float dvxdz = 0.5 \/ dz * (v(ij, PosZ).x - v(ij, NegZ).x);\n    float dvzdx = 0.5 \/ dx * (v(ij, PosX).z - v(ij, NegX).z);\n    float dvydx = 0.5 \/ dy * (v(ij, PosX).y - v(ij, NegX).y);\n    float dvxdy = 0.5 \/ dx * (v(ij, PosY).x - v(ij, NegY).x);\n    return vec3(dvzdy - dvydz, dvxdz - dvzdx, dvydx - dvxdy);\n}\n\nfloat laplacian(vec2 ij) {\n    return ( f(ij, PosX) + f(ij, NegX)\n           + f(ij, PosY) + f(ij, NegY)\n           + f(ij, PosZ) + f(ij, NegZ)\n           - 6.0 * f(ij, Zero)\n           ) \/ (dx * dy);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord\/iResolution.xy;\n    \n    int choice = int(iMouse.x * NUM_CHOICES \/ iResolution.x);\n    if (choice == 0)\n        choice = int(fragCoord.x * (NUM_CHOICES-1.0) \/ iResolution.x) + 1;\n    \n    float intensity = 1.0;\n    vec3 col;\n    if (choice == VECTOR_FIELD) {\n        col = v(fragCoord, vec2(0, 0));\n    } else if (choice == SCALAR_FIELD) {\n        col = vec3(f(fragCoord, vec2(0, 0)));\n    } else if (choice == GRADIENT_OF_SCALAR_FIELD) {\n        vec3 G = gradient(fragCoord);        \n        col = G;\n        \/\/ Boost the intensity.\n        intensity = 6.0;\n    } else if (choice == DIVERGENCE_OF_VECTOR_FIELD) {\n        col = vec3(divergence(fragCoord));\n        \/\/ Boost the intensity\n        intensity = 6.0;\n    } else if (choice == LAPLACIAN_OF_SCALAR_FIELD) {\n        col = vec3(laplacian(fragCoord));\n        \n        \/\/ Boost the intensity\n        intensity = 12.0;\n    } else if (choice == LAPLACIAN_OF_SCALAR_FIELD_SIGN) {\n        float L = laplacian(fragCoord);\n        \n        \/\/ Differentiate between negative, positive, and zero\n        \/\/ Red is less than zero, Green is greater than zero, Blue is none.\n        if (L < 0.0)\n            col = vec3(-L, 0.0, 0.0);\n        else if (L > 0.0)\n            col = vec3(0.0, L, 0.0);\n        else\n            col = vec3(0.0, 0.0, 0.0);\n        \n        \/\/ Boost the intensity\n        intensity = 12.0;\n    } else if (choice == CURL_OF_VECTOR_FIELD) {\n        col = curl(fragCoord);\n\n        \/\/ Boost the intensity\n        intensity = 12.0;\n    } else if (choice == CURL_OF_VECTOR_FIELD_LENGTH) {\n        float C = length(curl(fragCoord));\n        col = vec3(C);\n        \n        \/\/ Don't boost the intensity.\n        intensity = 1.0;\n    } else if (choice == CURL_OF_VECTOR_FIELD_VORTICITY) {\n        float C = dot(curl(fragCoord), vec3(0.0, 0.0, 1.0));\n        \n        \/\/ This is vorticity because we are using a 2D field.\n        \n        \/\/ Differentiate between negative, positive, and zero\n        \/\/ Red is less than zero, Green is greater than zero, Blue is none.\n        if (C < 0.0)\n            col = vec3(-C, 0.0, 0.0);\n        else if (C > 0.0)\n            col = vec3(0.0, C, 0.0);\n        else\n            col = vec3(0.0, 0.0, 0.0);\n        \n        \/\/ Boost the intensity\n        intensity = 6.0;\n    }\n    \n    if (intensity != 1.0)\n        col = intensity * col \/ (1.0 + intensity * col);\n\n    \/\/ Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}}