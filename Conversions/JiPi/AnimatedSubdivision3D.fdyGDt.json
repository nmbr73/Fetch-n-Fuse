{"Shader":{"ver":"0.1","info":{"id":"fdyGDt","date":"1632383518","viewed":326,"name":"Animated Subdivision 3D","username":"Tater","description":"I might keep making these until I run out of ideas. ","likes":20,"published":3,"flags":0,"usePreview":0,"tags":["3d","raymarching","cubes","subdivision","subdivide"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"id":37,"channel":0}],"code":"\/\/Building on ideas from \n\/\/https:\/\/www.shadertoy.com\/view\/NsKGDy\n\/\/https:\/\/www.shadertoy.com\/view\/7sKGRy\n\/\/https:\/\/www.shadertoy.com\/view\/fsyGD3\n\n#define MDIST 350.0\n#define STEPS 200.0\n#define pi 3.1415926535\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define pmod(p,x) (mod(p,x)-0.5*(x))\n\n\/\/iq palette\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ){\n    return a + b*cos(2.*pi*(c*t+d));\n}\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy,vec2(12.9898,78.233)))*43758.5453123);\n}\nfloat h11 (float a) {\n    return fract(sin((a)*12.9898)*43758.5453123);\n}\nfloat box(vec3 p, vec3 b){\n    vec3 d = abs(p)-b;\n    return max(d.x,max(d.y,d.z));\n}\n\n\/\/global ray direction\nvec3 rdg = vec3(0);\n\/\/block scale factor\nfloat gscl = 1.;\n\nvec2 blocks(vec3 p, vec3 scl, vec3 rd){\n    float t = iTime*(11.\/8.);\n      \n    vec3 dMin = vec3(-0.5) * scl;\n    vec3 dMax = vec3(0.5) * scl;\n    float id = 0.;\n    \n    \n    float MIN_SIZE = 0.3;\n    float ITERS = 6.;\n    float MIN_ITERS = 1.;\n    float PAD_FACTOR = 1.01;\n    float seed = floor(t\/(ITERS+5.0))+0.1;\n    t = mod(t,ITERS+5.0);\n\n    \/\/Offset and clamp the time at 0 so the cube stays uncut for a short time\n    t= clamp(t-1.0,0.0,ITERS);\n    \n    \/\/calculate initial box dimensions\n    vec3 dim = dMax - dMin;\n    \n    \/\/Big thanks for @0b5vr for cleaner version of subdiv algo\n    for (float i = 0.; i < ITERS; i++) {\n    \n        \/\/If this is the final cut when animating then break\n        if(i>floor(t)) break;\n        \n        \/\/divide the box into eight\n        vec3 divHash = vec3(\n            h21( vec2( i + id, seed )),\n            h21( vec2( i + id + 2.44, seed )),\n            h21( vec2( i + id + 7.83, seed ))\n        );\n        vec3 divide = divHash * dim + dMin;\n        \n        \/\/Clamp Division Line\n        divide = clamp(divide, dMin + MIN_SIZE * PAD_FACTOR, dMax - MIN_SIZE * PAD_FACTOR);\n        \n        \/\/Un-altered division line for coloring moving cells \n        vec3 divideFull = divide;\n        \n        \/\/find smallest dimension of divison\n        vec3 minAxis = min(abs(dMin - divide), abs(dMax - divide));\n        float minSize = min(minAxis.x, min(minAxis.y, minAxis.z));\n        \n        \/\/if the next cut will be below the minimum cut size then break out\n        if (minSize < MIN_SIZE && i + 1. > MIN_ITERS) {break ;}\n\n        \/\/If the current iteration is the cutting one\n        \/\/Smooth it between 0 and its final position\n        float tt = smoothstep(0.,1.,fract(t));\n        if(i == floor(t) &&mod(t,2.0)<1.0){\n            divide=mix(dMin,divide,tt);\n        }\n        else if(i == floor(t)){\n            divide=mix(dMax,divide,tt);\n        }\n\n        \n        \/\/ update the box domain\n        dMax = mix( dMax, divide, step( p, divide ));\n        dMin = mix( divide, dMin, step( p, divide ));\n\n        \/\/ id will be used for coloring and hash seeding\n        vec3 diff = mix( -divideFull, divideFull, step( p, divide));\n        id = length(diff + 10.0);\n    \n        \/\/ recalculate the dimension\n        dim = dMax - dMin;\n    }\n    float volume = dim.x*dim.y*dim.z;\n    vec3 center = (dMin + dMax)\/2.0;\n\n    \/\/Calculate the distance to the outside of the current cell bounds\n    \/\/to avoid overstepping\n    vec3 edgeAxis = mix( dMin, dMax, step( 0.0, rd ) );\n    vec3 dAxis = abs( p - edgeAxis ) \/ ( abs( rd ) + 1E-4 );\n    float dEdge = min(dAxis.x,min(dAxis.y,dAxis.z));\n    float b=dEdge;\n\n    vec3 d = abs(center);\n\n    \/\/Scale the cubes down so they stay the same size when they \"explode\"\n    dim*=gscl;\n    float a = box(p-center,dim*0.5);\n    \n    \/\/Take the minimum between the actual box and the intersection \n    \/\/to the outside of the cell\n    a = min(a, b);\n    \n    \/\/extra randomize the ID\n    id = h11(id)*1000.0;\n\n    return vec2(a,id);\n}\n\/\/This is a smooth square wave approximation function but I really like\n\/\/The curve it makes so I'm using it instead of a smoothstep to animate the\n\/\/spin and \"explode\". It's a bit long because I made it start at 0 and repeat every 3. \nfloat swave(float x, float a){\n    return (sin(x*pi\/3.-pi\/2.)\/sqrt(a*a+sin(x*pi\/3.-pi\/2.)*sin(x*pi\/3.-pi\/2.))+1.\/sqrt(a*a+1.))*0.5;\n}\nvec2 map(vec3 p){\n    float t = iTime*(11.\/8.);\n    \/\/The cycle for the spinning and explosion doesn't exaclty line up\n    \/\/with the cycle for the cutting because the spin needs to continue after the\n    \/\/cuts have reset, so the cycle is offset fowards a bit\n    t = mod(t-1.0,11.0)+1.0;\n    \n    \/\/timing out the spin+explode animation and making sure it happens\n    \/\/once per cycle\n    float wav = swave(clamp(t*0.78-4.0,0.0,6.0),0.1);\n    \n    \/\/Set the global scale variable that controls the exploding of boxes\n    gscl = 1.0-wav*0.5;\n    \n    \/\/rotation amount\n    float rotd = wav*pi*4.02;\n    \n    \/\/rotate the cube\n    p.xz*=rot(rotd);\n    \n    \/\/move the cube up when it rotates so it fits nicely in the screen\n    p.y-=wav*3.0;\n    \n    \/\/Scale space so the entire thing gets bigger (but the boxes are later re-sized,\n    \/\/so it looks like they stay the same time)\n    p*=gscl;\n    \n    \/\/Initalize output sdf, with vec2 for ID\n    vec2 a = vec2(1);\n    \n    \/\/Size of the subdivision fractal\n    vec3 scl = vec3(10);\n    \n    \/\/get the global ray direction and rotate it with the same rotation\n    \/\/as the cube so that the outside cell intersection still works correctly\n    vec3 rd2 = rdg;\n    rd2.xz*=rot(rotd);\n    \n    a = blocks(p,scl,rd2)+0.01;\n    \n    \/\/use a box to optimize areas outside of the fractal to minimize steps\n    \/\/Also I found you can instead the step distance of the fractal when it explodes\n    \/\/without causing artifacts which is free performance\n    a.x = max(box(p,vec3(scl*0.49)),a.x*(1.0+wav));\n    \n    return a;\n}\nvec3 norm(vec3 p){\n    vec2 e = vec2(0.0001,0.);\n    return normalize(map(p).x-vec3(\n    map(p-e.xyy).x,\n    map(p-e.yxy).x,\n    map(p-e.yyx).x));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)\/iResolution.y;\n    float t = iTime;\n    vec3 col = vec3(0);\n    vec3 ro = vec3(0,11.5,-20)*1.45;\n    if(iMouse.z>0.){\n    ro.zx*=rot(-7.0*(iMouse.x\/iResolution.x-0.5));\n    }\n    ro.xz*=rot(-pi\/4.);\n    vec3 lk = vec3(0,0.,0);\n    vec3 f = normalize(lk-ro);\n    vec3 r = normalize(cross(vec3(0,1,0),f));\n    vec3 rd = normalize(f*(gscl*0.9+0.13)+uv.x*r+uv.y*cross(f,r));    \n    rdg = rd;\n    vec3 p = ro;\n    float dO = 0.;\n    vec2 d = vec2(0);\n    bool hit = false;\n    for(float i = 0.; i<STEPS; i++){\n        p = ro+rd*dO;\n        d = map(p);\n        dO+=d.x*0.99;\n        if(d.x<0.0001){\n            hit = true;\n            break;\n        }\n        if(d.x>MDIST||i==STEPS-1.){\n            dO=MDIST;\n            break;\n        }\n    }\n    if(hit){\n        vec3 ld = normalize(vec3(0.5,0.9,-0.9));\n        vec3 n = norm(p);\n        vec3 e = vec3(0.5);\n        vec3 al = pal(fract(d.y)*0.8-0.15,e*1.3,e,e*2.0,vec3(0,0.33,0.66));\n        col = al;\n        float diff = length(sin(n*2.)*.5+.8)\/sqrt(3.);\n        col = al*diff;\n        float shadow = 1.;\n        \n        \/\/Mini hard shadow code\n        \/\/Need to make sure global ray direction is updated\n        rdg = ld;\n        for(float h = 0.09; h<10.;){\n            float dd = map(p+ld*h).x;\n            if(dd<0.001){shadow = 0.6; break;}\n            h+=dd;\n        }     \n        col*=shadow;\n    }\n    vec3 bg = vec3(0.741,0.498,0.498)*(1.0-length(uv)*0.5);\n    col = mix(col,bg,dO\/MDIST);\n    fragColor = vec4(col,1.0);\n}\n\n\n\n","name":"Image","description":"","type":"image"}]}}